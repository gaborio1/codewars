// ❗️❗️❗️ ✅  ❓❓❓
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: SIMPLE BEADS COUNT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Two red beads are placed between every two blue beads. There are N blue beads. After looking at the arrangement below work out the number of red beads.

@ @@ @ @@ @ @@ @ @@ @ @@ @

Implement count_red_beads(n) (in PHP count_red_beads($n); in Java, Javascript, TypeScript, C, C++ countRedBeads(n)) so that it returns the number of red beads.
If there are less than 2 blue beads return 0.
*/

function countRedBeads(n: number): number {
    return 0; //your code here
}

// console.log(countRedBeads(1));
// console.log(countRedBeads(3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: INVITE MORE WOMEN - Simple Fun 152
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
King Arthur and his knights are having a New Years party. Last year Lancelot was jealous of Arthur, because Arthur had a date and Lancelot did not, and they started a duel.

To prevent this from happening again, Arthur wants to make sure that there are at least as many women as men at this year's party. He gave you a list of integers of all the party goers.

Arthur needs you to return true if he needs to invite more women or false if he is all set.

Input/Output
[input] integer array L ($a in PHP)
An array (guaranteed non-associative in PHP) representing the genders of the attendees, where -1 represents women and 1 represents men.

2 <= L.length <= 50

[output] a boolean value

true if Arthur need to invite more women, false otherwise.
*/

function inviteMoreWomen(L: number[]): boolean {
    return true;
}

// console.log(inviteMoreWomen([1, -1, 1]));
// console.log(inviteMoreWomen([1, -1]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: SUM OF CUBES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function that takes a positive integer n, sums all the cubed values from 1 to n, and returns that sum.

Assume that the input n will always be a positive integer.

Examples: (Input --> output)

2 --> 9 (sum of the cubes of 1 and 2 is 1 + 8)
3 --> 36 (sum of the cubes of 1, 2, and 3 is 1 + 8 + 27)
*/

function sumCubes(n: number): number {
    return 1;
}

// console.log(sumCubes(2));
// console.log(sumCubes(3));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: ALPHABET SYMMETRY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Consider the word "abode". We can see that the letter a is in position 1 and b is in position 2. In the alphabet, a and b are also in positions 1 and 2. Notice also that d and e in abode occupy the positions they would occupy in the alphabet, which are positions 4 and 5.

Given an array of words, return an array of the number of letters that occupy their positions in the alphabet for each word. For example,

solve(["abode","ABc","xyzD"]) = [4, 3, 1]
See test cases for more examples.

Input will consist of alphabet characters, both uppercase and lowercase. No spaces.

Good luck!
*/

function solveA(arr: string[]) {
    // your code here
}

// [4, 3, 1]
// console.log(solve(["abode", "ABc", "xyzD"]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: MINIMIZE SUM OF ARRAY - Array Series #1
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: SORT, SPLICE, REDUCE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
Given an array of integers , Find the minimum sum which is obtained from summing each Two integers product .

Notes
Array/list will contain positives only .
Array/list will always has even size
Input >> Output Examples
minSum({5,4,2,3}) ==> return (22) 
Explanation:
The minimum sum obtained from summing each two integers product , 5*2 + 3*4 = 22
minSum({12,6,10,26,3,24}) ==> return (342)
Explanation:
The minimum sum obtained from summing each two integers product , 26*3 + 24*6 + 12*10 = 342
minSum({9,2,8,7,5,4,0,6}) ==> return (74)
Explanation:
The minimum sum obtained from summing each two integers product , 9*0 + 8*2 +7*4 +6*5 = 74
*/

const minSum = (arr: number[]): number | string => {

    if ((arr.length & 1) === 1) return "odd number of array elements!"

    let sum: number = 0;
    const ascArr = arr.sort((a, b) => a - b);
    console.log(ascArr);
    for (let i = 0; i < ascArr.length / 2; i++) {
        // console.table({ first: ascArr[i], last: ascArr[ascArr.length - 1 - i] });
        sum += ascArr[i] * ascArr[ascArr.length - 1 - i];
    }

    return sum;

}

//  ! MULTIPLY LARGEST BY SMALLEST !

//  SORT ARRAY NUMERICALLY ASCENDING (OR DESCENDING) 
//  LOOP OVER FIRST HALF OF ARRAY
//      MULTIPLY FIRST EL BY LAST, THEN SECOND BY LAST-1 ETC...AND ADD PRODUCT TO SUM

// 22
// console.log(minSum([5, 4, 2, 3]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function minSum2(arr: number[]) {
    let sum = 0;
    const nums = [...arr];
    while (nums.length !== 0) {
        const max = Math.max(...nums);
        const min = Math.min(...nums);
        sum += max * min;
        nums.splice(nums.indexOf(max), 1);
        nums.splice(nums.indexOf(min), 1);
    }
    return sum;
}



function minSum3(arr: number[]) {
    return [...arr]
        .sort((a, b) => a - b)
        .reduce((sum, x, _, sorted) => sum + x * sorted.pop()!, 0);
}



function minSum4(arr: number[]): number {
    return arr
        .sort((a: number, b: number) => a - b)
        .reduce(
            (acc: number, currVal: number, index: number, a: number[]) =>
                acc + (currVal * a[a.length - 1 - index]) / 2,
            0
        );
}



function minSum5(arr: number[]): number {
    return arr
        .sort((a: number, b: number) => a - b)
        .reduce(
            (acc: number, currVal: number, index: number, a: number[]) =>
                acc + (currVal * a[a.length - 1 - index]) / 2,
            0
        );
}



// ❗️❗️❗️ LOOK INTO REDUCE AND MAP ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: AVARAGES OF NUMBERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ MAP(), REDUCE(), ISARRAY(), SLICE(0, -1) ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
#Get the averages of these numbers

Write a method, that gets an array of integer-numbers and return an array of the averages of each integer-number and his follower, if there is one.

Example:

Input:  [ 1, 3, 5, 1, -10]
Output:  [ 2, 4, 3, -4.5]
If the array has 0 or 1 values or is null, your method should return an empty array.

Have fun coding it and please don't forget to vote and rank this kata! :-)
*/

// ❗️❗️❗️ (numArr![i] ❗️❗️❗️
// const averages = (numArr: number[] | null): number[] => {
//     for (let i = 0; i < numArr!.length - 1; i++) {
//         let pairAve: number = (numArr![i] + numArr![i + 1]) / 2;
//         console.log(pairAve);
//     }

//     return [1];
// };

const averages = (numArr: number[] | null): number[] => {
    if (!numArr || numArr.length < 2) return [];

    let solution: number[] = [];

    for (let i = 0; i < numArr.length - 1; i++) {
        let pairAve: number = (numArr[i] + numArr[i + 1]) / 2;
        solution.push(pairAve);
    }

    return solution;
};

// console.log(averages([1, 3, 5, 1, -10]));
// console.log(averages([1, 3]));
// console.log(averages([]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// REDUCE()
function averages2(numbers: number[]): number[] {
    let avrgs: number[] = [];
    if (!numbers || numbers.length <= 1) {
        return avrgs;
    }

    numbers.reduce((a, b) => {
        avrgs.push((a + b) / 2);
        return b;
    });

    return avrgs;
}

// ISARRAY(), MAP
// ❗️❗️❗️ slice(0, -1) WILL GET RID OF LAST ELEMENT NAN [2,4,3,-4.5,NaN] ❗️❗️❗️
// ❗️❗️❗️ slice(0, numbers.length -1) === slice(0, -1) ❗️❗️❗️
function averages3(numbers: number[]): number[] {
    return Array.isArray(numbers)
        ? numbers
            .map((item, index) => (item + numbers[index + 1]) / 2)
            .slice(0, -1)
        : [];
}

function averages4(numbers: number[] | null): number[] {
    if (numbers === null) return [];
    return numbers.slice(1).map((x, i) => (numbers[i] + x) / 2);
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️  INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: ALPHABETICAL ADDITION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ CHARCODEAT(), STRING.FROMCHARCODE(), REDUCE(INITIAL VALUE), SPREAD ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to add up letters to one letter.

The function will be given a variable amount of arguments, each one being a letter to add.

Notes:
Letters will always be lowercase.
Letters can overflow (see second to last example of the description)
If no letters are given, the function should return 'z'
Examples:
addLetters('a', 'b', 'c') = 'f'
addLetters('a', 'b') = 'c'
addLetters('z') = 'z'
addLetters('z', 'a') = 'a'
addLetters('y', 'c', 'b') = 'd' // notice the letters overflowing
addLetters() = 'z'
*/

/*
a	097	01100001	A	065	01000001
b	098	01100010	B	066	01000010
c	099	01100011	C	067	01000011
d	100	01100100	D	068	01000100
e	101	01100101	E	069	01000101
f	102	01100110	F	070	01000110
g	103	01100111	G	071	01000111
h	104	01101000	H	072	01001000
i	105	01101001	I	073	01001001
j	106	01101010	J	074	01001010
k	107	01101011	K	075	01001011
l	108	01101100	L	076	01001100
m	109	01101101	M	077	01001101
n	110	01101110	N	078	01001110
o	111	01101111	O	079	01001111
p	112	01110000	P	080	01010000
q	113	01110001	Q	081	01010001
r	114	01110010	R	082	01010010
s	115	01110011	S	083	01010011
t	116	01110100	T	084	01010100
u	117	01110101	U	085	01010101
v	118	01110110	V	086	01010110
w	119	01110111	W	087	01010111
x	120	01111000	X	088	01011000
y	121	01111001	Y	089	01011001
z	122	01111010	Z	090	01011010

*/

const addLetters = (...letters: string[]): string => {
    if (letters.length === 0) return "z";

    const charCodeSum = letters
        .map((char) => char.charCodeAt(0) - 96)
        .reduce((acc, curr) => acc + curr, 0); // 26 FOR "z"

    if (charCodeSum % 26 === 0) return "z";

    return charCodeSum > 26
        ? String.fromCharCode((charCodeSum % 26) + 96)
        : String.fromCharCode(charCodeSum + 96);
};

//  SOLUTION WITH COMMENTS:

const addLetters2 = (...letters: string[]): string => {
    // ❗️❗️❗️ SPREAD ARGUMENTS ❗️❗️❗️
    console.log(...letters); // a b c
    console.log(letters); // [ 'a', 'b', 'c' ]

    // RETURN Z FOR EMPTY ARRAY
    if (letters.length === 0) return "z";

    // ❗️❗️❗️ CHARCODEAT()
    const charCodeSum = letters
        .map((char) => char.charCodeAt(0) - 96) // [1(97-96), 2(98-96)...3]
        .reduce((acc, curr) => acc + curr, 0); // [6(1+2+3)]
    console.log(charCodeSum);
    console.log(charCodeSum % 26);

    // IF SUM IS MULTIPLIES OF 26 RETURN Z AS SUM % 26 WILL RESULT IN CHARCODE(0)
    if (charCodeSum % 26 === 0) return "z";

    // STRING.FROMCHARCODE()
    return charCodeSum > 26
        ? String.fromCharCode((charCodeSum % 26) + 96) // OVERLAP (MORE THAN 26)
        : String.fromCharCode(charCodeSum + 96);
};

// z
// console.log(addLetters(addLetters("f", "g", "a", "r", "t")));
// d
// console.log(addLetters(['y', 'c', 'b']));

// z FOR EMPTY ARRAY OR NO ARGUMENTS
// console.log(addLetters());

// f
// console.log(console.log(addLetters("s", "k", "g", "u", "z")));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function addLetters3(...letters: string[]): string {
    const aCode: number = "a".charCodeAt(0);
    const zCode: number = "z".charCodeAt(0);
    const mod: number = zCode - aCode + 1;

    const normalizeCharCode = (letter: string): number =>
        letter.charCodeAt(0) - aCode + 1;
    const normalizeCharCodes: number[] = letters.map(normalizeCharCode);

    const add = (a: number, b: number): number => a + b;
    const value: number = normalizeCharCodes.reduce(add, 0);

    const finalCharCode: number = ((value - 1 + mod) % mod) + aCode;
    return String.fromCharCode(finalCharCode);
}

const addLetters4 = (...letters: string[]) =>
    String.fromCharCode(
        (letters.reduce((acc, val) => acc + val.charCodeAt(0) - 96, 0) % 26 ||
            26) + 96
    );

const alphabet = "abcdefghijklmnopqrstuvwxyz";

const addLetters5 = (...letters: string[]): string =>
    letters.length === 0
        ? "z"
        : alphabet[
        (letters.reduce((acc, c) => acc + (alphabet.indexOf(c) + 1), 0) -
            1) %
        alphabet.length
        ];

function addLetters6(...letters: string[]) {
    // your code here
    if (letters.length === 0) return "z"; // account for empty input array
    const letterArray = "abcdefghijklmnopqrstuvwxyz".split(""); // create array for index reference
    let sum = 0;
    for (const letter of letters) {
        sum += letterArray.indexOf(letter) + 1; // add +1 to compensate for index 0 start logic
    }
    let remainder = sum % 26;
    if (remainder === 0) return "z";
    else return letterArray[remainder - 1];
}

function addLetters7(...letters: string[]) {
    const sum =
        letters.map((c) => c.charCodeAt(0) - 96).reduce((a, b) => a + b, 0) %
        26;

    return sum === 0 ? "z" : String.fromCharCode(96 + sum);
}

function addLetters8(...letters: string[]) {
    const s = "zabcdefghijklmnopqrstuvwxy";
    let sum = 0;
    for (let l of letters) {
        sum += s.indexOf(l);
    }
    return s[sum % 26];
}

function addLetters9(...letters: string[]) {
    if (!letters || letters.length < 1) return "z";
    if (letters.length === 1) return letters[0];

    const num: number =
        letters
            .map((ch) => ch.charCodeAt(0) - 96)
            .reduce((sum, curr) => sum + curr, 0) % 26;

    if (num === 0) return "z";
    else return String.fromCharCode(num + 96);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: POWER OF TWO
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:❗️❗️❗️  MATH.LOG() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Complete the function power_of_two/powerOfTwo (or equivalent, depending on your language) that determines if a given non-negative integer is a power of two. From the corresponding Wikipedia entry:

a power of two is a number of the form 2n where n is an integer, i.e. the result of exponentiation with number two as the base and integer n as the exponent.

You may assume the input is always valid.

Examples
power_of_two?(1024) # true
power_of_two?(4096) # true
power_of_two?(333)  # false
Beware of certain edge cases - for example, 1 is a power of 2 since 2^0 = 1 and 0 is not a power of 2.
*/

const isPowerOfTwo = (num: number): boolean => {
    if (num === 1) return true;
    if ((num & 1) === 1) return false;
    // KEEP DIVIDING NUM BY 2
    while (num > 1) {
        num = num / 2;
    }

    // console.log(num);

    // IF NUM / 2 EQUALS 1 RETURN true, OTHERWISE false
    return num === 1;

    // OR:

    // return num === 1
    //     ? true
    //     : false;
};

// console.log(isPowerOfTwo(23));
// console.log(isPowerOfTwo(18));
// console.log(isPowerOfTwo(4096));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function isPowerOfTwo2(n: number): boolean {
    return Number.isInteger(Math.log2(n));
}

const isPowerOfTwo3 = (n: number): boolean => Math.log2(n) % 1 === 0;

function isPowerOfTwo4(n: number): boolean {
    return n === 2 || n === 1 ? true : n < 2 ? false : isPowerOfTwo(n / 2);
}

function isPowerOfTwo5(n: number): boolean {
    for (let i = 0; true; i++) {
        const pow = Math.pow(2, i);
        if (pow === n) {
            return true;
        } else if (pow > n) {
            return false;
        }
    }
}

function isPowerOfTwo6(n: number): boolean {
    while (n > 2 && n % 2 == 0) n = n / 2;

    return n == 2 || n == 1;
}

// TITLE:  OVER THE ROAD
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
You've just moved into a perfectly straight street with exactly n identical houses on either side of the road. Naturally, you would like to find out the house number of the people on the other side of the street. The street looks something like this:

Street
1|   |6
3|   |4
5|   |2
Evens increase on the right; odds decrease on the left. House numbers start at 1 and increase without gaps. When n = 3, 1 is opposite 6, 3 opposite 4, and 5 opposite 2.

Example (address, n --> output)
Given your house number address and length of street n, give the house number on the opposite side of the street.

1, 3 --> 6
3, 3 --> 4
2, 3 --> 5
3, 5 --> 8
Note about errors
If you are timing out, running out of memory, or get any kind of "error", read on. Both n and address could get upto 500 billion with over 200 random tests. If you try to store the addresses of 500 billion houses in a list then you will run out of memory and the tests will crash. This is not a kata problem so please don't post an issue. Similarly if the tests don't complete within 12 seconds then you also fail.

To solve this, you need to think of a way to do the kata without making massive lists or huge for loops. Read the discourse for some inspiration :)
*/

const overTheRoad = (address: number, n: number): number => {
    return n * 2 + 1 - address;
};

//  OPPOSITE NUMBERS ADD UP TO TWICE THE LENGTH OF STREET PLUS 1
//  SUBSTRACT YOUR address FROM THAT SUM TO GET RESULT

// console.log(overTheRoad(1, 3));
// console.log(overTheRoad(3, 3));
// console.log(overTheRoad(7, 11));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function overTheRoad2(address: number, n: number): number {
    // Good luck!
    if (address % 2 === 0) {
        return 1 + 2 * (n - address / 2);
    } else {
        return 2 * n - (address - 1);
    }
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  EVEN NUMBERS IN AN ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: BITWISE AND, FILTER()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given an array of digitals numbers, return a new array of length number containing the last even numbers from the original array (in the same order). The original array will be not empty and will contain at least "number" even numbers.

For example:

([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) => [4, 6, 8]
([-22, 5, 3, 11, 26, -6, -7, -8, -9, -8, 26], 2) => [-8, 26]
([6, -25, 3, 7, 5, 5, 7, -3, 23], 1) => [6]
*/

const evenNumbers = (array: number[], n: number): number[] => {
    return array.filter((el) => (el & 1) === 0).slice(-n);
};

//  FILTER OUT ODD NUMBERS
//  RETURN SUB ARRAY OF LAST n ELEMENTS (SLICE WITH NEGATIVE IDX)

// console.log(evenNumbers([1, 2, 3, 4, 5, 6, 7, 8, 9], 3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function isEven2(n: number): boolean {
    return n % 2 === 0;
}

function evenNumbers2(array: number[], n: number): number[] {
    return array.filter(isEven2).slice(-n);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SPEED CONTROL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  BITWISE OR TO ROUND DOWN, MATH.MAX() WITH SPREAD
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
In John's car the GPS records every s seconds the distance travelled from an origin (distances are measured in an arbitrary but consistent unit). For example, below is part of a record with s = 15:

x = [0.0, 0.19, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25]
The sections are:

0.0-0.19, 0.19-0.5, 0.5-0.75, 0.75-1.0, 1.0-1.25, 1.25-1.50, 1.5-1.75, 1.75-2.0, 2.0-2.25
We can calculate John's average hourly speed on every section and we get:

[45.6, 74.4, 60.0, 60.0, 60.0, 60.0, 60.0, 60.0, 60.0]
Given s and x the task is to return as an integer the *floor* of the maximum average speed per hour obtained on the sections of x. If x length is less than or equal to 1 return 0 since the car didn't move.

Example:
with the above data your function gps(s, x)should return 74

Note
With floats it can happen that results depends on the operations order. To calculate hourly speed you can use:

(3600 * delta_distance) / s.
*/

class G965a1 {
    public static gps = (secInt: number, distArr: number[]): number => {
        // secInterval: SECONDS
        // distArr: KMS
        let speedsArr = [];

        for (let i = 1; i < distArr.length; i++) {
            let curr = distArr[i],
                prev = distArr[i - 1];
            let sectionDist = curr - prev;
            let sectAveSpeed = (3600 / secInt) * sectionDist;
            // console.table(
            //     { time: secInt, dist: sectionDist, speed: sectAveSpeed }
            // );
            speedsArr.push(sectAveSpeed);
        }

        console.log(speedsArr);

        return Math.max(...speedsArr) | 0;
    };
}

//  CALCULATE AVERAGE SPEED FOR EACH SECTION WITH LOOP
//  PUSH IT INTO speedsArray AS sectAveSpeed
//  FIND LARGEST NUMBER(SPEED) IN speedsArray AND ROUND IT DOWN TO NEAREST INT
//  BITWISE OR "|" WILL ROUND DOWN DECIMALS: 3.345 | 0  =>  3

// s = 15;
// u = 74;
// console.log(G965a1.gps(15, [0.0, 0.19, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25]));

// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G965a2 {
    public static gps = (seconds: number, sections: number[]): number => {
        if (sections.length <= 1) return 0;

        const sectionSpeeds = sections
            .map((start, index) => start - (sections[index - 1] || 0))
            .map((distance) => (3600 * distance) / seconds);

        return Math.floor(Math.max(...sectionSpeeds));
    };
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  NO ODDITIES HERE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: BITWISE AND "&" (EVEN OR ODD)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a small function that returns the values of an array that are not odd.

All values in the array will be integers. Return the good values in the order they are given.
*/

const noOdds = (values: number[]): number[] => {
    return values.filter((el) => {
        return (el & 1) === 0;
    });
};

//  BITWISE AND "&" OPERATOR
//  n & 1
//  RETURNS 1 IF n IS ODD
//  RETURNS 0 IF n IS EVEN

// console.log(noOdds( [0,1] ));
// console.log(noOdds([0, 1, 2, 3]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function noOdds2(values: number[]): number[] {
    return values.filter((i) => !(i % 2));
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PARTS OF A LIST
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: SLICE(), GET 2 SUB ARRAYS OF ARR AS STRING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function partlist that gives all the ways to divide a list (an array) of at least two elements into two non-empty parts.

Each two non empty parts will be in a pair (or an array for languages without tuples or a structin C - C: see Examples test Cases - )
Each part will be in a string
Elements of a pair must be in the same order as in the original array.
Examples of returns in different languages:
a = ["az", "toto", "picaro", "zone", "kiwi"] -->
[["az", "toto picaro zone kiwi"], ["az toto", "picaro zone kiwi"], ["az toto picaro", "zone kiwi"], ["az toto picaro zone", "kiwi"]] 
or
 a = {"az", "toto", "picaro", "zone", "kiwi"} -->
{{"az", "toto picaro zone kiwi"}, {"az toto", "picaro zone kiwi"}, {"az toto picaro", "zone kiwi"}, {"az toto picaro zone", "kiwi"}}
or
a = ["az", "toto", "picaro", "zone", "kiwi"] -->
[("az", "toto picaro zone kiwi"), ("az toto", "picaro zone kiwi"), ("az toto picaro", "zone kiwi"), ("az toto picaro zone", "kiwi")]
or 
a = [|"az", "toto", "picaro", "zone", "kiwi"|] -->
[("az", "toto picaro zone kiwi"), ("az toto", "picaro zone kiwi"), ("az toto picaro", "zone kiwi"), ("az toto picaro zone", "kiwi")]
or
a = ["az", "toto", "picaro", "zone", "kiwi"] -->
"(az, toto picaro zone kiwi)(az toto, picaro zone kiwi)(az toto picaro, zone kiwi)(az toto picaro zone, kiwi)"

*/

class G964a {
    public static partlist = (arr: string[]): string[][] => {
        let solution: string[][] = [];

        for (let i = 0; i < arr.length - 1; i++) {
            // console.log(arr.slice(0, i + 1).join(" "));
            // console.log(arr.slice(i + 1).join(" "));

            let subArr: string[] = [];
            subArr.push(
                arr.slice(0, i + 1).join(" "),
                arr.slice(i + 1).join(" ")
            );

            // subArr.push(arr.slice(0, i + 1).join(" "));
            // subArr.push(arr.slice(i + 1).join(" "));

            solution.push(subArr);
        }

        return solution;
    };
}

//  INITIALIZE SOLUTION ARR
//  LOOP OVER arr
//      CREATE subArr FOR EACH ITARATION
//      PUSH FIRST SUB ARRAY OF arr INTO subArr ENDING WITH arr[i]
//      PUSH SECOND SUB ARRAY OF arr INTO subArr STARTING WITH arr[i + 1]
//      PUSH subArr INTO solution
//  RETURN solution

// console.log(G964a.partlist(["a", "b", "c", "d", "e"]));
// console.log(G964a.partlist(["I", "wish", "I", "hadn't", "come"]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G964a2 {
    public static partlist(arr: string[]): string[][] {
        return arr
            .map((s, i, a) => [
                a.slice(0, i + 1).join(" "),
                a.slice(i + 1, a.length).join(" "),
            ])
            .slice(0, arr.length - 1);
    }
}

class G964a3 {
    public static partlist(arr: string[]): string[][] {
        return arr
            .slice(1)
            .map((x, i) => [
                arr.slice(0, i + 1).join(" "),
                arr.slice(i + 1).join(" "),
            ]);
    }
}

class G964a4 {
    public static partlist(arr: string[]): string[][] {
        const x = arr.map((word, idx) => {
            return [
                arr.slice(0, idx + 1).join(" "),
                arr.slice(idx + 1, arr.length).join(" "),
            ];
        });
        return x.slice(0, -1);
    }
}

// INCLUDE THIS IN EXAMPLES FOR MATCH() WITH POSSIBLE EMPTY ARR
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ REFACTOR THIS, MAKE IT WORK WITH STR.MATCH() ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  BUMPS IN THE ROAD
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your car is old, it breaks easily. The shock absorbers are gone and you think it can handle about 15 more bumps before it dies totally.

Unfortunately for you, your drive is very bumpy! Given a string showing either flat road ("_") or bumps ("n"), work out if you make it home safely. 15 bumps or under, return "Woohoo!", over 15 bumps return "Car Dead".
*/

const bump = (road: string): string => {
    // const bumps: number[] = road.match(/n/g);
    // console.log(bumps);

    // return bumps.length > 15
    //     ? "Car Dead"
    //     : "Woohoo!";

    let counter: number = 0;

    for (let i = 0; i < road.length; i++) {
        if (road[i] === "n") {
            counter++;
            if (counter > 15) return "Car Dead";
        }
    }

    return "Woohoo!";
};

// console.log(bump("n"));
// console.log(bump("_nnnnnnn_n__n______nn__nn_nnn"));
// console.log(bump("_"));

// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function bump2(x: string): string {
    return x.split("").filter((a) => a === "n").length <= 15
        ? "Woohoo!"
        : "Car Dead";
}

function bump3(x: string): string {
    return x.replace(/_/g, "").length > 15 ? `Car Dead` : `Woohoo!`;
}

function bump4(x: string): string {
    return x
        .split("")
        .reduce((total, n) => (n === "n" ? total + 1 : total), 0) > 15
        ? "Car Dead"
        : "Woohoo!";
}

// ❗️❗️❗️ MATCH() ❗️❗️❗️
function bump5(x: string): string {
    const arr: string[] = x.match(/[n+]/g) || [];
    return arr.length <= 15 ? "Woohoo!" : "Car Dead";
}

function bump6(x: string): string {
    return (x.match(/n/g) || []).length > 15 ? "Car Dead" : "Woohoo!";
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  MAXIMUM PRODUCT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  ❗️❗️❗️ SPREAD ARRAY FOR MATH.MAX() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
Given an array of integers , Find the maximum product obtained from multiplying 2 adjacent numbers in the array.

Notes
Array/list size is at least 2.

Array/list numbers could be a mixture of positives, negatives also zeroes .

Input >> Output Examples
adjacentElementsProduct([1, 2, 3]); ==> return 6
Explanation:
The maximum product obtained from multiplying 2 * 3 = 6, and they're adjacent numbers in the array.
adjacentElementsProduct([9, 5, 10, 2, 24, -1, -48]); ==> return 50
Explanation:
Max product obtained from multiplying 5 * 10 = 50 .

adjacentElementsProduct([-23, 4, -5, 99, -27, 329, -2, 7, -921])  ==>  return -14
Explanation:
The maximum product obtained from multiplying -2 * 7 = -14, and they're adjacent numbers in the array.
*/

const adjacentElementsProduct = (arr: number[]): number => {
    let productsArr: number[] = [];

    for (let i = 0; i < arr.length - 1; i++) {
        let adjacentProd: number = arr[i] * arr[i + 1];
        productsArr.push(adjacentProd);
    }

    // ❗️❗️❗️ SPREAD ARRAY FOR MATH.MAX() TO AVOID ERROR: ❗️❗️❗️
    // Argument of type 'number[]' is not assignable to parameter of type 'number'.ts(2345)
    return Math.max(...productsArr);
};

// console.log(adjacentElementsProduct([1, 5, 10, 9]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const adjacentElementsProduct2 = (arr: number[]): number =>
    Math.max(
        ...arr.map((value, index) =>
            index === arr.length - 1
                ? value * arr[index - 1]
                : value * arr[index + 1]
        )
    );

function adjacentElementsProduct3(arr: number[]): number {
    return Math.max(...arr.slice(1).map((x, i) => x * arr[i]));
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  JS ARRAY FILTER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The solution would work like the following:

getEvenNumbers([2,4,5,6]) // should == [2,4,6]
*/

const getEvenNumbers = (numbersArray: number[]): number[] => {
    return numbersArray.filter((num) => {
        return (num & 1) === 0;
    });
};

// console.log(getEvenNumbers([1, 2, 3, 6, 8, 10]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const getEvenNumbers2 = (numbersArray: number[]): number[] => {
    return numbersArray.filter((x) => x % 2 === 0);
};

const isEven = (num: number): boolean => num % 2 == 0;
const getEvenNumbers3 = (nums: number[]): number[] => nums.filter(isEven);

const getEvenNumbers4 = (numbersArray: number[]): number[] => {
    return numbersArray.filter((cond) => 0 === cond % 2);
};
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SUM OF TRIANGULAR NUMBERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to return the sum of Triangular Numbers up-to-and-including the nth Triangular Number.

Triangular Number: "any of the series of numbers (1, 3, 6, 10, 15, etc.) obtained by continued summation of the natural numbers 1, 2, 3, 4, 5, etc."

[01]
02 [03]
04 05 [06]
07 08 09 [10]
11 12 13 14 [15]
16 17 18 19 20 [21]
e.g. If 4 is given: 1 + 3 + 6 + 10 = 20.

Triangular Numbers cannot be negative so return 0 if a negative number is given.
*/

const sumTriangularNumbers = (n: number): number => {
    let sum: number = 0,
        triNum: number = 0;

    for (let i = 1; i <= n; i++) {
        triNum = triNum + i;
        sum += triNum;
    }

    return sum;
};

//  START LOOP AT 1, IN EVERY ITERATION:
//     INCREMENT triNum BY triNum + 1 (1, 3, 6, 10...)
//     INCREMENT sum BY trinum (1, 4, 10, 20...)
//  RETURN sum

//   56
// console.log(sumTriangularNumbers(1));
// console.log(sumTriangularNumbers(2));
// console.log(sumTriangularNumbers(3));
// console.log(sumTriangularNumbers(4));
// 7140
// console.log(sumTriangularNumbers(34));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function sumTriangularNumbers2(n: number): number {
    return n <= 0 ? 0 : (n * (n + 1) * (n + 2)) / 6;
}

//   Function lacks ending return statement and return type does not include 'undefined'.ts(2366)

//   function sumTriangularNumbers3(n:number):number {

//     if (n < 1) return 0;

//     if (n == 1)
//       return 1;
//     while (n > 0) {
//       return (n * (n +1) / 2) + sumTriangularNumbers(n-1);
//     }
//   }

function sumTriangularNumbers4(n: number): number {
    return Array.from({ length: n })
        .map((value, index) => ((1 + index + 1) * (index + 1)) / 2)
        .reduce((pre, current) => pre + current, 0);
}

function sumTriangularNumbers5(n: number): number {
    let result = 0;
    for (let i = 0; i <= n; i++) {
        result += (i * (i + 1)) / 2;
    }
    return result;
}

function sumTriangularNumbers6(n: number): number {
    let sum = 0;
    for (let i = 1, j = 1; i <= n; i++, j += i) {
        sum += j;
    }
    return sum;
}

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:  MOVES IN SQUARED STRINGS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You are given a string of n lines, each substring being n characters long: For example:

s = "abcd\nefgh\nijkl\nmnop"

We will study some transformations of this square of strings.

Vertical mirror: vert_mirror (or vertMirror or vert-mirror)
vert_mirror(s) => "dcba\nhgfe\nlkji\nponm"
Horizontal mirror: hor_mirror (or horMirror or hor-mirror)
 hor_mirror(s) => "mnop\nijkl\nefgh\nabcd"
or printed:

vertical mirror   |horizontal mirror   
abcd --> dcba     |abcd --> mnop 
efgh     hgfe     |efgh     ijkl 
ijkl     lkji     |ijkl     efgh 
mnop     ponm     |mnop     abcd 
Task:
Write these two functions
and

high-order function oper(fct, s) where

fct is the function of one variable f to apply to the string s (fct will be one of vertMirror, horMirror)

Examples:
s = "abcd\nefgh\nijkl\nmnop"
oper(vert_mirror, s) => "dcba\nhgfe\nlkji\nponm"
oper(hor_mirror, s) => "mnop\nijkl\nefgh\nabcd"
Note:
The form of the parameter fct in oper changes according to the language. You can see each form according to the language in "Sample Tests".

Bash Note:
The input strings are separated by , instead of \n. The output strings should be separated by \r instead of \n. See "Sample Tests".
*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PREDICT YOUR AGE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  ❗️❗️❗️ ARGUMENTS / SPREAD ❗️❗️❗️, MATH.TRUNC()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
My grandfather always predicted how old people would get, and right before he passed away he revealed his secret!

In honor of my grandfather's memory we will write a function using his formula!

Take a list of ages when each of your great-grandparent died.
Multiply each number by itself.
Add them all together.
Take the square root of the result.
Divide by two.
Example
predictAge(65, 60, 75, 55, 60, 63, 64, 45) === 86
Note: the result should be rounded down to the nearest integer.

Some random tests might fail due to a bug in the JavaScript implementation. Simply resubmit if that happens to you.
*/

// const predictAge = (
//     age1:number,
//     age2:number,
//     age3:number,
//     age4:number,
//     age5:number,
//     age6:number,
//     age7:number,
//     age8:number
// ): number => {

//   return 0;
// };

const predictAge = (...args: number[]): number => {
    // ❗️❗️❗️
    // console.log(args);

    return Math.floor(
        Math.sqrt(
            args
                .map((num) => Math.pow(num, 2))
                .reduce((acc, curr) => acc + curr)
        ) / 2
    );
};

//  GET arguments ARRAY
//  SQUARE ALL ELEMENTS WITH map
//  GET SUM WITH reduce
//  DIVIDE BY 2

//  GET SQUARE ROOT OF SUM
//  ROUND DOWN TO NEAREST INTEGER

// 86
// console.log(predictAge(65,60,75,55,60,63,64,45));
// 79
// console.log(predictAge(32,54,76,65,34,63,64,45));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// Rest parameter 'a' implicitly has an 'any[]' type.ts(7019)

// const predictAge2=(...a)=>Math.sqrt(a.reduce((b,c)=>b+c*c,0))>>1

function predictAge3(...ages: number[]): number {
    return Math.trunc(
        Math.sqrt(ages.map((x) => x * x).reduce((a, b) => a + b, 0)) / 2
    );
}

//   Cannot find name 'arguments'.ts(2304)
// Block-scoped variable 'number' used before its declaration.ts(2448)

//   predictAge4(age1:number, age2:number, age3:number,age4:number,age5:number,age6:number,age7:number,age8:number): number{
//     let args = Array.prototype.slice.call(arguments)
//     const sum = args.map(arg => {
//     return arg * arg
//     }).reduce((a,b) => a + b, 0)
//     const square = Math.sqrt(sum)
//     const total = Math.floor(square / 2)
//     return total;
//   };

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIND MOST DIGITS IN NUMBER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  SORT(), REDUCE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Find the number with the most digits.

If two numbers in the argument array have the same number of digits, return the first one in the array.
*/

class Kata {
    static findLongest(arr: number[]): number {
        // 1️⃣
        return arr.sort((a, b) => String(b).length - String(a).length)[0];

        // 2️⃣  ❗️❗️❗️    REFACTOR THIS WITH ARRAY.FIND() ❗️❗️❗️
        let solution: number = -1;
        const sortedArr = [...arr].sort((a, b) => b - a);
        // console.log(arr);
        console.log(sortedArr);
        const maxLength: number = String(sortedArr[0]).length;
        console.log(maxLength);
        // const findLength = (num: number): number => {
        //     console.table({ maxLength: maxLength, number: num });
        //     // return String(num).length === maxLength;
        //     console.log(String(num).length === maxLength);
        //     // if (String(num).length === length) return num;
        //     return String(num).length === maxLength
        //         ? num
        //         : -1;
        // }
        console.log(arr);
        // return arr.find(function (num: number): number {
        //     return String(num).length === maxLength
        //         ? num
        //         : -1;
        // })!;

        for (let i = 0; i < arr.length; i++) {
            if (String(arr[i]).length === maxLength) {
                solution = arr[i];
                break;
            }
        }
        return solution;
    }
}

//  SORT arr BY THE LENGTH OF ELEMENTS(CONVERTED TO STRING)
//  RETURN FIRST ELEMENT OF SORTED-BY-LENGTH ARRAY

// console.log(Kata.findLongest([1, 10, 100, 400, 56, 800]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// REDUCE()
class Kata5 {
    static findLongest(array: number[]): number {
        return array.reduce((a, b) =>
            a.toString().length < b.toString().length ? b : a
        );
    }
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SORTED? YES, NO, HOW? ASCENDING/DESCENDING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  SORT(),
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Complete the method which accepts an array of integers, and returns one of the following:

"yes, ascending" - if the numbers in the array are sorted in an ascending order
"yes, descending" - if the numbers in the array are sorted in a descending order
"no" - otherwise
You can assume the array will always be valid, and there will always be one correct answer.
*/

const isSortedAndHow = (arr: number[]): string => {
    let isAscending: boolean = false;
    let isDescending: boolean = false;
    let solution: string = "no";

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] >= arr[i - 1]) {
            isAscending = true;
        } else {
            break;
        }
        if (i === arr.length - 1 && isAscending) {
            solution = "yes, ascending";
        }
    }

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] <= arr[i - 1]) {
            isDescending = true;
        } else {
            break;
        }
        if (i === arr.length - 1 && isDescending) {
            solution = "yes, descending";
        }
    }

    return solution;
};

// console.log(isSortedAndHow([1, 2]));
// console.log(isSortedAndHow([15, 7, 3, -8]));
// console.log(isSortedAndHow([4, 2, 30]));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function isSortedAndHow2(array: number[]): string {
    let ascending = true,
        descending = true;
    for (var i = 1; i < array.length; i++) {
        if (array[i - 1] < array[i]) descending = false;
        if (array[i - 1] > array[i]) ascending = false;
        if (!ascending && !descending) return "no";
    }
    if (ascending) return "yes, ascending";
    return "yes, descending";
}

function isSortedAndHow3(array: number[]): string {
    if (array.every((x, i, a) => i === 0 || a[i - 1] <= x))
        return "yes, ascending";
    if (array.every((x, i, a) => i === 0 || a[i - 1] >= x))
        return "yes, descending";
    return "no";
}

function isSortedAndHow4(array: number[]): string {
    return [...array].sort((a, b) => a - b).join("") === array.join("")
        ? "yes, ascending"
        : [...array]
            .sort((a, b) => a - b)
            .reverse()
            .join("") === array.join("")
            ? "yes, descending"
            : "no";
}

function isSortedAndHow5(array: number[]): string {
    let isAsc: boolean = true;
    let isDesc: boolean = true;
    let i: number = 0;

    while (i + 1 < array.length) {
        if (array[i] > array[i + 1]) isAsc = false;
        if (array[i] < array[i + 1]) isDesc = false;

        i++;
    }

    if (isAsc) return "yes, ascending";
    else if (isDesc) return "yes, descending";
    else return "no";
}

function isSortedAndHow6(array: number[]): string {
    const asc: number[] = [...array].sort((a, b) => a - b);
    const dsc: number[] = [...array].sort((a, b) => b - a);
    switch (array.toString()) {
        case asc.toString():
            return "yes, ascending";
        case dsc.toString():
            return "yes, descending";
        default:
            return "no";
    }
}

function isSortedAndHow7(array: number[]): string {
    if ([...array].sort((a, b) => a - b).join("") === array.join("")) {
        return "yes, ascending";
    } else if ([...array].sort((a, b) => b - a).join("") === array.join("")) {
        return "yes, descending";
    } else {
        return "no";
    }
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SUM OF ANGLES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Find the total sum of internal angles (in degrees) in an n-sided simple polygon. N will be greater than 2.

If a convex polygon has n sides, then its interior angle sum is given by the following equation: S = ( n −2) × 180°.
*/

const angle = (n: number): number => {
    return (n - 2) * 180;
};

// console.log(angle(3));
// console.log(angle(4));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FACTORIAL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

const factorial = (num: number) => {
    let nthFact = 1;

    for (let i = 1; i <= num; i++) {
        nthFact *= i;
    }

    return nthFact;
};

// console.log(factorial(4));
// console.log(factorial(0));
// console.log(factorial(7));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function factorial2(n: number): number {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  EVAPORATION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  DO WHILE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
This program tests the life of an evaporator containing a gas.

We know the content of the evaporator (content in ml), the percentage of foam or gas lost every day (evap_per_day) and the threshold (threshold) in percentage beyond which the evaporator is no longer useful. All numbers are strictly positive.

The program reports the nth day (as an integer) on which the evaporator will be out of use.

Example:
evaporator(10, 10, 5) -> 29
Note:
Content is in fact not necessary in the body of the function "evaporator", you can use it or not use it, as you wish. Some people might prefer to reason with content, some other with percentages only. It's up to you but you must keep it as a parameter because the tests have it as an argument.
*/

const evaporator = (cont: number, dayEvap: number, thresH: number): number => {
    let contentLeft = cont;
    const minQuantity = cont * (thresH / 100);
    let daysLeft: number = 0;

    while (contentLeft >= minQuantity) {
        contentLeft -= contentLeft * (dayEvap / 100);
        daysLeft++;
    }

    return daysLeft;
};

//  INITIALIZE VARIABLES
//  KEEP DECREMENTING contentLeft WHILE IT IS GREATER OR EQUAL TO minQuantity
//  RETURN daysLeft

// 22
// console.log(evaporator(10, 10, 10));
// 29
// console.log(evaporator(10, 10, 5));

//============= OTHER CODEWARS SOLUTIONS: =============

function evaporator2(
    content: number,
    evap_per_day: number,
    threshold: number
): number {
    return Math.ceil(
        Math.log(threshold / 100) / Math.log(1 - evap_per_day / 100)
    );
}

function evaporator3(
    content: number,
    evapPerDay: number,
    threshold: number
): number {
    const reverseFactor = 1 / (1 - evapPerDay / 100);
    return Math.ceil(-Math.log(threshold / 100) / Math.log(reverseFactor));
}

function evaporator4(
    content: number,
    evapPerDay: number,
    threshold: number
): number {
    const full = content;
    let days = 0;

    do {
        content -= (content / 100) * evapPerDay;
        days++;
    } while (content > (full / 100) * threshold);

    return days;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FLATTEN AND SORT AN NESTED ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  TWO DIMENSIONAL ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

//  ❗️❗️❗️ HAD TO CHANGE TARGET PROPERTY IN COMPILER OPTIONS TO "es2019" OR LATER  FOR flat() ❗️❗️❗️
/*
Given a two-dimensional array of integers, return the flattened version of the array with all the integers in the sorted (ascending) order.

Example:

Given [[3, 2, 1], [4, 6, 5], [], [9, 7, 8]], your function should return [1, 2, 3, 4, 5, 6, 7, 8, 9].
*/

const flattenAndSort = (inputArray: number[][]): number[] => {
    // 1️⃣  ❗️❗️❗️ THIS IS NOT WORKING IN CODEWARS ❗️❗️❗️
    // return inputArray
    //     .flat()
    //     .sort((a, b) => a - b);

    // 2️⃣
    return inputArray
        .reduce((acc, curr) => acc.concat(curr), [])
        .sort((a, b) => a - b);
};

// console.log(flattenAndSort([]));
// console.log(flattenAndSort([[], []]));
// console.log(flattenAndSort([[], [1]]));
// console.log(flattenAndSort([[3, 2, 1], [7, 9, 8], [6, 4, 5]]));
// console.log(flattenAndSort([[1, 3, 5], [100], [2, 4, 6]]));

//============= OTHER CODEWARS SOLUTIONS: =============

function flattenAndSort2(inputArray: number[][]): number[] {
    return inputArray.flat().sort((a, b) => a - b);
}

// const flattenAndSort3 = (a: number[][]): number[] => [].concat(...a).sort((a, b) => a - b);

function flattenAndSort4($: number[][]): number[] {
    return $.toString()
        .split(",")
        .filter((e) => e)
        .map(Number)
        .sort((a, b) => a - b);
}

function flattenAndSort5(inputArray: number[][]): number[] {
    let numbers: number[] = [];
    for (const tuple of inputArray) {
        numbers = [...tuple, ...numbers];
    }

    return numbers.sort((a, b) => a - b);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  CHECK COUPON - STRING DATE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  ENUM, DATE.PARSE(), NEW DATE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Story
Your online store likes to give out coupons for special occasions. Some customers try to cheat the system by entering invalid codes or using expired coupons.

Task
Your mission:
Write a function called checkCoupon which verifies that a coupon code is valid and not expired.

A coupon is no more valid on the day AFTER the expiration date. All dates will be passed as strings in this format: "MONTH DATE, YEAR".

Examples:
checkCoupon("123", "123", "July 9, 2015", "July 9, 2015")  ===  true
checkCoupon("123", "123", "July 9, 2015", "July 2, 2015")  ===  false
*/

const checkCoupon = (
    usrCode: string,
    validCode: string,
    currDate: string,
    expDate: string
): boolean => {
    const isValidCode: boolean = usrCode === validCode;
    let isValidDate: boolean = true;

    enum months {
        January = 1,
        February,
        March,
        April,
        May,
        June,
        July,
        August,
        September,
        October,
        November,
        December,
    }

    const extractDate = (date: string): string[] => {
        return date.replace(/,/g, "").split(" ");
    };

    const currYear: number = Number(extractDate(currDate)[2]);
    const expYear: number = Number(extractDate(expDate)[2]);

    // ❗️❗️❗️ HAVE TO USE ANY, string WILL THROW AN ERROR WHEN ACCESSING VALUE BY KEY (months[currMonth]) ❗️❗️❗️
    const currMonth: any = extractDate(currDate)[0];
    const currMonthIdx: any = months[currMonth];
    const expMonth: any = extractDate(expDate)[0];
    const expMonthIdx: any = months[expMonth];

    const currDay: number = Number(extractDate(currDate)[1]);
    const expDay: number = Number(extractDate(expDate)[1]);

    console.table({
        currYear: currYear,
        expYear: expYear,
        currMonth: currMonth,
        currMonthIdx: currMonthIdx,
        expMonth: expMonth,
        expMonthIdx: expMonthIdx,
        currDay: currDay,
        expDay: expDay,
    });

    //  YEAR PLUS
    if (expYear > currYear) {
        isValidDate = true;
        //  YEAR SAME
    } else if (expYear === currYear) {
        if (expMonthIdx > currMonthIdx) {
            isValidDate = true;
        } else if (expMonthIdx === currMonthIdx) {
            if (expDay >= currDay) {
                isValidDate = true;
            } else {
                isValidDate = false;
            }
        } else {
            isValidDate = false;
        }
        //  YEAR INVALID
    } else {
        isValidDate = false;
    }

    return isValidCode && isValidDate;
};

/*

isvalidCode WILL CHECK IF CODES MATCH
INITIALIZE isValidDate
ASSIGN NUMERIC VALUES TO MONTHS FOR COMPARISON
extractDate WILL CONVERT STRING TO ARRAY ["September", "5", "2015"]
STORE YEAR, MONTH INDEX AND DAY IN VARIABLES (CONVERTED TO NUMBER)
┌──────────────┬───────────┐
│   (index)    │  Values   │
├──────────────┼───────────┤
│   currYear   │   2014    │
│   expYear    │   2014    │
│  currMonth   │ 'January' │
│ currMonthIdx │     1     │
│   expMonth   │ 'January' │
│ expMonthIdx  │     1     │
│   currDay    │     5     │
│    expDay    │     1     │
└──────────────┴───────────┘
if BLOCK DETERMINES IF DATE IS VALID
RETURN TRUE IF BOTH CODE AND DATE ARE VALID, OTHERWISE FALSE

*/

// console.log(checkCoupon('123', '123', 'September 5, 2014', 'October 1, 2014'));
// console.log(checkCoupon('123a', '123', 'September 5, 2014', 'October 1, 2014'));
// console.log(checkCoupon('12abcd3', '12abcd3', 'January 5, 2014', 'January 1, 2014'));

//============= OTHER CODEWARS SOLUTIONS: =============

function checkCoupon2(
    enteredCode: string,
    correctCode: string,
    currentDate: string,
    expirationDate: string
): boolean {
    return (
        enteredCode === correctCode &&
        Date.parse(currentDate) <= Date.parse(expirationDate)
    );
}

function checkCoupon3(
    enteredCode: string,
    correctCode: string,
    currentDate: string,
    expirationDate: string
): boolean {
    let cDate = new Date(currentDate);
    let expDate = new Date(expirationDate);
    return enteredCode === correctCode && cDate <= expDate ? true : false;
}

function checkCoupon4(
    enteredCode: string,
    correctCode: string,
    currentDate: string,
    expirationDate: string
): boolean {
    const isValidCode = enteredCode === correctCode;
    const isValidDate = new Date(currentDate) <= new Date(expirationDate);
    return isValidCode && isValidDate;
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ROW WEIGHTS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REDUCE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Scenario
Several people are standing in a row divided into two teams.
The first person goes into team 1, the second goes into team 2, the third goes into team 1, and so on.

Task
Given an array of positive integers (the weights of the people), return a new array/tuple of two integers, where the first one is the total weight of team 1, and the second one is the total weight of team 2.

Notes
Array size is at least 1.
All numbers will be positive.
Input >> Output Examples
rowWeights([13, 27, 49])  ==>  return (62, 27)
Explanation:
The first element 62 is the total weight of team 1, and the second element 27 is the total weight of team 2.

rowWeights([50, 60, 70, 80])  ==>  return (120, 140)
Explanation:
The first element 120 is the total weight of team 1, and the second element 140 is the total weight of team 2.

rowWeights([80])  ==>  return (80, 0)
Explanation:
The first element 80 is the total weight of team 1, and the second element 0 is the total weight of team 2.
*/

const rowWeights = (arr: number[]): number[] => {
    let arr1: number[] = [],
        arr2: number[] = [];

    arr.forEach((num, idx) => {
        idx & 1 ? arr1.push(num) : arr2.push(num);
    });

    return [arr2.reduce((a, b) => a + b), arr1.reduce((a, b) => a + b)];
};

//  INITIALIZE ARRAYS WITH 0 IN CASE arr HAS ONLY ONE ELEMENT
//  LOOP THROUGH INPUT arr
//      CHECK IF idx IS ODD (!!! idx & 1 RETURNS 1 IF idx IS ODD !!!)
//          IF SO, PUSH num TO arr1
//          OTHERWISE, PUSH num TO arr2
//  RETURN [SUM OF BOTH arr1 AND arr2]

// console.log(rowWeights([50, 60, 70, 80]));

//============= OTHER CODEWARS SOLUTIONS: =============

function rowWeights2(arr: number[]) {
    return arr.reduce((r, e, i) => ((r[i % 2] += e), r), [0, 0]);
}

function rowWeights3(arr: number[]): [number, number] {
    let even: number = arr.reduce((sum, x, i) => sum + (!(i % 2) ? x : 0), 0);
    let odd: number = arr.reduce((sum, x, i) => sum + (i % 2 ? x : 0), 0);
    return [even, odd];
}

function rowWeights4(arr: number[]) {
    return arr.reduce(
        (a: number[], c: number, i: number) =>
            i % 2 ? [a[0], a[1] + c] : [a[0] + c, a[1]],
        [0, 0]
    );
}

function rowWeights5(arr: number[]): number[] {
    return arr.reduce(
        (sumOfWeights, weight, i) => {
            sumOfWeights[i % 2] += weight;
            return sumOfWeights;
        },
        [0, 0]
    );
}

function rowWeights6(arr: number[]) {
    const res = [0, 0];

    arr.forEach((x, i) => {
        if (i % 2 === 0) {
            res[0] += x;
        } else {
            res[1] += x;
        }
    });

    return res;
}

function rowWeights7(arr: number[]) {
    let arr1 = 0;
    let arr2 = 0;
    arr.forEach((value, index) =>
        index % 2 ? (arr2 += value) : (arr1 += value)
    );
    return [arr1, arr2];
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SORT ARRAY NUMERICALLY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  SORT()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Finish the solution so that it sorts the passed in array of numbers. If the function passes in an empty array or null/nil value then it should return an empty array.

For example:

solution([1, 2, 10, 50, 5]); // should return [1, 2, 5, 10, 50]
solution([]); // should return []
*/

const sortNumbers = (numsArr: number[]): number[] => {
    return numsArr.sort((a, b) => a - b);
};

// console.log(sortNumbers([1, 2, 10, 50, 5]));

//============= OTHER CODEWARS SOLUTIONS: =============

function sortNumbers2(nums: number[]): number[] {
    return nums ? nums.sort((a, b) => a - b) : [];
}

function sortNumbers3(nums: number[]): number[] {
    return nums === null ? [] : nums.sort((left, right) => left - right);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  	REMOVE DUPLICATES FROM STRING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REDUCE(), FILTER(), SET(), ARRAY.FROM()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to remove all duplicate words from a string, leaving only single (first) words entries.

Example:

Input:

'alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta'

Output:

'alpha beta gamma delta'
*/

// ❗️❗️❗️ .reduce((acc: string[], curr) SPECIFY TYPE FOR acc ❗️❗️❗️
const removeDuplicateWords = (str: string): string => {
    return str
        .split(" ")
        .reduce(
            (acc: string[], curr) =>
                acc.includes(curr) ? acc : [...acc, curr],
            []
        )
        .join(" ");
};

// console.log(removeDuplicateWords('alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta'))

//============= OTHER CODEWARS SOLUTIONS: =============

function removeDuplicateWords2(s: string): string {
    return Array.from(new Set(s.split(" "))).join(" ");
}

function removeDuplicateWords3(s: string): string {
    return s
        .split(" ")
        .filter((v, i, a) => a.indexOf(v) === i)
        .join(" ");
}

function removeDuplicateWords4(s: string): string {
    return [...new Set(s.match(/[a-z]+/gi) || [])].join(" ");
}

function removeDuplicateWords5(s: string): string {
    const wordArray = s.split(" ");
    const wordSet = new Set(wordArray);
    const result = Array.from(wordSet).join(" ");
    return result;
}

function removeDuplicateWords6(s: string): string {
    let result: string[] = [];
    s.split(" ").forEach((string, index) => {
        if (result.indexOf(string) === -1) {
            result.push(string);
        }
    });
    return result.join(" ");
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ALTERNATE CAPITALIZATION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a string, capitalize the letters that occupy even indexes and odd indexes separately, and return as shown below. Index 0 will be considered even.

For example, capitalize("abcdef") = ['AbCdEf', 'aBcDeF']. See test cases for more examples.

The input will be a lowercase string with no spaces.
*/

const capitalize = (str: string): string[] => {
    let odds: string = "",
        evens: string = "";

    for (let i = 0; i < str.length; i++) {
        evens += i % 2 === 0 ? str[i].toUpperCase() : str[i];
        odds += i % 2 > 0 ? str[i].toUpperCase() : str[i];
    }

    return [evens, odds];
};

//  INITIALIZE EMPTY STRINGS FOR BOTH WORDS
//  LOOP OVER str
//      BUILD evens
//      BUILD odds
// RETURN SOLUTION AS ARRAY OF STRINGS

// console.log(capitalize("abcdef"));

//============= OTHER CODEWARS SOLUTIONS: =============

const capitalize2 = (s: string) => [
    [...s].map((l, i) => (i % 2 ? l : l.toUpperCase())).join(""),
    [...s].map((l, i) => (i % 2 ? l.toUpperCase() : l)).join(""),
];

function capitalize3(s: string) {
    const output = ["", ""];
    s.split("").forEach((letter, index) => {
        output[0] += index % 2 ? letter : letter.toUpperCase();
        output[1] += !(index % 2) ? letter : letter.toUpperCase();
    });
    return output;
}

function capitalize4(s: string) {
    return [...s].reduce(
        (acc, curr, indx) => {
            const isEven = indx % 2 == 0;
            acc[0] += curr[isEven ? "toUpperCase" : "toLowerCase"]();
            acc[1] += curr[!isEven ? "toUpperCase" : "toLowerCase"]();
            return acc;
        },
        ["", ""]
    );
}

function capitalize5(s: string): Array<string> {
    return [
        s
            .split("")
            .map((letter, i) =>
                i % 2 === 0 ? letter.toUpperCase() : letter.toLowerCase()
            )
            .join(""),
        s
            .split("")
            .map((letter, i) =>
                i % 2 !== 0 ? letter.toUpperCase() : letter.toLowerCase()
            )
            .join(""),
    ];
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  MAXIMUM LENGTH DIFFERENCE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You are given two arrays a1 and a2 of strings. Each string is composed with letters from a to z. Let x be any string in the first array and y be any string in the second array.

Find max(abs(length(x) − length(y)))

If a1 and/or a2 are empty return -1 in each language except in Haskell (F#) where you will return Nothing (None).

Example:
a1 = ["hoqq", "bbllkw", "oox", "ejjuyyy", "plmiis", "xxxzgpsssa", "xxwwkktt", "znnnnfqknaz", "qqquuhii", "dvvvwz"]
a2 = ["cccooommaaqqoxii", "gggqaffhhh", "tttoowwwmmww"]
mxdiflg(a1, a2) --> 13
Bash note:
input : 2 strings with substrings separated by ,
output: number as a string
*/

// 1️⃣
class G964 {
    // 1️⃣
    public static mxdiflg = (a1: string[], a2: string[]): number => {
        if (!a1.length || !a2.length) return -1;

        const shortest1: number = Math.min(...a1.map((word) => word.length));
        const longest1: number = Math.max(...a1.map((word) => word.length));
        const shortest2: number = Math.min(...a2.map((word) => word.length));
        const longest2: number = Math.max(...a2.map((word) => word.length));

        return Math.max(
            Math.abs(shortest1 - longest2),
            Math.abs(longest1 - shortest2)
        );
    };

    // 2️⃣
    public static mxdiflg2 = (a1: string[], a2: string[]): number => {
        if (!a1.length || !a2.length) return -1;

        const getShortest = (arr: string[]) =>
            Math.min(...arr.map((word): number => word.length));
        const getLongest = (arr: string[]) =>
            Math.max(...arr.map((word): number => word.length));

        const shortest1 = getShortest(a1);
        const longest1 = getLongest(a1);
        const shortest2 = getShortest(a2);
        const longest2 = getLongest(a2);

        return Math.max(
            Math.abs(shortest1 - longest2),
            Math.abs(longest1 - shortest2)
        );
    };

    // 3️⃣
    public static mxdiflg3 = (a1: string[], a2: string[]): number => {
        if (!a1.length || !a2.length) return -1;

        // REFACTOR getShortest / getShortest
        const getMinMax = (arr: string[], output: string): number => {
            // ❗️❗️❗️ HAVE TO USE ENDING RETURN STATEMENT WITH TERNARY ❗️❗️❗️
            // if (output === "min") return Math.min(...arr.map((word): number => word.length));
            // if (output === "max") return Math.max(...arr.map((word): number => word.length));

            return output === "min"
                ? Math.min(...arr.map((word): number => word.length))
                : Math.max(...arr.map((word): number => word.length));
        };

        const shortest1 = getMinMax(a1, "min");
        const longest1 = getMinMax(a1, "max");
        const shortest2 = getMinMax(a2, "min");
        const longest2 = getMinMax(a2, "max");

        return Math.max(
            Math.abs(shortest1 - longest2),
            Math.abs(longest1 - shortest2)
        );
    };

    // 4️⃣  FINAL:
    public static mxdiflg4 = (a1: string[], a2: string[]): number => {
        const getMinMax = (arr: string[], output: string): number => {
            return output === "min"
                ? Math.min(...arr.map((word): number => word.length))
                : Math.max(...arr.map((word): number => word.length));
        };

        const shortest1 = getMinMax(a1, "min");
        const longest1 = getMinMax(a1, "max");
        const shortest2 = getMinMax(a2, "min");
        const longest2 = getMinMax(a2, "max");

        return a1.length && a2.length // (!a1.length || !a2.length)
            ? Math.max(
                Math.abs(shortest1 - longest2),
                Math.abs(longest1 - shortest2)
            )
            : -1;
    };
}

//  getMinMax WILL CALCULATE THE LENGTH OF THE LONGEST OR SHORTEST ELEMENT OF ARRAY PASSED IN
//  CALCULATE LONGEST AND SHORTEST ELEMENTS FOR BOTH ARRAYS
//  CHECK ARRAY LENGTHS
//      IF BOTH VALID, RETURN MAX DIFFERENCE
//      OTHERWISE, -1

// var s1 = ["hoqq", "bbllkw", "oox", "ejjuyyy", "plmiis", "xxxzgpsssa", "xxwwkktt", "znnnnfqknaz", "qqquuhii", "dvvvwz"];
// var s2 = ["cccooommaaqqoxii", "gggqaffhhh", "tttoowwwmmww"];

// const s1 = ['ejjjjmmtthh',
//     'zxxuueeg',
//     'aanlljrrrxx',
//     'dqqqaaabbb',
//     'oocccffuucccjjjkkkjyyyeehh']

// const s2 = ['bbbaaayddqbbrrrv']

// console.log(G964.mxdiflg(s1, s2));

//============= OTHER CODEWARS SOLUTIONS: =============

/*

export class G964 {
  
    public static mxdiflg = (a1, a2) => {
        let max = -1;
        for (let x of a1) {
          for (let y of a2) {
            max = Math.max(Math.abs(x.length - y.length), max);
          }
        }
        
        return max;
    }
}


export class G964 {
    public static mxdiflg = (a1, a2) => {
      if (!a1.length || !a2.length) return -1;
      const x = Math.max(...a1.map(v => v.length)) - Math.min(...a2.map(v => v.length));
      const y = Math.max(...a2.map(v => v.length)) - Math.min(...a1.map(v => v.length));
      return x > y ? x : y;
    }
  }



  export class G964 {
    public static mxdiflg = (a1, a2) => !a1.length || !a2.length ? -1 : Math.max(...a1.map(s1 => Math.max(...a2.map(s2 => Math.abs(s1.length - s2.length)))));
}

*/

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIX STRING CASE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
In this Kata, you will be given a string that may have mixed uppercase and lowercase letters and your task is to convert that string to either lowercase only or uppercase only based on:

make as few changes as possible.
if the string contains equal number of uppercase and lowercase letters, convert the string to lowercase.
For example:

solve("coDe") = "code". Lowercase characters > uppercase. Change only the "D" to lowercase.
solve("CODe") = "CODE". Uppercase characters > lowecase. Change only the "e" to uppercase.
solve("coDE") = "code". Upper == lowercase. Change all to lowercase.
More examples in test cases. Good luck!
*/

// 1️⃣  ❗️❗️❗️ THIS WORKS IN IDE BUT THROWS ERROR IN CODEWARS ❗️❗️❗️
// (OBJECT IS POSSIBLY NULL)

// const solve = (str: string) => {

//     const capitals: number | undefined = str.match(/[A-Z]/g)?.length;

//     if (capitals) {
//         return capitals > str.length / 2 ? str.toUpperCase() : str.toLowerCase();
//     } else {
//         return str.toLowerCase();
//     }

// }

// 2️⃣ ✅ SOLVED WITH DIFFERENT LOGIC:
const solve = (str: string) => {
    let upperC: number = 0;

    for (const letter of str) {
        if (/[A-Z]/.test(letter)) upperC++;
    }

    return upperC > str.length / 2 ? str.toUpperCase() : str.toLowerCase();
};

// console.log(solve("code"));
// console.log(solve("CODe"));
// console.log(solve("COde"));
// console.log(solve("Code"));

//============= OTHER CODEWARS SOLUTIONS: =============

function solve2(s: string) {
    let uppercaseCount = s
        .split("")
        .filter((letter) => letter === letter.toUpperCase()).length;
    return uppercaseCount > s.length / 2 ? s.toUpperCase() : s.toLowerCase();
}

// ❗️❗️❗️ MATCH(REGEX || []) ❗️❗️❗️
function solve3(s: string): string {
    return (s.match(/[a-z]/g) || []).length >= s.length / 2
        ? s.toLowerCase()
        : s.toUpperCase();
}

const solve4 = (s: string) => {
    const upperCs = s.split("").filter((x) => x == x.toUpperCase());
    return upperCs.length > s.length / 2 ? s.toUpperCase() : s.toLowerCase();
};

function solve5(s: string) {
    return s.replace(/[a-z]/g, "").length > s.length / 2
        ? s.toUpperCase()
        : s.toLowerCase();
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FORM THE MINIMUM (SMALLEST NUMBER WITHOUT DUPLICATION)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  SET(), ARRAY.FROM()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a list of digits, return the smallest number that could be formed from these digits, using the digits only once (ignore duplicates).

Notes:
Only positive integers will be passed to the function (> 0 ), no negatives or zeros.
Input >> Output Examples
minValue ({1, 3, 1})  ==> return (13)
Explanation:
(13) is the minimum number could be formed from {1, 3, 1} , Without duplications

minValue({5, 7, 5, 9, 7})  ==> return (579)
Explanation:
(579) is the minimum number could be formed from {5, 7, 5, 9, 7} , Without duplications

minValue({1, 9, 3, 1, 7, 4, 6, 6, 7}) return  ==> (134679)
Explanation:
(134679) is the minimum number could be formed from {1, 9, 3, 1, 7, 4, 6, 6, 7} , Without duplications
*/

const minValue = (values: number[]): number => {
    //1️⃣
    // const uniques = new Set(values);
    // const incrOrder = Array.from(uniques).sort();
    // let numStr = "";
    // incrOrder.forEach((digit) => {
    //     numStr += digit;
    // })
    // return Number(numStr);

    // 2️⃣
    // const uniques = new Set(values);
    // return Number(Array.from(uniques).sort().join(""));

    // 3️⃣
    return Number(Array.from(new Set(values)).sort().join(""));
};

//  REMOVE DUPLICATES USING Set
//  MAKE ARRAY FROM UNUQUE VALUES
//  SORT ARRAY IN ASCENDING ORDER
//  JOIN INTO STRING
//  CONVERT TO NUMBER

// console.log(minValue([4, 7, 5, 7]));
// console.log(minValue([6, 7, 8, 7, 6, 6]));

//============= OTHER CODEWARS SOLUTIONS: =============

const minValue2 = (values: Array<number>): number => {
    return +[...new Set(values)].sort().join("");
};

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SMALL ENOUGH?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  EVERY()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You will be given an array and a limit value. You must check that all values in the array are below or equal to the limit value. If they are, return true. Else, return false.

You can assume all values in the array are numbers.
*/

const smallEnough = (arr: number[], limit: number): boolean => {
    // const checkLimit = (num: number) => num <= limit;

    // return arr.every(checkLimit);

    return arr.every((num: number) => num <= limit);
};

// console.log(smallEnough([101, 45, 75, 105, 99, 107], 107));
// console.log(smallEnough([78, 117, 110, 99, 104, 117, 107, 115], 100));

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  CHECK THE EXAM
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  SWITCH(), NESTED TERNARY, CONTINUE, MATH.MAX()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The first input array is the key to the correct answers to an exam, like ["a", "a", "b", "d"]. The second one contains a student's submitted answers.

The two arrays are not empty and are the same length. Return the score for this array of answers, giving +4 for each correct answer, -1 for each incorrect answer, and +0 for each blank answer, represented as an empty string (in C the space character is used).

If the score < 0, return 0.

For example:

checkExam(["a", "a", "b", "b"], ["a", "c", "b", "d"]) → 6
checkExam(["a", "a", "c", "b"], ["a", "a", "b",  ""]) → 7
checkExam(["a", "a", "b", "c"], ["a", "a", "b", "c"]) → 16
checkExam(["b", "c", "b", "a"], ["",  "a", "a", "c"]) → 0
*/

const checkExam = (array1: string[], array2: string[]): number => {
    let score: number = 0;

    for (let i = 0; i < array2.length; i++) {
        switch (array2[i]) {
            case "":
                score += 0;
                break;
            case array1[i]:
                score += 4;
                break;
            default:
                score += -1;
        }
    }

    return score < 0 ? 0 : score;
};

// console.log(checkExam(["a", "a", "b", "b"], ["a", "c", "b", "d"]));
// console.log(checkExam(["a", "a", "c", "b"], ["a", "a", "b", ""]));
// console.log(checkExam(["a", "a", "b", "c"], ["a", "a", "b", "c"]));
// console.log(checkExam(["b", "c", "b", "(a"], ["", "a", "a", "c"]));

//============= OTHER CODEWARS SOLUTIONS: =============

function checkExam2(array1: string[], array2: string[]): number {
    let result = 0;

    array2.forEach((item, index) => {
        item === array1[index]
            ? (result += 4)
            : item === ""
                ? (result += 0)
                : (result -= 1);
    });

    return Math.max(result, 0);
}

function checkExam3(array1: string[], array2: string[]): number {
    let score = 0;
    for (let i = 0; i < array1.length; i++) {
        if (array2[i] === "") continue;
        else if (array1[i] === array2[i]) score += 4;
        else score--;
    }
    return score > 0 ? score : 0;
}

function checkExam4(array1: string[], array2: string[]): number {
    return Math.max(
        0,
        array2.reduce(
            (a, b, i) => a + (b == "" ? 0 : b === array1[i] ? 4 : -1),
            0
        )
    );
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SUM DIGITS OF NUMBER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function named sumDigits which takes a number as input and returns the sum of the absolute value of each of the number's decimal digits.

For example: (Input --> Output)

10 --> 1
99 --> 18
-32 --> 5
Let's assume that all numbers in the input will be integer values.
*/

const sumDigits = (num: number): number => {
    return Math.abs(num)
        .toString()
        .split("")
        .map((digit) => Number(digit))
        .reduce((a, b) => a + b);
};

//  GET ABSOLUTE VALUE
//  CONVERT TO STRING
//  SPLIT INTO ARRAY OF STRINGS
//  CONVERT TO ARRAY OF NUMBERS
//  GET SUM

// console.log(sumDigits(453));
// console.log(sumDigits(-32));

//============= OTHER CODEWARS SOLUTIONS: =============

function sumDigits2(number: number): number {
    return Math.abs(number)
        .toString()
        .split("")
        .reduce((acc, digit) => parseInt(digit) + acc, 0);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  GIVEN A DIVISOR AND BOUND FOUND LARGEST INT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a Divisor and a Bound , Find the largest integer N , Such That ,

Conditions :
N is divisible by divisor

N is less than or equal to bound

N is greater than 0.

Notes
The parameters (divisor, bound) passed to the function are only positive values .
It's guaranteed that a divisor is Found .
Input >> Output Examples
maxMultiple (2,7) ==> return (6)
Explanation:
(6) is divisible by (2) , (6) is less than or equal to bound (7) , and (6) is > 0
*/

const maxMultiple = (divisor: number, bound: number): number => {
    let solution: number = 0;

    for (let num = bound; num > 0; num--) {
        if (num % divisor === 0) {
            solution = num;
            break;
        }
    }

    return solution;
};

//  START LOOP AT bound, DECREMENT BY 1
//  RETURN FIRST num THAT IS DIVISIBLE BY divisor

// console.log(maxMultiple(37, 200));

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️
function maxMultiple2(divisor: number, bound: number) {
    return bound - (bound % divisor);
}

function maxMultiple3(divisor: number, bound: number) {
    return Math.floor(bound / divisor) * divisor;
}

function maxMultiple4(divisor: number, bound: number) {
    for (let n = bound; n > 0; n -= 1) if (n % divisor === 0) return n;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  GET TWO LARGEST NUMBERS OF ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  FILTER() TO REMOVE DUPLICATES, SORT() NUMERICALLY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The two oldest ages function/method needs to be completed. It should take an array of numbers as its argument and return the two highest numbers within the array. The returned value should be an array in the format [second oldest age, oldest age].

The order of the numbers passed in could be any order. The array will always include at least 2 items. If there are two or more oldest age, then return both of them in array format.

For example:

two_oldest_ages( 4, {1, 2, 10, 8}, result) // should fill result array with {8, 10}
*/

const twoOldestAges = (ages: number[]): number[] => {
    return (
        ages
            // .filter((curr, index) => ages.indexOf(curr) === index)
            .sort((a, b) => b - a)
            .slice(0, 2)
            .reverse()
    );
};

//  FILTER WILL REMOVE DUPLICATES IF NEEDED
// SORT ARRAY DESCENDING NUMERICALLY
// GET FIRST TWO ELEMENTS
// REVERSE

// console.log(twoOldestAges([1, 5, 87, 45, 8, 8, 87]));
// console.log(twoOldestAges([1, 5, 87, 45, 8, 8]));

//============= OTHER CODEWARS SOLUTIONS: =============

const twoOldestAges2 = (ages: any) =>
    ages.sort((a: any, b: any) => a - b).slice(ages.length - 2);

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  COUNT NUMBER OF DIVISORS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Count the number of divisors of a positive integer n.

Random tests go up to n = 500000.

Examples (input --> output)
4 --> 3 (1, 2, 4)
5 --> 2 (1, 5)
12 --> 6 (1, 2, 3, 4, 6, 12)
30 --> 8 (1, 2, 3, 5, 6, 10, 15, 30)
*/

const divisors = (num: number): number => {
    if (num === 1) return 1;

    const divisors: number[] = [];

    for (let i = 1; i <= num / 2; i++) {
        let divisor1: number = i,
            divisor2: number = num / i;

        if (Number.isInteger(num / divisor1)) {
            // console.table({ divisor1: i, divisor2: num / i });

            if (!divisors.includes(divisor1)) {
                if (divisor1 === divisor2) {
                    divisors.push(divisor1);
                } else {
                    divisors.push(divisor1, divisor2);
                }
            }
        }
    }

    // console.log(divisors, divisors.length);
    return divisors.length;
};

//  LOOP OVER INTEGERS UP TO num / 2
//     IF num CAN BE DIVIDED BY divisor1
//        IF divisors ARRAY DOES NOT INCLUDE divisor1
//            IF divisor1 EQUALS divisor2
//                ONLY PUSH divisor1 TO AVOID DUPLICATES (8*8=64)
//            OTHERWISE
//                PUSH BOTH DIVISORS

//  RETURN LENGTH OF ARRAY AS RESULT

// console.log(divisors(1));
// console.log(divisors(64));
// console.log(divisors(4));

//============= OTHER CODEWARS SOLUTIONS: =============

function divisors2(n: number) {
    let steps = 0;

    for (let i = 0; i <= n; i++) {
        if (n % i === 0) steps++;
    }

    return steps;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  COUNT DIGIT APPEARING IN SQUARES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REGEXP OBJECT, MATCH()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Take an integer n (n >= 0) and a digit d (0 <= d <= 9) as an integer.

Square all numbers k (0 <= k <= n) between 0 and n.

Count the numbers of digits d used in the writing of all the k**2.

Call nb_dig (or nbDig or ...) the function taking n and d as parameters and returning this count.

Examples:
n = 10, d = 1 
the k*k are 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100
We are using the digit 1 in: 1, 16, 81, 100. The total count is then 4.

nb_dig(25, 1) returns 11 since
the k*k that contain the digit 1 are:
1, 16, 81, 100, 121, 144, 169, 196, 361, 441.
So there are 11 digits 1 for the squares of numbers between 0 and 25
*/

const nbDig = (num: number, digit: number): number => {
    let counter: number = 0;
    const regex = new RegExp(String(digit), "g");

    for (let i = 0; i <= num; i++) {
        let squareStr = String(Math.pow(i, 2));
        const matches = squareStr.match(regex);
        // console.table({
        //     square: squareStr,
        //     digit: String(digit),
        //     matches: matches?.length
        // });
        if (matches) counter += matches.length;
    }

    return counter;
};

//  CREATE JS REGEXP OBJECT FOR digit
//  LOOP OVER INTEGERS UP TO AND ICLUDING num
//      CALC SQUARE, CONVERT TO STRING AN SAVE TO VAR squareStr
//      GET ARRAY OF MATCHES (matches)
//      IF matches ARRAY IS NOT EMPTY
//          INCREMENT counter BY matches.length
//  RETURN counter AS RESULT

// 6
// console.log(nbDig(11, 1));

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  BREAKING CHOCOLEATE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to split the chocolate bar of given dimension n x m into small squares. Each square is of size 1x1 and unbreakable. Implement a function that will return minimum number of breaks needed.

For example if you are given a chocolate bar of size 2 x 1 you can split it to single squares in just one break, but for size 3 x 1 you must do two breaks.

If input data is invalid you should return 0 (as in no breaks are needed if we do not have any chocolate to split). Input will always be a non-negative integer.
*/

const breakChocolate = (n: number, m: number): number => {
    return n * m > 1 ? n * m - 1 : 0;
};

// console.log(breakChocolate(5, 5));

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  DONT GIVE ME FIVE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REGEX.TEST()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
In this kata you get the start number and the end number of a region and should return the count of all numbers except numbers with a 5 in it. The start and the end number are both inclusive!

Examples:

1,9 -> 1,2,3,4,6,7,8,9 -> Result 8
4,17 -> 4,6,7,8,9,10,11,12,13,14,16,17 -> Result 12
The result may contain fives. ;-)
The start number will always be smaller than the end number. Both numbers can be also negative!
*/

const dontGiveMeFive = (start: number, end: number): number => {
    let counter = 0;

    for (let i = start; i <= end; i++) {
        if (!/5/g.test(String(i))) {
            counter++;
        }
    }

    return counter;
};

//  TEST FOR A MATCH IN STRING(NUM) FOR "5"
//      IF NO MATCH, INCREMENT COUNTER
//  RETURN COUNTER AS RESULT

// return /^(\d{4}|\d{6})$/.test(pin);

// console.log(dontGiveMeFive(1, 9));
// console.log(dontGiveMeFive(4, 17));

//============= OTHER CODEWARS SOLUTIONS: =============

function dontGiveMeFive2(start: number, end: number): number {
    return Array.from(
        { length: end - start + 1 },
        (ix, it) => it + start
    ).filter((it) => !/5/.test(it + "")).length;
}

function dontGiveMeFive3(start: number, end: number): number {
    return Array.from({ length: end - start + 1 }, (_, i) => i + start).filter(
        (x) => !/5/.test(`${x}`)
    ).length;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  REVERSE WORDS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Complete the function that accepts a string parameter, and reverses each word in the string. All spaces in the string should be retained.

Examples
"This is an example!" ==> "sihT si na !elpmaxe"
"double  spaces"      ==> "elbuod  secaps"

*/

const reverseWords = (str: string): string => {
    return str
        .split(" ")
        .map((word) => word.split("").reverse().join(""))
        .join(" ");
};

// console.log(reverseWords('The quick brown fox jumps over the lazy dog.'));

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SUM OF THE FIRST NTH TERM OF SERIES ROUNDED TO 2 DIGITS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  TOFIXED(2), TRACKING MULTIPLE VARIABLES IN FOR LOOP
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to write a function which returns the sum of following series upto nth term(parameter).

Series: 1 + 1/4 + 1/7 + 1/10 + 1/13 + 1/16 +...
Rules:
You need to round the answer to 2 decimal places and return it as String.

If the given value is 0 then it should return 0.00

You will only be given Natural Numbers as arguments.

Examples:(Input --> Output)
1 --> 1 --> "1.00"
2 --> 1 + 1/4 --> "1.25"
5 --> 1 + 1/4 + 1/7 + 1/10 + 1/13 --> "1.57"
*/

const SeriesSum = (num: number): string => {
    let sum: number = 0;

    for (let i = 0, denominator = 1; i < num; i++, denominator += 3) {
        sum += 1 / denominator;
    }

    return String(sum.toFixed(2));
};

// TRACK/INCREMENT NUM AND DENOMINATOR IN LOOP
// INCREMENT SUM WITH 1 / DENOMINATOR NUM TIMES
// ROUND DOWN TO TWO DIGITS AND CONVERT NO STRING

// console.log(SeriesSum(1));
// console.log(SeriesSum(2));
// console.log(SeriesSum(3));

//============= OTHER CODEWARS SOLUTIONS: =============

function SeriesSum2(n: number): string {
    return [...Array(n).keys()]
        .map((k) => 1 / (k * 3 + 1))
        .reduce((acc, n) => acc + n, 0)
        .toFixed(2);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  STRING END WITH?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  ENDSWITH()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Complete the solution so that it returns true if the first argument(string) passed in ends with the 2nd argument (also a string).

Examples:

solution('abc', 'bc') // returns true
solution('abc', 'd') // returns false
*/

const solution = (str: string, ending: string): boolean => {
    return str.endsWith(ending);
};

// console.log(solution('abcde', 'cde'));
// console.log(solution('abcde', 'rde'));

//============= OTHER CODEWARS SOLUTIONS: =============

function solution2(str: string, ending: string): boolean {
    return !ending.length || str.slice(-ending.length) === ending;
}

function solution3(str: string, ending: string): boolean {
    const strSubstring = str.slice(str.length - ending.length);
    return strSubstring === ending; // TODO: complete
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ODD OR EVEN (SUM OF ARRAY)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REDUCE(), BITWISE AND (ODD OR EVEN), DOUBLE NESTED TERNARY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a list of integers, determine whether the sum of its elements is odd or even.

Give your answer as a string matching "odd" or "even".

If the input array is empty consider it as: [0] (array with a zero).
*/

// num(1) & 1 => 1   RETURNS  1 IF N IS ODD
// num(2) & 1 => 0   RETURNS 0 IF N IS EVEN

const oddOrEven = (array: number[]): string => {
    // if (array.length === 0) return "even";
    // return array.reduce((a, b) => a + b) & 1
    //     ? "odd"
    //     : "even";

    return array.length > 0
        ? array.reduce((a, b) => a + b) & 1
            ? "odd"
            : "even"
        : "even";
};

// console.log(oddOrEven([0, -1, -3]));
// console.log(oddOrEven([0, -1, -4]));
// console.log(oddOrEven([]));

//============= OTHER CODEWARS SOLUTIONS: =============

function oddOrEven2(array: number[]) {
    return array.reduce((acc, it) => acc + it, 0) % 2 ? "odd" : "even";
}

const oddOrEven3 = (array: number[]) =>
    array.reduce((acc, curr) => (acc += curr), 0) % 2 === 0 ? "even" : "odd";

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  NUMBER OF PEOPLE ON THE BUS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REDUCE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
There is a bus moving in the city, and it takes and drop some people in each bus stop.

You are provided with a list (or array) of integer pairs. Elements of each pair represent number of people get into bus (The first item) and number of people get off the bus (The second item) in a bus stop.

Your task is to return number of people who are still in the bus after the last bus station (after the last array). Even though it is the last bus stop, the bus is not empty and some people are still in the bus, and they are probably sleeping there :D

Take a look on the test cases.

Please keep in mind that the test cases ensure that the number of people in the bus is always >= 0. So the return integer can't be negative.

The second value in the first integer array is 0, since the bus is empty in the first bus stop.
*/

const number = (busStops: [number, number][]): number => {
    let counter: number = 0;

    busStops.forEach((stop) => {
        counter += stop[0];
        counter -= stop[1];
    });

    return counter;
};

// console.log(number([[10, 0], [3, 5], [5, 8]]));
// console.log(number([[3, 0], [9, 1], [4, 10], [12, 2], [6, 1], [7, 10]]));

//============= OTHER CODEWARS SOLUTIONS: =============

function number2(busStops: number[][]): number {
    return busStops.reduce((rem, [on, off]) => rem + (on - off), 0);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SUM OF ODD NUMBERS IN TRIANGLE OF CONS. ODD NUMS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given the triangle of consecutive odd numbers:

             1
          3     5
       7     9    11
   13    15    17    19
21    23    25    27    29
...
Calculate the sum of the numbers in the nth row of this triangle (starting at index 1) e.g.: (Input --> Output)

1 -->  1
2 --> 3 + 5 = 8
*/

function rowSumOddNumbers(n: number): number {
    return Math.pow(n, 3);
    //     return n ** 3;
}

// FIRST SOLUTION IN JS:

// const rowSumOddNumbers2 = (n) => {
//     const firstOfRow = n + Math.pow(n - 1, 2);
//     const subTotal = firstOfRow * n;
//     let increments = 0;
//     for (let j = 0; j <= n * 2 - 2; j += 2) {
//         increments = increments + j;
//     }
//     total = subTotal + increments;
//     return total;
// };

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  IS THIS A TRIANGLE?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Implement a function that accepts 3 integer values a, b, c. The function should return true if a triangle can be built with the sides of given length and false in any other case.

(In this case, all triangles must have surface greater than 0 to be accepted).
*/

const isTriangle = (a: number, b: number, c: number): boolean => {
    return a + b > c && a + c > b && b + c > a;
};

//   SUM OF ANY TWO SIDES MUST BE GREATER THAN THIRD SIDE

// console.log(isTriangle(1, 2, 2));
// console.log(isTriangle(7, 2, 2));

//============= OTHER CODEWARS SOLUTIONS: =============

const isTriangle2 = (a: number, b: number, c: number): boolean =>
    a + b <= c || a + c <= b || b + c <= a ? false : true;

function isTriangle3(a: number, b: number, c: number): boolean {
    return a + b <= c ? false : a + c <= b ? false : b + c <= a ? false : true;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  REGEX VALIDATE PIN CODE (4 OR 6 DIGITS)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REGEX
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

const validatePin = (pin: string): boolean => {
    // if (pin.length === 4 && pin.match(/\d/g)!.length === 4) return true;
    // if (pin.length === 6 && pin.match(/\d/g)!.length === 6) return true;
    // return false;

    return (
        (pin.length === 4 && pin.match(/\d/g)!.length === 4) ||
        (pin.length === 6 && pin.match(/\d/g)!.length === 6)
    );
};

// console.log(validatePin("12345654yw"));
// console.log(validatePin("123456"));
// console.log(validatePin("12345a"));
// console.log(validatePin("1234"));
// console.log(validatePin("-1234"));

//============= OTHER CODEWARS SOLUTIONS: =============

export class Kata2 {
    static pinFormat: RegExp = new RegExp(/^\d{4}(\d{2})?$/);

    static validatePin(pin: string): boolean {
        return Kata2.pinFormat.test(pin);
    }
}

export class Kata3 {
    static validatePin(pin: string) {
        return /^(\d{4}|\d{6})$/.test(pin);
    }
}

export class Kata4 {
    static validatePin(pin: string): boolean {
        const digits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
        if (pin.length !== 4 && pin.length !== 6) {
            return false;
        }

        for (let index = 0; index < pin.length; index++) {
            if (!digits.includes(pin[index])) {
                return false;
            }
        }
        return true;
    }
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// In DNA strings, symbols "A" and "T" are complements of each other, as "C" and "G". You function receives one side of the DNA (string, except for Haskell); you need to return the other complementary side. DNA strand is never empty or there is no DNA at all (again, except for Haskell).

// More similar exercise are found here: http://rosalind.info/problems/list-view/ (source)

// Example: (input --> output)

// "ATTGC" --> "TAACG"
// "GTAT" --> "CATA"
// dnaStrand []        `shouldBe` []
// dnaStrand [A,T,G,C] `shouldBe` [T,A,C,G]
// dnaStrand [G,T,A,T] `shouldBe` [C,A,T,A]
// dnaStrand [A,A,A,A] `shouldBe` [T,T,T,T]

const dnaStrand = (dna: string): string => {
    const arr = dna.split("");

    arr.map((el, i) => {
        switch (el) {
            case "A":
                arr[i] = "T";
                break;
            case "T":
                arr[i] = "A";
                break;
            case "C":
                arr[i] = "G";
                break;
            case "G":
                arr[i] = "C";
        }
    });

    console.log(arr.join(""));
    return arr.join("");
};

// dnaStrand("ATCG");

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️
// export class Kata {
//     static dnaStrand(dna: string) {
//       return dna.replace(/./g, (c)=>({A:'T',T:'A',G:'C',C:'G'})[c]);
//     }
// }

// ❗️❗️❗️ if you want a replaced with x, b with y and c with z, you can do something like this:

// var chars = {'a':'x','b':'y','c':'z'};
// var s = '234abc567bbbbac';
// s = s.replace(/[abc]/g, m => chars[m]);
// console.log(s);
// Output: 234xyz567yyyyxz

// ❗️❗️❗️
// let dummyString = 'Javascript^ is$ the most popular _language';
// newString = dummyString.replace(/[_^$]/g, charactersToReplace => ({'^': '', '_': ':', '$' : '+' })[charactersToReplace]);

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  JADEN CASE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// Jaden Smith, the son of Will Smith, is the star of films such as The Karate Kid (2010) and After Earth (2013). Jaden is also known for some of his philosophy that he delivers via Twitter. When writing on Twitter, he is known for almost always capitalizing every word. For simplicity, you'll have to capitalize each word, check out how contractions are expected to be in the example below.

// Your task is to convert strings to how they would be written by Jaden Smith. The strings are actual quotes from Jaden Smith, but they are not capitalized in the same way he originally typed them.

// Example:

// Not Jaden-Cased: "How can mirrors be real if our eyes aren't real"
// Jaden-Cased:     "How Can Mirrors Be Real If Our Eyes Aren't Real"

// 🟩
// String.prototype.toJadenCase = function (str: string ): string {

//     //  ❗️❗️❗️ TypeError: Cannot read property 'split' of undefined ❗️❗️❗️
//     //  return str.split(" ").map((word) => word.replace(word[0], word[0].toUpperCase())).join(" ");

//     // ❗️❗️❗️ USE this KEYWORD: ❗️❗️❗️
//     return this.split(" ").map((word) => word.replace(word[0], word[0].toUpperCase())).join(" ");

// };
// 🟩

// STRING -> ARR(WORDS) -> CAPITALIZE EACH WORD IN ARRAY -> JOIN INTO STRING WITH " "
const toJadenCase = (str: string): string => {
    console.log(
        str
            .split(" ")
            .map((word) => word.replace(word[0], word[0].toUpperCase()))
            .join(" ")
    );

    // ❗️❗️❗️ HAVE TO USE this IN CODEWARS SOLUTION ❗️❗️❗️
    return str
        .split(" ")
        .map((word) => word.replace(word[0], word[0].toUpperCase()))
        .join(" ");
};

// toJadenCase("How can mirrors be real if our eyes aren't real");
// toJadenCase("a b A B");

//============= OTHER CODEWARS SOLUTIONS: =============

// String.prototype.toJadenCase = function () {
//     return this.replace(/(?:^|\s)\S/g, firstLetter => firstLetter.toUpperCase());
// };

// const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1)
// String.prototype.toJadenCase = function() {
//   return this.split(' ').map(capitalize).join(' ')
// }

// String.prototype.toJadenCase = function () {
//     return this.replace(/^.|\s./gi, $ => $.toUpperCase())
// };

// String.prototype.toJadenCase = function () {
//     let temp = this;

//     if (temp === null || temp.length === 0) {
//       return null;
//     }

//     let result = '';

//     for (let i = 0; i < temp.length; i++) {
//       let x = temp[i];
//       if (i === 0) {
//         x = x.toUpperCase();
//       } else if (temp[i - 1] === ' ') {
//         x = x.toUpperCase();
//       }
//       result += x;
//     }

//     return result;
//   };

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SHORTEST WORD'S LENGTH
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// STR -> ARR(STR) -> SORT ARR BY LENGTH OF WORDS -> GRAB LENGTH OF FIRST ELEMENT
const findShort = (str: string): number => {
    return str.split(" ").sort((a, b) => {
        return a.length - b.length;
    })[0].length;
};

findShort("bitcoin take over the world maybe who knows perhaps");

//============= OTHER CODEWARS SOLUTIONS: =============

// export function findShort(s: string): number {
//     return Math.min(...s.split(" ").map((w) => w.length));
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  X's AND O's
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// Check to see if a string has the same amount of 'x's and 'o's. The method must return a boolean and be case insensitive. The string can contain any char.

// Examples input/output:

// XO("ooxx") => true
// XO("xooxx") => false
// XO("ooxXm") => true
// XO("zpzpzpp") => true // when no 'x' and 'o' is present should return true
// XO("zzoo") => false

const xo = (str: string): boolean => {
    const xS = str.toLowerCase().match(/x/g); // GET x's
    const oS = str.toLowerCase().match(/o/g); // GET o's
    if (xS && oS) {
        // IF BOTH FOUND:
        return xS.length === oS.length; // CHECK IF THEIR LENGTHS EQUAL (bool)
    } else if (xS || oS) {
        // IF ONLY ONE FOUND:
        return false; // false
    } else {
        // IF NEITHER FOUND
        return true; // true
    }
};

//============= OTHER CODEWARS SOLUTIONS: =============

// export function xo(str: string) {
// 	return str.toLowerCase().split('x').length == str.toLowerCase().split('o').length;
//   }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  IS ISOGRAM?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// STRING -> ARRAY OF LOWERCASED LETTERS -> SET (DUPLICATES REMOVED)
// COMPARE NUMBER OF ELEMENTS IN SET AND ORIGINAL STRING
// RETURN TRUE IF EQUAL, OTHERWISE FALSE
const isIsogram = (str: string): boolean => {
    const lettersSet = new Set(str.toLowerCase().split(""));
    return lettersSet.size === str.length;
};

//============= OTHER CODEWARS SOLUTIONS: =============

// export function isIsogram (str: string): boolean {
// 	return (new Set(str.toLowerCase())).size === str.length
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  IS SQUARE?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

function isSquare(num: number): boolean {
    return Number.isInteger(Math.sqrt(num));
}

//============= OTHER CODEWARS SOLUTIONS: =============

// export default (n: number): boolean => (Math.sqrt(n) % 1 === 0);

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

const getMiddle = (str: string): string => {
    const halfLength = str.length / 2;
    const isEvenLength = str.length % 2 === 0;

    // console.log(isEvenLength
    // 	? str.substring(halfLength - 1, halfLength + 1)
    // 	: str.charAt((str.length - 1) / 2)
    // )

    return isEvenLength
        ? str.substring(halfLength - 1, halfLength + 1)
        : str.charAt((str.length - 1) / 2);
};

// getMiddle("abcde");
// getMiddle("abcd");

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// NUM -> STR -> ARR(STR) -> ARR(NUM) -> ARR(SORTED) -> ARR(REVERSED) -> STRING -> NUM
const descendingOrder = (n: Number): number => {
    // JAVASCRIPT:

    // console.log(
    //     n
    //         .toString()
    //         .split("")
    //         .map(Number)
    //         .sort()
    //         .reverse()
    //         .map(String)
    //         .join("") * 1		// ❗️❗️❗️ *1 NOT WORKING IN TS ❗️❗️❗️
    // );

    return Number(
        n.toString().split("").map(Number).sort().reverse().map(String).join("")
    );
};

descendingOrder(123456789);

//============= OTHER CODEWARS SOLUTIONS: =============

// export function descendingOrder(n: number | null | undefined): number | null | undefined {
//   return n ? parseInt(n.toString().split("").sort().reverse().join("")) : n;
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  MUMBLING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// EMPTY ARR FOR SOLUTION
// SPLIT INTO ARRAY AND LOWERCASE
// REPEAT index + 1 TIMES AND CAPITALIZE FIRST LETTER THEN PUSH INTO SOLUTION ARRAY
// JOIN INTO STRING WITH "-"
const accum = (str: string): string => {
    const repsArr: string[] = [];
    const letters = str.split("").map((el) => el.toLowerCase());
    letters.forEach((letter, i) => {
        let rep = letter
            .repeat(i + 1)
            .replace(letter[0], letter[0].toUpperCase());
        repsArr.push(rep);
    });
    console.log(repsArr.join("-"));
    return repsArr.join("-");
};

// accum("ZpglnRxqenU");

//============= OTHER CODEWARS SOLUTIONS: =============

// export function accum(s: string): string {
// 	return s.split('')
// 	.map((elem, index) => elem.toUpperCase() + (elem.toLowerCase()).repeat(index))
// 	.join('-');
//   }

//   export function accum(s: string): string {
// 	return s.split("").map((value, index) => (value.toUpperCase() + value.toLowerCase().repeat(index))).join("-");
//   }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// SPLIT INTO ARRAY -> CONVERT TO NUM -> FIND MAX/MINN
const highAndLow = (numbers: string): string => {
    const numArr = numbers.split(" ").map((num) => Number(num));
    // console.log(`${Math.max(...numArr)} ${Math.min(...numArr)}`);
    return `${Math.max(...numArr)} ${Math.min(...numArr)}`;
};

highAndLow("1 2 3 4 -6");
// highAndLow("8 3 -5 42 -1 0 0 -9 4 7 4 -4");

//============= OTHER CODEWARS SOLUTIONS: =============

// export class Kata {
// 	static highAndLow(numbers: string) {
// 	  const max = Math.max(...numbers.split(' ').map(i => +i));
// 	  const min = Math.min(...numbers.split(' ').map(i => +i));

// 	  return `${max} ${min}`;

// 	}
// }

// export class Kata
// {
//   static highAndLow(numbers: string)
//   {
//     let splitted = numbers.split(" ").map(Number);
//     let low = Math.min( ...splitted );
//     let high = Math.max( ...splitted );
//     return high + " " + low;
//   }
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  DISEMVOWEL STRING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// REMOVE ALL VOWELS:
const disemvowel = (str: string): string => {
    return str.replace(/[aeiou]/gi, "");
};

//============= OTHER CODEWARS SOLUTIONS: =============

// export class Kata {
//   static disemvowel(str: string) {
//     var vowels: string = 'AEIOUaeiou';
//     return str.split('').filter(v => !vowels.includes(v)).join('')
//   }
// }

// export class Kata {
//   static readonly LETTERS_LIST = new RegExp('a|e|i|o|u', 'gi');

//   static disemvowel(str: string) {
//     return str.replace(Kata.LETTERS_LIST, '');
//   }
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SQUARE DIGITS OF NUMBER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

const squareDigits = (num: number): number => {
    let solution;
    // solution = num
    //     .toString()
    //     .split("")
    //     .map((el) => Number(el))
    //     .map((el) => Math.pow(el, 2))
    //     .map((el) => el.toString())
    //     .join("")

    solution = num
        .toString()
        .split("")
        .map((el) => Math.pow(Number(el), 2).toString())
        .join("");

    console.log(Number(solution));
    return Number(solution);
};

// squareDigits(9119);

//============= OTHER CODEWARS SOLUTIONS: =============

// export class Kata {
//     static squareDigits(num: number) {
//       return +num.toString().split('').map(i=>+i*+i).join('');
//     }
// }

// export class Kata {
//     static squareDigits(num: number) {
//       return +num.toString()
//                  .split('')
//                  .map(n => Math.pow(+n,2))
//                  .join('');
//     }
// }

// export class Kata {
//     static squareDigits(num: number): number {
//       return +num.toString().split('').map((n)=>(+n)**2).join('')
//     }
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  COUNT VOWELS IN STRING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// export class Kata {
//     static getCount = (str: string): number => {
//       return str.split("").filter((el) => el.match(/[aeiou]/gi)).length;
//     }
//   }

// SPLIT INTO ARRAY -> FIND VOWELS -> GET LENGTH OF VOWELS ARRAY
const getCount = (str: string): number => {
    return str.split("").filter((el) => el.match(/[aeiou]/gi)).length;
};

//============= OTHER CODEWARS SOLUTIONS: =============

//   export class Kata {
//     static getCount(str: string) {
//       let list = str.match(/[aeiou]/gi);
//       return list ? list.length : 0;
//     }
//   }

// export class Kata {
//     static getCount(str: string) : number {
//       return str.split('').filter(c => /[aeiou]/i.test(c)).length
//     }
//   }
