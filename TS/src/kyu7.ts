// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è ‚úÖ  ‚ùì‚ùì‚ùì
// üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®
// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®
// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è  INCLUDE THIS IN EXAMPLES (MODULO/REMAINDER )‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// 4 % 10 => 4 !!! DIVIDEND < DIVISOR => DIVIDEND
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: INCREMENT EVERY ELEMENT BY ITS POSITION, IF GREATER THAN 10, REPLACE WITH SECOND DIGIT
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Given an input of an array of digits, return the array with each digit incremented by its position in the array: the first digit will be incremented by 1, the second digit by 2, etc. Make sure to start counting your positions from 1 ( and not 0 ).

Your result can only contain single digit numbers, so if adding a digit with its position gives you a multiple-digit number, only the last digit of the number should be returned.

Notes:
return an empty array if your array is empty
arrays will only contain numbers so don't worry about checking that
Examples:
[1, 2, 3]  -->  [2, 4, 6]   #  [1+1, 2+2, 3+3]

[4, 6, 9, 1, 3]  -->  [5, 8, 2, 5, 8]  #  [4+1, 6+2, 9+3, 1+4, 3+5]
                                       #  9+3 = 12  -->  2
*/

const incrementer = (numArr: number[]): number[] => {

    const solution: number[] = numArr
        .map((el, idx) => {
            const sum: number = el + (numArr.indexOf(el) + 1);
            return sum > 9
                ? sum - 10
                : sum;
        })

    return solution;
}

// [2, 4, 6]
console.log(incrementer([1, 2, 3]));
// [5, 8, 0, 5, 8
console.log(incrementer([4, 6, 7, 1, 3]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è 4 % 10 => 4 !!! DIVIDEND < DIVISOR => DIVIDEND ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
const incrementer2 = (nums: number[]): number[] => nums.map((num, index) => (num + index + 1) % 10);

// üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®
// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è  INCLUDE THIS IN EXAMPLES (REGEX)‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: COMPARE STRINGS BY SUM OF CHARACTERS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è REGEX MATCH NEGATED SET ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Compare two strings by comparing the sum of their values (ASCII character code).

For comparing treat all letters as UpperCase
null/NULL/Nil/None should be treated as empty strings
If the string contains other characters than letters, treat the whole string as it would be empty
Your method should return true, if the strings are equal and false if they are not equal.

Examples:
"AD", "BC"  -> equal
"AD", "DD"  -> not equal
"gf", "FG"  -> equal
"zz1", ""   -> equal (both are considered empty)
"ZzZz", "ffPFF" -> equal
"kl", "lz"  -> not equal
null, ""    -> equal

*/
const compare = (str1: string | null, str2: string | null): boolean => {

    //  !!! REPLACE LETTERS WITH SPACE AND CHECK LENGTH !!!
    const getStrVal = (str: string | null): number => {
        // const validStr: string = str?.replace(/[^A-Z]/ig, "");

        // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è THESE TWO ARE REPLACED WITH !str BELOW ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
        // if (str === null) return 0;
        // if (str === "") return 0;
        // FILTER OUT INVALID INPUT (NON LETTER CHARACTERS / EMPTY STR / null)
        if (!str || /[^A-Z]/ig.test(str)) return 0;
        const upperCased: string = str.toUpperCase()
        let value: number = 0;

        for (let i = 0; i < upperCased.length; i++) {
            value += upperCased.charCodeAt(i);
        }

        return value;
    }

    console.table({
        value1: getStrVal(str1),
        value2: getStrVal(str2),
        isEqual: getStrVal(str1) === getStrVal(str2)
    })

    return getStrVal(str1) === getStrVal(str2);
}

/*
‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è REGEX MATCH NEGATED SET "^" ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è MATCH ANY CHAR THAT IS NOT IN THE SET
Match letters only /[A-Z]/ig
Match anything not letters /[^A-Z]/ig
Match number only /[0-9]/g or /\d+/g
Match anything not number /[^0-9]/g or /\D+/g
Match anything not number or letter /[^A-Z0-9]/ig

*/

// true
// console.log(compare("aD", "Bc"));
// false
// console.log(compare("AD", "DD"));
// true
// console.log(compare("cx1", ""));
// console.log(compare(null, ""));
// console.log(compare("!!", "235"));
// console.log();
// console.log();

/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index) ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ value1  ‚îÇ  133   ‚îÇ
‚îÇ value2  ‚îÇ  133   ‚îÇ
‚îÇ isEqual ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
true
*/

//============= OTHER CODEWARS SOLUTIONS: =============
function compare2(s1: string | null, s2: string | null): boolean {
    function fun(s: string | null): string {
        if (typeof (s) === 'string' && s.replace(/[a-z]/gi, '') === '') return s.toUpperCase();
        return '';
    }

    const red = (s: string | null): number => fun(s).split("").reduce((acc, el) => acc + el.charCodeAt(0), 0);

    return red(s1) === red(s2);
}


function compare3(s1: string | null, s2: string | null): boolean {
    function sum(str: string | null): number {
        if (!str || !str.length) { return 0; }
        let arr = str.toUpperCase().split("").map(c => c.charCodeAt(0));
        if (!arr.every(el => el >= "A".charCodeAt(0) && el <= "Z".charCodeAt(0))) { return 0; }
        return arr.reduce((acc, el) => acc + el);
    }

    return sum(s1) === sum(s2);
}


//   function compare4(x, y):boolean {
//     return (x = [x, y]
//       .map(a => (/[^A-Za-z]/g.test(a) ? '' : a || '')
//       .toUpperCase()
//       .split('')
//       .reduce((s, e) => s + e.charCodeAt(), 0)))[0] === x[1];
//   }


function compare5(s1: string | null, s2: string | null): boolean {
    function count(x: string | null): number {
        let count = 0;
        if (x) for (let c of x.toUpperCase()) {
            const cc = c.charCodeAt(0);
            if (cc >= 65 && cc <= 90) count += cc;
            else return 0;
        }
        return count;
    }
    return count(s1) == count(s2);
}
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: RETURN THE CLOSEST NUMBER MULTIPLE OF 10
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è MATH.ROUND() ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è SET UP TYPE ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Given a number return the closest number to it that is divisible by 10.

Example input:

22
25
37
Expected output:

20
30
40
*/
const closestMultiple10 = (num: number) => {
    return Math.round(num / 10) * 10;
};

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è Math.round ROUNDS TO NEAREST INTEGER ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
//  1. DIVIDE BY 10 TO MAKE NUM DECIMAL 54 => 5.4
//  2. RUN Math.round()                 5.4 => 5
//  3. MULTIPLY BY 10                   5 => 50

// 50
// console.log(closestMultiple10(54));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function closestMultiple102(num: number) {
    let last: number = num % 10;
    if (last < 5) {
        num -= last;
    } else {
        num += 10 - last;
    }
    return num;
};

// Parameter 'n' implicitly has an 'any' type.ts(7006)
// const closestMultiple103 = n => {
//     let s = n < 0 ? -1 : 1;
//     n = n < 0 ? -n : n;
//     let a = (n / 10 | 0) * 10;
//     let b = a + 10;
//     return s * ((n - a >= b - n) ? b : a);
// };
// ----------------------------------------------------
// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è SET UP TYPE ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è SEE OBJECTS IN TYPESCRIPT ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
type F10 = (num: number) => number;

const part10: F10 = (num) => {
    if (num < 5) return num * -1;
    return 10 - num;
}

export const closestMultiple104: F10 = (num) => {
    return num + part10(num % 10);
};

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: RECURSION #1 - FACTORIAL
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: FACTORIAL, RECURSION
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
This is a kata series that you can only solve using recursion.
##1 - Factorial

In mathematics, the factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example,

5! = 5 * 4 * 3 * 2 * 1 = 120.

The value of 0! is 1.

#Your task

You have to create the function factorial that receives n and returns n!. You have to use recursion.
*/

// 1Ô∏è‚É£
const factorialA = (n: number): number => {
    if (n < 2) {
        return 1;
    } else {
        return n * factorialA(n - 1);
    }
};

// 2Ô∏è‚É£
const factorialA2 = (n: number): number => {
    return n < 2 ? 1 : n * factorialA(n - 1);
};

// 120
// console.log(factorialA(5));
// 720
// console.log(factorialA2(6));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// const factorialA3 = (n: number, total: number = 1): number => {
//     if (n === 0) {
//         return 1;
//     }

//     if (n === 1) {
//         return total;
//     }

//     return factorial(n - 1, total * n)
// };

// const factorialA4 = (n: number): number => {
//     return (n > 0) ? n * this.factorial(n - 1) : 1;
// };


const factorialA5 = (n: number): number => {

    var fact = 1;

    function factorial(num: number): number {
        if (num > 0) {
            fact = fact * num;
            factorial(num - 1);
        }
        return fact;
    }
    return (factorial(n));

};

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: DIGITAL CYPHER
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: MAP(IDX)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Introduction
Digital Cypher assigns to each letter of the alphabet unique number. For example:

 a  b  c  d  e  f  g  h  i  j  k  l  m
 1  2  3  4  5  6  7  8  9 10 11 12 13
 n  o  p  q  r  s  t  u  v  w  x  y  z
14 15 16 17 18 19 20 21 22 23 24 25 26
Instead of letters in encrypted word we write the corresponding number, eg. The word scout:

 s  c  o  u  t
19  3 15 21 20
Then we add to each obtained digit consecutive digits from the key. For example. In case of key equal to 1939 :

   s  c  o  u  t
  19  3 15 21 20
 + 1  9  3  9  1
 ---------------
  20 12 18 30 21
  
   m  a  s  t  e  r  p  i  e  c  e
  13  1 19 20  5 18 16  9  5  3  5
+  1  9  3  9  1  9  3  9  1  9  3
  --------------------------------
  14 10 22 29  6 27 19 18  6  12 8
Task
Write a function that accepts str string and key number and returns an array of integers representing encoded str.

Input / Output
The str input string consists of lowercase characters only.
The key input number is a positive integer.

Example
Encode("scout",1939);  ==>  [ 20, 12, 18, 30, 21]
Encode("masterpiece",1939);  ==>  [ 14, 10, 22, 29, 6, 27, 19, 18, 6, 12, 8]
*/
const encode = (str: String, key: number): number[] => {

    const alphabet = "abcdefghijklmnopqrstuvwxyz";
    // SPLIT KEY INTO ARRAY OF DIGITS: [ 1, 9, 3, 9 ]
    const keyArr: number[] = key
        .toString()
        .split("")
        .map((el) => Number(el));
    // GET KEY LENGTH FOR SEQUENCING KEY: 4
    const seqLength: number = keyArr.length;
    // MAKE ARRAY OF CHARACTERS: [ 's', 'c', 'o', 'u', 't' ]
    const strArr: string[] = str.split("");
    // REPLACE EVERY ELEMENT WITH ITS POSITION IN THE ALPHABET: [ 19, 3, 15, 21, 20 ]
    const charPositionArr: number[] = strArr.map(
        (char) => alphabet.indexOf(char) + 1
    );

    // ADD CONSECUTIVE KEY DIGITS TO EACH DIGIT IN SEQUENCE (1,9,3,9,1,9,3,9,1...) [ 20, 12, 18, 30, 21 ]
    const encodedArr: number[] = charPositionArr.map(
        (el: number, idx) =>
            (el += idx < seqLength ? keyArr[idx] : keyArr[idx % seqLength])
    );


    return encodedArr;

}
// [ 20, 12, 18, 30, 21]
// console.log(encode("scout", 1939));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function encode2(str: String, n: number): number[] {
    const keys: number[] = n.toString().split('').map(Number);
    return str.split('').map((code, index) => {
        return code.toLowerCase().charCodeAt(0) - 96 + keys[index % keys.length]
    });
}


function encode3(str: string, n: number): number[] {
    return str.split('')
        .map(c => c.charCodeAt(0) - 96)
        .map((c, idx) => c + parseInt(n.toString()[idx % n.toString().length]))
}

/*
function encode4(str: String, n: number): number[] {
    const decodedArray: number[] = [];
    const stringArray = str.split("");
    const codeArray = stringArray.map(letter => letter.charCodeAt(0) - 96);
    const numberArray = n.toString().split("").map(Number)
    let tempArray = [...numberArray];

    const result = codeArray.map(code => {
        if (!tempArray.length) tempArray = [...numberArray];

        // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è Object is possibly 'undefined'.ts(2532) ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
        return code += tempArray.shift()
    })

    return result;
}
*/

/*
function encode5(str: String, n: number): number[] {
    const decodedArray: number[] = [];
    const code = {
        a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7, h: 8,
        i: 9, j: 10, k: 11, l: 12, m: 13, n: 14, o: 15,
        p: 16, q: 17, r: 18, s: 19, t: 20, u: 21, v: 22,
        w: 23, x: 24, y: 25, z: 26,
    }
    const stringArray = str.split("");
    // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ a: number; b: number; c: number; d: number; e: number; f: number; g: number; h: number; i: number; j: number; k: number; l: number; m: number; n: number; o: number; p: number; q: number; r: number; s: number; t: number; u: number; ... 4 more ...; z: number; }'.
    const codeArray = stringArray.map(letter => code[letter]);
    const numberArray = n.toString().split("").map(str => parseInt(str))
    let tempArray = [...numberArray];

    const result = codeArray.map(code => {
        if (!tempArray.length) tempArray = [...numberArray];

        return code += tempArray.shift()
    })

    return result;
}
*/
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: SIMPLE FUN - HOUSE NUMBERS SUM
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: FOR OF, BREAK
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Task
A boy is walking a long way from school to his home. To make the walk more fun he decides to add up all the numbers of the houses that he passes by during his walk. Unfortunately, not all of the houses have numbers written on them, and on top of that the boy is regularly taking turns to change streets, so the numbers don't appear to him in any particular order.

At some point during the walk the boy encounters a house with number 0 written on it, which surprises him so much that he stops adding numbers to his total right after seeing that house.

For the given sequence of houses determine the sum that the boy will get. It is guaranteed that there will always be at least one 0 house on the path.

Example
For inputArray = [5, 1, 2, 3, 0, 1, 5, 0, 2], the output should be 11.

The answer was obtained as 5 + 1 + 2 + 3 = 11.

Input/Output
[input] integer array inputArray

Constraints: 5 ‚â§ inputArray.length ‚â§ 50, 0 ‚â§ inputArray[i] ‚â§ 10.

[output] an integer
*/
const houseNumbersSum = (arr: number[]): number => {
    let solution: number = 0;
    for (let i = 0; i < arr.length; i++) {
        solution += arr[i];
        // if (arr[i] === 0) break;
        // OR:
        if (!arr[i]) break;
    }
    return solution;
};

// 11
// console.log(houseNumbersSum([5, 1, 2, 3, 0, 1, 5, 0, 2]));
// 13
// console.log(houseNumbersSum([4, 2, 1, 6, 0]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const houseNumbersSum2 = (arr: number[]): number =>
    arr.splice(0, arr.indexOf(0)).reduce((a, v) => a + v, 0);

function houseNumbersSum3(inputArray: number[]): number {
    let counter: number = 0;

    for (let i: number = 0; i < inputArray.length; i++) {
        if (inputArray[i] !== 0) {
            counter += inputArray[i];
        } else {
            break;
        }
    }
    return counter;
}

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è FOR OF ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
function houseNumbersSum4(inputArray: number[]): number {
    let sum: number = 0;
    4;
    for (let i of inputArray) {
        if (i === 0) break;
        sum += i;
    }
    return sum;
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: NUMBERS IN STRINGS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: TEST(), MATCH(), ‚ùì‚ùì‚ùì SYMBOL ITERATOR ‚ùì‚ùì‚ùì
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
n this Kata, you will be given a string that has lowercase letters and numbers. Your task is to compare the number groupings and return the largest number. Numbers will not have leading zeros.

For example, solve("gh12cdy695m1") = 695, because this is the largest of all number groupings.

Good luck!
*/

// 1Ô∏è‚É£
const solveC = (str: string): number => {
    // CHECK FOR NUMERIC DIGITS
    if (!/\d/g.test(str)) return 0;
    // FIND ALL DIGIT SUBSTRINGS AND CONVERT TO NUMBER
    const digitSubs: number[] = str.match(/\d+/g)!.map((el) => Number(el));
    // GET THE LARGEST ELEMENT
    // ‚ùì‚ùì‚ùì Type 'number[] | undefined' must have a '[Symbol.iterator]()' method that returns an iterator.ts(2488) ‚ùì‚ùì‚ùì
    // console.log(Math.max(...digitSubs));
    const solution: number = Math.max(...digitSubs);
    return solution;
};

// 2Ô∏è‚É£ REFACTORED:
const solveC2 = (str: string): number => {
    return /\d/g.test(str)
        ? Math.max(...str.match(/\d+/g)!.map((el) => Number(el)))
        : 0;
};

// 695
// console.log(solveC2("gh12cdy695m1"));
// 9
// console.log(solveC2("2ti9iei7qhr5"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
const solveC3 = (s: string): number =>
    Math.max(...s.split(/[a-z]/g).map((el) => +el));

function solveC4(s: string) {
    return Math.max(...s.split(/\D+/).map((e) => Number(e)));
}

function solveC5(s: string): number {
    const numArray = s.replace(/\D+/g, " ").trim().split(" ").map(Number);
    return Math.max(...numArray);
}

function solveC6(s: string): number {
    const matches = s.match(/\d+/g)!;
    return Math.max(...matches.map((el) => Number(el)));
}
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: SPECIAL NUMBER (Special Numbers Series #5)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: TEST()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Definition
A number is a Special Number if it‚Äôs digits only consist 0, 1, 2, 3, 4 or 5

Given a number determine if it special number or not .

Notes
The number passed will be positive (N > 0) .

All single-digit numbers within the interval [1:5] are considered as special number.

Input >> Output Examples
specialNumber(2) ==> return "Special!!"
Explanation:
It's a single-digit number within the interval [1:5] .

specialNumber(9) ==> return "NOT!!"
Explanation:
Although, it's a single-digit number but Outside the interval [1:5] .

specialNumber(23) ==> return "Special!!"
Explanation:
All the number's digits formed from the interval [0:5] digits .

specialNumber(39) ==> return "NOT!!"
Explanation:
Although, there is a digit (3) Within the interval But the second digit is not (Must be ALL The Number's Digits ) .

specialNumber(59) ==> return "NOT!!"
Explanation:
Although, there is a digit (5) Within the interval But the second digit is not (Must be ALL The Number's Digits ) .

specialNumber(513) ==> return "Special!!"
specialNumber(709) ==> return "NOT!!"
*/
const specialNumber = (num: number) => {
    const numStr: string = num.toString();
    // console.log(numStr);
    // console.log(/[6-9]/g.test(numStr));
    return /[6-9]/g.test(numStr) ? "NOT!!" : "Special!!";
};

// "Special!!"
// console.log(specialNumber(234055));
// "NOT!!"
// console.log(specialNumber(6789));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
const specialNumbers = [0, 1, 2, 3, 4, 5].map((n) => n.toString());

export const specialNumber2 = (n: number): string =>
    n
        .toString()
        .split("")
        .every((n) => specialNumbers.includes(n))
        ? "Special!!"
        : "NOT!!";

function specialNumber3(n: number) {
    return /[^0-5]/.test(n.toString()) ? "NOT!!" : "Special!!";
}

function specialNumber4(n: number) {
    return n.toString().match(/[^0-5]/) ? "NOT!!" : "Special!!";
}
// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE: UNLUCKY DAYS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Friday 13th or Black Friday is considered as unlucky day. Calculate how many unlucky days are in the given year.

Find the number of Friday 13th in the given year.

Input: Year in Gregorian calendar as integer.

Output: Number of Black Fridays in the year as an integer.

Examples:

unluckyDays(2015) == 3
unluckyDays(1986) == 1

*/
function unluckyDays(year: number): number {
    return 1;
}

// 3
// console.log(unluckyDays(2015));
// 1
// console.log(unluckyDays(1986));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: PRODUCT OF MAXIMUMS IN ARRAY (Array Series #2)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è REDUCE WITH INITIAL VALUE ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Task
Given an array/list [] of integers , Find the product of the k maximal numbers.

Notes
Array/list size is at least 3 .

Array/list's numbers Will be mixture of positives , negatives and zeros

Repetition of numbers in the array/list could occur.

Input >> Output Examples
maxProduct ({4, 3, 5}, 2) ==>  return (20)
Explanation:
Since the size (k) equal 2 , then the subsequence of size 2 whose gives product of maxima is 5 * 4 = 20 .
maxProduct ({8, 10 , 9, 7}, 3) ==>  return (720)
Explanation:
Since the size (k) equal 3 , then the subsequence of size 3 whose gives product of maxima is 8 * 9 * 10 = 720 .
maxProduct ({10, 8, 3, 2, 1, 4, 10}, 5) ==> return (9600)
Explanation:
Since the size (k) equal 5 , then the subsequence of size 5 whose gives product of maxima is 10 * 10 * 8 * 4 * 3 = 9600 .
maxProduct ({-4, -27, -15, -6, -1}, 2) ==> return (4)
Explanation:
Since the size (k) equal 2 , then the subsequence of size 2 whose gives product of maxima is -4 * -1 = 4 .
maxProduct ({10, 3, -1, -27} , 3)  return (-30)
Explanation:
Since the size (k) equal 3 , then the subsequence of size 3 whose gives product of maxima is 10 * 3 * -1 = -30 .
*/

// 1Ô∏è‚É£
const maxProduct = (numbers: number[], size: number): number => {
    // SORT DESCENDING
    const descArr: number[] = numbers.sort((a, b) => b - a);
    // GRAB SUB-ARRAY STARTING AT INDEX 0, WITH size NUMBER OF ELEMENTS
    const factorsArr: number[] = descArr.slice(0, size);
    // MULTIPLY ELEMENTS
    let solution: number = factorsArr.reduce((acc, curr) => acc * curr);

    return solution;
};

// 2Ô∏è‚É£
const maxProduct2 = (numbers: number[], size: number): number => {
    return numbers
        .sort((a, b) => b - a)
        .slice(0, size)
        .reduce((acc, curr) => acc * curr);
};

// 20
// console.log(maxProduct([4, 3, 5], 2));
// 720
// console.log(maxProduct([10, 8, 7, 9], 3));
// 9600
// console.log(maxProduct([10, 2, 3, 8, 1, 10, 4], 5));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è REDUCE WITH INITIAL VALUE ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
function maxProduct3(numbers: number[], size: number) {
    return numbers
        .sort((a, b) => a - b)
        .slice(-size)
        .reduce((ret, val) => ret * val, 1);
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: LONGEST VOWEL CHAIN
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: MATCH(AEIOU), SORT ARRAY BY LENGTH OF ELEMENTS, REGEX, TEST()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
The vowel substrings in the word codewarriors are o,e,a,io. The longest of these has a length of 2. Given a lowercase string that has alphabetic characters only (both vowels and consonants) and no spaces, return the length of the longest vowel substring. Vowels are any of aeiou.

Good luck!
*/
const solveB = (str: string): number => {
    // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è CHECK IF STRING HAS ANY VOWELS ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
    if (!/[aeiou]/g.test(str)) return 0;
    // !!! THIS IS NOW NOT NEEDED !!!
    // if (str.length < 1) return 0;
    const substrings: string[] = str.match(/[aeiou]+/g)!;
    const solution: number = substrings.sort((a, b) => b.length - a.length)[0]
        .length;
    return solution;
};

// 2
// console.log(solveB("codewarriors"));
// 3
// console.log(solveB("suoidea"));
// FIXED:‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è TypeError: Cannot read property 'sort' of null ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// console.log(solveB("fgfgfg"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
function solveB2(s: string): number {
    return Math.max(...(s.match(/[aeiou]+/gi) || []).map((x) => x.length));
}

const solveB3 = (str: string): number =>
    Math.max(...str.split(/[^aeiou]/i).map((x) => x.length));

function solveB4(str: string) {
    return str
        .split(/[^aeiou]+/)
        .reduce((acc, vowelChain) => Math.max(acc, vowelChain.length), 0);
}
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:   CHAR CODE CALCULATION
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è REDUCE OF EMPTY ARRAY, STR.CHARCODEAT()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Given a string, turn each character into its ASCII character code and join them together to create a number - let's call this number total1:

'ABC' --> 'A' = 65, 'B' = 66, 'C' = 67 --> 656667
Then replace any incidence of the number 7 with the number 1, and call this number 'total2':

total1 = 656667
              ^
total2 = 656661
              ^
Then return the difference between the‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è  sum of the digits ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è in total1 and total2:

  (6 + 5 + 6 + 6 + 6 + 7)
- (6 + 5 + 6 + 6 + 6 + 1)
-------------------------
                       6
*/

export const calc = (str: string): number => {
    // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è TypeError: Reduce of empty array with no initial value ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è CHECK FOR EMPTY ARRAY ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
    if (str.length < 1) return 0;
    const strArr: string[] = str.split("");
    let numStrConcat: string = "";
    //  CONCAT CHAR CODE FOR EACH CHAR TO numStrConcat
    strArr.forEach((char: string, idx) => {
        numStrConcat += str.charCodeAt(idx);
    });
    //  REPLACE ALL INSTANCES OF "7" WITH "1"
    const numStrMinusSeven: string = numStrConcat.replace(/7/g, "1");
    //  GET SUM OF DIGITS FOR BOTH STRINGS
    const total1: number = numStrConcat
        .split("")
        .map((el) => Number(el))
        .reduce((a, b) => a + b);
    const total2: number = numStrMinusSeven
        .split("")
        .map((el) => Number(el))
        .reduce((a, b) => a + b);
    //  SUBSTRACT
    const result: number = total1 - total2;

    return result;
};

// 6
// console.log(calc("ABC"));

// console.log(calc("abcdef"));
// console.log(calc("hkodededyvcmntdzdyqrbqhxipcynkjezcsxcbyjktjaugiwllioggxvwijjpqmoxngklpqvsphtsklcbugkpdlnwuinbfeqphpctbaqfmrorkxyrhvbnlfuyktrdnyavxjvublyqfgdopehfjgcvwmilrghgvnwkjeklaihsalcfdqtdsmzbtqocslkbrxycrdnxgoliezbiwobdvxcijtjkcwijjrygfucmpufpmxigjrnuhsckyqhehxvnmadkbrwqrbcjqlstamfmpmqgcurpdemyuqqearbnzpywaycwpntcwrndwxkadbdwgjqairzoplqiinrxgdzebebxlilekpqokdrhwhyrjlfpedqywfiaqjseorwpjhimazefhsypzvyxtjggytrawymqvkrrggpdezrdtotwqhizigvuvvkepskmajinldotdwnzwwplfyezkzxbmfclaisbpybnewwlnttgeezuhbnedugpjxtahmrlcoccfmwygbiosggjqrzxtibfthvucdfjxivfeijcjkgcfwusehzxtlqrphwizngcaefaktbzjuppdtloulpbqorxckntgumqwhqqotzltulsyzoxpqsjccewvxlrizjppnmeeihnwusjuhdpnwjjkucaizjxaspjxuypsybxywdwriwkynpgbzrbvszpntjkappmzhoywferhpyuaqcsbxozfyjmksvk"));
// console.log(calc(""));

//============= OTHER CODEWARS SOLUTIONS: =============

function calc2(str: string): number {
    return (
        [...str]
            .map((x) => x.charCodeAt(0))
            .join("")
            .split("")
            .filter((x) => x === "7").length * 6
    );
}

const calc3 = (x: string): number => {
    return (
        (x.replace(/./g, (x) => x.charCodeAt(0).toString()).match(/7/g) || [])
            .length * 6
    );
};

function calc4(str: string): number {
    return (
        Array.from(str, (c) => c.charCodeAt(0))
            .toString()
            .replace(/[^7]/g, "").length * 6
    );
}

const calc5 = (str: string): number => {
    const codes = str.split("").map((c: string) => c.charCodeAt(0));
    const total1 = codes.reduce((a, b) => a + b, 0);
    const total2 = codes
        .map((x) => +x.toString().replace(/7/g, "1"))
        .reduce((a, b) => a + b, 0);
    return total1 - total2;
};

// ===

function calc6(str: string): number {
    const charCodes = str.split("").map((char) => char.charCodeAt(0));
    return sum2(charCodes) - sum(charCodes.map(replace7with1));
}

function sum2(arr: number[]): number {
    return arr.reduce((total, x) => total + x, 0);
}

function replace7with1(num: number): number {
    return parseInt(num.toString().replace(/7/g, "1"));
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: WORD VALUES MULTIPLIED BY ITS POSITION
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Given a string "abc" and assuming that each letter in the string has a value equal to its position in the alphabet, our string will have a value of 1 + 2 + 3 = 6. This means that: a = 1, b = 2, c = 3 ....z = 26.

You will be given a list of strings and your task will be to return the values of the strings as explained above multiplied by the position of that string in the list. For our purpose, position begins with 1.

nameValue ["abc","abc abc"] should return [6,24] because of [ 6 * 1, 12 * 2 ]. Note how spaces are ignored.

"abc" has a value of 6, while "abc abc" has a value of 12. Now, the value at position 1 is multiplied by 1 while the value at position 2 is multiplied by 2.

Input will only contain lowercase characters and spaces.
*/

const wordValue = (arr: string[]) => {
    const alphabet = "abcdefghijklmnopqrstuvwxyz";
    let solution: number[] = [];
    arr.forEach((word, idx) => {
        console.log(word);
        let letterArr: string[] = word.split("");
        console.log(letterArr);
        let wordVal: number = 0;
        letterArr.forEach((letter) => {
            // let wordVal: number = 0;
            let letterVal: number = alphabet.indexOf(letter) + 1;
            wordVal += letterVal;
            // console.table({
            //     word: word,
            //     letter: letter,
            //     value: letterVal,
            //     wordVal: wordVal,
            //     solution: solution,
            // });
        });
        solution.push(wordVal * (idx + 1));
    });
    // return solution.map((val, idx) => val * (idx + 1));
    return solution;
};

// [88, 12, 225]
// console.log(wordValue(["codewars", "abc", "xyz"]));
// console.log(wordValue(["lencsi", "mama", "papa"]));
// [6,24]
// console.log(wordValue(["abc", "abc abc"]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function wordValue2(arr: string[]): number[] {
    const w: string = " abcdefghijklmnopqrstuvwxyz";
    return arr.map(
        (x, i) =>
            x.split("").reduce((sum, y) => sum + w.indexOf(y), 0) * (i + 1)
    );
}

const wordValue3 = (arr: string[]) =>
    arr
        .map((a) =>
            a
                .split("")
                .map((c) => (c === " " ? 0 : c.charCodeAt(0) - 96))
                .reduce((z, x) => z + x, 0)
        )
        .map((e, i) => e * +[i + 1]);

function wordValue4(arr: string[]): number[] {
    let res: number[] = [];

    arr.forEach((str, ind) => {
        let sum = 0;
        for (let i = 0; i < str.length; i++) {
            str.charCodeAt(i) !== 32
                ? (sum += (str.charCodeAt(i) - 96) * (ind + 1))
                : 0;
        }
        res.push(sum);
    });

    return res;
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: JUMPING NUMBER (Special Numbers Series #4)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è EVERY()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Definition
Jumping number is the number that All adjacent digits in it differ by 1.

Task
Given a number, Find if it is Jumping or not .

Warm-up (Highly recommended)
Playing With Numbers Series
Notes
Number passed is always Positive .

Return the result as String .

The difference between ‚Äò9‚Äô and ‚Äò0‚Äô is not considered as 1 .

All single digit numbers are considered as Jumping numbers.

Input >> Output Examples
jumpingNumber(9) ==> return "Jumping!!"
Explanation:
It's single-digit number
jumpingNumber(79) ==> return "Not!!"
Explanation:
Adjacent digits don't differ by 1
jumpingNumber(23) ==> return "Jumping!!"
Explanation:
Adjacent digits differ by 1
jumpingNumber(556847) ==> return "Not!!"
Explanation:
Adjacent digits don't differ by 1
jumpingNumber(4343456) ==> return "Jumping!!"
Explanation:
Adjacent digits differ by 1
jumpingNumber(89098) ==> return "Not!!"
Explanation:
Adjacent digits don't differ by 1
jumpingNumber(32) ==> return "Jumping!!"
Explanation:
Adjacent digits differ by 1
*/

const jumpingNumber = (num: number): string => {
    if (num < 10) return "Jumping!!";
    let isJumping: boolean = true;
    const digitArr: number[] = num
        .toString()
        .split("")
        .map((el) => Number(el));
    for (let i = 0; i < digitArr.length - 1; i++) {
        if (
            digitArr[i] + 1 !== digitArr[i + 1] &&
            digitArr[i] - 1 !== digitArr[i + 1]
        ) {
            isJumping = false;
            break;
        }
        console.table({
            current: digitArr[i],
            next: digitArr[i + 1],
            isJumping: isJumping,
        });
    }

    return isJumping ? "Jumping!!" : "Not!!";
};

// JUMPING
// console.log(jumpingNumber(12321));
// NOT
// console.log(jumpingNumber(79));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function jumpingNumber2(n: number) {
    let arr: number[] = String(n)
        .split("")
        .map((num) => Number(num));

    if (arr.length === 1) {
        return "Jumping!!";
    }
    for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] - arr[i + 1] !== 1 && arr[i + 1] - arr[i] !== 1) {
            return "Not!!";
        }
    }
    return "Jumping!!";
}

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è EVERY() ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
function jumpingNumber3(n: number): string {
    let arr: string[] = [...String(n)];
    return arr.slice(1).every((x, i) => Math.abs(+x - +arr[i]) == 1)
        ? "Jumping!!"
        : "Not!!";
}

function jumpingNumber4(n: number) {
    // your code here
    if (n < 10) {
        return "Jumping!!";
    }
    let arr = n.toString().split("").map(Number);

    for (let i = 0; i < arr.length - 1; i++) {
        if (Math.pow(arr[i] - arr[i + 1], 2) != 1) {
            return "Not!!";
        }
    }
    return "Jumping!!";
}

function jumpingNumber5(n: number) {
    return n
        .toString()
        .split("")
        .map((n) => parseInt(n))
        .every((digit, index, arr) =>
            index === 0 ? true : Math.abs(arr[index - 1] - arr[index]) === 1
        )
        ? "Jumping!!"
        : "Not!!";
}

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è REFACTOR ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: ARRAY LEADERS (Array Series #3)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: FILTER() ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Definition
An element is leader if it is greater than The Sum all the elements to its right side.

Task
Given an array/list [] of integers , Find all the LEADERS in the array.

Notes
Array/list size is at least 3 .

Array/list's numbers Will be mixture of positives , negatives and zeros

Repetition of numbers in the array/list could occur.

Returned Array/list should store the leading numbers in the same order in the original array/list .

Input >> Output Examples
arrayLeaders ({1, 2, 3, 4, 0}) ==> return {4}
Explanation:
4 is greater than the sum all the elements to its right side

Note : The last element 0 is equal to right sum of its elements (abstract zero).

arrayLeaders ({16, 17, 4, 3, 5, 2}) ==> return {17, 5, 2}
Explanation:
17 is greater than the sum all the elements to its right side

5 is greater than the sum all the elements to its right side

Note : The last element 2 is greater than the sum of its right elements (abstract zero).

arrayLeaders ({5, 2, -1}) ==> return {5, 2}
Explanation:
5 is greater than the sum all the elements to its right side

2 is greater than the sum all the elements to its right side

Note : The last element -1 is less than the sum of its right elements (abstract zero).

arrayLeaders ({0, -1, -29, 3, 2}) ==> return {0, -1, 3, 2}
Explanation:
0 is greater than the sum all the elements to its right side

-1 is greater than the sum all the elements to its right side

3 is greater than the sum all the elements to its right side

Note : The last element 2 is greater than the sum of its right elements (abstract zero).
*/

const arrayLeaders = (numbers: number[]): number[] => {
    let leadersArr: number[] = [];
    const lastEl: number = numbers.length - 1;

    for (let i = 0; i < lastEl; i++) {
        let current: number = numbers[i];
        // console.table({
        //     idx: i,
        //     current: numbers[i],
        //     rest: numbers.slice(i + 1).reduce((a, b) => a + b),
        // });
        if (current > numbers.slice(i + 1).reduce((a, b) => a + b)) {
            // console.log(current);
            leadersArr.push(current);
        }
    }

    if (numbers[lastEl] > 0) {
        leadersArr.push(numbers[lastEl]);
    }

    return leadersArr;
};

// [17, 5, 2]
// console.log(arrayLeaders([16, 17, 4, 3, 5, 2]));
// console.log();
// console.log();
// console.log();

/*

arrayLeaders([16, 17, 4, 3, 5, 2])

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index) ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   idx   ‚îÇ   0    ‚îÇ
‚îÇ current ‚îÇ   16   ‚îÇ
‚îÇ  rest   ‚îÇ   31   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index) ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   idx   ‚îÇ   1    ‚îÇ
‚îÇ current ‚îÇ   17   ‚îÇ
‚îÇ  rest   ‚îÇ   14   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
17
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index) ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   idx   ‚îÇ   2    ‚îÇ
‚îÇ current ‚îÇ   4    ‚îÇ
‚îÇ  rest   ‚îÇ   10   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index) ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   idx   ‚îÇ   3    ‚îÇ
‚îÇ current ‚îÇ   3    ‚îÇ
‚îÇ  rest   ‚îÇ   7    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index) ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   idx   ‚îÇ   4    ‚îÇ
‚îÇ current ‚îÇ   5    ‚îÇ
‚îÇ  rest   ‚îÇ   2    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
5

[ 17, 5, 2 ]
*/

//============= OTHER CODEWARS SOLUTIONS: =============

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è FILTER() ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
const arrayLeaders2 = (numbers: number[]) =>
    numbers.filter(
        (item, i) => item > numbers.slice(i + 1).reduce((a, b) => a + b, 0)
    );

function arrayLeaders3(numbers: number[]): number[] {
    return numbers.filter(
        (x, i) => x > numbers.slice(i + 1).reduce((a, b) => a + b, 0)
    );
}

function arrayLeaders4(numbers: number[]) {
    let sum = 0;
    const results = [];
    for (let i = numbers.length - 1; i >= 0; i--) {
        const current = numbers[i];
        if (current > sum) {
            results.push(current);
        }
        sum += current;
    }
    return results.reverse();
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: MAXIMUM TRIPLET SUM (Array Series #7)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Task
Given an array/list [] of n integers , find maximum triplet sum in the array Without duplications .

Notes :
Array/list size is at least 3 .

Array/list numbers could be a mixture of positives , negatives and zeros .

Repetition of numbers in the array/list could occur , So (duplications are not included when summing).

Input >> Output Examples
1- maxTriSum ({3,2,6,8,2,3}) ==> return (17)
Explanation:
As the triplet that maximize the sum {6,8,3} in order , their sum is (17)

Note : duplications are not included when summing , (i.e) the numbers added only once .

2- maxTriSum ({2,1,8,0,6,4,8,6,2,4}) ==> return (18)
Explanation:
As the triplet that maximize the sum {8, 6, 4} in order , their sum is (18) ,

Note : duplications are not included when summing , (i.e) the numbers added only once .

3- maxTriSum ({-7,12,-7,29,-5,0,-7,0,0,29}) ==> return (41)
Explanation:
As the triplet that maximize the sum {12 , 29 , 0} in order , their sum is (41) ,

Note : duplications are not included when summing , (i.e) the numbers added only once .
*/

const maxTriSum = (nums: number[]): number => {
    const unuqueNums = new Set<number>(nums);
    console.log(unuqueNums);
    const ascArr: number[] = Array.from(unuqueNums).sort((a, b) => b - a);
    console.log(ascArr);
    console.log(ascArr[0] + ascArr[1] + ascArr[2]);

    return ascArr[0] + ascArr[1] + ascArr[2];
};

// 17
// console.log(maxTriSum([3, 2, 6, 8, 2, 3]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function maxTriSum2(nums: number[]): number {
    return [...new Set(nums)]
        .sort((a, b) => b - a)
        .slice(0, 3)
        .reduce((c, d) => c + d, 0);
}

const maxTriSum3 = (nums: number[]) =>
    nums
        .filter((item, i) => nums.indexOf(item) == i)
        .sort((a, b) => (a < b ? 1 : -1))
        .slice(0, 3)
        .reduce((a, b) => a + b, 0);

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: NTH SMALLEST ELEMENT (Array Series #4) DON'T REMOVE DUPLICATES
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Introduction and Warm-up (Highly recommended)
Playing With Lists/Arrays Series
Task
Given an array/list [] of integers , Find the Nth smallest element in this array of integers

Notes
Array/list size is at least 3 .

Array/list's numbers could be a mixture of positives , negatives and zeros .

Repetition in array/list's numbers could occur , so don't Remove Duplications .

Input >> Output Examples
nthSmallest({3,1,2} ,2) ==> return (2) 
Explanation:
Since the passed number is 2 , Then * the second smallest element in this array/list is 2*

nthSmallest({15,20,7,10,4,3} ,3) ==> return (7) 
Explanation:
Since the passed number is 3 , Then * the third smallest element in this array/list is 7*

nthSmallest({2,169,13,-5,0,-1} ,4) ==> return (2) 
Explanation:
Since the passed number is 4 , Then * the fourth smallest element in this array/list is 2*

nthSmallest({177,225,243,-169,-12,-5,2,92} ,5) ==> return (92) 
Explanation:
Since the passed number is 5 , Then * the fifth smallest element in this array/list is 92*


*/

const nthSmallest = (arr: number[], pos: number): number => {
    // SORT ASCENDING
    const ascArr: number[] = arr.sort((a, b) => a - b);
    // RETURN ELEMENT AT POSITION pos
    return ascArr[pos - 1];
};

// 7
// console.log(nthSmallest([15, 20, 7, 10, 4, 3], 3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function nthSmallest2(arr: number[], pos: number) {
    return arr.sort((a, b) => a - b)[--pos];
}

function nthSmallest3(arr: number[], pos: number) {
    return [...arr].sort((a, b) => a - b)[pos - 1];
}

function nthSmallest4(arr: number[], pos: number) {
    for (let i = 1; i < pos; i++) {
        arr.splice(arr.indexOf(Math.min(...arr)), 1);
    }
    return arr[arr.indexOf(Math.min(...arr))];
}

function nthSmallest5(arr: number[], pos: number) {
    var sortArray: Array<number> = arr.sort((a, b) => a - b);
    return sortArray[pos - 1];
}

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è NOT SUBMITTED ON CODEWARS YET ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è REFACTOR ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: 16+18=214
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
For this kata you will have to forget how to add two numbers.

It can be best explained using the following meme:

Dayane Rivas adding up a sum while competing in the Guatemalan television show "Combate" in May 2016

In simple terms, our method does not like the principle of carrying over numbers and just writes down every number it calculates :-)

You may assume both integers are positive integers.

Examples
16+1821426+39515122+811103\large \begin{array}{lll} & 1 & 6 \\ + & 1 & 8 \\ \hline & 2 & 1 4 \\ \end{array} \qquad \large \begin{array}{lll} & 2 & 6 \\ + & 3 & 9 \\ \hline & 5 & 15 \\ \end{array} \qquad \large \begin{array}{lll} & 1 & 2 & 2 \\ + & & 8 & 1 \\ \hline & 1 & 10 & 3 \\ \end{array} 
+
‚Äã
*/

// const nyuszi: string = "üê∞";
// console.log("maci ‚ù§Ô∏è : ", nyuszi);

const add = (num1: number, num2: number): number => {
    const greater = Math.max(num1, num2).toString();
    // console.log(greater.length);

    const numStr1: string = num1.toString();
    const numStr2: string = num2.toString();
    let solutionArr: number[] = [];

    for (let i = 0; i < greater.length; i++) {
        console.log(
            "numbers: ",
            numStr1[numStr1.length - 1 - i],
            numStr2[numStr2.length - 1 - i]
        );
        let sum: number = 0;
        if (numStr1[numStr1.length - 1 - i] === undefined) {
            console.log("undefined");
            sum = Number(numStr2[numStr2.length - 1 - i]);
            // continue;
        } else if (numStr2[numStr2.length - 1 - i] === undefined) {
            console.log("undefined");
            sum = Number(numStr1[numStr1.length - 1 - i]);
            // continue;
        } else {
            sum =
                Number(numStr1[numStr1.length - 1 - i]) +
                Number(numStr2[numStr2.length - 1 - i]);
            // console.log("sum: ", sum);
        }
        console.log("sum: ", sum);
        solutionArr.unshift(sum);
    }
    console.log(solutionArr);

    return Number(solutionArr.join(""));
};

// 1 10 3 (1103)
// console.log(add(122, 81));
// 31499
// console.log(add(1222, 30277));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: TIDY NUMBER (Special Numbers Series #9)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Definition
A Tidy number is a number whose digits are in non-decreasing order.

Task
Given a number, Find if it is Tidy or not .
*/

const tidyNumber = (num: number): boolean => {
    // ARRANGE DIGITS IN INCREASING ORDER(STRING)
    const increasingNum = num
        .toString()
        .split("")
        .map((el) => Number(el))
        .sort((a, b) => a - b)
        .join("");

    // CONVERT TO NUMBER AND COMPARE TO INPUT NUMBER
    return parseInt(increasingNum) === num;
};

// TRUE
// console.log(tidyNumber(2789));
// FALSE
// console.log(tidyNumber(9672));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function tidyNumber2(num: number) {
    let s = "" + num;
    for (let i = 1; i < s.length; i++) {
        if (s[i] < s[i - 1]) {
            return false;
        }
    }
    return true;
}

const tidyNumber3 = (num: number) =>
    num == +[...String(num)].sort((a, b) => +a - +b).join("");

const tidyNumber4 = (n: number) => +[...String(n)].sort().join("") === n;
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: ALL INCLUSIVE?
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ROTATE STRING,
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Input:

a string strng
an array of strings arr
Output of function contain_all_rots(strng, arr) (or containAllRots or contain-all-rots):

a boolean true if all rotations of strng are included in arr (C returns 1)
false otherwise (C returns 0)
Examples:
contain_all_rots(
  "bsjq", ["bsjq", "qbsj", "sjqb", "twZNsslC", "jqbs"]) -> true

contain_all_rots(
  "Ajylvpy", ["Ajylvpy", "ylvpyAj", "jylvpyA", "lvpyAjy", "pyAjylv", "vpyAjyl", "ipywee"]) -> false)
Note:
Though not correct in a mathematical sense

we will consider that there are no rotations of strng == ""
and for any array arr: contain_all_rots("", arr) --> true
Ref: https://en.wikipedia.org/wiki/String_(computer_science)#Rotations

*/

const containAllRots = (str: string, arr: string[]): boolean => {
    const strArr: string[] = str.split("");
    // GET ALL ROTATIONS AND COMPARE
    for (let i = 0; i < strArr.length; i++) {
        // ROTATE
        let currChar = strArr[0];
        strArr.splice(0, 1);
        strArr.push(currChar);
        // CONVERT TO STRING
        let currtRotationStr: string = strArr.join("");
        // COMPARE
        if (arr.indexOf(currtRotationStr) < 0) return false;
    }

    return true;
};

// true
// console.log(
// containAllRots("bsjq", ["bsjq", "qbsj", "sjqb", "twZNsslC", "jqbs"])
// );
// false
// console.log(
//     containAllRots("XjYABhR", [
//         "TzYxlgfnhf",
//         "yqVAuoLjMLy",
//         "BhRXjYA",
//         "YABhRXj",
//         "hRXjYAB",
//         "jYABhRX",
//         "XjYABhR",
//         "ABhRXjY",
//     ])
// );
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function containAllRots2($: string, arr: string[]): boolean {
    arr = arr.map((e) => e.toLowerCase());
    const arr$ = Array.from({ length: $.length }, (x) => $.toLowerCase()).map(
        (el, i) => el.slice(i) + el.slice(0, i)
    );
    return arr$.every((e) => arr.includes(e));
}

function containAllRots3(str: string, arr: string[]): boolean {
    const inputStrings = new Set(arr);
    return getRots(str).every((rotation) => inputStrings.has(rotation));
}

function getRots(str: string, res: string[] = []): string[] {
    if (res.length === str.length) return res;
    res.push(str);
    return getRots(str.slice(1) + str[0], res);
}

function containAllRots4(str: string, arr: string[]): boolean {
    for (let idx = 0; idx < str.length; idx += 1) {
        const rot = str.slice(idx) + str.slice(0, idx);
        if (!arr.includes(rot)) return false;
    }
    return true;
}
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: DISARIUM NUMBER - (Special Numbers Series #3)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Definition
Disarium number is the number that The sum of its digits powered with their respective positions is equal to the number itself.

Task
Given a number, Find if it is Disarium or not .

Warm-up (Highly recommended)
Playing With Numbers Series
Notes
Number passed is always Positive .
Return the result as String
Input >> Output Examples
disariumNumber(89) ==> return "Disarium !!"
Explanation:
Since , 81 + 92 = 89 , thus output is "Disarium !!"
disariumNumber(564) ==> return "Not !!"
Explanation:
Since , 51 + 62 + 43 = 105 != 564 , thus output is "Not !!"
*/

const disariumNumber = (num: number): string => {
    // CONVERT NUM TO ARRAY OF ITS NUMERIC DIGITS
    const digitsArr: number[] = num
        .toString()
        .split("")
        .map((el) => Number(el));

    // console.log(digitsArr);

    // RAISE EACH EL TO ITS POSITION'S POWER AND GET SUM OF ARRAY
    const pwrPosSum: number = digitsArr
        // POSITION 1 = 0 SO HAVE TO ADJUST BY ADDING 1
        .map((el, idx) => Math.pow(el, idx + 1))
        .reduce((a, b) => a + b);

    // console.log(pwrPosSum);

    return pwrPosSum === num ? "Disarium !!" : "Not !!";
};

// "Disarium !!"
// console.log(disariumNumber(89));
// "Not !!"
// console.log(disariumNumber(564));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function disariumNumber2(n: number): string {
    return String(n)
        .split("")
        .reduce((sum, x, i) => sum + parseInt(x) ** (i + 1), 0) === n
        ? "Disarium !!"
        : "Not !!";
}

const disariumNumber3 = (n: number): string =>
    n
        .toString()
        .split("")
        .map((value, index) => parseInt(value) ** (index + 1))
        .reduce((acc, n) => acc + n, 0) === n
        ? "Disarium !!"
        : "Not !!";

function disariumNumber4(n: number) {
    return String(n)
        .split("")
        .reduce(
            (prev, curr, index) => prev + Math.pow(Number(curr), index + 1),
            0
        ) === n
        ? "Disarium !!"
        : "Not !!";
}
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: BOILED EGGS - COOKING TIME
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
You are the greatest chef on earth. No one boils eggs like you! Your restaurant is always full of guests, who love your boiled eggs. But when there is a greater order of boiled eggs, you need some time, because you have only one pot for your job. How much time do you need?

Your Task
Implement a function, which takes a non-negative integer, representing the number of eggs to boil. It must return the time in minutes (integer), which it takes to have all the eggs boiled.

Rules
you can put at most 8 eggs into the pot at once
it takes 5 minutes to boil an egg
we assume, that the water is boiling all the time (no time to heat up)
for simplicity we also don't consider the time it takes to put eggs into the pot or get them out of it
Example (Input --> Output)
0 --> 0
5 --> 5
10 --> 10
*/

// 1Ô∏è‚É£ ‚úÖ
const cookingTime = (eggs: number): number => {
    if (eggs === 0) return 0;
    // CALC HOW MANY ROUNDS NEEDED(EGGS/8 ROUNDED UP TO NEAREST INT)
    const rounds: number = Math.ceil(eggs / 8);
    const time: number = rounds * 5;
    return time;
};

// 2Ô∏è‚É£ ‚úÖ REFACTOR WITH TERNARY
const cookingTime2 = (eggs: number): number => {
    return eggs < 1 ? 0 : Math.ceil(eggs / 8) * 5;
};

// console.log(cookingTime(7));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: STRONG NUMBER
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: FACTORIAL()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Definition
Strong number is the number that the sum of the factorial of its digits is equal to number itself.

For example: 145, since
1! + 4! + 5! = 1 + 24 + 120 = 145
So, 145 is a Strong number.

Task
Given a number, Find if it is Strong or not.

Warm-up (Highly recommended)
Playing With Numbers Series
Notes
Number passed is always Positive.
Return the result as String
Input >> Output Examples
strong_num(1) ==> return "STRONG!!!!"
Explanation:
Since , the sum of its digits' factorial of (1) is equal to number itself (1) , Then its a Strong .

strong_num(123) ==> return "Not Strong !!"
Explanation:
Since the sum of its digits' factorial of 1! + 2! + 3! = 9 is not equal to number itself (123) , Then it's Not Strong .

strong_num(2)  ==>  return "STRONG!!!!"
Explanation:
Since the sum of its digits' factorial of 2! = 2 is equal to number itself (2) , Then its a Strong .

strong_num(150) ==> return "Not Strong !!"
Explanation:
Since the sum of its digits' factorial of 1! + 5! + 0! = 122 is not equal to number itself (150), Then it's Not Strong .


*/

const strongNumber = (num: number): string => {
    const factorial = (n: number): number => {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    };
    // console.log(factorial(4));
    const numArr: number[] = num
        .toString()
        .split("")
        .map((el) => Number(el));
    console.log(numArr);

    const factSum: number = numArr
        .map((digit) => {
            return factorial(digit);
        })
        .reduce((a, b) => a + b);
    console.log(factSum);

    return num === factSum ? "STRONG!!!!" : "Not Strong !!";
};

//   NOT STRONG
// console.log(strongNumber(7));
// console.log(strongNumber(145));

// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

/*
const strongNumber2 = (num: number): string => {
    var arr: number[] = [];
  
    function factorial(n: number) { 
        return n <= 1 ? 1 : n * factorial(n - 1)
    }
  
    return num === String(num).split('')
        .map((e) => Number(e))
        .map((e) => factorial(e))
        .reduce((a, b) => a + b) ? "STRONG!!!!" : "Not Strong !!";
  };




  function fac(n: number){
    return n < 2 ? 1 : n * fac(n - 1)
  }
  
  export const strongNumber3 = (num: number): string => {
    return String(num).split("").reduce((a, b) => a + fac(+b), 0) === num ? "STRONG!!!!" : "Not Strong !!";
}; 
  */

const factorial3 = (n: number): number => (n === 0 ? 1 : n * factorial(n - 1));

export const strongNumber4 = (num: number): string =>
    num ===
        num
            .toString()
            .split("")
            .reduce((acc, value) => acc + factorial(parseInt(value)), 0)
        ? "STRONG!!!!"
        : "Not Strong !!";
// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:   GOING TO THE CINEMA
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ACCUMULATOR WHILE()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
My friend John likes to go to the cinema. He can choose between system A and system B.

System A : he buys a ticket (15 dollars) every time
System B : he buys a card (500 dollars) and a first ticket for 0.90 times the ticket price, 
then for each additional ticket he pays 0.90 times the price paid for the previous ticket.
Example:
If John goes to the cinema 3 times:

System A : 15 * 3 = 45
System B : 500 + 15 * 0.90 + (15 * 0.90) * 0.90 + (15 * 0.90 * 0.90) * 0.90 ( = 536.5849999999999, no rounding for each ticket)
John wants to know how many times he must go to the cinema so that the final result of System B, when rounded up to the next dollar, will be cheaper than System A.

The function movie has 3 parameters: card (price of the card), ticket (normal price of a ticket), perc (fraction of what he paid for the previous ticket) and returns the first n such that

ceil(price of System B) < price of System A.
More examples:
movie(500, 15, 0.9) should return 43 
    (with card the total price is 634, with tickets 645)
movie(100, 10, 0.95) should return 24 
    (with card the total price is 235, with tickets 240)
*/

class G964c {
    public static movie(prePaid: number, ticket: number, perc: number): number {
        let counter: number = 0, // SOLUTION
            sysA: number = 0, // A
            sysB: number = prePaid, // B
            currDiscPrice: number = ticket; // TRACK CURRENT PRICE FOR sysB
        // ROUND UP sysB WHEN CHECKING CONDITION
        while (Math.ceil(sysB) >= sysA) {
            // console.table({ sysA: sysA, sysB: sysB, counter: counter });
            sysA += ticket; // UPDATE sysA
            currDiscPrice *= perc; // CALC CURRENT DISC PRICE
            sysB += currDiscPrice; // UPDATE sysB
            counter++; // INCREMENT COUNTER
            // console.table({
            //     sysA: sysA,
            //     sysB: sysB,
            //     "sysB rounded up: ": Math.ceil(sysB),
            //     counter: counter,
            // });
        }

        return counter;
    }
}

/*
G964c.movie(0, 10, 0.95)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      (index)      ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ       sysA        ‚îÇ   10   ‚îÇ
‚îÇ       sysB        ‚îÇ  9.5   ‚îÇ
‚îÇ sysB rounded up:  ‚îÇ   10   ‚îÇ
‚îÇ      counter      ‚îÇ   1    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      (index)      ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ       sysA        ‚îÇ   20   ‚îÇ
‚îÇ       sysB        ‚îÇ 18.525 ‚îÇ
‚îÇ sysB rounded up:  ‚îÇ   19   ‚îÇ
‚îÇ      counter      ‚îÇ   2    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
2
*/

// 43
// console.log(G964c.movie(500, 15, 0.9));
// 2
// console.log(G964c.movie(0, 10, 0.95));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G964c1 {
    public static movie(card: number, ticket: number, perc: number): number {
        let i: number = 0;
        while (Math.ceil(card) >= ticket * i) {
            card += ticket * perc ** i;
            i++;
        }
        return i - 1;
    }
}

class G964c2 {
    public static movie(card: number, ticket: number, perc: number): number {
        let k = 1,
            i = 1;
        while (Math.ceil(card + ticket * perc * k) >= ticket * i) {
            k += Math.pow(perc, i);
            i++;
        }
        return i;
    }
}

class G964c3 {
    public static movie(card: number, ticket: number, perc: number): number {
        var cardPrice: number = card + ticket;
        var ticketPrice: number = ticket;
        var previousTicket: number = ticket;
        var i: number = 1;
        while (Math.ceil(cardPrice) >= ticketPrice) {
            ticketPrice += ticket;
            previousTicket *= perc;
            cardPrice += previousTicket;
            i += 1;
        }
        return i - 1;
    }
}

/*
class G964c4 {
    
    public static movie(card: number, ticket: number, perc: number): number {
        let lastN = 0;
        let n = 0;
        let count = 0;
        while(true) {
          lastN = n;
          let costA = G964.systemA(ticket, n);
          let costB = G964.systemB(card, ticket, perc, n);
          if(roundup(costB) >= roundup(costA)) {
            if(Math.abs(costB - costA) < ticket) {
              n++;
            } else {
            n += Math.ceil((costB - costA)/ticket);
            }
          } else {
              break;
          }
          if(count++ > 20) break;
        }
        return n;
    };
    
    public static systemA(ticket, n) {
        return ticket*n;
    }    
    
    public static systemB(card, ticket, perc, n) {
        return card + ticket*perc*(1-Math.pow(perc,n))/(1-perc);
    }
    
    public static costDifference(card: number, ticket: number, perc: number, n: number) {
        return (G964.systemB(card, ticket, perc, n)) - (G964.systemA(ticket, n));
    }
}

function roundup(x): number {
    return Math.ceil(x);
}
*/

class G964c5 {
    public static movie(card: number, ticket: number, perc: number): number {
        let counter = 1;
        let ticketTotal = ticket;

        let currentTicketPrice = ticket * perc;

        let cardTotal = card + currentTicketPrice;

        while (ticketTotal <= Math.ceil(cardTotal)) {
            counter++;

            ticketTotal += ticket;

            currentTicketPrice *= perc;
            cardTotal += currentTicketPrice;
        }

        return counter;
    }
}

// üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®
// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è  INCLUDE THIS IN EXAMPLES ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:   ORDERED COUNT OF CHARACTERS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: COUNT OCCURENCES IN ARRAY, OBJECT.ENTRIES(), SET(), LOOP OVER SET
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Count the number of occurrences of each character and return it as a list of tuples in order of appearance. For empty output return an empty list.

Example:

orderedCount("abracadabra") == [['a', 5], ['b', 2], ['r', 2], ['c', 1], ['d', 1]]
*/

// 1Ô∏è‚É£  !!! THIS IS NOT IN ORDER OF APPEARANCE FOR NUMBER STRING !!!
// WORKS WITH ALPABETIC STRINGS
const orderedCount = (text: string): [string, number][] => {
    let solution: [string, number][] = [];

    interface StingKey {
        [key: string]: number;
    }

    const counterObj: StingKey = {};

    text.split("").forEach(
        (num) => (counterObj[num] = (counterObj[num] || 0) + 1)
    );

    console.log(counterObj);

    Object.entries(counterObj).forEach(([key, value]) => {
        console.log([key, value]);
        solution.push([key, value]);
    });

    return solution;
};

// 2Ô∏è‚É£
const orderedCount2 = (text: string): [string, number][] => {
    const strArr: string[] = text.split("");
    let solution: [string, number][] = [];

    interface StringNumber {
        [key: string]: number;
    }

    const counterObj: StringNumber = {};

    strArr.forEach((num) => (counterObj[num] = (counterObj[num] || 0) + 1));

    console.log(counterObj);

    // Object.entries(counterObj).forEach(([key, value]) => {
    //     console.log([key, value]);
    //     solution.push([key, value]);
    // });

    // LOOP OVER strArr TO PRESERVE ORIGINAL ORDER ???
    // REMOVE DUPLICATES [2, 3, 3, 3, 1, 2] => [2, 3, 1]
    // AND LOOP OVER SET:
    const uniqueElements = new Set<string>(strArr);
    console.log(uniqueElements);

    uniqueElements.forEach((el) => {
        console.log(el, counterObj[el]);
        solution.push([el, counterObj[el]]);
    });

    return solution;
};

// [['a', 5], ['b', 2], ['r', 2], ['c', 1], ['d', 1]]
// console.log(orderedCount("abracadabra"));
// [ [ '2', 2 ], [ '3', 3 ], [ '1', 1 ] ]
// console.log(orderedCount2("233312"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function orderedCount3(text: string): [string, number][] {
    return [...new Set(text)].map((x: string) => [x, text.split(x).length - 1]);
}

function orderedCount4(t: string): [string, number][] {
    return [...new Set(t.split(""))].map((e) => [
        e,
        t.split("").filter((v) => v == e).length,
    ]);
}

function orderedCount5(text: string): [string, number][] {
    const arr = text.split("").filter((el, i, arr) => arr.indexOf(el) === i);
    return arr.map((value, index) => {
        return [value, text.split("").filter((val) => val === value).length];
    });
}

function orderedCount6(text: string): [string, number][] {
    return text
        .split("")
        .filter((el, i) => text.indexOf(el) === i)
        .map((item) => [item, text.split(item).length - 1]);
}

function orderedCount7(text: string): [string, number][] {
    let m: any = {};
    let output: any = [];

    for (let i of text) {
        if (!(i in m)) {
            m[i] = 1;
        } else {
            m[i] += 1;
        }
    }

    for (let i of text) {
        if (i in m) {
            output.push([i, m[i]]);
            delete m[i];
        }
    }

    return output;
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: GROWING PLANT - Simple Fun #74
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: BREAK OUT OF WHILE LOOP
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Task
Each day a plant is growing by upSpeed meters. Each night that plant's height decreases by downSpeed meters due to the lack of sun heat. Initially, plant is 0 meters tall. We plant the seed at the beginning of a day. We want to know when the height of the plant will reach a certain level.

Example
For upSpeed = 100, downSpeed = 10 and desiredHeight = 910, the output should be 10.

After day 1 --> 100
After night 1 --> 90
After day 2 --> 190
After night 2 --> 180
After day 3 --> 280
After night 3 --> 270
After day 4 --> 370
After night 4 --> 360
After day 5 --> 460
After night 5 --> 450
After day 6 --> 550
After night 6 --> 540
After day 7 --> 640
After night 7 --> 630
After day 8 --> 730
After night 8 --> 720
After day 9 --> 820
After night 9 --> 810
After day 10 --> 910 
For upSpeed = 10, downSpeed = 9 and desiredHeight = 4, the output should be 1.

Because the plant reach to the desired height at day 1(10 meters).

After day 1 --> 10
Input/Output
[input] integer upSpeed

A positive integer representing the daily growth.

Constraints: 5 ‚â§ upSpeed ‚â§ 100.

[input] integer downSpeed

A positive integer representing the nightly decline.

Constraints: 2 ‚â§ downSpeed < upSpeed.

[input] integer desiredHeight

A positive integer representing the threshold.

Constraints: 4 ‚â§ desiredHeight ‚â§ 1000.

[output] an integer

The number of days that it will take for the plant to reach/pass desiredHeight (including the last day in the total count).
*/

const growingPlant = (up: number, down: number, target: number): number => {
    if (
        up < 5 ||
        up > 100 ||
        down < 2 ||
        down >= up ||
        target < 4 ||
        target > 1000
    ) {
        return 0;
    }

    let actualHeigth = 0,
        counter = 0;

    while (actualHeigth <= target) {
        actualHeigth += up;
        counter++;
        if (actualHeigth >= target) {
            // ‚ùóÔ∏è REFACTOR: END RETURN STATEMENT NEVER RUNS ‚ùóÔ∏è
            // return counter;

            // VS:

            // ‚ùóÔ∏è STOP LOOP AND RETURN AT END OF FUNCTION ‚ùóÔ∏è
            break;
        }
        actualHeigth -= down;

        // console.table({
        //     up: up,
        //     down: down,
        //     actualHeigth: actualHeigth,
        //     counter: counter,
        // });
    }

    return counter;
};

// 10
// console.log(growingPlant(100, 10, 410));
// console.log(growingPlant(10, 10, 410));
// 1
// console.log(growingPlant(10, 9, 4));
// console.log();
// console.log();

/*
growingPlant(100, 10, 410)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)    ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      up      ‚îÇ  100   ‚îÇ
‚îÇ     down     ‚îÇ   10   ‚îÇ
‚îÇ actualHeigth ‚îÇ   90   ‚îÇ
‚îÇ   counter    ‚îÇ   1    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)    ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      up      ‚îÇ  100   ‚îÇ
‚îÇ     down     ‚îÇ   10   ‚îÇ
‚îÇ actualHeigth ‚îÇ  180   ‚îÇ
‚îÇ   counter    ‚îÇ   2    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)    ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      up      ‚îÇ  100   ‚îÇ
‚îÇ     down     ‚îÇ   10   ‚îÇ
‚îÇ actualHeigth ‚îÇ  270   ‚îÇ
‚îÇ   counter    ‚îÇ   3    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)    ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ      up      ‚îÇ  100   ‚îÇ
‚îÇ     down     ‚îÇ   10   ‚îÇ
‚îÇ actualHeigth ‚îÇ  360   ‚îÇ
‚îÇ   counter    ‚îÇ   4    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
5
*/

//============= OTHER CODEWARS SOLUTIONS: =============

function growingPlant2(up: number, down: number, h: number): number {
    let count: number = 1;
    let a: number = up;
    while (a < h) {
        count++;
        a = a - down + up;
    }
    return count;
}

function growingPlant3(up: number, down: number, target: number): number {
    let height = up;
    let days = 1;
    while (height < target) {
        height += up - down;
        days++;
    }
    return days;
}

function growingPlant4(up: number, down: number, h: number): number {
    return Math.max(Math.ceil((h - down) / (up - down)), 1);
}

function growingPlant5(up: number, down: number, h: number): number {
    let meters = 0;
    let day = 0;
    while (meters < h) {
        day++;
        meters += up;
        if (meters >= h) return day;
        meters -= down;
    }
    return day;
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: ROTATE FOR A MAX
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Let us begin with an example:

Take a number: 56789. Rotate left, you get 67895.

Keep the first digit in place and rotate left the other digits: 68957.

Keep the first two digits in place and rotate the other ones: 68579.

Keep the first three digits and rotate left the rest: 68597. Now it is over since keeping the first four it remains only one digit which rotated is itself.

You have the following sequence of numbers:

56789 -> 67895 -> 68957 -> 68579 -> 68597

and you must return the greatest: 68957.

Task
Write function max_rot(n) which given a positive integer n returns the maximum number you got doing rotations similar to the above example.

So max_rot (or maxRot or ... depending on the language) is such as:

max_rot(56789) should return 68957

max_rot(38458215) should return 85821534
*/

class G964B {
    public static maxRot = (num: number): number => {
        console.log(num);
        // GET HOW MANY TIMES NUM WILL BE ROTATED
        const numRotations: number = num.toString().length - 1;
        const numArr = num.toString().split("");
        // NOT NECESSARY AS ORIGINAL NUM IS NOW ADDED TO VERSIONSARR TO COMPARE
        // if (numArr[1] === "0" || num < 10) return num;

        // ARRAY FOR ALL VARIATIONS
        let versionsArr = [];

        for (let i = 0; i < numRotations; i++) {
            // CURRENT DIGIT TO SHIFT
            let rotateDigit = numArr[i];
            // REMOVE iTH DIGIT
            numArr.splice(i, 1);
            // ADD IT TO END OF ARRAY
            numArr.push(rotateDigit);
            //  console.log("CURRENT DIGITS: ", numArr);
            // CONVERT TO NUMBER
            let number: number = parseInt(numArr.join(""));
            // PUSH INTO versionsArr
            versionsArr.push(number);

            // console.table({
            //     rotateDigit: rotateDigit,
            //     number: number
            // })
        }

        // ADD ORIGINAL INPUT NUM TO versionsArr AND GET LARGEST NUMBER
        return Math.max(...versionsArr.concat(num));
    };
}

/*
553188569
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)   ‚îÇ  Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ rotateDigit ‚îÇ    '5'    ‚îÇ
‚îÇ   number    ‚îÇ 531885695 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)   ‚îÇ  Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ rotateDigit ‚îÇ    '3'    ‚îÇ
‚îÇ   number    ‚îÇ 518856953 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)   ‚îÇ  Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ rotateDigit ‚îÇ    '8'    ‚îÇ
‚îÇ   number    ‚îÇ 518569538 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)   ‚îÇ  Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ rotateDigit ‚îÇ    '5'    ‚îÇ
‚îÇ   number    ‚îÇ 518695385 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)   ‚îÇ  Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ rotateDigit ‚îÇ    '9'    ‚îÇ
‚îÇ   number    ‚îÇ 518653859 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)   ‚îÇ  Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ rotateDigit ‚îÇ    '3'    ‚îÇ
‚îÇ   number    ‚îÇ 518658593 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)   ‚îÇ  Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ rotateDigit ‚îÇ    '5'    ‚îÇ
‚îÇ   number    ‚îÇ 518658935 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)   ‚îÇ  Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ rotateDigit ‚îÇ    '3'    ‚îÇ
‚îÇ   number    ‚îÇ 518658953 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
553188569
*/

// 553188569
// console.log(G964B.maxRot(553188569));
// 988103115
// console.log(G964B.maxRot(1));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

/*
class G964B1 {
    public static maxRot(n) {

        let arrResult = [];
        arrResult.push(n);

        let arrNum = n.toString().split('');
        let i = 0;
        while (arrNum.length >= i) {
            arrNum.push(...arrNum.splice(i, 1));

            arrResult.push(arrNum.join(''));
            i++;
        }

        return arrResult.sort().pop();
    }
}




class G964B2 {
    public static maxRot = ($) => Math.max(...($ = `${$}`.split(``)).reduce((a, b, i) =>
        a.concat([a[i].slice(0, i).concat(a[i].slice(i + 1))
            .concat(a[i].slice(i, i + 1))]), [$]).map(el => el.join('')));
}




class G964B3 {
    public static maxRot(n: number) {
        var s: string = String(n)
        var max = Number(s)

        for (var i = 0; i < s.length; i++) {
            s = s.substr(0, i) + rot(s.substr(i))
            var num = Number(s)
            if (num > max) max = num
        }

        return max

        /////////////////////////

        function rot(s: string) {
            return s.substr(1) + s.substr(0, 1)
        }
    }
}



class G964B4 {
    public static maxRot = n =>
        Math.max(...(n = String(n).split(''))
            .reduce((r, _, i) =>
                r.concat([r[i].slice(0, i)
                    .concat(r[i].slice(i + 1))
                    .concat(r[i].slice(i, i + 1))]), [n])
            .map(e => e.join('')));
}



class G964B5 {
    public static maxRot(n) {
        let arr = n.toString().split('');
        const length = arr.length;
        let results = [];
        for (let i = 0; i < length; i++) {
            // the results are pushed here to include the initial number
            results.push(Number(arr.join('')));
            // cut and paste the rotating number
            let cache = arr.splice(i, 1);
            arr.push(cache[0])
            cache = [];
        }
        return Math.max.apply(null, results);
    }
}



class G964B6 {
    public static maxRot(n) {
        let digits = `${n}`, max = n;

        for (let i = 0; i < digits.length; i++) {

            //  rotate the next digit
            digits = digits.substr(0, i) //  before the rotated digit
                + digits.substr(i + 1)     //  after rotated digit
                + digits.substr(i, 1);     //  the rotated digit

            max = Math.max(max, parseInt(digits));
        }

        return max;
    }
}


class G964B7 {
    public static maxRot(n) {
        let str = n.toString()
        let max = n;
        for (let i = 0; i < str.length; i++) {
            str = str.slice(0, i) + str.slice(i + 1) + str.charAt(i)
            max = Math.max(max, parseInt(str));
        };
        return max;
    }
}



class G964B8 {
    public static maxRot(n) {
        const arrNum = n.toString().split('');
        const resArr = [];
        for (let i = 0; i < arrNum.length - 1; i++) {
            arrNum.push(arrNum.splice(i, 1)[0]);
            resArr.push(Number(arrNum.join('')));
        }
        return Math.max(n, ...resArr);
    }
}
*/

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: SORT OUT MEN FROM BOYS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è CREATE SET TYPE, ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è SET(),
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Scenario
Now that the competition gets tough it will Sort out the men from the boys .

Men are the Even numbers and Boys are the odd!alt!alt
Task
Given an array/list [] of n integers , Separate The even numbers from the odds , or Separate the men from the boys!alt!alt
Notes
Return an array/list where Even numbers come first then odds

Since , Men are stronger than Boys , Then Even numbers in ascending order While odds in descending .

Array/list size is at least 4 .

Array/list numbers could be a mixture of positives , negatives .

Have no fear , It is guaranteed that no Zeroes will exists .!alt
Repetition of numbers in the array/list could occur , So (duplications are not included when separating).

Input >> Output Examples:
menFromBoys ({7, 3 , 14 , 17}) ==> return ({14, 17, 7, 3}) 
Explanation:
Since , { 14 } is the even number here , So it came first , then the odds in descending order {17 , 7 , 3} .

menFromBoys ({-94, -99 , -100 , -99 , -96 , -99 }) ==> return ({-100 , -96 , -94 , -99})
Explanation:
Since , { -100, -96 , -94 } is the even numbers here , So it came first in *ascending order *, then the odds in descending order { -99 }

Since , (Duplications are not included when separating) , then you can see only one (-99) was appeared in the final array/list .

menFromBoys ({49 , 818 , -282 , 900 , 928 , 281 , -282 , -1 }) ==> return ({-282 , 818 , 900 , 928 , 281 , 49 , -1})
Explanation:
Since , {-282 , 818 , 900 , 928 } is the even numbers here , So it came first in ascending order , then the odds in descending order { 281 , 49 , -1 }

Since , (Duplications are not included when separating) , then you can see only one (-282) was appeared in the final array/list .
*/

// ! [...EVENS ASCENDING, ...ODDS DESCENDING] REMOVE DUPLICATES !
const menFromBoys = (arr: number[]): number[] => {
    // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è CREATE SET TYPE ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è Type 'unknown' is not assignable to type 'number'.ts(2322)
    let uniqueOdds = new Set<number>(),
        uniqueEvens = new Set<number>();
    arr.forEach((int) => {
        (int & 1) === 1 ? uniqueOdds.add(int) : uniqueEvens.add(int);
    });
    const oddsArr = [...uniqueOdds].sort((a, b) => b - a);
    const evensArr = [...uniqueEvens].sort((a, b) => a - b);

    // console.table({
    //     input: arr,
    //     uniqueOdds: [uniqueOdds],
    //     uniqueEvens: [uniqueEvens],
    //     oddsArr: [oddsArr],
    //     evensArr: [evensArr],
    // });

    const solution: number[] = [...evensArr, ...oddsArr];
    return solution;
};

// [14, 17, 7, 3]
// console.log((menFromBoys([7, 3, 14, 17]));
// [2, 90, 95, 43, 37]
// console.log(menFromBoys([37, 2, 43, 95, 90, 37]));

/*

FILTER OUT DUPLICATES WITH SET 
CREATE ASC/DESC SORTED SUB-ARRAYS
MERGE SUB-ARRAYS FOR SOLUTION

INPUT: [37, 2, 43, 95, 90, 37]
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)   ‚îÇ           0           ‚îÇ 1 ‚îÇ 2  ‚îÇ 3  ‚îÇ 4  ‚îÇ 5  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ    input    ‚îÇ          37           ‚îÇ 2 ‚îÇ 43 ‚îÇ 95 ‚îÇ 90 ‚îÇ 37 ‚îÇ
‚îÇ uniqueOdds  ‚îÇ Set(3) { 37, 43, 95 } ‚îÇ   ‚îÇ    ‚îÇ    ‚îÇ    ‚îÇ    ‚îÇ
‚îÇ uniqueEvens ‚îÇ   Set(2) { 2, 90 }    ‚îÇ   ‚îÇ    ‚îÇ    ‚îÇ    ‚îÇ    ‚îÇ
‚îÇ   oddsArr   ‚îÇ    [ 95, 43, 37 ]     ‚îÇ   ‚îÇ    ‚îÇ    ‚îÇ    ‚îÇ    ‚îÇ
‚îÇ  evensArr   ‚îÇ       [ 2, 90 ]       ‚îÇ   ‚îÇ    ‚îÇ    ‚îÇ    ‚îÇ    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îò
SOLUTION: [ 2, 90, 95, 43, 37 ]
*/

//============= OTHER CODEWARS SOLUTIONS: =============

function menFromBoys2(arr: number[]) {
    let urr = [...new Set(arr)];
    return [
        ...urr.filter((x) => Math.abs(x % 2) == 0).sort((a, b) => a - b),
        ...urr.filter((x) => Math.abs(x % 2) == 1).sort((a, b) => b - a),
    ];
}

function menFromBoys3(arr: number[]): number[] {
    let ar: number[] = [...new Set(arr)];
    return ar
        .filter((x) => x % 2 === 0)
        .sort((a, b) => a - b)
        .concat(...ar.filter((x) => x % 2).sort((a, b) => b - a));
}

function menFromBoys4(arr: number[]): number[] {
    const [even, odd] = [new Set<number>(), new Set<number>()];

    for (const x of arr) {
        x % 2 ? odd.add(x) : even.add(x);
    }

    return [...even]
        .sort((a, b) => a - b)
        .concat([...odd].sort((a, b) => b - a));
}

function menFromBoys5(arr: number[]): number[] {
    return arr
        .reduce(
            ([even, odd], x) => {
                x % 2 ? odd.add(x) : even.add(x);
                return [even, odd];
            },
            [new Set<number>(), new Set<number>()]
        )
        .map((set, i) =>
            [...set].sort(i % 2 ? (a, b) => b - a : (a, b) => a - b)
        )
        .flat();
}

const menFromBoys6 = (arr: number[]): number[] => [
    ...new Set(
        arr
            .filter((e) => e % 2 === 0)
            .sort((a, b) => a - b)
            .concat(arr.filter((a) => a % 2).sort((a, b) => b - a))
    ),
];
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: BALANCED NUMBER (Special Numbers Series #1 )
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è GENERICS ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Definition
Balanced number is the number that * The sum of all digits to the left of the middle digit(s) and the sum of all digits to the right of the middle digit(s) are equal*.

Task
Given a number, Find if it is Balanced or not .

Warm-up (Highly recommended)
Playing With Numbers Series
Notes
If the number has an odd number of digits then there is only one middle digit, e.g. 92645 has middle digit 6; otherwise, there are two middle digits , e.g. 1301 has middle digits 3 and 0

The middle digit(s) should not be considered when determining whether a number is balanced or not, e.g 413023 is a balanced number because the left sum and right sum are both 5.

Number passed is always Positive .

Return the result as String

Input >> Output Examples
(balanced-num 7) ==> return "Balanced"
Explanation:
Since , The sum of all digits to the left of the middle digit (0)

and the sum of all digits to the right of the middle digit (0) are equal , then It's Balanced

(balanced-num 295591) ==> return "Not Balanced"
Explanation:
Since , The sum of all digits to the left of the middle digits (11)

and the sum of all digits to the right of the middle digits (10) are Not equal , then It's Not Balanced

Note : The middle digit(s) are 55 .

(balanced-num 959) ==> return "Balanced"
Explanation:
Since , The sum of all digits to the left of the middle digits (9)

and the sum of all digits to the right of the middle digits (9) are equal , then It's Balanced

Note : The middle digit is 5 .

(balanced-num 27102983) ==> return "Not Balanced"
Explanation:
Since , The sum of all digits to the left of the middle digits (10)

and the sum of all digits to the right of the middle digits (20) are Not equal , then It's Not Balanced

Note : The middle digit(s) are 02 .


*/

const balancedNum = (num: number) => {
    if (num < 100) return "Balanced";

    // CONVERT TO STRING
    const numStr: string = String(num);
    // GET LENGTH
    const length: number = numStr.length;

    // GET BOTH SIDES AS STRING
    const getLeftNumStr = (numStr: string): string => {
        let leftStr =
            (length & 1) === 1
                ? numStr.slice(0, (length - 1) / 2)
                : numStr.slice(0, length / 2 - 1);

        return leftStr;
    };

    const getRightNumStr = (numStr: string): string => {
        let rightStr =
            (length & 1) === 1
                ? numStr.slice((length - 1) / 2 + 1)
                : numStr.slice(length / 2 + 1);

        return rightStr;
    };

    // GET VALUE OF SUM OF NUMERIC DIGITS
    const leftSum: number = getLeftNumStr(numStr)
        .split("")
        .map((strDigit) => Number(strDigit))
        .reduce((a, b) => a + b);

    const rightSum: number = getRightNumStr(numStr)
        .split("")
        .map((strDigit) => Number(strDigit))
        .reduce((a, b) => a + b);

    /*
      console.table({
          input: num,
          numStr: numStr,
          length: length,
          middleDigitIdxOdd: (length - 1) / 2,
          middleDigitOdd: numStr[(length - 1) / 2],
          middleDigitsIdxEven: [length / 2 - 1, length / 2],
          middleDigitsEven: [numStr[length / 2 - 1], numStr[length / 2]],
          leftNumStr: getLeftNumStr(numStr),
          rightNumStr: getRightNumStr(numStr),
          leftSum: leftSum,
          rightSum: rightSum,
          isBalanced: leftSum === rightSum
      })
      */

    // COMPARE SIDES AND RETURN SOLUTION STRING
    return leftSum === rightSum ? "Balanced" : "Not Balanced";
};

// balanced
// console.log(balancedNum(56239814));
// not balanced
// console.log(balancedNum(1230987));
// console.log();
// console.log();

/*

56239814 EVEN LENGTH
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       (index)       ‚îÇ  0  ‚îÇ  1  ‚îÇ   Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ        input        ‚îÇ     ‚îÇ     ‚îÇ  56239814  ‚îÇ
‚îÇ       numStr        ‚îÇ     ‚îÇ     ‚îÇ '56239814' ‚îÇ
‚îÇ       length        ‚îÇ     ‚îÇ     ‚îÇ     8      ‚îÇ
‚îÇ  middleDigitIdxOdd  ‚îÇ     ‚îÇ     ‚îÇ    3.5     ‚îÇ
‚îÇ   middleDigitOdd    ‚îÇ     ‚îÇ     ‚îÇ undefined  ‚îÇ
‚îÇ middleDigitsIdxEven ‚îÇ  3  ‚îÇ  4  ‚îÇ            ‚îÇ
‚îÇ  middleDigitsEven   ‚îÇ '3' ‚îÇ '9' ‚îÇ            ‚îÇ
‚îÇ     leftNumStr      ‚îÇ     ‚îÇ     ‚îÇ   '562'    ‚îÇ
‚îÇ     rightNumStr     ‚îÇ     ‚îÇ     ‚îÇ   '814'    ‚îÇ
‚îÇ       leftSum       ‚îÇ     ‚îÇ     ‚îÇ     13     ‚îÇ
‚îÇ      rightSum       ‚îÇ     ‚îÇ     ‚îÇ     13     ‚îÇ
‚îÇ     isBalanced      ‚îÇ     ‚îÇ     ‚îÇ    true    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Balanced

1230987 ODD LENGTH
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       (index)       ‚îÇ     0     ‚îÇ     1     ‚îÇ  Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ        input        ‚îÇ           ‚îÇ           ‚îÇ  1230987  ‚îÇ
‚îÇ       numStr        ‚îÇ           ‚îÇ           ‚îÇ '1230987' ‚îÇ
‚îÇ       length        ‚îÇ           ‚îÇ           ‚îÇ     7     ‚îÇ
‚îÇ  middleDigitIdxOdd  ‚îÇ           ‚îÇ           ‚îÇ     3     ‚îÇ
‚îÇ   middleDigitOdd    ‚îÇ           ‚îÇ           ‚îÇ    '0'    ‚îÇ
‚îÇ middleDigitsIdxEven ‚îÇ    2.5    ‚îÇ    3.5    ‚îÇ           ‚îÇ
‚îÇ  middleDigitsEven   ‚îÇ undefined ‚îÇ undefined ‚îÇ           ‚îÇ
‚îÇ     leftNumStr      ‚îÇ           ‚îÇ           ‚îÇ   '123'   ‚îÇ
‚îÇ     rightNumStr     ‚îÇ           ‚îÇ           ‚îÇ   '987'   ‚îÇ
‚îÇ       leftSum       ‚îÇ           ‚îÇ           ‚îÇ     6     ‚îÇ
‚îÇ      rightSum       ‚îÇ           ‚îÇ           ‚îÇ    24     ‚îÇ
‚îÇ     isBalanced      ‚îÇ           ‚îÇ           ‚îÇ   false   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Not Balanced

*/

//============= OTHER CODEWARS SOLUTIONS: =============

function balancedNum2(number: number): "Balanced" | "Not Balanced" {
    const numbers = (number + "").split("").map((digit) => parseInt(digit));
    const length = numbers.length;
    if (length <= 2) return "Balanced";

    const left = numbers.slice(0, Math.floor(length / 2 - 0.5));
    const right = numbers.slice(Math.ceil(length / 2 + 0.5), length);

    return left.reduce((a, b) => a + b) == right.reduce((a, b) => a + b)
        ? "Balanced"
        : "Not Balanced";
}

function balancedNum3(number: number): string {
    let s: string = number.toString();
    let n: number = Math.floor((s.length - 1) / 2);
    return !n ||
        [...s.slice(0, n)].reduce((a, b) => a + +b, 0) ==
        [...s.slice(-n)].reduce((a, b) => a + +b, 0)
        ? "Balanced"
        : "Not Balanced";
}

function balancedNum4(number: number) {
    const numArray = number.toString().split("");
    let forwardSum = 0;
    let backwardSum = 0;
    for (let i = 0; i < numArray.length / 2 - 1; i++) {
        forwardSum += parseInt(numArray[i]);
        backwardSum += parseInt(numArray[numArray.length - 1 - i]);
    }

    return forwardSum === backwardSum ? "Balanced" : "Not Balanced";
}

// =====================================================
function balancedNum5(num: number): string {
    const [leftSum, rightSum] = splitMiddle(numToArray(num)).map(sum);

    return leftSum === rightSum ? "Balanced" : "Not Balanced";
}

function numToArray(num: number, res: number[] = []): number[] {
    if (num === 0) return res;
    res.push(num % 10);
    return numToArray(Math.trunc(num / 10), res);
}

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è GENERICS ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
function splitMiddle<T>(arr: T[]): [T[], T[]] {
    const middle = Math.floor(arr.length / 2);
    return [
        arr.slice(0, middle - (arr.length % 2 ? 0 : 1)),
        arr.slice(middle + 1),
    ];
}

function sum(arr: number[]): number {
    return arr.reduce((total, x) => total + x, 0);
}
// =====================================================

// üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®
// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è  INCLUDE THIS IN EXAMPLES ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: RULE OF DIVISIBILITY BY 7
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: RECURSION, SUBSTRING()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
A number m of the form 10x + y is divisible by 7 if and only if x ‚àí 2y is divisible by 7. In other words, subtract twice the last digit from the number formed by the remaining digits. Continue to do this until a number known to be divisible by 7 is obtained; you can stop when this number has at most 2 digits because you are supposed to know if a number of at most 2 digits is divisible by 7 or not.

The original number is divisible by 7 if and only if the last number obtained using this procedure is divisible by 7.

Examples:
1 - m = 371 -> 37 ‚àí (2√ó1) -> 37 ‚àí 2 = 35 ; thus, since 35 is divisible by 7, 371 is divisible by 7.

The number of steps to get the result is 1.

2 - m = 1603 -> 160 - (2 x 3) -> 154 -> 15 - 8 = 7 and 7 is divisible by 7.

3 - m = 372 -> 37 ‚àí (2√ó2) -> 37 ‚àí 4 = 33 ; thus, since 33 is not divisible by 7, 372 is not divisible by 7.

4 - m = 477557101->47755708->4775554->477547->47740->4774->469->28 and 28 is divisible by 7, so is 477557101. The number of steps is 7.

Task:
Your task is to return to the function seven(m) (m integer >= 0) an array (or a pair, depending on the language) of numbers, the first being the last number m with at most 2 digits obtained by your function (this last m will be divisible or not by 7), the second one being the number of steps to get the result.

Forth Note:
Return on the stack number-of-steps, last-number-m-with-at-most-2-digits

Examples:
seven(371) should return [35, 1]
seven(1603) should return [7, 2]
seven(477557101) should return [28, 7]
*/

// 1Ô∏è‚É£

// GLOBAL COUNTER VARIABLE TO COUNT HOW MANY TIMES FUNCTION RUNS
let cycleCount: number = 0;

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è RETURNS number WHEN CALLED AGAIN, AND number[] WHEN SOLUTION IS FOUND ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
const seven = (num: number): number | number[] => {
    if (num === 0) return [0, 0];

    // CONVERT TO STRING IN ORDER TO BE ABLE TO EXTRACT DIGITS
    const numStr: string = num.toString();
    // GRAB LAST DIGIT AND REMAINING DIGITS
    let lastDigit: number = Number(numStr.slice(-1));
    let remainingDigits: number = Number(
        // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è SUBSTRING() ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
        numStr.substring(0, numStr.length - 1)
    );

    // GET REMAINDER AFTER SUBSTRACTING LASTDIGIT TWICE
    let remainder: number = remainingDigits - lastDigit * 2;
    // INCREMENT CYCLECOUNT
    cycleCount++;
    // INITIALIZE SOLUTION ARRAY
    let solution: number[] = [remainder, cycleCount];

    console.table({
        numStr: numStr,
        lastDigit: lastDigit,
        remainingDigits: remainingDigits,
        remainder: remainder,
        cycleCount: cycleCount,
        solution: [solution],
    });

    // IF REMAINDER IS REDUCED TO MAX 2 DIGITS
    if (remainder < 100) {
        // RESET COUNTER
        cycleCount = 0;
        // RETURN
        return solution;
    }

    // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è RECURSION ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
    // OTHERWISE, IF REMAINDER IS NOT REDUCED TO 2 DIGITS
    // RETURN FUNCION WITH REMAINDER
    return seven(remainder);

    // !!! THIS TERNARY IS NOT NECESSARY !!
    // return remainder > 99 ? seven(remainder) : remainder;
};

// 35, 1
// console.log(seven(371));
// [10, 2]
// console.log(seven(1021));
// [28, 7]
// console.log(seven(477557101));

/*

seven(477557101)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     (index)     ‚îÇ        0        ‚îÇ   Values    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     numStr      ‚îÇ                 ‚îÇ '477557101' ‚îÇ
‚îÇ    lastDigit    ‚îÇ                 ‚îÇ      1      ‚îÇ
‚îÇ remainingDigits ‚îÇ                 ‚îÇ  47755710   ‚îÇ
‚îÇ    remainder    ‚îÇ                 ‚îÇ  47755708   ‚îÇ
‚îÇ   cycleCount    ‚îÇ                 ‚îÇ      1      ‚îÇ
‚îÇ    solution     ‚îÇ [ 47755708, 1 ] ‚îÇ             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     (index)     ‚îÇ       0        ‚îÇ   Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     numStr      ‚îÇ                ‚îÇ '47755708' ‚îÇ
‚îÇ    lastDigit    ‚îÇ                ‚îÇ     8      ‚îÇ
‚îÇ remainingDigits ‚îÇ                ‚îÇ  4775570   ‚îÇ
‚îÇ    remainder    ‚îÇ                ‚îÇ  4775554   ‚îÇ
‚îÇ   cycleCount    ‚îÇ                ‚îÇ     2      ‚îÇ
‚îÇ    solution     ‚îÇ [ 4775554, 2 ] ‚îÇ            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     (index)     ‚îÇ       0       ‚îÇ  Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     numStr      ‚îÇ               ‚îÇ '4775554' ‚îÇ
‚îÇ    lastDigit    ‚îÇ               ‚îÇ     4     ‚îÇ
‚îÇ remainingDigits ‚îÇ               ‚îÇ  477555   ‚îÇ
‚îÇ    remainder    ‚îÇ               ‚îÇ  477547   ‚îÇ
‚îÇ   cycleCount    ‚îÇ               ‚îÇ     3     ‚îÇ
‚îÇ    solution     ‚îÇ [ 477547, 3 ] ‚îÇ           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     (index)     ‚îÇ      0       ‚îÇ  Values  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     numStr      ‚îÇ              ‚îÇ '477547' ‚îÇ
‚îÇ    lastDigit    ‚îÇ              ‚îÇ    7     ‚îÇ
‚îÇ remainingDigits ‚îÇ              ‚îÇ  47754   ‚îÇ
‚îÇ    remainder    ‚îÇ              ‚îÇ  47740   ‚îÇ
‚îÇ   cycleCount    ‚îÇ              ‚îÇ    4     ‚îÇ
‚îÇ    solution     ‚îÇ [ 47740, 4 ] ‚îÇ          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     (index)     ‚îÇ      0      ‚îÇ Values  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     numStr      ‚îÇ             ‚îÇ '47740' ‚îÇ
‚îÇ    lastDigit    ‚îÇ             ‚îÇ    0    ‚îÇ
‚îÇ remainingDigits ‚îÇ             ‚îÇ  4774   ‚îÇ
‚îÇ    remainder    ‚îÇ             ‚îÇ  4774   ‚îÇ
‚îÇ   cycleCount    ‚îÇ             ‚îÇ    5    ‚îÇ
‚îÇ    solution     ‚îÇ [ 4774, 5 ] ‚îÇ         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     (index)     ‚îÇ     0      ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     numStr      ‚îÇ            ‚îÇ '4774' ‚îÇ
‚îÇ    lastDigit    ‚îÇ            ‚îÇ   4    ‚îÇ
‚îÇ remainingDigits ‚îÇ            ‚îÇ  477   ‚îÇ
‚îÇ    remainder    ‚îÇ            ‚îÇ  469   ‚îÇ
‚îÇ   cycleCount    ‚îÇ            ‚îÇ   6    ‚îÇ
‚îÇ    solution     ‚îÇ [ 469, 6 ] ‚îÇ        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     (index)     ‚îÇ     0     ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ     numStr      ‚îÇ           ‚îÇ '469'  ‚îÇ
‚îÇ    lastDigit    ‚îÇ           ‚îÇ   9    ‚îÇ
‚îÇ remainingDigits ‚îÇ           ‚îÇ   46   ‚îÇ
‚îÇ    remainder    ‚îÇ           ‚îÇ   28   ‚îÇ
‚îÇ   cycleCount    ‚îÇ           ‚îÇ   7    ‚îÇ
‚îÇ    solution     ‚îÇ [ 28, 7 ] ‚îÇ        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
[ 28, 7 ]
*/

//============= OTHER CODEWARS SOLUTIONS: =============

// üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®
// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è  INCLUDE THIS IN EXAMPLES ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:   BUILD A SQUARE
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è LINEBREAK "\n" (ADD NEW LINE TO CONSOLE OUTPUT) ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
I will give you an integer. Give me back a shape that is as long and wide as the integer. The integer will be a whole number between 1 and 50.

Example
n = 3, so I expect a 3x3 square back just like below as a string:

+++
+++
+++
*/

const generateShape = (int: number): string => {
    if (int === 1) return "+";

    let solution: string = "";

    for (let i = 0; i < int; i++) {
        // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è LINE BREAK ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
        let row: string = i >= 1 ? "\n" + "+".repeat(int) : "+".repeat(int);
        solution += row;
    }

    return solution;
};

//   ADD LINE BREAK TO EVERY ROW BUT FIRST

// console.log(generateShape(3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è LINE BREAK ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
function generateShape2(int: number): string {
    return `${"+".repeat(int)}\n`.repeat(int).slice(0, -1);
}

function generateShape3(int: number): string {
    return Array(int)
        .fill(Array(int + 1).join("+"))
        .join("\n");
}

function generateShape4(int: number): string {
    var array = [];
    for (let i = 0; i < int; i++) {
        array.push("+".repeat(int));
    }

    return array.join("\n");
}

function generateShape5(int: number): string {
    let result: string = "";
    for (let i: number = 0; i < int; i++) result += "+".repeat(int) + "\n";
    return result.slice(0, result.length - 1);
}

function generateShape6(size: number): string {
    return new Array(size).fill(new Array(size).fill("+").join("")).join("\n");
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: AUTOMORPHIC NUMBER (Special Numbers Series #6)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è ENDSWITH ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Definition
A number is called Automorphic number if and only if its square ends in the same digits as the number itself.

Task
Given a number determine if it Automorphic or not .

Warm-up (Highly recommended)
Playing With Numbers Series
Notes
The number passed to the function is positive
Input >> Output Examples
autoMorphic (25) -->> return "Automorphic" 
Explanation:
25 squared is 625 , Ends with the same number's digits which are 25 .

autoMorphic (13) -->> return "Not!!"
Explanation:
13 squared is 169 , Not ending with the same number's digits which are 69 .

autoMorphic (76) -->> return "Automorphic"
Explanation:
76 squared is 5776 , Ends with the same number's digits which are 76 .

autoMorphic (225) -->> return "Not!!"
Explanation:
225 squared is 50625 , Not ending with the same number's digits which are 225.

*/

const automorphic = (num: number): string => {
    const numStr: string = num.toString();
    const numStrLength: number = numStr.length;

    const sqStr: string = Math.pow(num, 2).toString();

    // console.table({
    //     numStr: numStr,
    //     numStrLength: numStrLength,
    //     sqStr: sqStr,
    //     isAutoMorphic: numStr == sqStr.slice(-numStrLength),
    // });

    return numStr === sqStr.slice(-numStrLength) ? "Automorphic" : "Not!!";
};

//  CONVERT BOTH TO STRING
//  GET LENGTH OF num (THIS WILL BE THE NUMBER OF LAST DIGITS OF sqStr TO COMPARE  num WITH)
//  COMPARE AND RETURN RESULT STRING

/*
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    (index)    ‚îÇ Values  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ    numStr     ‚îÇ  '225'  ‚îÇ
‚îÇ numStrLength  ‚îÇ    3    ‚îÇ
‚îÇ     sqStr     ‚îÇ '50625' ‚îÇ
‚îÇ isAutoMorphic ‚îÇ  false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Not!!
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    (index)    ‚îÇ  Values  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ    numStr     ‚îÇ  '625'   ‚îÇ
‚îÇ numStrLength  ‚îÇ    3     ‚îÇ
‚îÇ     sqStr     ‚îÇ '390625' ‚îÇ
‚îÇ isAutoMorphic ‚îÇ   true   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Automorphic
*/

// console.log(automorphic(3));
// console.log(automorphic(225));
// console.log(automorphic(625));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è ENDSWITH ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
function automorphic2(n: number): string {
    return String(n ** 2).endsWith(String(n)) ? "Automorphic" : "Not!!";
}

// // üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©

// TITLE: SIMPLE BEADS COUNT
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Two red beads are placed between every two blue beads. There are N blue beads. After looking at the arrangement below work out the number of red beads.

@ @@ @ @@ @ @@ @ @@ @ @@ @

Implement count_red_beads(n) (in PHP count_red_beads($n); in Java, Javascript, TypeScript, C, C++ countRedBeads(n)) so that it returns the number of red beads.
If there are less than 2 blue beads return 0.
*/

const countRedBeads = (num: number): number => {
    return num <= 1 ? 0 : (num - 1) * 2;
};

// console.log(countRedBeads(1));
// console.log(countRedBeads(3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function countRedBeads2(n: number): number {
    return Math.max(0, (n - 1) * 2);
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: INVITE MORE WOMEN - Simple Fun 152
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: EVAL,
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Task
King Arthur and his knights are having a New Years party. Last year Lancelot was jealous of Arthur, because Arthur had a date and Lancelot did not, and they started a duel.

To prevent this from happening again, Arthur wants to make sure that there are at least as many women as men at this year's party. He gave you a list of integers of all the party goers.

Arthur needs you to return true if he needs to invite more women or false if he is all set.

Input/Output
[input] integer array L ($a in PHP)
An array (guaranteed non-associative in PHP) representing the genders of the attendees, where -1 represents women and 1 represents men.

2 <= L.length <= 50

[output] a boolean value

true if Arthur need to invite more women, false otherwise.
*/

const inviteMoreWomen = (guestsArr: number[]): boolean => {
    return guestsArr.reduce((acc, curr) => acc + curr) > 0;
};

// console.log(inviteMoreWomen([1, -1, 1]));
// console.log(inviteMoreWomen([1, -1]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è EVAL ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
function inviteMoreWomen2(L: number[]): boolean {
    return eval(L.join("+")) > 0;
}

function inviteMoreWomen3(L: number[]): boolean {
    return (
        L.filter((num) => num > 0).length > L.filter((num) => num < 0).length
    );
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: SUM OF CUBES
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: RECURSION ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Write a function that takes a positive integer n, sums all the cubed values from 1 to n, and returns that sum.

Assume that the input n will always be a positive integer.

Examples: (Input --> output)

2 --> 9 (sum of the cubes of 1 and 2 is 1 + 8)
3 --> 36 (sum of the cubes of 1, 2, and 3 is 1 + 8 + 27)
*/

const sumCubes = (num: number): number => {
    let result: number = 0;

    for (let i = 1; i <= num; i++) {
        result += Math.pow(i, 3);
    }

    return result;
};

// console.log(sumCubes(2));
// console.log(sumCubes(3));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function sumCubes2(n: number): number {
    let res = 0;
    for (let i = 0; i <= n; i += 1) {
        res += i ** 3;
    }
    return res;
}

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è RECURSION ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
function sumCubes3(n: number): number {
    if (n == 1) {
        return 1;
    } else {
        return Math.pow(n, 3) + sumCubes(n - 1);
    }
}
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: ALPHABET SYMMETRY
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: CHARCODEAT
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Consider the word "abode". We can see that the letter a is in position 1 and b is in position 2. In the alphabet, a and b are also in positions 1 and 2. Notice also that d and e in abode occupy the positions they would occupy in the alphabet, which are positions 4 and 5.

Given an array of words, return an array of the number of letters that occupy their positions in the alphabet for each word. For example,

solve(["abode","ABc","xyzD"]) = [4, 3, 1]
See test cases for more examples.

Input will consist of alphabet characters, both uppercase and lowercase. No spaces.

Good luck!
*/

const solveA = (arr: string[]): number[] => {
    let solution: number[] = [];

    arr.map((el) => el.toLowerCase()).forEach((word) => {
        let counter: number = 0;

        for (let i = 0; i < word.length; i++) {
            let position: number = i;
            let charCode: number = word.charCodeAt(i) - 97;
            // console.table({
            //     char: word[i],
            //     position: position,
            //     charCode: charCode,
            //     match: position === charCode,
            // });
            if (position === charCode) counter++;
        }
        solution.push(counter);
    });

    return solution;
};

//  CASE INSENSITIVE (LOWERCASE)
//  LOOP OVER ARRAY
//      INNER LOOP WILL ITERATE OVER EACH WORD
//          COMPARE CHAR POSITION TO ITS CHARCODE(-97)
//          IF THEY MATCH:
//              INCREMENT COUNTER FOR WORD
//  PUSH COUNTER INTO SOLUTION IN FOREACH
//  RETURN SOLUTION

//

/*
["IAMDEFANDJKL", "thedefgh", "xyzDEFghijabc"]
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'i'   ‚îÇ
‚îÇ position ‚îÇ   0    ‚îÇ
‚îÇ charCode ‚îÇ   8    ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'a'   ‚îÇ
‚îÇ position ‚îÇ   1    ‚îÇ
‚îÇ charCode ‚îÇ   0    ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'm'   ‚îÇ
‚îÇ position ‚îÇ   2    ‚îÇ
‚îÇ charCode ‚îÇ   12   ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'd'   ‚îÇ
‚îÇ position ‚îÇ   3    ‚îÇ
‚îÇ charCode ‚îÇ   3    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'e'   ‚îÇ
‚îÇ position ‚îÇ   4    ‚îÇ
‚îÇ charCode ‚îÇ   4    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'f'   ‚îÇ
‚îÇ position ‚îÇ   5    ‚îÇ
‚îÇ charCode ‚îÇ   5    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'a'   ‚îÇ
‚îÇ position ‚îÇ   6    ‚îÇ
‚îÇ charCode ‚îÇ   0    ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'n'   ‚îÇ
‚îÇ position ‚îÇ   7    ‚îÇ
‚îÇ charCode ‚îÇ   13   ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'd'   ‚îÇ
‚îÇ position ‚îÇ   8    ‚îÇ
‚îÇ charCode ‚îÇ   3    ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'j'   ‚îÇ
‚îÇ position ‚îÇ   9    ‚îÇ
‚îÇ charCode ‚îÇ   9    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'k'   ‚îÇ
‚îÇ position ‚îÇ   10   ‚îÇ
‚îÇ charCode ‚îÇ   10   ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'l'   ‚îÇ
‚îÇ position ‚îÇ   11   ‚îÇ
‚îÇ charCode ‚îÇ   11   ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
thedefgh
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  't'   ‚îÇ
‚îÇ position ‚îÇ   0    ‚îÇ
‚îÇ charCode ‚îÇ   19   ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'h'   ‚îÇ
‚îÇ position ‚îÇ   1    ‚îÇ
‚îÇ charCode ‚îÇ   7    ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'e'   ‚îÇ
‚îÇ position ‚îÇ   2    ‚îÇ
‚îÇ charCode ‚îÇ   4    ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'd'   ‚îÇ
‚îÇ position ‚îÇ   3    ‚îÇ
‚îÇ charCode ‚îÇ   3    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'e'   ‚îÇ
‚îÇ position ‚îÇ   4    ‚îÇ
‚îÇ charCode ‚îÇ   4    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'f'   ‚îÇ
‚îÇ position ‚îÇ   5    ‚îÇ
‚îÇ charCode ‚îÇ   5    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'g'   ‚îÇ
‚îÇ position ‚îÇ   6    ‚îÇ
‚îÇ charCode ‚îÇ   6    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'h'   ‚îÇ
‚îÇ position ‚îÇ   7    ‚îÇ
‚îÇ charCode ‚îÇ   7    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
xyzdefghijabc
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'x'   ‚îÇ
‚îÇ position ‚îÇ   0    ‚îÇ
‚îÇ charCode ‚îÇ   23   ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'y'   ‚îÇ
‚îÇ position ‚îÇ   1    ‚îÇ
‚îÇ charCode ‚îÇ   24   ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'z'   ‚îÇ
‚îÇ position ‚îÇ   2    ‚îÇ
‚îÇ charCode ‚îÇ   25   ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'd'   ‚îÇ
‚îÇ position ‚îÇ   3    ‚îÇ
‚îÇ charCode ‚îÇ   3    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'e'   ‚îÇ
‚îÇ position ‚îÇ   4    ‚îÇ
‚îÇ charCode ‚îÇ   4    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'f'   ‚îÇ
‚îÇ position ‚îÇ   5    ‚îÇ
‚îÇ charCode ‚îÇ   5    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'g'   ‚îÇ
‚îÇ position ‚îÇ   6    ‚îÇ
‚îÇ charCode ‚îÇ   6    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'h'   ‚îÇ
‚îÇ position ‚îÇ   7    ‚îÇ
‚îÇ charCode ‚îÇ   7    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'i'   ‚îÇ
‚îÇ position ‚îÇ   8    ‚îÇ
‚îÇ charCode ‚îÇ   8    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'j'   ‚îÇ
‚îÇ position ‚îÇ   9    ‚îÇ
‚îÇ charCode ‚îÇ   9    ‚îÇ
‚îÇ  match   ‚îÇ  true  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'a'   ‚îÇ
‚îÇ position ‚îÇ   10   ‚îÇ
‚îÇ charCode ‚îÇ   0    ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'b'   ‚îÇ
‚îÇ position ‚îÇ   11   ‚îÇ
‚îÇ charCode ‚îÇ   1    ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ (index)  ‚îÇ Values ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   char   ‚îÇ  'c'   ‚îÇ
‚îÇ position ‚îÇ   12   ‚îÇ
‚îÇ charCode ‚îÇ   2    ‚îÇ
‚îÇ  match   ‚îÇ false  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
[ 6, 5, 7 ]
*/

// [4, 3, 1]
// console.log(solveA(["abode", "ABc", "xyzD"]));
// console.log(solveA(["ABCABC"]));

// [ 6, 5, 7 ]
// console.log(solveA(["IAMDEFANDJKL", "thedefgh", "xyzDEFghijabc"]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function solveA2(arr: string[]) {
    const alphabet: string = "abcdefghijklmnopqrstuvwxyz";
    return arr.map((s) =>
        s
            .split("")
            .reduce(
                (t, c, i) => (c.toLowerCase() === alphabet[i] ? t + 1 : t),
                0
            )
    );
}

function solveA3(arr: string[]): number[] {
    return arr.map((str) => {
        var count = 0;
        var i = str.length;

        while (i > 0) {
            i--;
            if ((str.charCodeAt(i) & 31) == i + 1) count++;
        }

        return count;
    });
}

const solveA4 = (arr: string[]) =>
    arr.map((x) =>
        x
            .split("")
            .reduce(
                (acc, item, i) =>
                    acc + (item.toLowerCase().charCodeAt(0) - 97 == i ? 1 : 0),
                0
            )
    );

function solveA5(arr: string[]) {
    const alphabet: string[] = "abcdefghijklmnopqrstuvwxyz".split("");

    return arr.map((word) => {
        return word
            .toLowerCase()
            .split("")
            .reduce((acc, char, i) => {
                const isPositionMatch = alphabet[i] === char;
                return acc + (isPositionMatch ? 1 : 0);
            }, 0);
    });
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: MINIMIZE SUM OF ARRAY - Array Series #1
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: SORT, SPLICE, REDUCE
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Task
Given an array of integers , Find the minimum sum which is obtained from summing each Two integers product .

Notes
Array/list will contain positives only .
Array/list will always has even size
Input >> Output Examples
minSum({5,4,2,3}) ==> return (22) 
Explanation:
The minimum sum obtained from summing each two integers product , 5*2 + 3*4 = 22
minSum({12,6,10,26,3,24}) ==> return (342)
Explanation:
The minimum sum obtained from summing each two integers product , 26*3 + 24*6 + 12*10 = 342
minSum({9,2,8,7,5,4,0,6}) ==> return (74)
Explanation:
The minimum sum obtained from summing each two integers product , 9*0 + 8*2 +7*4 +6*5 = 74
*/

const minSum = (arr: number[]): number | string => {
    if ((arr.length & 1) === 1) return "odd number of array elements!";

    let sum: number = 0;
    const ascArr = arr.sort((a, b) => a - b);
    console.log(ascArr);
    for (let i = 0; i < ascArr.length / 2; i++) {
        // console.table({ first: ascArr[i], last: ascArr[ascArr.length - 1 - i] });
        sum += ascArr[i] * ascArr[ascArr.length - 1 - i];
    }

    return sum;
};

//  ! MULTIPLY LARGEST BY SMALLEST !

//  SORT ARRAY NUMERICALLY ASCENDING (OR DESCENDING)
//  LOOP OVER FIRST HALF OF ARRAY
//      MULTIPLY FIRST EL BY LAST, THEN SECOND BY LAST-1 ETC...AND ADD PRODUCT TO SUM

// 22
// console.log(minSum([5, 4, 2, 3]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function minSum2(arr: number[]) {
    let sum = 0;
    const nums = [...arr];
    while (nums.length !== 0) {
        const max = Math.max(...nums);
        const min = Math.min(...nums);
        sum += max * min;
        nums.splice(nums.indexOf(max), 1);
        nums.splice(nums.indexOf(min), 1);
    }
    return sum;
}

function minSum3(arr: number[]) {
    return [...arr]
        .sort((a, b) => a - b)
        .reduce((sum, x, _, sorted) => sum + x * sorted.pop()!, 0);
}

function minSum4(arr: number[]): number {
    return arr
        .sort((a: number, b: number) => a - b)
        .reduce(
            (acc: number, currVal: number, index: number, a: number[]) =>
                acc + (currVal * a[a.length - 1 - index]) / 2,
            0
        );
}

function minSum5(arr: number[]): number {
    return arr
        .sort((a: number, b: number) => a - b)
        .reduce(
            (acc: number, currVal: number, index: number, a: number[]) =>
                acc + (currVal * a[a.length - 1 - index]) / 2,
            0
        );
}

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è LOOK INTO REDUCE AND MAP ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: AVARAGES OF NUMBERS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è MAP(), REDUCE(), ISARRAY(), SLICE(0, -1) ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
#Get the averages of these numbers

Write a method, that gets an array of integer-numbers and return an array of the averages of each integer-number and his follower, if there is one.

Example:

Input:  [ 1, 3, 5, 1, -10]
Output:  [ 2, 4, 3, -4.5]
If the array has 0 or 1 values or is null, your method should return an empty array.

Have fun coding it and please don't forget to vote and rank this kata! :-)
*/

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è (numArr![i] ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// const averages = (numArr: number[] | null): number[] => {
//     for (let i = 0; i < numArr!.length - 1; i++) {
//         let pairAve: number = (numArr![i] + numArr![i + 1]) / 2;
//         console.log(pairAve);
//     }

//     return [1];
// };

const averages = (numArr: number[] | null): number[] => {
    if (!numArr || numArr.length < 2) return [];

    let solution: number[] = [];

    for (let i = 0; i < numArr.length - 1; i++) {
        let pairAve: number = (numArr[i] + numArr[i + 1]) / 2;
        solution.push(pairAve);
    }

    return solution;
};

// console.log(averages([1, 3, 5, 1, -10]));
// console.log(averages([1, 3]));
// console.log(averages([]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// REDUCE()
function averages2(numbers: number[]): number[] {
    let avrgs: number[] = [];
    if (!numbers || numbers.length <= 1) {
        return avrgs;
    }

    numbers.reduce((a, b) => {
        avrgs.push((a + b) / 2);
        return b;
    });

    return avrgs;
}

// ISARRAY(), MAP
// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è slice(0, -1) WILL GET RID OF LAST ELEMENT NAN [2,4,3,-4.5,NaN] ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è slice(0, numbers.length -1) === slice(0, -1) ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
function averages3(numbers: number[]): number[] {
    return Array.isArray(numbers)
        ? numbers
            .map((item, index) => (item + numbers[index + 1]) / 2)
            .slice(0, -1)
        : [];
}

function averages4(numbers: number[] | null): number[] {
    if (numbers === null) return [];
    return numbers.slice(1).map((x, i) => (numbers[i] + x) / 2);
}

// üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®
// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è  INCLUDE THIS IN EXAMPLES ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: ALPHABETICAL ADDITION
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è CHARCODEAT(), STRING.FROMCHARCODE(), REDUCE(INITIAL VALUE), SPREAD ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Your task is to add up letters to one letter.

The function will be given a variable amount of arguments, each one being a letter to add.

Notes:
Letters will always be lowercase.
Letters can overflow (see second to last example of the description)
If no letters are given, the function should return 'z'
Examples:
addLetters('a', 'b', 'c') = 'f'
addLetters('a', 'b') = 'c'
addLetters('z') = 'z'
addLetters('z', 'a') = 'a'
addLetters('y', 'c', 'b') = 'd' // notice the letters overflowing
addLetters() = 'z'
*/

/*
a	097	01100001	A	065	01000001
b	098	01100010	B	066	01000010
c	099	01100011	C	067	01000011
d	100	01100100	D	068	01000100
e	101	01100101	E	069	01000101
f	102	01100110	F	070	01000110
g	103	01100111	G	071	01000111
h	104	01101000	H	072	01001000
i	105	01101001	I	073	01001001
j	106	01101010	J	074	01001010
k	107	01101011	K	075	01001011
l	108	01101100	L	076	01001100
m	109	01101101	M	077	01001101
n	110	01101110	N	078	01001110
o	111	01101111	O	079	01001111
p	112	01110000	P	080	01010000
q	113	01110001	Q	081	01010001
r	114	01110010	R	082	01010010
s	115	01110011	S	083	01010011
t	116	01110100	T	084	01010100
u	117	01110101	U	085	01010101
v	118	01110110	V	086	01010110
w	119	01110111	W	087	01010111
x	120	01111000	X	088	01011000
y	121	01111001	Y	089	01011001
z	122	01111010	Z	090	01011010

*/

const addLetters = (...letters: string[]): string => {
    if (letters.length === 0) return "z";

    const charCodeSum = letters
        .map((char) => char.charCodeAt(0) - 96)
        .reduce((acc, curr) => acc + curr, 0); // 26 FOR "z"

    if (charCodeSum % 26 === 0) return "z";

    return charCodeSum > 26
        ? String.fromCharCode((charCodeSum % 26) + 96)
        : String.fromCharCode(charCodeSum + 96);
};

//  SOLUTION WITH COMMENTS:

const addLetters2 = (...letters: string[]): string => {
    // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è SPREAD ARGUMENTS ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
    console.log(...letters); // a b c
    console.log(letters); // [ 'a', 'b', 'c' ]

    // RETURN Z FOR EMPTY ARRAY
    if (letters.length === 0) return "z";

    // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è CHARCODEAT()
    const charCodeSum = letters
        .map((char) => char.charCodeAt(0) - 96) // [1(97-96), 2(98-96)...3]
        .reduce((acc, curr) => acc + curr, 0); // [6(1+2+3)]
    console.log(charCodeSum);
    console.log(charCodeSum % 26);

    // IF SUM IS MULTIPLIES OF 26 RETURN Z AS SUM % 26 WILL RESULT IN CHARCODE(0)
    if (charCodeSum % 26 === 0) return "z";

    // STRING.FROMCHARCODE()
    return charCodeSum > 26
        ? String.fromCharCode((charCodeSum % 26) + 96) // OVERLAP (MORE THAN 26)
        : String.fromCharCode(charCodeSum + 96);
};

// z
// console.log(addLetters(addLetters("f", "g", "a", "r", "t")));
// d
// console.log(addLetters(['y', 'c', 'b']));

// z FOR EMPTY ARRAY OR NO ARGUMENTS
// console.log(addLetters());

// f
// console.log(console.log(addLetters("s", "k", "g", "u", "z")));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function addLetters3(...letters: string[]): string {
    const aCode: number = "a".charCodeAt(0);
    const zCode: number = "z".charCodeAt(0);
    const mod: number = zCode - aCode + 1;

    const normalizeCharCode = (letter: string): number =>
        letter.charCodeAt(0) - aCode + 1;
    const normalizeCharCodes: number[] = letters.map(normalizeCharCode);

    const add = (a: number, b: number): number => a + b;
    const value: number = normalizeCharCodes.reduce(add, 0);

    const finalCharCode: number = ((value - 1 + mod) % mod) + aCode;
    return String.fromCharCode(finalCharCode);
}

const addLetters4 = (...letters: string[]) =>
    String.fromCharCode(
        (letters.reduce((acc, val) => acc + val.charCodeAt(0) - 96, 0) % 26 ||
            26) + 96
    );

const alphabet = "abcdefghijklmnopqrstuvwxyz";

const addLetters5 = (...letters: string[]): string =>
    letters.length === 0
        ? "z"
        : alphabet[
        (letters.reduce((acc, c) => acc + (alphabet.indexOf(c) + 1), 0) -
            1) %
        alphabet.length
        ];

function addLetters6(...letters: string[]) {
    // your code here
    if (letters.length === 0) return "z"; // account for empty input array
    const letterArray = "abcdefghijklmnopqrstuvwxyz".split(""); // create array for index reference
    let sum = 0;
    for (const letter of letters) {
        sum += letterArray.indexOf(letter) + 1; // add +1 to compensate for index 0 start logic
    }
    let remainder = sum % 26;
    if (remainder === 0) return "z";
    else return letterArray[remainder - 1];
}

function addLetters7(...letters: string[]) {
    const sum =
        letters.map((c) => c.charCodeAt(0) - 96).reduce((a, b) => a + b, 0) %
        26;

    return sum === 0 ? "z" : String.fromCharCode(96 + sum);
}

function addLetters8(...letters: string[]) {
    const s = "zabcdefghijklmnopqrstuvwxy";
    let sum = 0;
    for (let l of letters) {
        sum += s.indexOf(l);
    }
    return s[sum % 26];
}

function addLetters9(...letters: string[]) {
    if (!letters || letters.length < 1) return "z";
    if (letters.length === 1) return letters[0];

    const num: number =
        letters
            .map((ch) => ch.charCodeAt(0) - 96)
            .reduce((sum, curr) => sum + curr, 0) % 26;

    if (num === 0) return "z";
    else return String.fromCharCode(num + 96);
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE: POWER OF TWO
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è  MATH.LOG() ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Complete the function power_of_two/powerOfTwo (or equivalent, depending on your language) that determines if a given non-negative integer is a power of two. From the corresponding Wikipedia entry:

a power of two is a number of the form 2n where n is an integer, i.e. the result of exponentiation with number two as the base and integer n as the exponent.

You may assume the input is always valid.

Examples
power_of_two?(1024) # true
power_of_two?(4096) # true
power_of_two?(333)  # false
Beware of certain edge cases - for example, 1 is a power of 2 since 2^0 = 1 and 0 is not a power of 2.
*/

const isPowerOfTwo = (num: number): boolean => {
    if (num === 1) return true;
    if ((num & 1) === 1) return false;
    // KEEP DIVIDING NUM BY 2
    while (num > 1) {
        num = num / 2;
    }

    // console.log(num);

    // IF NUM / 2 EQUALS 1 RETURN true, OTHERWISE false
    return num === 1;

    // OR:

    // return num === 1
    //     ? true
    //     : false;
};

// console.log(isPowerOfTwo(23));
// console.log(isPowerOfTwo(18));
// console.log(isPowerOfTwo(4096));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function isPowerOfTwo2(n: number): boolean {
    return Number.isInteger(Math.log2(n));
}

const isPowerOfTwo3 = (n: number): boolean => Math.log2(n) % 1 === 0;

function isPowerOfTwo4(n: number): boolean {
    return n === 2 || n === 1 ? true : n < 2 ? false : isPowerOfTwo(n / 2);
}

function isPowerOfTwo5(n: number): boolean {
    for (let i = 0; true; i++) {
        const pow = Math.pow(2, i);
        if (pow === n) {
            return true;
        } else if (pow > n) {
            return false;
        }
    }
}

function isPowerOfTwo6(n: number): boolean {
    while (n > 2 && n % 2 == 0) n = n / 2;

    return n == 2 || n == 1;
}

// TITLE:  OVER THE ROAD
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Task
You've just moved into a perfectly straight street with exactly n identical houses on either side of the road. Naturally, you would like to find out the house number of the people on the other side of the street. The street looks something like this:

Street
1|   |6
3|   |4
5|   |2
Evens increase on the right; odds decrease on the left. House numbers start at 1 and increase without gaps. When n = 3, 1 is opposite 6, 3 opposite 4, and 5 opposite 2.

Example (address, n --> output)
Given your house number address and length of street n, give the house number on the opposite side of the street.

1, 3 --> 6
3, 3 --> 4
2, 3 --> 5
3, 5 --> 8
Note about errors
If you are timing out, running out of memory, or get any kind of "error", read on. Both n and address could get upto 500 billion with over 200 random tests. If you try to store the addresses of 500 billion houses in a list then you will run out of memory and the tests will crash. This is not a kata problem so please don't post an issue. Similarly if the tests don't complete within 12 seconds then you also fail.

To solve this, you need to think of a way to do the kata without making massive lists or huge for loops. Read the discourse for some inspiration :)
*/

const overTheRoad = (address: number, n: number): number => {
    return n * 2 + 1 - address;
};

//  OPPOSITE NUMBERS ADD UP TO TWICE THE LENGTH OF STREET PLUS 1
//  SUBSTRACT YOUR address FROM THAT SUM TO GET RESULT

// console.log(overTheRoad(1, 3));
// console.log(overTheRoad(3, 3));
// console.log(overTheRoad(7, 11));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function overTheRoad2(address: number, n: number): number {
    // Good luck!
    if (address % 2 === 0) {
        return 1 + 2 * (n - address / 2);
    } else {
        return 2 * n - (address - 1);
    }
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  EVEN NUMBERS IN AN ARRAY
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: BITWISE AND, FILTER()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Given an array of digitals numbers, return a new array of length number containing the last even numbers from the original array (in the same order). The original array will be not empty and will contain at least "number" even numbers.

For example:

([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) => [4, 6, 8]
([-22, 5, 3, 11, 26, -6, -7, -8, -9, -8, 26], 2) => [-8, 26]
([6, -25, 3, 7, 5, 5, 7, -3, 23], 1) => [6]
*/

const evenNumbers = (array: number[], n: number): number[] => {
    return array.filter((el) => (el & 1) === 0).slice(-n);
};

//  FILTER OUT ODD NUMBERS
//  RETURN SUB ARRAY OF LAST n ELEMENTS (SLICE WITH NEGATIVE IDX)

// console.log(evenNumbers([1, 2, 3, 4, 5, 6, 7, 8, 9], 3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function isEven2(n: number): boolean {
    return n % 2 === 0;
}

function evenNumbers2(array: number[], n: number): number[] {
    return array.filter(isEven2).slice(-n);
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  SPEED CONTROL
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  BITWISE OR TO ROUND DOWN, MATH.MAX() WITH SPREAD
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
In John's car the GPS records every s seconds the distance travelled from an origin (distances are measured in an arbitrary but consistent unit). For example, below is part of a record with s = 15:

x = [0.0, 0.19, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25]
The sections are:

0.0-0.19, 0.19-0.5, 0.5-0.75, 0.75-1.0, 1.0-1.25, 1.25-1.50, 1.5-1.75, 1.75-2.0, 2.0-2.25
We can calculate John's average hourly speed on every section and we get:

[45.6, 74.4, 60.0, 60.0, 60.0, 60.0, 60.0, 60.0, 60.0]
Given s and x the task is to return as an integer the *floor* of the maximum average speed per hour obtained on the sections of x. If x length is less than or equal to 1 return 0 since the car didn't move.

Example:
with the above data your function gps(s, x)should return 74

Note
With floats it can happen that results depends on the operations order. To calculate hourly speed you can use:

(3600 * delta_distance) / s.
*/

class G965a1 {
    public static gps = (secInt: number, distArr: number[]): number => {
        // secInterval: SECONDS
        // distArr: KMS
        let speedsArr = [];

        for (let i = 1; i < distArr.length; i++) {
            let curr = distArr[i],
                prev = distArr[i - 1];
            let sectionDist = curr - prev;
            let sectAveSpeed = (3600 / secInt) * sectionDist;
            // console.table(
            //     { time: secInt, dist: sectionDist, speed: sectAveSpeed }
            // );
            speedsArr.push(sectAveSpeed);
        }

        console.log(speedsArr);

        return Math.max(...speedsArr) | 0;
    };
}

//  CALCULATE AVERAGE SPEED FOR EACH SECTION WITH LOOP
//  PUSH IT INTO speedsArray AS sectAveSpeed
//  FIND LARGEST NUMBER(SPEED) IN speedsArray AND ROUND IT DOWN TO NEAREST INT
//  BITWISE OR "|" WILL ROUND DOWN DECIMALS: 3.345 | 0  =>  3

// s = 15;
// u = 74;
// console.log(G965a1.gps(15, [0.0, 0.19, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25]));

// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G965a2 {
    public static gps = (seconds: number, sections: number[]): number => {
        if (sections.length <= 1) return 0;

        const sectionSpeeds = sections
            .map((start, index) => start - (sections[index - 1] || 0))
            .map((distance) => (3600 * distance) / seconds);

        return Math.floor(Math.max(...sectionSpeeds));
    };
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  NO ODDITIES HERE
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: BITWISE AND "&" (EVEN OR ODD)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Write a small function that returns the values of an array that are not odd.

All values in the array will be integers. Return the good values in the order they are given.
*/

const noOdds = (values: number[]): number[] => {
    return values.filter((el) => {
        return (el & 1) === 0;
    });
};

//  BITWISE AND "&" OPERATOR
//  n & 1
//  RETURNS 1 IF n IS ODD
//  RETURNS 0 IF n IS EVEN

// console.log(noOdds( [0,1] ));
// console.log(noOdds([0, 1, 2, 3]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function noOdds2(values: number[]): number[] {
    return values.filter((i) => !(i % 2));
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  PARTS OF A LIST
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS: SLICE(), GET 2 SUB ARRAYS OF ARR AS STRING
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Write a function partlist that gives all the ways to divide a list (an array) of at least two elements into two non-empty parts.

Each two non empty parts will be in a pair (or an array for languages without tuples or a structin C - C: see Examples test Cases - )
Each part will be in a string
Elements of a pair must be in the same order as in the original array.
Examples of returns in different languages:
a = ["az", "toto", "picaro", "zone", "kiwi"] -->
[["az", "toto picaro zone kiwi"], ["az toto", "picaro zone kiwi"], ["az toto picaro", "zone kiwi"], ["az toto picaro zone", "kiwi"]] 
or
 a = {"az", "toto", "picaro", "zone", "kiwi"} -->
{{"az", "toto picaro zone kiwi"}, {"az toto", "picaro zone kiwi"}, {"az toto picaro", "zone kiwi"}, {"az toto picaro zone", "kiwi"}}
or
a = ["az", "toto", "picaro", "zone", "kiwi"] -->
[("az", "toto picaro zone kiwi"), ("az toto", "picaro zone kiwi"), ("az toto picaro", "zone kiwi"), ("az toto picaro zone", "kiwi")]
or 
a = [|"az", "toto", "picaro", "zone", "kiwi"|] -->
[("az", "toto picaro zone kiwi"), ("az toto", "picaro zone kiwi"), ("az toto picaro", "zone kiwi"), ("az toto picaro zone", "kiwi")]
or
a = ["az", "toto", "picaro", "zone", "kiwi"] -->
"(az, toto picaro zone kiwi)(az toto, picaro zone kiwi)(az toto picaro, zone kiwi)(az toto picaro zone, kiwi)"

*/

class G964a {
    public static partlist = (arr: string[]): string[][] => {
        let solution: string[][] = [];

        for (let i = 0; i < arr.length - 1; i++) {
            // console.log(arr.slice(0, i + 1).join(" "));
            // console.log(arr.slice(i + 1).join(" "));

            let subArr: string[] = [];
            subArr.push(
                arr.slice(0, i + 1).join(" "),
                arr.slice(i + 1).join(" ")
            );

            // subArr.push(arr.slice(0, i + 1).join(" "));
            // subArr.push(arr.slice(i + 1).join(" "));

            solution.push(subArr);
        }

        return solution;
    };
}

//  INITIALIZE SOLUTION ARR
//  LOOP OVER arr
//      CREATE subArr FOR EACH ITARATION
//      PUSH FIRST SUB ARRAY OF arr INTO subArr ENDING WITH arr[i]
//      PUSH SECOND SUB ARRAY OF arr INTO subArr STARTING WITH arr[i + 1]
//      PUSH subArr INTO solution
//  RETURN solution

// console.log(G964a.partlist(["a", "b", "c", "d", "e"]));
// console.log(G964a.partlist(["I", "wish", "I", "hadn't", "come"]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G964a2 {
    public static partlist(arr: string[]): string[][] {
        return arr
            .map((s, i, a) => [
                a.slice(0, i + 1).join(" "),
                a.slice(i + 1, a.length).join(" "),
            ])
            .slice(0, arr.length - 1);
    }
}

class G964a3 {
    public static partlist(arr: string[]): string[][] {
        return arr
            .slice(1)
            .map((x, i) => [
                arr.slice(0, i + 1).join(" "),
                arr.slice(i + 1).join(" "),
            ]);
    }
}

class G964a4 {
    public static partlist(arr: string[]): string[][] {
        const x = arr.map((word, idx) => {
            return [
                arr.slice(0, idx + 1).join(" "),
                arr.slice(idx + 1, arr.length).join(" "),
            ];
        });
        return x.slice(0, -1);
    }
}

// INCLUDE THIS IN EXAMPLES FOR MATCH() WITH POSSIBLE EMPTY ARR
// üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®üü®
// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è REFACTOR THIS, MAKE IT WORK WITH STR.MATCH() ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  BUMPS IN THE ROAD
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Your car is old, it breaks easily. The shock absorbers are gone and you think it can handle about 15 more bumps before it dies totally.

Unfortunately for you, your drive is very bumpy! Given a string showing either flat road ("_") or bumps ("n"), work out if you make it home safely. 15 bumps or under, return "Woohoo!", over 15 bumps return "Car Dead".
*/

const bump = (road: string): string => {
    // const bumps: number[] = road.match(/n/g);
    // console.log(bumps);

    // return bumps.length > 15
    //     ? "Car Dead"
    //     : "Woohoo!";

    let counter: number = 0;

    for (let i = 0; i < road.length; i++) {
        if (road[i] === "n") {
            counter++;
            if (counter > 15) return "Car Dead";
        }
    }

    return "Woohoo!";
};

// console.log(bump("n"));
// console.log(bump("_nnnnnnn_n__n______nn__nn_nnn"));
// console.log(bump("_"));

// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function bump2(x: string): string {
    return x.split("").filter((a) => a === "n").length <= 15
        ? "Woohoo!"
        : "Car Dead";
}

function bump3(x: string): string {
    return x.replace(/_/g, "").length > 15 ? `Car Dead` : `Woohoo!`;
}

function bump4(x: string): string {
    return x
        .split("")
        .reduce((total, n) => (n === "n" ? total + 1 : total), 0) > 15
        ? "Car Dead"
        : "Woohoo!";
}

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è MATCH() ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
function bump5(x: string): string {
    const arr: string[] = x.match(/[n+]/g) || [];
    return arr.length <= 15 ? "Woohoo!" : "Car Dead";
}

function bump6(x: string): string {
    return (x.match(/n/g) || []).length > 15 ? "Car Dead" : "Woohoo!";
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  MAXIMUM PRODUCT
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è SPREAD ARRAY FOR MATH.MAX() ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Task
Given an array of integers , Find the maximum product obtained from multiplying 2 adjacent numbers in the array.

Notes
Array/list size is at least 2.

Array/list numbers could be a mixture of positives, negatives also zeroes .

Input >> Output Examples
adjacentElementsProduct([1, 2, 3]); ==> return 6
Explanation:
The maximum product obtained from multiplying 2 * 3 = 6, and they're adjacent numbers in the array.
adjacentElementsProduct([9, 5, 10, 2, 24, -1, -48]); ==> return 50
Explanation:
Max product obtained from multiplying 5 * 10 = 50 .

adjacentElementsProduct([-23, 4, -5, 99, -27, 329, -2, 7, -921])  ==>  return -14
Explanation:
The maximum product obtained from multiplying -2 * 7 = -14, and they're adjacent numbers in the array.
*/

const adjacentElementsProduct = (arr: number[]): number => {
    let productsArr: number[] = [];

    for (let i = 0; i < arr.length - 1; i++) {
        let adjacentProd: number = arr[i] * arr[i + 1];
        productsArr.push(adjacentProd);
    }

    // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è SPREAD ARRAY FOR MATH.MAX() TO AVOID ERROR: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
    // Argument of type 'number[]' is not assignable to parameter of type 'number'.ts(2345)
    return Math.max(...productsArr);
};

// console.log(adjacentElementsProduct([1, 5, 10, 9]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const adjacentElementsProduct2 = (arr: number[]): number =>
    Math.max(
        ...arr.map((value, index) =>
            index === arr.length - 1
                ? value * arr[index - 1]
                : value * arr[index + 1]
        )
    );

function adjacentElementsProduct3(arr: number[]): number {
    return Math.max(...arr.slice(1).map((x, i) => x * arr[i]));
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  JS ARRAY FILTER
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
The solution would work like the following:

getEvenNumbers([2,4,5,6]) // should == [2,4,6]
*/

const getEvenNumbers = (numbersArray: number[]): number[] => {
    return numbersArray.filter((num) => {
        return (num & 1) === 0;
    });
};

// console.log(getEvenNumbers([1, 2, 3, 6, 8, 10]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const getEvenNumbers2 = (numbersArray: number[]): number[] => {
    return numbersArray.filter((x) => x % 2 === 0);
};

const isEven = (num: number): boolean => num % 2 == 0;
const getEvenNumbers3 = (nums: number[]): number[] => nums.filter(isEven);

const getEvenNumbers4 = (numbersArray: number[]): number[] => {
    return numbersArray.filter((cond) => 0 === cond % 2);
};
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  SUM OF TRIANGULAR NUMBERS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Your task is to return the sum of Triangular Numbers up-to-and-including the nth Triangular Number.

Triangular Number: "any of the series of numbers (1, 3, 6, 10, 15, etc.) obtained by continued summation of the natural numbers 1, 2, 3, 4, 5, etc."

[01]
02 [03]
04 05 [06]
07 08 09 [10]
11 12 13 14 [15]
16 17 18 19 20 [21]
e.g. If 4 is given: 1 + 3 + 6 + 10 = 20.

Triangular Numbers cannot be negative so return 0 if a negative number is given.
*/

const sumTriangularNumbers = (n: number): number => {
    let sum: number = 0,
        triNum: number = 0;

    for (let i = 1; i <= n; i++) {
        triNum = triNum + i;
        sum += triNum;
    }

    return sum;
};

//  START LOOP AT 1, IN EVERY ITERATION:
//     INCREMENT triNum BY triNum + 1 (1, 3, 6, 10...)
//     INCREMENT sum BY trinum (1, 4, 10, 20...)
//  RETURN sum

//   56
// console.log(sumTriangularNumbers(1));
// console.log(sumTriangularNumbers(2));
// console.log(sumTriangularNumbers(3));
// console.log(sumTriangularNumbers(4));
// 7140
// console.log(sumTriangularNumbers(34));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function sumTriangularNumbers2(n: number): number {
    return n <= 0 ? 0 : (n * (n + 1) * (n + 2)) / 6;
}

//   Function lacks ending return statement and return type does not include 'undefined'.ts(2366)

//   function sumTriangularNumbers3(n:number):number {

//     if (n < 1) return 0;

//     if (n == 1)
//       return 1;
//     while (n > 0) {
//       return (n * (n +1) / 2) + sumTriangularNumbers(n-1);
//     }
//   }

function sumTriangularNumbers4(n: number): number {
    return Array.from({ length: n })
        .map((value, index) => ((1 + index + 1) * (index + 1)) / 2)
        .reduce((pre, current) => pre + current, 0);
}

function sumTriangularNumbers5(n: number): number {
    let result = 0;
    for (let i = 0; i <= n; i++) {
        result += (i * (i + 1)) / 2;
    }
    return result;
}

function sumTriangularNumbers6(n: number): number {
    let sum = 0;
    for (let i = 1, j = 1; i <= n; i++, j += i) {
        sum += j;
    }
    return sum;
}

// üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•üü•
// TITLE:  MOVES IN SQUARED STRINGS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
You are given a string of n lines, each substring being n characters long: For example:

s = "abcd\nefgh\nijkl\nmnop"

We will study some transformations of this square of strings.

Vertical mirror: vert_mirror (or vertMirror or vert-mirror)
vert_mirror(s) => "dcba\nhgfe\nlkji\nponm"
Horizontal mirror: hor_mirror (or horMirror or hor-mirror)
 hor_mirror(s) => "mnop\nijkl\nefgh\nabcd"
or printed:

vertical mirror   |horizontal mirror   
abcd --> dcba     |abcd --> mnop 
efgh     hgfe     |efgh     ijkl 
ijkl     lkji     |ijkl     efgh 
mnop     ponm     |mnop     abcd 
Task:
Write these two functions
and

high-order function oper(fct, s) where

fct is the function of one variable f to apply to the string s (fct will be one of vertMirror, horMirror)

Examples:
s = "abcd\nefgh\nijkl\nmnop"
oper(vert_mirror, s) => "dcba\nhgfe\nlkji\nponm"
oper(hor_mirror, s) => "mnop\nijkl\nefgh\nabcd"
Note:
The form of the parameter fct in oper changes according to the language. You can see each form according to the language in "Sample Tests".

Bash Note:
The input strings are separated by , instead of \n. The output strings should be separated by \r instead of \n. See "Sample Tests".
*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  PREDICT YOUR AGE
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è ARGUMENTS / SPREAD ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è, MATH.TRUNC()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
My grandfather always predicted how old people would get, and right before he passed away he revealed his secret!

In honor of my grandfather's memory we will write a function using his formula!

Take a list of ages when each of your great-grandparent died.
Multiply each number by itself.
Add them all together.
Take the square root of the result.
Divide by two.
Example
predictAge(65, 60, 75, 55, 60, 63, 64, 45) === 86
Note: the result should be rounded down to the nearest integer.

Some random tests might fail due to a bug in the JavaScript implementation. Simply resubmit if that happens to you.
*/

// const predictAge = (
//     age1:number,
//     age2:number,
//     age3:number,
//     age4:number,
//     age5:number,
//     age6:number,
//     age7:number,
//     age8:number
// ): number => {

//   return 0;
// };

const predictAge = (...args: number[]): number => {
    // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
    // console.log(args);

    return Math.floor(
        Math.sqrt(
            args
                .map((num) => Math.pow(num, 2))
                .reduce((acc, curr) => acc + curr)
        ) / 2
    );
};

//  GET arguments ARRAY
//  SQUARE ALL ELEMENTS WITH map
//  GET SUM WITH reduce
//  DIVIDE BY 2

//  GET SQUARE ROOT OF SUM
//  ROUND DOWN TO NEAREST INTEGER

// 86
// console.log(predictAge(65,60,75,55,60,63,64,45));
// 79
// console.log(predictAge(32,54,76,65,34,63,64,45));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// Rest parameter 'a' implicitly has an 'any[]' type.ts(7019)

// const predictAge2=(...a)=>Math.sqrt(a.reduce((b,c)=>b+c*c,0))>>1

function predictAge3(...ages: number[]): number {
    return Math.trunc(
        Math.sqrt(ages.map((x) => x * x).reduce((a, b) => a + b, 0)) / 2
    );
}

//   Cannot find name 'arguments'.ts(2304)
// Block-scoped variable 'number' used before its declaration.ts(2448)

//   predictAge4(age1:number, age2:number, age3:number,age4:number,age5:number,age6:number,age7:number,age8:number): number{
//     let args = Array.prototype.slice.call(arguments)
//     const sum = args.map(arg => {
//     return arg * arg
//     }).reduce((a,b) => a + b, 0)
//     const square = Math.sqrt(sum)
//     const total = Math.floor(square / 2)
//     return total;
//   };

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  FIND MOST DIGITS IN NUMBER
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  SORT(), REDUCE()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Find the number with the most digits.

If two numbers in the argument array have the same number of digits, return the first one in the array.
*/

class Kata {
    static findLongest(arr: number[]): number {
        // 1Ô∏è‚É£
        return arr.sort((a, b) => String(b).length - String(a).length)[0];

        // 2Ô∏è‚É£  ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è    REFACTOR THIS WITH ARRAY.FIND() ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
        let solution: number = -1;
        const sortedArr = [...arr].sort((a, b) => b - a);
        // console.log(arr);
        console.log(sortedArr);
        const maxLength: number = String(sortedArr[0]).length;
        console.log(maxLength);
        // const findLength = (num: number): number => {
        //     console.table({ maxLength: maxLength, number: num });
        //     // return String(num).length === maxLength;
        //     console.log(String(num).length === maxLength);
        //     // if (String(num).length === length) return num;
        //     return String(num).length === maxLength
        //         ? num
        //         : -1;
        // }
        console.log(arr);
        // return arr.find(function (num: number): number {
        //     return String(num).length === maxLength
        //         ? num
        //         : -1;
        // })!;

        for (let i = 0; i < arr.length; i++) {
            if (String(arr[i]).length === maxLength) {
                solution = arr[i];
                break;
            }
        }
        return solution;
    }
}

//  SORT arr BY THE LENGTH OF ELEMENTS(CONVERTED TO STRING)
//  RETURN FIRST ELEMENT OF SORTED-BY-LENGTH ARRAY

// console.log(Kata.findLongest([1, 10, 100, 400, 56, 800]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// REDUCE()
class Kata5 {
    static findLongest(array: number[]): number {
        return array.reduce((a, b) =>
            a.toString().length < b.toString().length ? b : a
        );
    }
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  SORTED? YES, NO, HOW? ASCENDING/DESCENDING
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  SORT(),
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Complete the method which accepts an array of integers, and returns one of the following:

"yes, ascending" - if the numbers in the array are sorted in an ascending order
"yes, descending" - if the numbers in the array are sorted in a descending order
"no" - otherwise
You can assume the array will always be valid, and there will always be one correct answer.
*/

const isSortedAndHow = (arr: number[]): string => {
    let isAscending: boolean = false;
    let isDescending: boolean = false;
    let solution: string = "no";

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] >= arr[i - 1]) {
            isAscending = true;
        } else {
            break;
        }
        if (i === arr.length - 1 && isAscending) {
            solution = "yes, ascending";
        }
    }

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] <= arr[i - 1]) {
            isDescending = true;
        } else {
            break;
        }
        if (i === arr.length - 1 && isDescending) {
            solution = "yes, descending";
        }
    }

    return solution;
};

// console.log(isSortedAndHow([1, 2]));
// console.log(isSortedAndHow([15, 7, 3, -8]));
// console.log(isSortedAndHow([4, 2, 30]));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function isSortedAndHow2(array: number[]): string {
    let ascending = true,
        descending = true;
    for (var i = 1; i < array.length; i++) {
        if (array[i - 1] < array[i]) descending = false;
        if (array[i - 1] > array[i]) ascending = false;
        if (!ascending && !descending) return "no";
    }
    if (ascending) return "yes, ascending";
    return "yes, descending";
}

function isSortedAndHow3(array: number[]): string {
    if (array.every((x, i, a) => i === 0 || a[i - 1] <= x))
        return "yes, ascending";
    if (array.every((x, i, a) => i === 0 || a[i - 1] >= x))
        return "yes, descending";
    return "no";
}

function isSortedAndHow4(array: number[]): string {
    return [...array].sort((a, b) => a - b).join("") === array.join("")
        ? "yes, ascending"
        : [...array]
            .sort((a, b) => a - b)
            .reverse()
            .join("") === array.join("")
            ? "yes, descending"
            : "no";
}

function isSortedAndHow5(array: number[]): string {
    let isAsc: boolean = true;
    let isDesc: boolean = true;
    let i: number = 0;

    while (i + 1 < array.length) {
        if (array[i] > array[i + 1]) isAsc = false;
        if (array[i] < array[i + 1]) isDesc = false;

        i++;
    }

    if (isAsc) return "yes, ascending";
    else if (isDesc) return "yes, descending";
    else return "no";
}

function isSortedAndHow6(array: number[]): string {
    const asc: number[] = [...array].sort((a, b) => a - b);
    const dsc: number[] = [...array].sort((a, b) => b - a);
    switch (array.toString()) {
        case asc.toString():
            return "yes, ascending";
        case dsc.toString():
            return "yes, descending";
        default:
            return "no";
    }
}

function isSortedAndHow7(array: number[]): string {
    if ([...array].sort((a, b) => a - b).join("") === array.join("")) {
        return "yes, ascending";
    } else if ([...array].sort((a, b) => b - a).join("") === array.join("")) {
        return "yes, descending";
    } else {
        return "no";
    }
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  SUM OF ANGLES
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Find the total sum of internal angles (in degrees) in an n-sided simple polygon. N will be greater than 2.

If a convex polygon has n sides, then its interior angle sum is given by the following equation: S = ( n ‚àí2) √ó 180¬∞.
*/

const angle = (n: number): number => {
    return (n - 2) * 180;
};

// console.log(angle(3));
// console.log(angle(4));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  FACTORIAL
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*

*/

const factorial = (num: number) => {
    let nthFact = 1;

    for (let i = 1; i <= num; i++) {
        nthFact *= i;
    }

    return nthFact;
};

// console.log(factorial(4));
// console.log(factorial(0));
// console.log(factorial(7));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function factorial2(n: number): number {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  EVAPORATION
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  DO WHILE()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
This program tests the life of an evaporator containing a gas.

We know the content of the evaporator (content in ml), the percentage of foam or gas lost every day (evap_per_day) and the threshold (threshold) in percentage beyond which the evaporator is no longer useful. All numbers are strictly positive.

The program reports the nth day (as an integer) on which the evaporator will be out of use.

Example:
evaporator(10, 10, 5) -> 29
Note:
Content is in fact not necessary in the body of the function "evaporator", you can use it or not use it, as you wish. Some people might prefer to reason with content, some other with percentages only. It's up to you but you must keep it as a parameter because the tests have it as an argument.
*/

const evaporator = (cont: number, dayEvap: number, thresH: number): number => {
    let contentLeft = cont;
    const minQuantity = cont * (thresH / 100);
    let daysLeft: number = 0;

    while (contentLeft >= minQuantity) {
        contentLeft -= contentLeft * (dayEvap / 100);
        daysLeft++;
    }

    return daysLeft;
};

//  INITIALIZE VARIABLES
//  KEEP DECREMENTING contentLeft WHILE IT IS GREATER OR EQUAL TO minQuantity
//  RETURN daysLeft

// 22
// console.log(evaporator(10, 10, 10));
// 29
// console.log(evaporator(10, 10, 5));

//============= OTHER CODEWARS SOLUTIONS: =============

function evaporator2(
    content: number,
    evap_per_day: number,
    threshold: number
): number {
    return Math.ceil(
        Math.log(threshold / 100) / Math.log(1 - evap_per_day / 100)
    );
}

function evaporator3(
    content: number,
    evapPerDay: number,
    threshold: number
): number {
    const reverseFactor = 1 / (1 - evapPerDay / 100);
    return Math.ceil(-Math.log(threshold / 100) / Math.log(reverseFactor));
}

function evaporator4(
    content: number,
    evapPerDay: number,
    threshold: number
): number {
    const full = content;
    let days = 0;

    do {
        content -= (content / 100) * evapPerDay;
        days++;
    } while (content > (full / 100) * threshold);

    return days;
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  FLATTEN AND SORT AN NESTED ARRAY
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  TWO DIMENSIONAL ARRAY
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

//  ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è HAD TO CHANGE TARGET PROPERTY IN COMPILER OPTIONS TO "es2019" OR LATER  FOR flat() ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
/*
Given a two-dimensional array of integers, return the flattened version of the array with all the integers in the sorted (ascending) order.

Example:

Given [[3, 2, 1], [4, 6, 5], [], [9, 7, 8]], your function should return [1, 2, 3, 4, 5, 6, 7, 8, 9].
*/

const flattenAndSort = (inputArray: number[][]): number[] => {
    // 1Ô∏è‚É£  ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è THIS IS NOT WORKING IN CODEWARS ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
    // return inputArray
    //     .flat()
    //     .sort((a, b) => a - b);

    // 2Ô∏è‚É£
    return inputArray
        .reduce((acc, curr) => acc.concat(curr), [])
        .sort((a, b) => a - b);
};

// console.log(flattenAndSort([]));
// console.log(flattenAndSort([[], []]));
// console.log(flattenAndSort([[], [1]]));
// console.log(flattenAndSort([[3, 2, 1], [7, 9, 8], [6, 4, 5]]));
// console.log(flattenAndSort([[1, 3, 5], [100], [2, 4, 6]]));

//============= OTHER CODEWARS SOLUTIONS: =============

function flattenAndSort2(inputArray: number[][]): number[] {
    return inputArray.flat().sort((a, b) => a - b);
}

// const flattenAndSort3 = (a: number[][]): number[] => [].concat(...a).sort((a, b) => a - b);

function flattenAndSort4($: number[][]): number[] {
    return $.toString()
        .split(",")
        .filter((e) => e)
        .map(Number)
        .sort((a, b) => a - b);
}

function flattenAndSort5(inputArray: number[][]): number[] {
    let numbers: number[] = [];
    for (const tuple of inputArray) {
        numbers = [...tuple, ...numbers];
    }

    return numbers.sort((a, b) => a - b);
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  CHECK COUPON - STRING DATE
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  ENUM, DATE.PARSE(), NEW DATE()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Story
Your online store likes to give out coupons for special occasions. Some customers try to cheat the system by entering invalid codes or using expired coupons.

Task
Your mission:
Write a function called checkCoupon which verifies that a coupon code is valid and not expired.

A coupon is no more valid on the day AFTER the expiration date. All dates will be passed as strings in this format: "MONTH DATE, YEAR".

Examples:
checkCoupon("123", "123", "July 9, 2015", "July 9, 2015")  ===  true
checkCoupon("123", "123", "July 9, 2015", "July 2, 2015")  ===  false
*/

const checkCoupon = (
    usrCode: string,
    validCode: string,
    currDate: string,
    expDate: string
): boolean => {
    const isValidCode: boolean = usrCode === validCode;
    let isValidDate: boolean = true;

    enum months {
        January = 1,
        February,
        March,
        April,
        May,
        June,
        July,
        August,
        September,
        October,
        November,
        December,
    }

    const extractDate = (date: string): string[] => {
        return date.replace(/,/g, "").split(" ");
    };

    const currYear: number = Number(extractDate(currDate)[2]);
    const expYear: number = Number(extractDate(expDate)[2]);

    // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è HAVE TO USE ANY, string WILL THROW AN ERROR WHEN ACCESSING VALUE BY KEY (months[currMonth]) ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
    const currMonth: any = extractDate(currDate)[0];
    const currMonthIdx: any = months[currMonth];
    const expMonth: any = extractDate(expDate)[0];
    const expMonthIdx: any = months[expMonth];

    const currDay: number = Number(extractDate(currDate)[1]);
    const expDay: number = Number(extractDate(expDate)[1]);

    console.table({
        currYear: currYear,
        expYear: expYear,
        currMonth: currMonth,
        currMonthIdx: currMonthIdx,
        expMonth: expMonth,
        expMonthIdx: expMonthIdx,
        currDay: currDay,
        expDay: expDay,
    });

    //  YEAR PLUS
    if (expYear > currYear) {
        isValidDate = true;
        //  YEAR SAME
    } else if (expYear === currYear) {
        if (expMonthIdx > currMonthIdx) {
            isValidDate = true;
        } else if (expMonthIdx === currMonthIdx) {
            if (expDay >= currDay) {
                isValidDate = true;
            } else {
                isValidDate = false;
            }
        } else {
            isValidDate = false;
        }
        //  YEAR INVALID
    } else {
        isValidDate = false;
    }

    return isValidCode && isValidDate;
};

/*

isvalidCode WILL CHECK IF CODES MATCH
INITIALIZE isValidDate
ASSIGN NUMERIC VALUES TO MONTHS FOR COMPARISON
extractDate WILL CONVERT STRING TO ARRAY ["September", "5", "2015"]
STORE YEAR, MONTH INDEX AND DAY IN VARIABLES (CONVERTED TO NUMBER)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   (index)    ‚îÇ  Values   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   currYear   ‚îÇ   2014    ‚îÇ
‚îÇ   expYear    ‚îÇ   2014    ‚îÇ
‚îÇ  currMonth   ‚îÇ 'January' ‚îÇ
‚îÇ currMonthIdx ‚îÇ     1     ‚îÇ
‚îÇ   expMonth   ‚îÇ 'January' ‚îÇ
‚îÇ expMonthIdx  ‚îÇ     1     ‚îÇ
‚îÇ   currDay    ‚îÇ     5     ‚îÇ
‚îÇ    expDay    ‚îÇ     1     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
if BLOCK DETERMINES IF DATE IS VALID
RETURN TRUE IF BOTH CODE AND DATE ARE VALID, OTHERWISE FALSE

*/

// console.log(checkCoupon('123', '123', 'September 5, 2014', 'October 1, 2014'));
// console.log(checkCoupon('123a', '123', 'September 5, 2014', 'October 1, 2014'));
// console.log(checkCoupon('12abcd3', '12abcd3', 'January 5, 2014', 'January 1, 2014'));

//============= OTHER CODEWARS SOLUTIONS: =============

function checkCoupon2(
    enteredCode: string,
    correctCode: string,
    currentDate: string,
    expirationDate: string
): boolean {
    return (
        enteredCode === correctCode &&
        Date.parse(currentDate) <= Date.parse(expirationDate)
    );
}

function checkCoupon3(
    enteredCode: string,
    correctCode: string,
    currentDate: string,
    expirationDate: string
): boolean {
    let cDate = new Date(currentDate);
    let expDate = new Date(expirationDate);
    return enteredCode === correctCode && cDate <= expDate ? true : false;
}

function checkCoupon4(
    enteredCode: string,
    correctCode: string,
    currentDate: string,
    expirationDate: string
): boolean {
    const isValidCode = enteredCode === correctCode;
    const isValidDate = new Date(currentDate) <= new Date(expirationDate);
    return isValidCode && isValidDate;
}
// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  ROW WEIGHTS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  REDUCE()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Scenario
Several people are standing in a row divided into two teams.
The first person goes into team 1, the second goes into team 2, the third goes into team 1, and so on.

Task
Given an array of positive integers (the weights of the people), return a new array/tuple of two integers, where the first one is the total weight of team 1, and the second one is the total weight of team 2.

Notes
Array size is at least 1.
All numbers will be positive.
Input >> Output Examples
rowWeights([13, 27, 49])  ==>  return (62, 27)
Explanation:
The first element 62 is the total weight of team 1, and the second element 27 is the total weight of team 2.

rowWeights([50, 60, 70, 80])  ==>  return (120, 140)
Explanation:
The first element 120 is the total weight of team 1, and the second element 140 is the total weight of team 2.

rowWeights([80])  ==>  return (80, 0)
Explanation:
The first element 80 is the total weight of team 1, and the second element 0 is the total weight of team 2.
*/

const rowWeights = (arr: number[]): number[] => {
    let arr1: number[] = [],
        arr2: number[] = [];

    arr.forEach((num, idx) => {
        idx & 1 ? arr1.push(num) : arr2.push(num);
    });

    return [arr2.reduce((a, b) => a + b), arr1.reduce((a, b) => a + b)];
};

//  INITIALIZE ARRAYS WITH 0 IN CASE arr HAS ONLY ONE ELEMENT
//  LOOP THROUGH INPUT arr
//      CHECK IF idx IS ODD (!!! idx & 1 RETURNS 1 IF idx IS ODD !!!)
//          IF SO, PUSH num TO arr1
//          OTHERWISE, PUSH num TO arr2
//  RETURN [SUM OF BOTH arr1 AND arr2]

// console.log(rowWeights([50, 60, 70, 80]));

//============= OTHER CODEWARS SOLUTIONS: =============

function rowWeights2(arr: number[]) {
    return arr.reduce((r, e, i) => ((r[i % 2] += e), r), [0, 0]);
}

function rowWeights3(arr: number[]): [number, number] {
    let even: number = arr.reduce((sum, x, i) => sum + (!(i % 2) ? x : 0), 0);
    let odd: number = arr.reduce((sum, x, i) => sum + (i % 2 ? x : 0), 0);
    return [even, odd];
}

function rowWeights4(arr: number[]) {
    return arr.reduce(
        (a: number[], c: number, i: number) =>
            i % 2 ? [a[0], a[1] + c] : [a[0] + c, a[1]],
        [0, 0]
    );
}

function rowWeights5(arr: number[]): number[] {
    return arr.reduce(
        (sumOfWeights, weight, i) => {
            sumOfWeights[i % 2] += weight;
            return sumOfWeights;
        },
        [0, 0]
    );
}

function rowWeights6(arr: number[]) {
    const res = [0, 0];

    arr.forEach((x, i) => {
        if (i % 2 === 0) {
            res[0] += x;
        } else {
            res[1] += x;
        }
    });

    return res;
}

function rowWeights7(arr: number[]) {
    let arr1 = 0;
    let arr2 = 0;
    arr.forEach((value, index) =>
        index % 2 ? (arr2 += value) : (arr1 += value)
    );
    return [arr1, arr2];
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  SORT ARRAY NUMERICALLY
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  SORT()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Finish the solution so that it sorts the passed in array of numbers. If the function passes in an empty array or null/nil value then it should return an empty array.

For example:

solution([1, 2, 10, 50, 5]); // should return [1, 2, 5, 10, 50]
solution([]); // should return []
*/

const sortNumbers = (numsArr: number[]): number[] => {
    return numsArr.sort((a, b) => a - b);
};

// console.log(sortNumbers([1, 2, 10, 50, 5]));

//============= OTHER CODEWARS SOLUTIONS: =============

function sortNumbers2(nums: number[]): number[] {
    return nums ? nums.sort((a, b) => a - b) : [];
}

function sortNumbers3(nums: number[]): number[] {
    return nums === null ? [] : nums.sort((left, right) => left - right);
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  	REMOVE DUPLICATES FROM STRING
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  REDUCE(), FILTER(), SET(), ARRAY.FROM()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Your task is to remove all duplicate words from a string, leaving only single (first) words entries.

Example:

Input:

'alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta'

Output:

'alpha beta gamma delta'
*/

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è .reduce((acc: string[], curr) SPECIFY TYPE FOR acc ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
const removeDuplicateWords = (str: string): string => {
    return str
        .split(" ")
        .reduce(
            (acc: string[], curr) =>
                acc.includes(curr) ? acc : [...acc, curr],
            []
        )
        .join(" ");
};

// console.log(removeDuplicateWords('alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta'))

//============= OTHER CODEWARS SOLUTIONS: =============

function removeDuplicateWords2(s: string): string {
    return Array.from(new Set(s.split(" "))).join(" ");
}

function removeDuplicateWords3(s: string): string {
    return s
        .split(" ")
        .filter((v, i, a) => a.indexOf(v) === i)
        .join(" ");
}

function removeDuplicateWords4(s: string): string {
    return [...new Set(s.match(/[a-z]+/gi) || [])].join(" ");
}

function removeDuplicateWords5(s: string): string {
    const wordArray = s.split(" ");
    const wordSet = new Set(wordArray);
    const result = Array.from(wordSet).join(" ");
    return result;
}

function removeDuplicateWords6(s: string): string {
    let result: string[] = [];
    s.split(" ").forEach((string, index) => {
        if (result.indexOf(string) === -1) {
            result.push(string);
        }
    });
    return result.join(" ");
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  ALTERNATE CAPITALIZATION
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Given a string, capitalize the letters that occupy even indexes and odd indexes separately, and return as shown below. Index 0 will be considered even.

For example, capitalize("abcdef") = ['AbCdEf', 'aBcDeF']. See test cases for more examples.

The input will be a lowercase string with no spaces.
*/

const capitalize = (str: string): string[] => {
    let odds: string = "",
        evens: string = "";

    for (let i = 0; i < str.length; i++) {
        evens += i % 2 === 0 ? str[i].toUpperCase() : str[i];
        odds += i % 2 > 0 ? str[i].toUpperCase() : str[i];
    }

    return [evens, odds];
};

//  INITIALIZE EMPTY STRINGS FOR BOTH WORDS
//  LOOP OVER str
//      BUILD evens
//      BUILD odds
// RETURN SOLUTION AS ARRAY OF STRINGS

// console.log(capitalize("abcdef"));

//============= OTHER CODEWARS SOLUTIONS: =============

const capitalize2 = (s: string) => [
    [...s].map((l, i) => (i % 2 ? l : l.toUpperCase())).join(""),
    [...s].map((l, i) => (i % 2 ? l.toUpperCase() : l)).join(""),
];

function capitalize3(s: string) {
    const output = ["", ""];
    s.split("").forEach((letter, index) => {
        output[0] += index % 2 ? letter : letter.toUpperCase();
        output[1] += !(index % 2) ? letter : letter.toUpperCase();
    });
    return output;
}

function capitalize4(s: string) {
    return [...s].reduce(
        (acc, curr, indx) => {
            const isEven = indx % 2 == 0;
            acc[0] += curr[isEven ? "toUpperCase" : "toLowerCase"]();
            acc[1] += curr[!isEven ? "toUpperCase" : "toLowerCase"]();
            return acc;
        },
        ["", ""]
    );
}

function capitalize5(s: string): Array<string> {
    return [
        s
            .split("")
            .map((letter, i) =>
                i % 2 === 0 ? letter.toUpperCase() : letter.toLowerCase()
            )
            .join(""),
        s
            .split("")
            .map((letter, i) =>
                i % 2 !== 0 ? letter.toUpperCase() : letter.toLowerCase()
            )
            .join(""),
    ];
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  MAXIMUM LENGTH DIFFERENCE
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
You are given two arrays a1 and a2 of strings. Each string is composed with letters from a to z. Let x be any string in the first array and y be any string in the second array.

Find max(abs(length(x) ‚àí length(y)))

If a1 and/or a2 are empty return -1 in each language except in Haskell (F#) where you will return Nothing (None).

Example:
a1 = ["hoqq", "bbllkw", "oox", "ejjuyyy", "plmiis", "xxxzgpsssa", "xxwwkktt", "znnnnfqknaz", "qqquuhii", "dvvvwz"]
a2 = ["cccooommaaqqoxii", "gggqaffhhh", "tttoowwwmmww"]
mxdiflg(a1, a2) --> 13
Bash note:
input : 2 strings with substrings separated by ,
output: number as a string
*/

// 1Ô∏è‚É£
class G964 {
    // 1Ô∏è‚É£
    public static mxdiflg = (a1: string[], a2: string[]): number => {
        if (!a1.length || !a2.length) return -1;

        const shortest1: number = Math.min(...a1.map((word) => word.length));
        const longest1: number = Math.max(...a1.map((word) => word.length));
        const shortest2: number = Math.min(...a2.map((word) => word.length));
        const longest2: number = Math.max(...a2.map((word) => word.length));

        return Math.max(
            Math.abs(shortest1 - longest2),
            Math.abs(longest1 - shortest2)
        );
    };

    // 2Ô∏è‚É£
    public static mxdiflg2 = (a1: string[], a2: string[]): number => {
        if (!a1.length || !a2.length) return -1;

        const getShortest = (arr: string[]) =>
            Math.min(...arr.map((word): number => word.length));
        const getLongest = (arr: string[]) =>
            Math.max(...arr.map((word): number => word.length));

        const shortest1 = getShortest(a1);
        const longest1 = getLongest(a1);
        const shortest2 = getShortest(a2);
        const longest2 = getLongest(a2);

        return Math.max(
            Math.abs(shortest1 - longest2),
            Math.abs(longest1 - shortest2)
        );
    };

    // 3Ô∏è‚É£
    public static mxdiflg3 = (a1: string[], a2: string[]): number => {
        if (!a1.length || !a2.length) return -1;

        // REFACTOR getShortest / getShortest
        const getMinMax = (arr: string[], output: string): number => {
            // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è HAVE TO USE ENDING RETURN STATEMENT WITH TERNARY ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
            // if (output === "min") return Math.min(...arr.map((word): number => word.length));
            // if (output === "max") return Math.max(...arr.map((word): number => word.length));

            return output === "min"
                ? Math.min(...arr.map((word): number => word.length))
                : Math.max(...arr.map((word): number => word.length));
        };

        const shortest1 = getMinMax(a1, "min");
        const longest1 = getMinMax(a1, "max");
        const shortest2 = getMinMax(a2, "min");
        const longest2 = getMinMax(a2, "max");

        return Math.max(
            Math.abs(shortest1 - longest2),
            Math.abs(longest1 - shortest2)
        );
    };

    // 4Ô∏è‚É£  FINAL:
    public static mxdiflg4 = (a1: string[], a2: string[]): number => {
        const getMinMax = (arr: string[], output: string): number => {
            return output === "min"
                ? Math.min(...arr.map((word): number => word.length))
                : Math.max(...arr.map((word): number => word.length));
        };

        const shortest1 = getMinMax(a1, "min");
        const longest1 = getMinMax(a1, "max");
        const shortest2 = getMinMax(a2, "min");
        const longest2 = getMinMax(a2, "max");

        return a1.length && a2.length // (!a1.length || !a2.length)
            ? Math.max(
                Math.abs(shortest1 - longest2),
                Math.abs(longest1 - shortest2)
            )
            : -1;
    };
}

//  getMinMax WILL CALCULATE THE LENGTH OF THE LONGEST OR SHORTEST ELEMENT OF ARRAY PASSED IN
//  CALCULATE LONGEST AND SHORTEST ELEMENTS FOR BOTH ARRAYS
//  CHECK ARRAY LENGTHS
//      IF BOTH VALID, RETURN MAX DIFFERENCE
//      OTHERWISE, -1

// var s1 = ["hoqq", "bbllkw", "oox", "ejjuyyy", "plmiis", "xxxzgpsssa", "xxwwkktt", "znnnnfqknaz", "qqquuhii", "dvvvwz"];
// var s2 = ["cccooommaaqqoxii", "gggqaffhhh", "tttoowwwmmww"];

// const s1 = ['ejjjjmmtthh',
//     'zxxuueeg',
//     'aanlljrrrxx',
//     'dqqqaaabbb',
//     'oocccffuucccjjjkkkjyyyeehh']

// const s2 = ['bbbaaayddqbbrrrv']

// console.log(G964.mxdiflg(s1, s2));

//============= OTHER CODEWARS SOLUTIONS: =============

/*

export class G964 {
  
    public static mxdiflg = (a1, a2) => {
        let max = -1;
        for (let x of a1) {
          for (let y of a2) {
            max = Math.max(Math.abs(x.length - y.length), max);
          }
        }
        
        return max;
    }
}


export class G964 {
    public static mxdiflg = (a1, a2) => {
      if (!a1.length || !a2.length) return -1;
      const x = Math.max(...a1.map(v => v.length)) - Math.min(...a2.map(v => v.length));
      const y = Math.max(...a2.map(v => v.length)) - Math.min(...a1.map(v => v.length));
      return x > y ? x : y;
    }
  }



  export class G964 {
    public static mxdiflg = (a1, a2) => !a1.length || !a2.length ? -1 : Math.max(...a1.map(s1 => Math.max(...a2.map(s2 => Math.abs(s1.length - s2.length)))));
}

*/

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  FIX STRING CASE
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
In this Kata, you will be given a string that may have mixed uppercase and lowercase letters and your task is to convert that string to either lowercase only or uppercase only based on:

make as few changes as possible.
if the string contains equal number of uppercase and lowercase letters, convert the string to lowercase.
For example:

solve("coDe") = "code". Lowercase characters > uppercase. Change only the "D" to lowercase.
solve("CODe") = "CODE". Uppercase characters > lowecase. Change only the "e" to uppercase.
solve("coDE") = "code". Upper == lowercase. Change all to lowercase.
More examples in test cases. Good luck!
*/

// 1Ô∏è‚É£  ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è THIS WORKS IN IDE BUT THROWS ERROR IN CODEWARS ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// (OBJECT IS POSSIBLY NULL)

// const solve = (str: string) => {

//     const capitals: number | undefined = str.match(/[A-Z]/g)?.length;

//     if (capitals) {
//         return capitals > str.length / 2 ? str.toUpperCase() : str.toLowerCase();
//     } else {
//         return str.toLowerCase();
//     }

// }

// 2Ô∏è‚É£ ‚úÖ SOLVED WITH DIFFERENT LOGIC:
const solve = (str: string) => {
    let upperC: number = 0;

    for (const letter of str) {
        if (/[A-Z]/.test(letter)) upperC++;
    }

    return upperC > str.length / 2 ? str.toUpperCase() : str.toLowerCase();
};

// console.log(solve("code"));
// console.log(solve("CODe"));
// console.log(solve("COde"));
// console.log(solve("Code"));

//============= OTHER CODEWARS SOLUTIONS: =============

function solve2(s: string) {
    let uppercaseCount = s
        .split("")
        .filter((letter) => letter === letter.toUpperCase()).length;
    return uppercaseCount > s.length / 2 ? s.toUpperCase() : s.toLowerCase();
}

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è MATCH(REGEX || []) ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
function solve3(s: string): string {
    return (s.match(/[a-z]/g) || []).length >= s.length / 2
        ? s.toLowerCase()
        : s.toUpperCase();
}

const solve4 = (s: string) => {
    const upperCs = s.split("").filter((x) => x == x.toUpperCase());
    return upperCs.length > s.length / 2 ? s.toUpperCase() : s.toLowerCase();
};

function solve5(s: string) {
    return s.replace(/[a-z]/g, "").length > s.length / 2
        ? s.toUpperCase()
        : s.toLowerCase();
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  FORM THE MINIMUM (SMALLEST NUMBER WITHOUT DUPLICATION)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  SET(), ARRAY.FROM()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Given a list of digits, return the smallest number that could be formed from these digits, using the digits only once (ignore duplicates).

Notes:
Only positive integers will be passed to the function (> 0 ), no negatives or zeros.
Input >> Output Examples
minValue ({1, 3, 1})  ==> return (13)
Explanation:
(13) is the minimum number could be formed from {1, 3, 1} , Without duplications

minValue({5, 7, 5, 9, 7})  ==> return (579)
Explanation:
(579) is the minimum number could be formed from {5, 7, 5, 9, 7} , Without duplications

minValue({1, 9, 3, 1, 7, 4, 6, 6, 7}) return  ==> (134679)
Explanation:
(134679) is the minimum number could be formed from {1, 9, 3, 1, 7, 4, 6, 6, 7} , Without duplications
*/

const minValue = (values: number[]): number => {
    //1Ô∏è‚É£
    // const uniques = new Set(values);
    // const incrOrder = Array.from(uniques).sort();
    // let numStr = "";
    // incrOrder.forEach((digit) => {
    //     numStr += digit;
    // })
    // return Number(numStr);

    // 2Ô∏è‚É£
    // const uniques = new Set(values);
    // return Number(Array.from(uniques).sort().join(""));

    // 3Ô∏è‚É£
    return Number(Array.from(new Set(values)).sort().join(""));
};

//  REMOVE DUPLICATES USING Set
//  MAKE ARRAY FROM UNUQUE VALUES
//  SORT ARRAY IN ASCENDING ORDER
//  JOIN INTO STRING
//  CONVERT TO NUMBER

// console.log(minValue([4, 7, 5, 7]));
// console.log(minValue([6, 7, 8, 7, 6, 6]));

//============= OTHER CODEWARS SOLUTIONS: =============

const minValue2 = (values: Array<number>): number => {
    return +[...new Set(values)].sort().join("");
};

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  SMALL ENOUGH?
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  EVERY()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
You will be given an array and a limit value. You must check that all values in the array are below or equal to the limit value. If they are, return true. Else, return false.

You can assume all values in the array are numbers.
*/

const smallEnough = (arr: number[], limit: number): boolean => {
    // const checkLimit = (num: number) => num <= limit;

    // return arr.every(checkLimit);

    return arr.every((num: number) => num <= limit);
};

// console.log(smallEnough([101, 45, 75, 105, 99, 107], 107));
// console.log(smallEnough([78, 117, 110, 99, 104, 117, 107, 115], 100));

//============= OTHER CODEWARS SOLUTIONS: =============

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  CHECK THE EXAM
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  SWITCH(), NESTED TERNARY, CONTINUE, MATH.MAX()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
The first input array is the key to the correct answers to an exam, like ["a", "a", "b", "d"]. The second one contains a student's submitted answers.

The two arrays are not empty and are the same length. Return the score for this array of answers, giving +4 for each correct answer, -1 for each incorrect answer, and +0 for each blank answer, represented as an empty string (in C the space character is used).

If the score < 0, return 0.

For example:

checkExam(["a", "a", "b", "b"], ["a", "c", "b", "d"]) ‚Üí 6
checkExam(["a", "a", "c", "b"], ["a", "a", "b",  ""]) ‚Üí 7
checkExam(["a", "a", "b", "c"], ["a", "a", "b", "c"]) ‚Üí 16
checkExam(["b", "c", "b", "a"], ["",  "a", "a", "c"]) ‚Üí 0
*/

const checkExam = (array1: string[], array2: string[]): number => {
    let score: number = 0;

    for (let i = 0; i < array2.length; i++) {
        switch (array2[i]) {
            case "":
                score += 0;
                break;
            case array1[i]:
                score += 4;
                break;
            default:
                score += -1;
        }
    }

    return score < 0 ? 0 : score;
};

// console.log(checkExam(["a", "a", "b", "b"], ["a", "c", "b", "d"]));
// console.log(checkExam(["a", "a", "c", "b"], ["a", "a", "b", ""]));
// console.log(checkExam(["a", "a", "b", "c"], ["a", "a", "b", "c"]));
// console.log(checkExam(["b", "c", "b", "(a"], ["", "a", "a", "c"]));

//============= OTHER CODEWARS SOLUTIONS: =============

function checkExam2(array1: string[], array2: string[]): number {
    let result = 0;

    array2.forEach((item, index) => {
        item === array1[index]
            ? (result += 4)
            : item === ""
                ? (result += 0)
                : (result -= 1);
    });

    return Math.max(result, 0);
}

function checkExam3(array1: string[], array2: string[]): number {
    let score = 0;
    for (let i = 0; i < array1.length; i++) {
        if (array2[i] === "") continue;
        else if (array1[i] === array2[i]) score += 4;
        else score--;
    }
    return score > 0 ? score : 0;
}

function checkExam4(array1: string[], array2: string[]): number {
    return Math.max(
        0,
        array2.reduce(
            (a, b, i) => a + (b == "" ? 0 : b === array1[i] ? 4 : -1),
            0
        )
    );
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  SUM DIGITS OF NUMBER
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Write a function named sumDigits which takes a number as input and returns the sum of the absolute value of each of the number's decimal digits.

For example: (Input --> Output)

10 --> 1
99 --> 18
-32 --> 5
Let's assume that all numbers in the input will be integer values.
*/

const sumDigits = (num: number): number => {
    return Math.abs(num)
        .toString()
        .split("")
        .map((digit) => Number(digit))
        .reduce((a, b) => a + b);
};

//  GET ABSOLUTE VALUE
//  CONVERT TO STRING
//  SPLIT INTO ARRAY OF STRINGS
//  CONVERT TO ARRAY OF NUMBERS
//  GET SUM

// console.log(sumDigits(453));
// console.log(sumDigits(-32));

//============= OTHER CODEWARS SOLUTIONS: =============

function sumDigits2(number: number): number {
    return Math.abs(number)
        .toString()
        .split("")
        .reduce((acc, digit) => parseInt(digit) + acc, 0);
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  GIVEN A DIVISOR AND BOUND FOUND LARGEST INT
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Given a Divisor and a Bound , Find the largest integer N , Such That ,

Conditions :
N is divisible by divisor

N is less than or equal to bound

N is greater than 0.

Notes
The parameters (divisor, bound) passed to the function are only positive values .
It's guaranteed that a divisor is Found .
Input >> Output Examples
maxMultiple (2,7) ==> return (6)
Explanation:
(6) is divisible by (2) , (6) is less than or equal to bound (7) , and (6) is > 0
*/

const maxMultiple = (divisor: number, bound: number): number => {
    let solution: number = 0;

    for (let num = bound; num > 0; num--) {
        if (num % divisor === 0) {
            solution = num;
            break;
        }
    }

    return solution;
};

//  START LOOP AT bound, DECREMENT BY 1
//  RETURN FIRST num THAT IS DIVISIBLE BY divisor

// console.log(maxMultiple(37, 200));

//============= OTHER CODEWARS SOLUTIONS: =============

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
function maxMultiple2(divisor: number, bound: number) {
    return bound - (bound % divisor);
}

function maxMultiple3(divisor: number, bound: number) {
    return Math.floor(bound / divisor) * divisor;
}

function maxMultiple4(divisor: number, bound: number) {
    for (let n = bound; n > 0; n -= 1) if (n % divisor === 0) return n;
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  GET TWO LARGEST NUMBERS OF ARRAY
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  FILTER() TO REMOVE DUPLICATES, SORT() NUMERICALLY
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
The two oldest ages function/method needs to be completed. It should take an array of numbers as its argument and return the two highest numbers within the array. The returned value should be an array in the format [second oldest age, oldest age].

The order of the numbers passed in could be any order. The array will always include at least 2 items. If there are two or more oldest age, then return both of them in array format.

For example:

two_oldest_ages( 4, {1, 2, 10, 8}, result) // should fill result array with {8, 10}
*/

const twoOldestAges = (ages: number[]): number[] => {
    return (
        ages
            // .filter((curr, index) => ages.indexOf(curr) === index)
            .sort((a, b) => b - a)
            .slice(0, 2)
            .reverse()
    );
};

//  FILTER WILL REMOVE DUPLICATES IF NEEDED
// SORT ARRAY DESCENDING NUMERICALLY
// GET FIRST TWO ELEMENTS
// REVERSE

// console.log(twoOldestAges([1, 5, 87, 45, 8, 8, 87]));
// console.log(twoOldestAges([1, 5, 87, 45, 8, 8]));

//============= OTHER CODEWARS SOLUTIONS: =============

const twoOldestAges2 = (ages: any) =>
    ages.sort((a: any, b: any) => a - b).slice(ages.length - 2);

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  COUNT NUMBER OF DIVISORS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Count the number of divisors of a positive integer n.

Random tests go up to n = 500000.

Examples (input --> output)
4 --> 3 (1, 2, 4)
5 --> 2 (1, 5)
12 --> 6 (1, 2, 3, 4, 6, 12)
30 --> 8 (1, 2, 3, 5, 6, 10, 15, 30)
*/

const divisors = (num: number): number => {
    if (num === 1) return 1;

    const divisors: number[] = [];

    for (let i = 1; i <= num / 2; i++) {
        let divisor1: number = i,
            divisor2: number = num / i;

        if (Number.isInteger(num / divisor1)) {
            // console.table({ divisor1: i, divisor2: num / i });

            if (!divisors.includes(divisor1)) {
                if (divisor1 === divisor2) {
                    divisors.push(divisor1);
                } else {
                    divisors.push(divisor1, divisor2);
                }
            }
        }
    }

    // console.log(divisors, divisors.length);
    return divisors.length;
};

//  LOOP OVER INTEGERS UP TO num / 2
//     IF num CAN BE DIVIDED BY divisor1
//        IF divisors ARRAY DOES NOT INCLUDE divisor1
//            IF divisor1 EQUALS divisor2
//                ONLY PUSH divisor1 TO AVOID DUPLICATES (8*8=64)
//            OTHERWISE
//                PUSH BOTH DIVISORS

//  RETURN LENGTH OF ARRAY AS RESULT

// console.log(divisors(1));
// console.log(divisors(64));
// console.log(divisors(4));

//============= OTHER CODEWARS SOLUTIONS: =============

function divisors2(n: number) {
    let steps = 0;

    for (let i = 0; i <= n; i++) {
        if (n % i === 0) steps++;
    }

    return steps;
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  COUNT DIGIT APPEARING IN SQUARES
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  REGEXP OBJECT, MATCH()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Take an integer n (n >= 0) and a digit d (0 <= d <= 9) as an integer.

Square all numbers k (0 <= k <= n) between 0 and n.

Count the numbers of digits d used in the writing of all the k**2.

Call nb_dig (or nbDig or ...) the function taking n and d as parameters and returning this count.

Examples:
n = 10, d = 1 
the k*k are 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100
We are using the digit 1 in: 1, 16, 81, 100. The total count is then 4.

nb_dig(25, 1) returns 11 since
the k*k that contain the digit 1 are:
1, 16, 81, 100, 121, 144, 169, 196, 361, 441.
So there are 11 digits 1 for the squares of numbers between 0 and 25
*/

const nbDig = (num: number, digit: number): number => {
    let counter: number = 0;
    const regex = new RegExp(String(digit), "g");

    for (let i = 0; i <= num; i++) {
        let squareStr = String(Math.pow(i, 2));
        const matches = squareStr.match(regex);
        // console.table({
        //     square: squareStr,
        //     digit: String(digit),
        //     matches: matches?.length
        // });
        if (matches) counter += matches.length;
    }

    return counter;
};

//  CREATE JS REGEXP OBJECT FOR digit
//  LOOP OVER INTEGERS UP TO AND ICLUDING num
//      CALC SQUARE, CONVERT TO STRING AN SAVE TO VAR squareStr
//      GET ARRAY OF MATCHES (matches)
//      IF matches ARRAY IS NOT EMPTY
//          INCREMENT counter BY matches.length
//  RETURN counter AS RESULT

// 6
// console.log(nbDig(11, 1));

//============= OTHER CODEWARS SOLUTIONS: =============

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  BREAKING CHOCOLEATE
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Your task is to split the chocolate bar of given dimension n x m into small squares. Each square is of size 1x1 and unbreakable. Implement a function that will return minimum number of breaks needed.

For example if you are given a chocolate bar of size 2 x 1 you can split it to single squares in just one break, but for size 3 x 1 you must do two breaks.

If input data is invalid you should return 0 (as in no breaks are needed if we do not have any chocolate to split). Input will always be a non-negative integer.
*/

const breakChocolate = (n: number, m: number): number => {
    return n * m > 1 ? n * m - 1 : 0;
};

// console.log(breakChocolate(5, 5));

//============= OTHER CODEWARS SOLUTIONS: =============

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  DONT GIVE ME FIVE
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  REGEX.TEST()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
In this kata you get the start number and the end number of a region and should return the count of all numbers except numbers with a 5 in it. The start and the end number are both inclusive!

Examples:

1,9 -> 1,2,3,4,6,7,8,9 -> Result 8
4,17 -> 4,6,7,8,9,10,11,12,13,14,16,17 -> Result 12
The result may contain fives. ;-)
The start number will always be smaller than the end number. Both numbers can be also negative!
*/

const dontGiveMeFive = (start: number, end: number): number => {
    let counter = 0;

    for (let i = start; i <= end; i++) {
        if (!/5/g.test(String(i))) {
            counter++;
        }
    }

    return counter;
};

//  TEST FOR A MATCH IN STRING(NUM) FOR "5"
//      IF NO MATCH, INCREMENT COUNTER
//  RETURN COUNTER AS RESULT

// return /^(\d{4}|\d{6})$/.test(pin);

// console.log(dontGiveMeFive(1, 9));
// console.log(dontGiveMeFive(4, 17));

//============= OTHER CODEWARS SOLUTIONS: =============

function dontGiveMeFive2(start: number, end: number): number {
    return Array.from(
        { length: end - start + 1 },
        (ix, it) => it + start
    ).filter((it) => !/5/.test(it + "")).length;
}

function dontGiveMeFive3(start: number, end: number): number {
    return Array.from({ length: end - start + 1 }, (_, i) => i + start).filter(
        (x) => !/5/.test(`${x}`)
    ).length;
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  REVERSE WORDS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Complete the function that accepts a string parameter, and reverses each word in the string. All spaces in the string should be retained.

Examples
"This is an example!" ==> "sihT si na !elpmaxe"
"double  spaces"      ==> "elbuod  secaps"

*/

const reverseWords = (str: string): string => {
    return str
        .split(" ")
        .map((word) => word.split("").reverse().join(""))
        .join(" ");
};

// console.log(reverseWords('The quick brown fox jumps over the lazy dog.'));

//============= OTHER CODEWARS SOLUTIONS: =============

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

//============= OTHER CODEWARS SOLUTIONS: =============

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  SUM OF THE FIRST NTH TERM OF SERIES ROUNDED TO 2 DIGITS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  TOFIXED(2), TRACKING MULTIPLE VARIABLES IN FOR LOOP
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Your task is to write a function which returns the sum of following series upto nth term(parameter).

Series: 1 + 1/4 + 1/7 + 1/10 + 1/13 + 1/16 +...
Rules:
You need to round the answer to 2 decimal places and return it as String.

If the given value is 0 then it should return 0.00

You will only be given Natural Numbers as arguments.

Examples:(Input --> Output)
1 --> 1 --> "1.00"
2 --> 1 + 1/4 --> "1.25"
5 --> 1 + 1/4 + 1/7 + 1/10 + 1/13 --> "1.57"
*/

const SeriesSum = (num: number): string => {
    let sum: number = 0;

    for (let i = 0, denominator = 1; i < num; i++, denominator += 3) {
        sum += 1 / denominator;
    }

    return String(sum.toFixed(2));
};

// TRACK/INCREMENT NUM AND DENOMINATOR IN LOOP
// INCREMENT SUM WITH 1 / DENOMINATOR NUM TIMES
// ROUND DOWN TO TWO DIGITS AND CONVERT NO STRING

// console.log(SeriesSum(1));
// console.log(SeriesSum(2));
// console.log(SeriesSum(3));

//============= OTHER CODEWARS SOLUTIONS: =============

function SeriesSum2(n: number): string {
    return [...Array(n).keys()]
        .map((k) => 1 / (k * 3 + 1))
        .reduce((acc, n) => acc + n, 0)
        .toFixed(2);
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  STRING END WITH?
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  ENDSWITH()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Complete the solution so that it returns true if the first argument(string) passed in ends with the 2nd argument (also a string).

Examples:

solution('abc', 'bc') // returns true
solution('abc', 'd') // returns false
*/

const solution = (str: string, ending: string): boolean => {
    return str.endsWith(ending);
};

// console.log(solution('abcde', 'cde'));
// console.log(solution('abcde', 'rde'));

//============= OTHER CODEWARS SOLUTIONS: =============

function solution2(str: string, ending: string): boolean {
    return !ending.length || str.slice(-ending.length) === ending;
}

function solution3(str: string, ending: string): boolean {
    const strSubstring = str.slice(str.length - ending.length);
    return strSubstring === ending; // TODO: complete
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  ODD OR EVEN (SUM OF ARRAY)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  REDUCE(), BITWISE AND (ODD OR EVEN), DOUBLE NESTED TERNARY
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Given a list of integers, determine whether the sum of its elements is odd or even.

Give your answer as a string matching "odd" or "even".

If the input array is empty consider it as: [0] (array with a zero).
*/

// num(1) & 1 => 1   RETURNS  1 IF N IS ODD
// num(2) & 1 => 0   RETURNS 0 IF N IS EVEN

const oddOrEven = (array: number[]): string => {
    // if (array.length === 0) return "even";
    // return array.reduce((a, b) => a + b) & 1
    //     ? "odd"
    //     : "even";

    return array.length > 0
        ? array.reduce((a, b) => a + b) & 1
            ? "odd"
            : "even"
        : "even";
};

// console.log(oddOrEven([0, -1, -3]));
// console.log(oddOrEven([0, -1, -4]));
// console.log(oddOrEven([]));

//============= OTHER CODEWARS SOLUTIONS: =============

function oddOrEven2(array: number[]) {
    return array.reduce((acc, it) => acc + it, 0) % 2 ? "odd" : "even";
}

const oddOrEven3 = (array: number[]) =>
    array.reduce((acc, curr) => (acc += curr), 0) % 2 === 0 ? "even" : "odd";

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  NUMBER OF PEOPLE ON THE BUS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  REDUCE()
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
There is a bus moving in the city, and it takes and drop some people in each bus stop.

You are provided with a list (or array) of integer pairs. Elements of each pair represent number of people get into bus (The first item) and number of people get off the bus (The second item) in a bus stop.

Your task is to return number of people who are still in the bus after the last bus station (after the last array). Even though it is the last bus stop, the bus is not empty and some people are still in the bus, and they are probably sleeping there :D

Take a look on the test cases.

Please keep in mind that the test cases ensure that the number of people in the bus is always >= 0. So the return integer can't be negative.

The second value in the first integer array is 0, since the bus is empty in the first bus stop.
*/

const number = (busStops: [number, number][]): number => {
    let counter: number = 0;

    busStops.forEach((stop) => {
        counter += stop[0];
        counter -= stop[1];
    });

    return counter;
};

// console.log(number([[10, 0], [3, 5], [5, 8]]));
// console.log(number([[3, 0], [9, 1], [4, 10], [12, 2], [6, 1], [7, 10]]));

//============= OTHER CODEWARS SOLUTIONS: =============

function number2(busStops: number[][]): number {
    return busStops.reduce((rem, [on, off]) => rem + (on - off), 0);
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  SUM OF ODD NUMBERS IN TRIANGLE OF CONS. ODD NUMS
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Given the triangle of consecutive odd numbers:

             1
          3     5
       7     9    11
   13    15    17    19
21    23    25    27    29
...
Calculate the sum of the numbers in the nth row of this triangle (starting at index 1) e.g.: (Input --> Output)

1 -->  1
2 --> 3 + 5 = 8
*/

function rowSumOddNumbers(n: number): number {
    return Math.pow(n, 3);
    //     return n ** 3;
}

// FIRST SOLUTION IN JS:

// const rowSumOddNumbers2 = (n) => {
//     const firstOfRow = n + Math.pow(n - 1, 2);
//     const subTotal = firstOfRow * n;
//     let increments = 0;
//     for (let j = 0; j <= n * 2 - 2; j += 2) {
//         increments = increments + j;
//     }
//     total = subTotal + increments;
//     return total;
// };

//============= OTHER CODEWARS SOLUTIONS: =============

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  IS THIS A TRIANGLE?
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

/*
Implement a function that accepts 3 integer values a, b, c. The function should return true if a triangle can be built with the sides of given length and false in any other case.

(In this case, all triangles must have surface greater than 0 to be accepted).
*/

const isTriangle = (a: number, b: number, c: number): boolean => {
    return a + b > c && a + c > b && b + c > a;
};

//   SUM OF ANY TWO SIDES MUST BE GREATER THAN THIRD SIDE

// console.log(isTriangle(1, 2, 2));
// console.log(isTriangle(7, 2, 2));

//============= OTHER CODEWARS SOLUTIONS: =============

const isTriangle2 = (a: number, b: number, c: number): boolean =>
    a + b <= c || a + c <= b || b + c <= a ? false : true;

function isTriangle3(a: number, b: number, c: number): boolean {
    return a + b <= c ? false : a + c <= b ? false : b + c <= a ? false : true;
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  REGEX VALIDATE PIN CODE (4 OR 6 DIGITS)
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// KEYWORDS:  REGEX
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

const validatePin = (pin: string): boolean => {
    // if (pin.length === 4 && pin.match(/\d/g)!.length === 4) return true;
    // if (pin.length === 6 && pin.match(/\d/g)!.length === 6) return true;
    // return false;

    return (
        (pin.length === 4 && pin.match(/\d/g)!.length === 4) ||
        (pin.length === 6 && pin.match(/\d/g)!.length === 6)
    );
};

// console.log(validatePin("12345654yw"));
// console.log(validatePin("123456"));
// console.log(validatePin("12345a"));
// console.log(validatePin("1234"));
// console.log(validatePin("-1234"));

//============= OTHER CODEWARS SOLUTIONS: =============

export class Kata2 {
    static pinFormat: RegExp = new RegExp(/^\d{4}(\d{2})?$/);

    static validatePin(pin: string): boolean {
        return Kata2.pinFormat.test(pin);
    }
}

export class Kata3 {
    static validatePin(pin: string) {
        return /^(\d{4}|\d{6})$/.test(pin);
    }
}

export class Kata4 {
    static validatePin(pin: string): boolean {
        const digits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
        if (pin.length !== 4 && pin.length !== 6) {
            return false;
        }

        for (let index = 0; index < pin.length; index++) {
            if (!digits.includes(pin[index])) {
                return false;
            }
        }
        return true;
    }
}

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

// In DNA strings, symbols "A" and "T" are complements of each other, as "C" and "G". You function receives one side of the DNA (string, except for Haskell); you need to return the other complementary side. DNA strand is never empty or there is no DNA at all (again, except for Haskell).

// More similar exercise are found here: http://rosalind.info/problems/list-view/ (source)

// Example: (input --> output)

// "ATTGC" --> "TAACG"
// "GTAT" --> "CATA"
// dnaStrand []        `shouldBe` []
// dnaStrand [A,T,G,C] `shouldBe` [T,A,C,G]
// dnaStrand [G,T,A,T] `shouldBe` [C,A,T,A]
// dnaStrand [A,A,A,A] `shouldBe` [T,T,T,T]

const dnaStrand = (dna: string): string => {
    const arr = dna.split("");

    arr.map((el, i) => {
        switch (el) {
            case "A":
                arr[i] = "T";
                break;
            case "T":
                arr[i] = "A";
                break;
            case "C":
                arr[i] = "G";
                break;
            case "G":
                arr[i] = "C";
        }
    });

    console.log(arr.join(""));
    return arr.join("");
};

// dnaStrand("ATCG");

//============= OTHER CODEWARS SOLUTIONS: =============

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// export class Kata {
//     static dnaStrand(dna: string) {
//       return dna.replace(/./g, (c)=>({A:'T',T:'A',G:'C',C:'G'})[c]);
//     }
// }

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è if you want a replaced with x, b with y and c with z, you can do something like this:

// var chars = {'a':'x','b':'y','c':'z'};
// var s = '234abc567bbbbac';
// s = s.replace(/[abc]/g, m => chars[m]);
// console.log(s);
// Output: 234xyz567yyyyxz

// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
// let dummyString = 'Javascript^ is$ the most popular _language';
// newString = dummyString.replace(/[_^$]/g, charactersToReplace => ({'^': '', '_': ':', '$' : '+' })[charactersToReplace]);

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  JADEN CASE
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

// Jaden Smith, the son of Will Smith, is the star of films such as The Karate Kid (2010) and After Earth (2013). Jaden is also known for some of his philosophy that he delivers via Twitter. When writing on Twitter, he is known for almost always capitalizing every word. For simplicity, you'll have to capitalize each word, check out how contractions are expected to be in the example below.

// Your task is to convert strings to how they would be written by Jaden Smith. The strings are actual quotes from Jaden Smith, but they are not capitalized in the same way he originally typed them.

// Example:

// Not Jaden-Cased: "How can mirrors be real if our eyes aren't real"
// Jaden-Cased:     "How Can Mirrors Be Real If Our Eyes Aren't Real"

// üü©
// String.prototype.toJadenCase = function (str: string ): string {

//     //  ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è TypeError: Cannot read property 'split' of undefined ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
//     //  return str.split(" ").map((word) => word.replace(word[0], word[0].toUpperCase())).join(" ");

//     // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è USE this KEYWORD: ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
//     return this.split(" ").map((word) => word.replace(word[0], word[0].toUpperCase())).join(" ");

// };
// üü©

// STRING -> ARR(WORDS) -> CAPITALIZE EACH WORD IN ARRAY -> JOIN INTO STRING WITH " "
const toJadenCase = (str: string): string => {
    console.log(
        str
            .split(" ")
            .map((word) => word.replace(word[0], word[0].toUpperCase()))
            .join(" ")
    );

    // ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è HAVE TO USE this IN CODEWARS SOLUTION ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
    return str
        .split(" ")
        .map((word) => word.replace(word[0], word[0].toUpperCase()))
        .join(" ");
};

// toJadenCase("How can mirrors be real if our eyes aren't real");
// toJadenCase("a b A B");

//============= OTHER CODEWARS SOLUTIONS: =============

// String.prototype.toJadenCase = function () {
//     return this.replace(/(?:^|\s)\S/g, firstLetter => firstLetter.toUpperCase());
// };

// const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1)
// String.prototype.toJadenCase = function() {
//   return this.split(' ').map(capitalize).join(' ')
// }

// String.prototype.toJadenCase = function () {
//     return this.replace(/^.|\s./gi, $ => $.toUpperCase())
// };

// String.prototype.toJadenCase = function () {
//     let temp = this;

//     if (temp === null || temp.length === 0) {
//       return null;
//     }

//     let result = '';

//     for (let i = 0; i < temp.length; i++) {
//       let x = temp[i];
//       if (i === 0) {
//         x = x.toUpperCase();
//       } else if (temp[i - 1] === ' ') {
//         x = x.toUpperCase();
//       }
//       result += x;
//     }

//     return result;
//   };

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  SHORTEST WORD'S LENGTH
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

// STR -> ARR(STR) -> SORT ARR BY LENGTH OF WORDS -> GRAB LENGTH OF FIRST ELEMENT
const findShort = (str: string): number => {
    return str.split(" ").sort((a, b) => {
        return a.length - b.length;
    })[0].length;
};

findShort("bitcoin take over the world maybe who knows perhaps");

//============= OTHER CODEWARS SOLUTIONS: =============

// export function findShort(s: string): number {
//     return Math.min(...s.split(" ").map((w) => w.length));
// }

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  X's AND O's
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

// Check to see if a string has the same amount of 'x's and 'o's. The method must return a boolean and be case insensitive. The string can contain any char.

// Examples input/output:

// XO("ooxx") => true
// XO("xooxx") => false
// XO("ooxXm") => true
// XO("zpzpzpp") => true // when no 'x' and 'o' is present should return true
// XO("zzoo") => false

const xo = (str: string): boolean => {
    const xS = str.toLowerCase().match(/x/g); // GET x's
    const oS = str.toLowerCase().match(/o/g); // GET o's
    if (xS && oS) {
        // IF BOTH FOUND:
        return xS.length === oS.length; // CHECK IF THEIR LENGTHS EQUAL (bool)
    } else if (xS || oS) {
        // IF ONLY ONE FOUND:
        return false; // false
    } else {
        // IF NEITHER FOUND
        return true; // true
    }
};

//============= OTHER CODEWARS SOLUTIONS: =============

// export function xo(str: string) {
// 	return str.toLowerCase().split('x').length == str.toLowerCase().split('o').length;
//   }

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  IS ISOGRAM?
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

// STRING -> ARRAY OF LOWERCASED LETTERS -> SET (DUPLICATES REMOVED)
// COMPARE NUMBER OF ELEMENTS IN SET AND ORIGINAL STRING
// RETURN TRUE IF EQUAL, OTHERWISE FALSE
const isIsogram = (str: string): boolean => {
    const lettersSet = new Set(str.toLowerCase().split(""));
    return lettersSet.size === str.length;
};

//============= OTHER CODEWARS SOLUTIONS: =============

// export function isIsogram (str: string): boolean {
// 	return (new Set(str.toLowerCase())).size === str.length
// }

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  IS SQUARE?
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

function isSquare(num: number): boolean {
    return Number.isInteger(Math.sqrt(num));
}

//============= OTHER CODEWARS SOLUTIONS: =============

// export default (n: number): boolean => (Math.sqrt(n) % 1 === 0);

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

const getMiddle = (str: string): string => {
    const halfLength = str.length / 2;
    const isEvenLength = str.length % 2 === 0;

    // console.log(isEvenLength
    // 	? str.substring(halfLength - 1, halfLength + 1)
    // 	: str.charAt((str.length - 1) / 2)
    // )

    return isEvenLength
        ? str.substring(halfLength - 1, halfLength + 1)
        : str.charAt((str.length - 1) / 2);
};

// getMiddle("abcde");
// getMiddle("abcd");

//============= OTHER CODEWARS SOLUTIONS: =============

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

// NUM -> STR -> ARR(STR) -> ARR(NUM) -> ARR(SORTED) -> ARR(REVERSED) -> STRING -> NUM
const descendingOrder = (n: Number): number => {
    // JAVASCRIPT:

    // console.log(
    //     n
    //         .toString()
    //         .split("")
    //         .map(Number)
    //         .sort()
    //         .reverse()
    //         .map(String)
    //         .join("") * 1		// ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è *1 NOT WORKING IN TS ‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è
    // );

    return Number(
        n.toString().split("").map(Number).sort().reverse().map(String).join("")
    );
};

descendingOrder(123456789);

//============= OTHER CODEWARS SOLUTIONS: =============

// export function descendingOrder(n: number | null | undefined): number | null | undefined {
//   return n ? parseInt(n.toString().split("").sort().reverse().join("")) : n;
// }

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  MUMBLING
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

// EMPTY ARR FOR SOLUTION
// SPLIT INTO ARRAY AND LOWERCASE
// REPEAT index + 1 TIMES AND CAPITALIZE FIRST LETTER THEN PUSH INTO SOLUTION ARRAY
// JOIN INTO STRING WITH "-"
const accum = (str: string): string => {
    const repsArr: string[] = [];
    const letters = str.split("").map((el) => el.toLowerCase());
    letters.forEach((letter, i) => {
        let rep = letter
            .repeat(i + 1)
            .replace(letter[0], letter[0].toUpperCase());
        repsArr.push(rep);
    });
    console.log(repsArr.join("-"));
    return repsArr.join("-");
};

// accum("ZpglnRxqenU");

//============= OTHER CODEWARS SOLUTIONS: =============

// export function accum(s: string): string {
// 	return s.split('')
// 	.map((elem, index) => elem.toUpperCase() + (elem.toLowerCase()).repeat(index))
// 	.join('-');
//   }

//   export function accum(s: string): string {
// 	return s.split("").map((value, index) => (value.toUpperCase() + value.toLowerCase().repeat(index))).join("-");
//   }

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

// SPLIT INTO ARRAY -> CONVERT TO NUM -> FIND MAX/MINN
const highAndLow = (numbers: string): string => {
    const numArr = numbers.split(" ").map((num) => Number(num));
    // console.log(`${Math.max(...numArr)} ${Math.min(...numArr)}`);
    return `${Math.max(...numArr)} ${Math.min(...numArr)}`;
};

highAndLow("1 2 3 4 -6");
// highAndLow("8 3 -5 42 -1 0 0 -9 4 7 4 -4");

//============= OTHER CODEWARS SOLUTIONS: =============

// export class Kata {
// 	static highAndLow(numbers: string) {
// 	  const max = Math.max(...numbers.split(' ').map(i => +i));
// 	  const min = Math.min(...numbers.split(' ').map(i => +i));

// 	  return `${max} ${min}`;

// 	}
// }

// export class Kata
// {
//   static highAndLow(numbers: string)
//   {
//     let splitted = numbers.split(" ").map(Number);
//     let low = Math.min( ...splitted );
//     let high = Math.max( ...splitted );
//     return high + " " + low;
//   }
// }

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  DISEMVOWEL STRING
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

// REMOVE ALL VOWELS:
const disemvowel = (str: string): string => {
    return str.replace(/[aeiou]/gi, "");
};

//============= OTHER CODEWARS SOLUTIONS: =============

// export class Kata {
//   static disemvowel(str: string) {
//     var vowels: string = 'AEIOUaeiou';
//     return str.split('').filter(v => !vowels.includes(v)).join('')
//   }
// }

// export class Kata {
//   static readonly LETTERS_LIST = new RegExp('a|e|i|o|u', 'gi');

//   static disemvowel(str: string) {
//     return str.replace(Kata.LETTERS_LIST, '');
//   }
// }

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  SQUARE DIGITS OF NUMBER
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

const squareDigits = (num: number): number => {
    let solution;
    // solution = num
    //     .toString()
    //     .split("")
    //     .map((el) => Number(el))
    //     .map((el) => Math.pow(el, 2))
    //     .map((el) => el.toString())
    //     .join("")

    solution = num
        .toString()
        .split("")
        .map((el) => Math.pow(Number(el), 2).toString())
        .join("");

    console.log(Number(solution));
    return Number(solution);
};

// squareDigits(9119);

//============= OTHER CODEWARS SOLUTIONS: =============

// export class Kata {
//     static squareDigits(num: number) {
//       return +num.toString().split('').map(i=>+i*+i).join('');
//     }
// }

// export class Kata {
//     static squareDigits(num: number) {
//       return +num.toString()
//                  .split('')
//                  .map(n => Math.pow(+n,2))
//                  .join('');
//     }
// }

// export class Kata {
//     static squareDigits(num: number): number {
//       return +num.toString().split('').map((n)=>(+n)**2).join('')
//     }
// }

// üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©üü©
// TITLE:  COUNT VOWELS IN STRING
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞
// SOURCE:
// üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞üÄ∞

// export class Kata {
//     static getCount = (str: string): number => {
//       return str.split("").filter((el) => el.match(/[aeiou]/gi)).length;
//     }
//   }

// SPLIT INTO ARRAY -> FIND VOWELS -> GET LENGTH OF VOWELS ARRAY
const getCount = (str: string): number => {
    return str.split("").filter((el) => el.match(/[aeiou]/gi)).length;
};

//============= OTHER CODEWARS SOLUTIONS: =============

//   export class Kata {
//     static getCount(str: string) {
//       let list = str.match(/[aeiou]/gi);
//       return list ? list.length : 0;
//     }
//   }

// export class Kata {
//     static getCount(str: string) : number {
//       return str.split('').filter(c => /[aeiou]/i.test(c)).length
//     }
//   }
