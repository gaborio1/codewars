// ❗️❗️❗️ ✅  ❓❓❓
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: GENETIC ALGORITHM SERIES  - #1 Generate
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A genetic algorithm is based in groups of chromosomes, called populations. To start our population of chromosomes we need to generate random binary strings with a specified length.

In this kata you have to implement a function generate that receives a length and has to return a random binary strign with length characters.



Example:
Generate a chromosome with length of 4 generate(4) could return the chromosome 0010, 1110, 1111... or any of 2^4 possibilities.

Note: Some tests are random. If you think your algorithm is correct but the result fails, trying again should work.
*/
function generate(length: number): string {
    return "hello";
}

// assert.equal(generate(16).length, 16);
// assert.equal(generate(32).length, 32);
// assert.equal(generate(64).length, 64);

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: LARGEST SQUARE INSIDE A CIRCLE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Determine the area of the largest square that can fit inside a circle with radius r.
*/
function areaLargestSquare(r: number): number {
    return 0;
}

// assert.strictEqual(areaLargestSquare(5), 50);
// assert.strictEqual(areaLargestSquare(7), 98);
// assert.strictEqual(areaLargestSquare(15), 450);

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: DIGITAL CYPHER - VOL 2
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Introduction
Digital Cypher assigns to each letter of the alphabet unique number. For example:

 a  b  c  d  e  f  g  h  i  j  k  l  m
 1  2  3  4  5  6  7  8  9 10 11 12 13
 n  o  p  q  r  s  t  u  v  w  x  y  z
14 15 16 17 18 19 20 21 22 23 24 25 26
Instead of letters in encrypted word we write the corresponding number, eg. The word scout:

 s  c  o  u  t
19  3 15 21 20
Then we add to each obtained digit consecutive digits from the key. For example. In case of key equal to 1939 :

   s  c  o  u  t
  19  3 15 21 20
 + 1  9  3  9  1
 ---------------
  20 12 18 30 21
  
   m  a  s  t  e  r  p  i  e  c  e
  13  1 19 20  5 18 16  9  5  3  5
+  1  9  3  9  1  9  3  9  1  9  3
  --------------------------------
  14 10 22 29  6 27 19 18  6  12 8
Task
Write a function that accepts an array of integers code and a key number. As the result, it should return string containg a decoded message from the code.

Input / Output
The code is a array of positive integers.
The key input is a positive integer.

Example
decode([ 20, 12, 18, 30, 21],1939);  ==> "scout"
decode([ 14, 10, 22, 29, 6, 27, 19, 18, 6, 12, 8],1939);  ==>  "masterpiece"
*/
function decode(code: number[], n: number): String {
    return "noidea";
}

//    assert.equal( solution.decode([ 20, 12, 18, 30, 21], 1939) , "scout");
//    assert.equal( solution.decode([ 14, 10, 22, 29, 6, 27, 19, 18, 6, 12, 8], 1939) , "masterpiece");

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: CARTESIAN NEIGHBOR
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A Cartesian coordinate system is a coordinate system that specifies each point uniquely in a plane by a pair of numerical coordinates, which are the signed distances to the point from two fixed perpendicular directed lines, measured in the same unit of length.

The сoordinates of a point in the grid are written as (x,y). Each point in a coordinate system has eight neighboring points. Provided that the grid step = 1.

It is necessary to write a function that takes a coordinate on the x-axis and y-axis and returns a list of all the neighboring points. Points inside your returned list need not be sorted (any order is valid).

For Example:

cartesianNeighbor(2,2) -> [[1,1],[1,2],[1,3],[2,1],[2,3],[3,1],[3,2],[3,3]]
cartesianNeighbor(5,7) -> [[6,7],[6,6],[6,8],[4,7],[4,6],[4,8],[5,6],[5,8]]

*/
function cartesianNeighbor(x: number, y: number): number[][] {
    return [];
}

// sortedList(cartesianNeighbor(2, 2)),[[1,1],[1,2],[1,3],[2,1],[2,3],[3,1],[3,2],[3,3]]
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: SORT THE VOWELS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Sort the Vowels!
In this kata, we want to sort the vowels in a special format.

Task
Write a function which takes a input string s and return a string in the following way:

   
                  C|                          R|
                  |O                          n|
                  D|                          d|
   "CODEWARS" =>  |E       "Rnd Te5T"  =>      |
                  W|                          T|
                  |A                          |e
                  R|                          5|
                  S|                          T|

Notes:

List all the Vowels on the right side of |
List every character except Vowels on the left side of |
for the purpose of this kata, the vowels are : a e i o u
Return every character in its original case
Each line is seperated with \n
Invalid input ( undefined / null / integer ) should return an empty string
*/
function sortVowels(str?: number | string | null): string {
    return "hello";
}

/*
assert.equal(sortVowels('Codewars'), 'C|\n|o\nd|\n|e\nw|\n|a\nr|\ns|');
    assert.equal(sortVowels('Is RubY dEad?'), '|I\ns|\n |\nR|\n|u\nb|\nY|\n |\nd|\n|E\n|a\nd|\n?|');
    assert.equal(sortVowels('yo!'), 'y|\n|o\n!|');
    assert.equal(sortVowels('LOrEm IpsUm dOlOr sIt AmEt'), 'L|\n|O\nr|\n|E\nm|\n |\n|I\np|\ns|\n|U\nm|\n |\nd|\n|O\nl|\n|O\nr|\n |\ns|\n|I\nt|\n |\n|A\nm|\n|E\nt|');
  });
*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: FIND THE SQUARES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Problem
Complete the function that takes an odd integer (0 < n < 1000000) which is the difference between two consecutive perfect squares, and return these squares as a string in the format "bigger-smaller"

Examples
9  -->  "25-16"
5  -->  "9-4"
7  -->  "16-9"
*/
const findSquares = (num: number): string => {
    return `${num}-${num}`;
};

// assert.strictEqual(findSquares(9), '25-16');
// assert.strictEqual(findSquares(5), '9-4');

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: ODD ONES OUT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The town sheriff dislikes odd numbers and wants all odd numbered families out of town! In town crowds can form and individuals are often mixed with other people and families. However you can distinguish the family they belong to by the number on the shirts they wear. As the sheriff's assistant it's your job to find all the odd numbered families and remove them from the town!

Challenge: You are given a list of numbers. The numbers each repeat a certain number of times. Remove all numbers that repeat an odd number of times while keeping everything else the same.

oddOnesOut([1, 2, 3, 1, 3, 3]) = [1, 1]
In the above example:

the number 1 appears twice
the number 2 appears once
the number 3 appears three times
2 and 3 both appear an odd number of times, so they are removed from the list. The final result is: [1,1]

Here are more examples:

oddOnesOut([1, 1, 2, 2, 3, 3, 3]) = [1, 1, 2, 2]
oddOnesOut([26, 23, 24, 17, 23, 24, 23, 26]) = [26, 24, 24, 26]
oddOnesOut([1, 2, 3]) = []
oddOnesOut([1]) = []
Are you up to the challenge?
*/

function oddOnesOut(nums: number[]) {
    // your code here
}

/*
it("Testing for [1, 2, 3, 1, 3, 3]", function() {
    assert.deepEqual(oddOnesOut([1, 2, 3, 1, 3, 3]), [1, 1]);
  });
  it("Testing for [75, 68, 75, 47, 68]", function() {
    assert.deepEqual(oddOnesOut([75, 68, 75, 47, 68]), [75, 68, 75, 68]);
  });
  it("Testing for [42, 72, 32, 4, 94, 82, 67, 67]", function() {
    assert.deepEqual(oddOnesOut([42, 72, 32, 4, 94, 82, 67, 67]), [67, 67]);
  });
  it("Testing for [100, 100, 5, 5, 100, 50, 68, 50, 68, 50, 68, 5, 100]", function() {
    assert.deepEqual(oddOnesOut([100, 100, 5, 5, 100, 50, 68, 50, 68, 50, 68, 5, 100]), [100, 100, 100, 100]);
  });
  it("Testing for [82, 86, 71, 58, 44, 79, 50, 44, 79, 67, 82, 82, 55, 50]", function() {
    assert.deepEqual(oddOnesOut([82, 86, 71, 58, 44, 79, 50, 44, 79, 67, 82, 82, 55, 50]), [44, 79, 50, 44, 79, 50]);
  });
*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: THE OFFICE VI - SABBATICAL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Learning to code around your full time job is taking over your life. You realise that in order to make significant steps quickly, it would help to go to a coding bootcamp in London.

Problem is, many of them cost a fortune, and those that don't still involve a significant amount of time off work - who will pay your mortgage?!

To offset this risk, you decide that rather than leaving work totally, you will request a sabbatical so that you can go back to work post bootcamp and be paid while you look for your next role.

You need to approach your boss. Her decision will be based on three parameters:

val = your value to the organisation
happiness = her happiness level at the time of asking and finally
The numbers of letters from 'sabbatical' that are present in string s.

Note that if s contains three instances of the letter 'l', that still scores three points, even though there is only one in the word sabbatical.

If the sum of the three parameters (as described above) is > 22, return 'Sabbatical! Boom!', else return 'Back to your desk, boy.'.
*/
function sabb(s: string, val: number, happiness: number): string {
    return "";
}

/*
assert.strictEqual(sabb('Can I have a sabbatical?', 5, 5), 'Sabbatical! Boom!');
    assert.strictEqual(sabb('Why are you shouting?', 7, 2), 'Back to your desk, boy.'); 
    assert.strictEqual(sabb('What do you mean I cant learn to code??', 8, 9), 'Sabbatical! Boom!'); 
    assert.strictEqual(sabb('Please calm down', 9, 1), 'Back to your desk, boy.'); 
    assert.strictEqual(sabb('I can?! Nice. FaC..Im coming :D', 9, 9), 'Sabbatical! Boom!'); 
*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// INCLUDE THIS IN EXAMPLES: ❗️❗️❗️ ~~ ❗️❗️❗️
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ REFACTOR WITH MATH.FLOOR AND DIVISION ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: MOD 256 WITHOUT THE MOD OPERATOR,
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ ~~ ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
MOD 256 without the MOD operator
The MOD-operator % (aka mod/modulus/remainder):

Returns the remainder of a division operation.
The sign of the result is the same as the sign of the first operand.
(Different behavior in Python!)
The short unbelievable mad story for this kata:
I wrote a program and needed the remainder of the division by 256. And then it happened: The "5"/"%"-Key did not react. It must be broken! So I needed a way to:

Calculate the remainder of the division by 256 without the %-operator.
Also here some examples:

Input 254  -> Result 254
Input 256  -> Result 0
Input 258  -> Result 2 
Input -258 -> Result -2 (in Python: Result: 254!)
It is always expected the behavior of the MOD-Operator of the language!

The input number will always between -10000 and 10000.

For some languages the %-operator will be blocked. If it is not blocked and you know how to block it, tell me and I will include it.

For all, who say, this would be a duplicate: No, this is no duplicate! There are two katas, in that you have to write a general method for MOD without %. But this kata is only for MOD 256. And so you can create also other specialized solutions. ;-)

Of course you can use the digit "5" in your solution. :-)

I'm very curious for your solutions and the way you solve it. I found several interesting "funny" ways.
*/
const mod256WithoutMod = (num: number): number => {
    const divisor: number = 256;
    const isPositive: boolean = num > 0;

    if (Math.abs(num) < divisor) return num;

    while (Math.abs(num) >= divisor) {
        num = Math.abs(num) - divisor;
    }

    if (num === 0) return 0;
    return isPositive ? num : -num;
};

/*
assert.equal(solution.mod256WithoutMod(254), 254);
    assert.equal(solution.mod256WithoutMod(256), 0);
    assert.equal(solution.mod256WithoutMod(258), 2);
    
    assert.equal(solution.mod256WithoutMod(-254), -254);
    assert.equal(solution.mod256WithoutMod(-256), 0);
    assert.equal(solution.mod256WithoutMod(-258), -2);
*/

// console.log(mod256WithoutMod(-254));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function mod256WithoutMod2(n: number): number {
    return n % 256;
}


function mod256WithoutMod3(n: number): number {
    if (n < 0) {
        return -mod256WithoutMod(-n);
    }
    return n & 255;
}

function mod256WithoutMod4(n: number): number {
    return n < 0 ? -mod256WithoutMod(-n) : n & 0xff;
}


function mod256WithoutMod5(n: number): number {
    return n < 0 ? -(-n & 255) : (n & 255);
}


function mod256WithoutMod6(n: number): number {
    return n >= 0 ? (n / 256 - Math.floor(n / 256)) * 256 : ((n / 256 - Math.ceil(n / 256))) * 256;
}

// ❗️❗️❗️ ~~ ❗️❗️❗️
function mod256WithoutMod7(n: number): number {
    return n - ~~(n / 256) * 256
}
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES  ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: ABSENT VOWEL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️  FINDINDEX() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your job is to figure out the index of which vowel is missing from a given string:

A has an index of 0,
E has an index of 1,
I has an index of 2,
O has an index of 3,
U has an index of 4.
Notes: There is no need for string validation and every sentence given will contain all vowels but one. Also, you won't need to worry about capitals.

Examples
"John Doe hs seven red pples under his bsket"          =>  0  ; missing: "a"
"Bb Smith sent us six neatly arranged range bicycles"  =>  3  ; missing: "o"

*/
const absentVowel = (text: string): number => {
    let solution: number = 0;

    const vowels: string = "aeiou";

    // ['i', 'e', 'u', 'i','e', 'a', 'a', 'a','e', 'a', 'e', 'i','e']
    const allVowels: string[] = text.match(/[aeiou]/g)!;
    // console.log(allVowels);
    // Set(4) { 'o', 'e', 'u', 'i' }
    const uniqueVowels = new Set(allVowels);
    // console.log(uniqueVowels);

    for (let i = 0; i < vowels.length; i += 1) {
        if (!uniqueVowels.has(vowels[i])) {
            solution = i;
            break;
        }
    }
    // console.log(solution);
    return solution;
};

// assert.equal(absentVowel("John Doe hs seven red pples under his bsket"), 0)
// assert.equal(absentVowel("Bb Smith sent us six neatly arranged range bicycles"), 3)

// console.log(absentVowel("John Doe hs seven red pples under his bsket"));
// console.log(absentVowel("Bb Smith sent us six neatly arranged range bicycles"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️  FINDINDEX() ❗️❗️❗️
const absentVowel2 = (str: string): number =>
    [..."aeiou"].findIndex((v) => !str.includes(v));

// ❗️❗️❗️  FINDINDEX() ❗️❗️❗️
function absentVowel3(x: string): number {
    return [..."aeiou"].findIndex((c) => !x.toLowerCase().includes(c));
}

function absentVowel4(x: string) {
    let vowels: Array<string> = ["a", "e", "i", "o", "u"];
    let result: number = 0;
    vowels.forEach((v) => {
        if (!x.includes(v)) {
            result = vowels.indexOf(v);
            return;
        }
    });
    return result;
}

function absentVowel5(x: string): number | undefined {
    var vowels: string = "aeiou";
    for (let i in [...vowels]) {
        if (x.toLowerCase().indexOf(vowels[i]) === -1) {
            return Number(i);
        }
    }
}

function absentVowel6(x: string) {
    if (/a/i.test(x) === false) return 0;
    if (/e/i.test(x) === false) return 1;
    if (/i/i.test(x) === false) return 2;
    if (/o/i.test(x) === false) return 3;
    if (/u/i.test(x) === false) return 4;
}

function absentVowel7(x: string): number {
    switch (true) {
        case !x.includes("a"):
            return 0;
            break;
        case !x.includes("e"):
            return 1;
            break;
        case !x.includes("i"):
            return 2;
            break;
        case !x.includes("o"):
            return 3;
            break;
        case !x.includes("u"):
            return 4;
            break;
        default:
            return NaN;
    }
}
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ LOOK INTO THIS  ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: PERIMETER SEQUENCE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Perimeter sequence
The first three stages of a sequence are shown.
blocks
The blocksize is a by a and a ≥ 1.
What is the perimeter of the nth shape in the sequence (n ≥ 1) ?
*/
function perimeterSequence(a: number, n: number): number {
    return n * 4 * a;
}

// 12
// console.log(perimeterSequence(1,3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ LOOK INTO THIS  << ❗️❗️❗️
const perimeterSequence2 = (a: number, n: number): number => (a * n) << 2;

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ LOOK INTO THIS  ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: DRIVING LICENCE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: EXTRACT BITS FROM DATA STRING, ❗️❗️❗️ DATE.GETFULLYEAR() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Introduction
In the United Kingdom, the driving licence is the official document which authorises its holder to operate various types of motor vehicle on highways and some other roads to which the public have access. In England, Scotland and Wales they are administered by the Driver and Vehicle Licensing Agency (DVLA) and in Northern Ireland by the Driver & Vehicle Agency (DVA). A driving licence is required in the UK by any person driving a vehicle on any highway or other road defined in s.192 Road Traffic Act 1988[1] irrespective of ownership of the land over which the road passes, thus including many which allow the public to pass over private land; similar requirements apply in Northern Ireland under the Road Traffic (Northern Ireland) Order 1981. (Source Wikipedia)
Driving
Task
The UK driving number is made up from the personal details of the driver. The individual letters and digits can be code using the below information
Rules
1–5: The first five characters of the surname (padded with 9s if less than 5 characters)
6: The decade digit from the year of birth (e.g. for 1987 it would be 8)
7–8: The month of birth (7th character incremented by 5 if driver is female i.e. 51–62 instead of 01–12)
9–10: The date within the month of birth
11: The year digit from the year of birth (e.g. for 1987 it would be 7)
12–13: The first two initials of the first name and middle name, padded with a 9 if no middle name
14: Arbitrary digit – usually 9, but decremented to differentiate drivers with the first 13 characters in common. We will always use 9
15–16: Two computer check digits. We will always use "AA"
Your task is to code a UK driving license number using an Array of data. The Array will look like
data = ["John","James","Smith","01-Jan-2000","M"]
Where the elements are as follows
0 = Forename
1 = Middle Name (if any)
2 = Surname
3 = Date of Birth (In the format Day Month Year, this could include the full Month name or just shorthand ie September or Sep)
4 = M-Male or F-Female
You will need to output the full 16 digit driving license number.
Good luck and enjoy!
*/
const driver = (data: Array<string>): string => {
    console.log(data);

    // 1-5 SURNAME
    const inputSurname: string = data[2];
    console.log(inputSurname);
    let surname: string = "";
    if (inputSurname.length >= 5) {
        surname = inputSurname.substring(0, 5);
    }
    if (inputSurname.length < 5) {
        // MIGHT NOT WORK IN CODEWARS
        // validSurname = surname.padEnd(5, "9");
        surname = `${inputSurname}${"x".repeat(5 - inputSurname.length)}`;
    }
    console.log("surname", surname);

    // 6 DECADE DIGIT FROM DOB
    const dob: string = data[3].match(/\d{4}/)![0];
    // const year: string = dob.match;
    console.log(dob);
    const decadeDigit: string = dob.toString()[2];
    console.log(decadeDigit);

    // 7-8 MONTH OF BIRTH
    let monthStr: any = data[3]
        .match(/[a-z]{3,}/gi)![0]
        .toLowerCase()
        .slice(0, 3);
    console.log(monthStr);

    enum months {
        jan = 1,
        feb,
        mar,
        apr,
        may,
        jun,
        jul,
        aug,
        sep,
        oct,
        nov,
        dec,
    }

    // HAVE TO MAKE MONTHSTRING ANY, OTHERWISE WE GET THIS ERROR:
    // error TS7015: Element implicitly has an 'any' type because index expression is not of type 'number'.
    let monthDigit: any = Number(months[monthStr]); // NUMBER
    console.log(typeof monthDigit);
    // CONVERT TO STRING AND ADD LEADING "0" IF LENGTH IS 1
    if (monthDigit < 10) {
        // TYR PADSTART
        monthDigit = `0${monthDigit}`; // STRING
    } else {
        monthDigit = monthDigit.toString();
    }

    // INCREMENT FIRST DIGIT BY 5 IF DRIVER IS FEMALE
    if (data[4].toLowerCase() === "f") {
        // CONVERT TO NUMBER, ADD 50 AND CONVERT BACK TO STRING
        monthDigit = (Number(monthDigit) + 50).toString();
    }
    console.log(monthDigit);

    // 9-10 DATE WITHIN MONTH OF BIRTH
    const date: string = data[3].match(/\d{2}/)![0];
    console.log(date);

    // 11 YEAR DIGIT FROM DOB
    const yearDigit: string = dob.toString()[3];
    console.log(yearDigit);

    // 12-13 FIRST TWO INITIALS, PADDED WITH "9" IF NO MIDDLE NAME
    let initials: string = data[0][0];
    initials += data[1] ? data[1][0] : "9";
    console.log(initials);

    console.log(surname);
    const solution: string = `${surname.toUpperCase()}${decadeDigit}${monthDigit}${date}${yearDigit}${initials}9AA`;
    // const solution: string = surname;

    return solution;
};

/*
data = ["John","James","Smith","01-Jan-2000","M"]
    assert.equal(driver(data), "SMITH001010JJ9AA", "Should return 'SMITH001010JJ9AA'")
    
    data = ["Johanna","","Gibbs","13-Dec-1981","F"]
    assert.equal(driver(data), "GIBBS862131J99AA", "Should return 'GIBBS862131J99AA'")
    
    data = ["Andrew","Robert","Lee","02-September-1981","M"]
    assert.equal(driver(data), "LEE99809021AR9AA", "Should return 'LEE99809021AR9AA'")
*/

const data = ["John", "James", "Smith", "01-Jan-2000", "M"];
// const data = ["John", "James", "Carpenter", "01-Jan-2000", "M"];
// const data = ["John", "James", "J", "01-Jan-2010", "M"];

// 'SMITH 0 01 01 0 JJ 9 AA'
// console.log(driver(data));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ DATE.GETFULLYEAR() ❗️❗️❗️
function driver2(data: Array<string>): string {
    var r = data[2].toUpperCase().substring(0, 5);
    var i;
    console.log(data[2]);
    for (i = data[2].length; i < 5; i++) {
        r += "9";
    }
    var date = new Date(data[3]);
    r += date.getFullYear().toString().charAt(2); // 6
    r += ("0" + (date.getMonth() + 1 + (data[4] === "M" ? 0 : 50))).slice(-2); // 7-8
    r += ("0" + date.getDate()).slice(-2); //9 - 10
    r += date.getFullYear().toString().charAt(3); // 11
    r +=
        (data[0].length ? data[0].charAt(0) : "9") +
        (data[1].length ? data[1].charAt(0) : "9");
    r += "9AA";

    return r;
}

function driver3(data: Array<string>): string {
    let output: string = "";

    data[2] = data[2].toUpperCase();

    // 5 letters of surname + ending 9s
    output += data[2].substr(0, 5);
    while (output.length < 5) {
        output += "9";
    }

    // Decade digit
    output += data[3].substr(-2, 1);

    // Month
    let date = new Date(data[3]);
    let month = (date.getMonth() + 1).toString();
    if (month.length < 2) {
        month = 0 + month;
    }
    if (data[4] == "F") {
        output += parseInt(month[0]) + 5 + month[1];
    } else {
        output += month;
    }

    // Date
    let dateDay = date.getDate().toString();
    if (dateDay.length < 2) {
        dateDay = "0" + dateDay;
    }
    output += dateDay;

    // Year digit
    output += date.getFullYear().toString().substr(-1);

    // Initials
    output += data[0].substr(0, 1);

    if (data[1] == "") {
        output += "9";
    } else {
        output += data[1].substr(0, 1);
    }

    // Arbitrary + Check
    output += "9AA";

    return output;
}

function driver4(data: Array<string>): string {
    let date = new Date(data[3]);
    let apellido = data[2].toUpperCase().substring(0, 5);

    if (apellido.length < 5) {
        for (
            let i = 0;
            i < 5 - data[2].toUpperCase().substring(0, 4).length;
            i++
        ) {
            apellido = apellido.concat("9");
        }
    }

    return (
        apellido +
        data[3].split("-")[2].substring(2, 3) +
        (data[4] === "F"
            ? String(date.getMonth() + 51)
            : date.getMonth() + 1 < 10
                ? "0" + String(date.getMonth() + 1)
                : String(date.getMonth() + 1)) +
        (date.getDate() < 10
            ? "0" + String(date.getDate())
            : String(date.getDate())) +
        data[3].split("-")[2].substring(3, 4) +
        data[0].substring(0, 1) +
        (data[1] !== "" ? data[1].substring(0, 1) : "9") +
        "9AA"
    );
}

function driver5(data: Array<string>): string {
    const [name, middleName, surname, birthDate, sex] = data;
    const [day, month, year] = birthDate.split("-");
    let result = "";
    const monthsAlphabet = {
        January: "01",
        Jan: "01",
        February: "02",
        Feb: "02",
        March: "03",
        Mar: "03",
        April: "04",
        Apr: "04",
        May: "05",
        June: "06",
        Jun: "06",
        Jule: "07",
        Jul: "07",
        August: "08",
        Aug: "08",
        September: "09",
        Sep: "09",
        October: "10",
        Oct: "10",
        November: "11",
        Nov: "11",
        December: "12",
        Dec: "12",
    };
    // 1-5
    result += surname.slice(0, 5).padEnd(5, "9");
    // 6
    result += birthDate.substr(-2, 1);
    // 7-8
    const monthNumber = monthsAlphabet[month as keyof typeof monthsAlphabet];
    if (sex === "M") {
        result += monthNumber;
    } else {
        const femaleNumber = "" + (Number(monthNumber[0]) + 5) + monthNumber[1];
        result += femaleNumber;
    }
    // 9-10
    result += day;
    // 11
    result += year.substr(-1);
    // 12-13
    const initials = (name[0] || "9") + (middleName[0] || "9");
    result += initials;
    // 14
    result += "9";
    // 15-16
    result += "AA";

    return result.toUpperCase();
}

function driver6(data: Array<string>): string {
    const [first_name, middle_name, last_name, birth, sex] = data;
    return [
        last_name.slice(0, 5).toUpperCase().padEnd(5, "9"),
        birth.charAt(birth.length - 2),
        String(
            new Date(birth).getMonth() + 1 + (sex === "F" ? 50 : 0)
        ).padStart(2, "0"),
        String(new Date(birth).getDate()).padStart(2, "0"),
        birth.charAt(birth.length - 1),
        first_name.charAt(0) +
        (middle_name.charAt(0) ? middle_name.charAt(0) : 9),
        "9AA",
    ].join("");
}

// =============================================================

interface month {
    [key: string]: string;
}

const months: month = {
    Jan: "01",
    Feb: "02",
    Mar: "03",
    Apr: "04",
    May: "05",
    Jun: "06",
    Jul: "07",
    Aug: "08",
    Sep: "09",
    Oct: "10",
    Nov: "11",
    Dec: "12",
};

export function driver7(data: Array<string>): string {
    return ""
        .concat(
            data[2].toUpperCase().slice(0, 5),
            data[2].length < 5 ? "9".repeat(5 - data[2].length) : ""
        )
        .concat(data[3].slice(-2, -1))
        .concat(
            data[4] === "F"
                ? (50 + Number(months[data[3].split("-")[1]])).toString()
                : months[data[3].split("-")[1].slice(0, 3)]
        )
        .concat(data[3].split("-")[0])
        .concat(data[3].slice(-1))
        .concat(data[0].slice(0, 1), data[1].length ? data[1].slice(0, 1) : "9")
        .concat("9", "AA");
}

// =============================================================

function driver8(data: Array<string>): string {
    const getMonth = (dateStr: string, shouldIncrement: boolean) => {
        const date = new Date(dateStr);
        const month = date.getMonth() + 1;
        const monthString = month < 10 ? "0" + month : "" + month;
        if (!shouldIncrement) return monthString;

        return `${Number(monthString[0]) + 5}${monthString[1]}`;
    };
    // Good luck

    const oneToFive = Array(5)
        .fill(null)
        .map((e, i) => (data[2][i] ? data[2][i] : "9"))
        .join("");
    const six = data[3].split("-")[2][2];
    const sevenEight = getMonth(data[3], data[4] === "F");
    const nineTen = data[3].split("-")[0];
    const eleven = data[3].split("-")[2][3];
    const twelveThirteen = [data[0][0], data[1][0]]
        .map((elem) => elem || "9")
        .join("");

    return (
        oneToFive +
        six +
        sevenEight +
        nineTen +
        eleven +
        twelveThirteen +
        "9AA"
    ).toUpperCase();
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: BILLIARDS TRIANGLE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Remember the triangle of balls in billiards? To build a classic triangle (5 levels) you need 15 balls. With 3 balls you can build a 2-level triangle, etc.

For more examples,

pyramid(1) == 1

pyramid(3) == 2

pyramid(6) == 3

pyramid(10) == 4

pyramid(15) == 5
Write a function that takes number of balls (≥ 1) and calculates how many levels you can build a triangle.


*/ const pyramid = (numBalls: number): number => {
    // SOLUTION:
    let levCount: number = 0;
    // NUMBER OF BALLS IN EACH ROW (1-2-3-4-5...)
    let currentRow: number = 0;

    while (true) {
        currentRow += 1;
        // console.log("row:", currentRow);
        numBalls -= currentRow;
        // console.log("numBalls:", numBalls);
        if (numBalls < 0) break;
        levCount += 1;
    }

    // console.log(levCount);

    return levCount;
};

/*
row: 1
numBalls: 19
row: 2
numBalls: 17
row: 3
numBalls: 14
row: 4
numBalls: 10
row: 5
numBalls: 5
row: 6
numBalls: -1
5
*/

/*
 assert.strictEqual(pyramid(1) , 1); 
    assert.strictEqual(pyramid(4) , 2); 
    assert.strictEqual(pyramid(20) , 5); 
    assert.strictEqual(pyramid(100) , 13);
    assert.strictEqual(pyramid(2211) ,66); 
    assert.strictEqual(pyramid(9999) , 140);
*/

// console.log(pyramid(20));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function pyramid2(balls: number): number {
    let level: number = 0;
    while (balls > level) {
        level += 1;
        balls -= level;
    }
    return level;
}

function pyramid3(balls: number): number {
    return Math.floor((-1 + (1 + 4 * balls * 2) ** 0.5) / 2);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: THE POET AND THE PENDULUM
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Scenario
the rhythm of beautiful musical notes is drawing a Pendulum

Beautiful musical notes are the Numbers!alt!alt
Task
Given an array/list [] of n integers , Arrange them in a way similar to the to-and-fro movement of a Pendulum

The Smallest element of the list of integers , must come in center position of array/list.

The Higher than smallest , goes to the right .
The Next higher number goes to the left of minimum number and So on , in a to-and-fro manner similar to that of a Pendulum.

!alt
Notes
Array/list size is at least 3 .

In Even array size , The minimum element should be moved to (n-1)/2 index (considering that indexes start from 0)

Repetition of numbers in the array/list could occur , So (duplications are included when Arranging).

Input >> Output Examples:
pendulum ([6, 6, 8 ,5 ,10]) ==> [10, 6, 5, 6, 8]
Explanation:
Since , 5 is the The Smallest element of the list of integers , came in The center position of array/list

The Higher than smallest is 6 goes to the right of 5 .

The Next higher number goes to the left of minimum number and So on .

Remember , Duplications are included when Arranging , Don't Delete Them .

pendulum ([-9, -2, -10, -6]) ==> [-6, -10, -9, -2]
Explanation:
Since , -10 is the The Smallest element of the list of integers , came in The center position of array/list

The Higher than smallest is -9 goes to the right of it .

The Next higher number goes to the left of -10 , and So on .

Remeber , In Even array size , The minimum element moved to (n-1)/2 index (considering that indexes start from 0) .

pendulum ([11, -16, -18, 13, -11, -12, 3, 18 ]) ==> [13, 3, -12, -18, -16, -11, 11, 18]
Explanation:
Since , -18 is the The Smallest element of the list of integers , came in The center position of array/list

The Higher than smallest is -16 goes to the right of it .

The Next higher number goes to the left of -18 , and So on .

Remember , In Even array size , The minimum element moved to (n-1)/2 index (considering that indexes start from 0) .

Tune Your Code , There are 200 Assertions , 60.000 element For Each .

*/
const pendulum = (values: number[]) => {
    // SORT ASCENDING
    const ascArr: number[] = values.sort((a, b) => a - b);
    // console.log(ascArr);

    // INI9TIALIZE SOLUTION WITH SMALLEST ELEMENT
    let solution: number[] = [ascArr[0]];
    // console.log(solution);

    // ALTERNATE BETWEEN PUSH/UNSHIFT
    ascArr.slice(1).forEach((el, idx) => {
        // console.log(el, idx);
        if (!(idx & 1)) {
            solution.push(el);
        } else {
            solution.unshift(el);
        }
    });

    // console.log(solution);

    return solution;
};

/*
it("Check Short length Positives", function() {
    doTest([4, 10, 9], [10, 4, 9]);
    doTest([8, 7, 10, 3], [8, 3, 7, 10]);
    doTest([6, 6, 8, 5, 10], [10, 6, 5, 6, 8]);
    doTest([9, 4, 6, 4, 10, 5], [9, 5, 4, 4, 6, 10]);
    doTest([4, 6, 8, 7, 5], [8, 6, 4, 5, 7]);
    doTest([10, 5, 6, 10], [10, 5, 6, 10]);
    doTest([11, 12, 12], [12, 11, 12]);
  });
  it("Check Medium length Positives", function() {
    doTest([27, 27, 19, 21, 22, 28, 24], [28, 27, 22, 19, 21, 24, 27]);
    doTest([20, 19, 25, 16, 19, 30, 18, 24], [25, 20, 19, 16, 18, 19, 24, 30]);
    doTest([22, 26, 21, 27, 24, 21, 15, 26, 25], [27, 26, 24, 21, 15, 21, 22, 25, 26]);
    doTest([19, 30, 16, 19, 28, 26, 28, 17, 21, 17], [28, 26, 19, 17, 16, 17, 19, 21, 28, 30]);
    doTest([27, 28, 26, 28, 24, 22, 18, 16, 15, 24], [28, 26, 24, 18, 15, 16, 22, 24, 27, 28]);
    doTest([17, 26, 15, 26, 26, 20, 16, 18, 15], [26, 26, 18, 16, 15, 15, 17, 20, 26]);
    doTest([22, 21, 19, 27, 18, 15, 24, 24], [24, 22, 19, 15, 18, 21, 24, 27]);
  });
  it("Check lengthy Positives", function() {
    doTest([33, 38, 38, 36, 43, 48, 32, 40, 47, 50, 33], [50, 47, 40, 38, 33, 32, 33, 36, 38, 43, 48]);
    doTest([49, 40, 41, 41, 39, 43, 40, 46, 30, 47, 46, 40], [47, 46, 41, 40, 40, 30, 39, 40, 41, 43, 46, 49]);
    doTest([48, 41, 38, 35, 50, 46, 38, 42, 37, 49, 44, 32, 37], [50, 48, 44, 41, 38, 37, 32, 35, 37, 38, 42, 46, 49]);
    doTest([49, 30, 39, 30, 40, 44, 43, 48, 47, 50, 42, 48, 33], [50, 48, 47, 43, 40, 33, 30, 30, 39, 42, 44, 48, 49]);
    doTest([48, 43, 35, 47, 39, 38, 38, 46, 49, 32, 42], [49, 47, 43, 39, 38, 32, 35, 38, 42, 46, 48]);
  });
  it("Check Short length Negatives", function() {
    doTest([-9, -2, -10, -6], [-6, -10, -9, -2]);
    doTest([-3, -6, -7], [-3, -7, -6]);
    doTest([-7, -8, -2, -3, -4], [-2, -4, -8, -7, -3]);
    doTest([-8, -8, -9, -10, -10, -3], [-8, -9, -10, -10, -8, -3]);
    doTest([-7, -10, -1, -10, -8], [-1, -8, -10, -10, -7]);
    doTest([-6, -2, -5], [-2, -6, -5]);
  });
  it("Check Medium length Negatives", function() {
    doTest([-2, -11, -6, -11, -4, -3, -5], [-2, -4, -6, -11, -11, -5, -3]);
    doTest([-19, -9, -5, -6, -15, -16, -5, -12], [-5, -9, -15, -19, -16, -12, -6, -5]);
    doTest([-18, -2, -11, -10, -6, -7, -7, -12, -16], [-2, -7, -10, -12, -18, -16, -11, -7, -6]);
    doTest([-10, -10, -12, -13, -5, -10, -4, -17, -5, -12], [-5, -10, -10, -12, -17, -13, -12, -10, -5, -4]);
  });
  it("Check lengthy Negatives", function() {
    doTest([-33, -21, -6, -29, -24, -5, -50, -42, -43, -17, -17], [-5, -17, -21, -29, -42, -50, -43, -33, -24, -17, -6]);
    doTest(
      [-4, -50, -32, -23, -47, -44, -43, -24, -29, -44, -20, -35],
      [-20, -24, -32, -43, -44, -50, -47, -44, -35, -29, -23, -4]
    );
    doTest(
      [-36, -38, -44, -47, -41, -27, -10, -30, -22, -11, -23, -50, -23],
      [-10, -22, -23, -30, -38, -44, -50, -47, -41, -36, -27, -23, -11]
    );
  });
  it("Check Mixture Of Positives And Negatives", function() {
    doTest([-15, 8, 11], [11, -15, 8]);
    doTest([8, -1, -1, -10], [-1, -10, -1, 8]);
    doTest([-8, 15, 8, -3, -11], [15, -3, -11, -8, 8]);
    doTest([15, 17, 3, -20, -1, 3], [15, 3, -20, -1, 3, 17]);
    doTest([-8, -13, -19, -8, 7, 15, -10], [15, -8, -10, -19, -13, -8, 7]);
    doTest([11, -16, -18, 13, -11, -12, 3, 18], [13, 3, -12, -18, -16, -11, 11, 18]);
    doTest([7, -5, -20, 15, 2, 10, 18, 4, -10], [18, 10, 4, -5, -20, -10, 2, 7, 15]);
    doTest([-6, 1, 2, 12, 19, 12, 19, -10, 13, 1], [19, 12, 2, 1, -10, -6, 1, 12, 13, 19]);
  });
  */

// console.log(pendulum([6, 6, 8, 5, 10]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function pendulum2(values: number[]) {
    const solution: number[] = [];
    values
        .sort((x: number, y: number) => (x > y ? 1 : x === y ? 0 : -1))
        .forEach((x, i) => {
            const fun = i % 2 ? "push" : "unshift";
            solution[fun](x);
        });
    return solution;
}

function pendulum3(values: number[]) {
    return values
        .sort((a, b) => a - b)
        .reduce((previousValue, currentValue, index) => {
            if (index % 2 == 0) {
                previousValue.unshift(currentValue);
            } else {
                previousValue.push(currentValue);
            }

            return previousValue;
        }, [] as Array<number>);
}

function pendulum4(values: number[]) {
    return values
        .sort((a, b) => a - b)
        .reduce<number[]>((result, v, i) => {
            if (i % 2 === 0) result.unshift(v);
            else result.push(v);
            return result;
        }, []);
}

function pendulum5(values: number[]): number[] {
    let fin: any[] = [];
    values
        .sort((a, b) => a - b)
        .forEach((n, i) => (!(i % 2) ? fin.unshift(n) : fin.push(n)));
    return fin;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: COLLATZ CONJECTURE LENGTH
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The Collatz Conjecture states that for any natural number n, if n is even, divide it by 2. If n is odd, multiply it by 3 and add 1. If you repeat the process continuously for n, n will eventually reach 1.

For example, if n = 20, the resulting sequence will be:

[20, 10, 5, 16, 8, 4, 2, 1]

Write a program that will output the length of the Collatz Conjecture for any given n. In the example above, the output would be 8.
*/

const collatz = (num: number): number => {
    let counter: number = 1;

    while (num > 1) {
        counter += 1;
        if (num & 1) {
            num = num * 3 + 1;
            // console.log(num);
        } else {
            num /= 2;
            // console.log(num);
        }
    }

    return counter;
};

// assert.strictEqual(collatz(20), 8);
// assert.strictEqual(collatz(15), 18);

// console.log(collatz(20));
// console.log(collatz(15));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function collatz2(n: number): number {
    let numSteps: number = 1;
    while (n !== 1) {
        n = n % 2 ? n * 3 + 1 : n / 2;
        ++numSteps;
    }
    return numSteps;
}

const collatz3 = (n: number): number =>
    n === 1 ? 1 : 1 + collatz(n & 1 ? n * 3 + 1 : n / 2);

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES : OBJECT.IS(),  MATH.SIGN() ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: IS IT NEGATIVE ZERO
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
There exist two zeroes: +0 (or just 0) and -0.

Write a function that returns true if the input number is -0 and false otherwise (True and False for Python).

In JavaScript / TypeScript / Coffeescript the input will be a number.

In Python / Java / C / NASM / Haskell / the input will be a float.
*/
// const isNegativeZero = (num: number): boolean => {
const isNegativeZero = (num: number) => {
    // NOT STRICT ENOUGH:
    // console.log(Math.sign(num));

    // console.log(Object.is(-0, num));

    return Object.is(-0, num);
};

// describe("Basic Tests", function() {
//     it("should return true for -0", function() {
//       assert.equal(userSolution.isNegativeZero(-0), true);
//     });

//     it("should return false for non-negative-zero numbers", function() {
//       assert.equal(userSolution.isNegativeZero(-Infinity), false);
//       assert.equal(userSolution.isNegativeZero(-5), false);
//       assert.equal(userSolution.isNegativeZero(-4), false);
//       assert.equal(userSolution.isNegativeZero(-3), false);
//       assert.equal(userSolution.isNegativeZero(-2), false);
//       assert.equal(userSolution.isNegativeZero(-1), false);
//       assert.equal(userSolution.isNegativeZero(-Number.MIN_VALUE), false);
//       assert.equal(userSolution.isNegativeZero(0), false);
//       assert.equal(userSolution.isNegativeZero(Number.MIN_VALUE), false);
//       assert.equal(userSolution.isNegativeZero(1), false);
//       assert.equal(userSolution.isNegativeZero(2), false);
//       assert.equal(userSolution.isNegativeZero(3), false);
//       assert.equal(userSolution.isNegativeZero(4), false);
//       assert.equal(userSolution.isNegativeZero(5), false);
//       assert.equal(userSolution.isNegativeZero(Infinity), false);
//     });
//   });

// console.log(isNegativeZero(-0));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function isNegativeZero2(n: number): boolean {
    return Object.is(n, -0);
}

function isNegativeZero3(n: number): boolean {
    return n != 0 ? false : 1 / n == -Infinity;
}

function isNegativeZero4(n: number): boolean {
    return n === 0 && 1 / n === -Infinity;
}

function isNegativeZero5(n: number): boolean {
    const isZero = n === 0;
    const isNegative = 1 / n === -Infinity;
    return isNegative && isZero;
}

function isNegativeZero6(n: number): boolean {
    return n === -0 && 1 / n === -Infinity;
}

const isNegativeZero7 = (n: number): boolean => 1 / n === -Infinity && n === -0;

function isNegativeZero8(n: number): boolean {
    if (n === 0) {
        return 1 / n === -Infinity;
    } else {
        return false;
    }
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: HUNGARIAN VOWEL HARMONY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Vowel harmony is a phenomenon in some languages. It means that "A vowel or vowels in a word are changed to sound the same (thus "in harmony.")" (wikipedia). This kata is based on vowel harmony in Hungarian.

Task:
Your goal is to create a function dative() (Dative() in C#) which returns the valid form of a valid Hungarian word w in dative case i. e. append the correct suffix nek or nak to the word w based on vowel harmony rules.

Vowel Harmony Rules (simplified)
When the last vowel in the word is

a front vowel (e, é, i, í, ö, ő, ü, ű) the suffix is -nek
a back vowel (a, á, o, ó, u, ú) the suffix is -nak
Examples:
dative("ablak") == "ablaknak"
dative("szék") == "széknek"
dative("otthon") == "otthonnak"
Preconditions:
To keep it simple: All words end with a consonant :)
All strings are unicode strings.
There are no grammatical exceptions in the tests.

*/
const dative = (word: string): string | undefined => {
    let solution: string = word;
    // GET LAST VOWEL
    const lettersArr: string[] = word.split("");
    // console.log(lettersArr);

    for (let i = lettersArr.length - 1; i >= 0; i -= 1) {
        console.log(lettersArr[i]);
        if (/[eéiíöőüű]/.test(lettersArr[i])) {
            solution += "nek";
            break;
        }
        if (/[aáoóuú]/.test(lettersArr[i])) {
            solution += "nak";
            break;
        }
    }

    return solution;
};

//   const tests: string[][] = [
//     // [input, expected]
//     ['ablak', 'ablaknak'],
//     ['tükör', 'tükörnek'],
//     ['keret', 'keretnek'],
//     ['otthon', 'otthonnak'],
//     ['virág', 'virágnak'],
//     ['tett', 'tettnek'],
//     ['rokkant', 'rokkantnak'],
//     ['rossz', 'rossznak'],
//     ['gonosz', 'gonosznak']
//   ]

// console.log(dative("ablak"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function dative2(word: string): string | undefined {
    return word + (/[aáoóuú]+/.test(word) ? "nak" : "nek");
}

function dative3(word: string): string | undefined {
    let front = ["e", "é", "i", "í", "ö", "ő", "ü", "ű"];
    let back = ["a", "á", "o", "ó", "u", "ú"];
    for (let i = word.length - 1; i >= 0; i--) {
        if (front.includes(word[i])) return word + "nek";
        else if (back.includes(word[i])) return word + "nak";
    }
}

// ❓❓❓
const dative4 = (word: string) =>
    word +
    (/[aáoóuú]/.test(word.replace(/[b-dghj-np-tv-z]/g, "").slice(-1))
        ? "nak"
        : "nek");

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: FIND THE CALCULATION TYPE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You have to create a function calcType, which receives 3 arguments: 2 numbers, and the result of an unknown operation performed on them (also a number).

Based on those 3 values you have to return a string, that describes which operation was used to get the given result.

The possible return strings are: "addition", "subtraction", "multiplication", "division".

Example:
calcType(1, 2, 3) -->   1 ? 2 = 3   --> "addition"
Notes
In case of division you should expect that the result of the operation is obtained by using / operator on the input values - no manual data type conversion or rounding should be performed.
Cases with just one possible answers are generated.
Only valid arguments will be passed to the function.
Only valid arguments will be passed to the function!
*/
const calcType2 = (a: number, b: number, res: number): string => {
    let solution: string = "";

    if (res === a + b) solution = "addition";
    if (res === a * b) solution = "multiplication";
    if (res === a - b) solution = "substraction";
    if (res === a / b) solution = "division";

    return solution;
};

const calcType = (a: number, b: number, res: number): string => {
    let solution: string = "";

    switch (true) {
        case res === a + b:
            solution = "addition";
            break;
        case res === a * b:
            solution = "multiplication";
            break;
        case res === a - b:
            solution = "substraction";
            break;
        case res === a / b:
            solution = "division";
    }

    return solution;
};

//   it('Fixed test for addition', () => {
//     assert.strictEqual(calcType(1, 2, 3), 'addition');
//   });
//   it('Fixed test for multiplication', () => {
//     assert.strictEqual(calcType(10, 4, 40), 'multiplication');
//   });
//   it('Fixed test for subtraction', () => {
//     assert.strictEqual(calcType(10, 5, 5), 'subtraction');
//   });
//   it('Fixed test for division', () => {
//     assert.strictEqual(calcType(9, 5, 1.8), 'division');

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function calcType3(a: number, b: number, c: number): string {
    return "addition|multiplication|subtraction|division".split("|")[
        a + b == c ? 0 : a * b == c ? 1 : a - b == c ? 2 : 3
    ];
}

// ===========================================================

type Operation =
    | "addition"
    | "subtraction"
    | "multiplication"
    | "division"
    | "operation";

export const calcType4 = (a: number, b: number, res: number): Operation => {
    if (a + b === res) return "addition";
    if (a - b === res) return "subtraction";
    if (a / b === res) return "division";
    if (a * b === res) return "multiplication";
    return "operation";
};

// ===========================================================

function calcType5(a: number, b: number, res: number): string {
    return a + b === res
        ? "addition"
        : a - b === res
            ? "subtraction"
            : a * b === res
                ? "multiplication"
                : "division";
}

function calcType6(a: number, b: number, res: number): string {
    if (res >= a + b) {
        return a + b === res ? "addition" : "multiplication";
    }
    return a - b === res ? "subtraction" : "division";
}

function calcType7(a: number, b: number, res: number): string {
    const add = a + b;
    const sub = a - b;
    const mult = a * b;

    if (add === res) {
        return "addition";
    } else if (mult === res) {
        return "multiplication";
    } else if (sub === res) {
        return "subtraction";
    }
    return "division";
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES : SWITCH(TRUE), RECURSION ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: THE FUSC FUNCTION -- Part 1
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: RECURSION, SWITCH(TRUE)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The fusc function is defined recursively as follows:

1. fusc(0) = 0
2. fusc(1) = 1
3. fusc(2 * n) = fusc(n)
4. fusc(2 * n + 1) = fusc(n) + fusc(n + 1)
The 4 rules above are sufficient to determine the value of fusc for any non-negative input n. For example, let's say you want to compute fusc(10).

fusc(10) = fusc(5), by rule 3.
fusc(5) = fusc(2) + fusc(3), by rule 4.
fusc(2) = fusc(1), by rule 3.
fusc(1) = 1, by rule 2.
fusc(3) = fusc(1) + fusc(2) by rule 4.
fusc(1) and fusc(2) have already been computed are both equal to 1.
Putting these results together fusc(10) = fusc(5) = fusc(2) + fusc(3) = 1 + 2 = 3

Your job is to produce the code for the fusc function. In this kata, your function will be tested with small values of n, so you should not need to be concerned about stack overflow or timeouts.

Hint: Use recursion.

There isn't much to explain.
How would you calculate fusc(5)?
Well, 5 = 2 x 2 + 1, and fusc(2 x 2 + 1) = fusc(2) + fusc(3). fusc(3) = fusc(2 x 1 + 1) = fusc(1) + fusc(2). fusc(2) = fusc(2 x 1) = fusc(1) = 1.
Put these results together and you get fusc(5) = 3. Your job is to implement the function fusc.

*/
// 1️⃣
const fusc2 = (num: number): any => {
    if (num === 0) return 0;
    if (num === 1) return 1;
    if (num % 2 === 0) return fusc(num / 2);
    if (num % 2 === 1) return fusc((num - 1) / 2) + fusc((num - 1) / 2 + 1);
};

// 2️⃣
const fusc = (num: number): number => {
    if (num < 2) return num;

    return num & 1
        ? fusc((num - 1) / 2) + fusc((num - 1) / 2 + 1)
        : fusc(num / 2);
};

// assert.equal(fusc(0), 0, 'fusc(0)')
// assert.equal(fusc(1), 1, 'fusc(1)')
// assert.equal(fusc(85), 21, 'fusc(85)')

// console.log(fusc(0));
// console.log(fusc(1));
// console.log(fusc(85));

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ SWITCH(TRUE), RECURSION ❗️❗️❗️

function fusc7(n: number): number {
    switch (true) {
        case n === 0:
            return 0;
        case n === 1:
            return 1;
        case n % 2 === 0:
            return fusc(n / 2);
        case n % 2 === 1:
            return fusc((n - 1) / 2) + fusc((n - 1) / 2 + 1);
        default:
            throw new Error("Invalid input");
    }
}

const fusc3 = ($: number): number =>
    $ < 2
        ? $
        : $ % 2 === 0
            ? fusc($ / 2)
            : fusc(($ + 1) / 2) + fusc(($ - 1) / 2);

function fusc4(n: number): number {
    if (n === 0 || n === 1) {
        return n;
    }
    if (n % 2 === 0) {
        return fusc(n / 2);
    }
    return fusc((n - 1) / 2) + fusc((n + 1) / 2);
}

function fusc5(n: number): number {
    if (n === 0) return 0;
    if (n === 1) return 1;
    if (n % 2 === 0) return fusc(n / 2);
    let x = (n - 1) / 2;
    return fusc(x) + fusc(x + 1);
}

function fusc6(
    n: number,
    map = new Map<number, number>([
        [0, 0],
        [1, 1],
    ])
): number {
    if (map.has(n)) {
        return map.get(n)!;
    }
    const half = n >> 1;
    if (n % 2 === 0) {
        const result = fusc(half);
        map.set(n, result);
        return result;
    } else {
        const result = fusc(half) + fusc(half + 1);
        map.set(n, result);
        return result;
    }
}
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: DRYING POTATOES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
All we eat is water and dry matter.

Let us begin with an example:

John bought potatoes: their weight is 100 kilograms. Potatoes contain water and dry matter. The water content is 99 percent of the total weight. He thinks they are too wet and puts them in an oven - at low temperature - for them to lose some water.

At the output the water content is only 98%.

What is the total weight in kilograms (water content plus dry matter) coming out of the oven?

He finds 50 kilograms and he thinks he made a mistake: "So much weight lost for such a small change in water content!"

Can you help him?

Task
Write function potatoes with

int parameter p0 - initial percent of water-
int parameter w0 - initial weight -
int parameter p1 - final percent of water -
potatoesshould return the final weight coming out of the oven w1 truncated as an int.

Example:
potatoes(99, 100, 98) --> 50
*/
const potatoes = (
    inputCont: number,
    inputWeight: number,
    outputCont: number
): number => {
    // 104.14
    let waterContent: number = (inputWeight * inputCont) / 100;
    console.log(waterContent);

    // 22.86
    const dryWeight: number = inputWeight - (inputWeight * inputCont) / 100;
    console.log(dryWeight);

    const solution: number = inputWeight / (100 - outputCont);
    console.log(solution);

    return 1;
};

// assert.strictEqual(potatoes(82, 127, 80), 114);
//     assert.strictEqual(potatoes(93, 129, 91), 100);

// 114
// console.log(potatoes(82, 127, 80));
// console.log(potatoes(99, 100, 98));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

/*
❗️❗️❗️ FAILING RANDOM TESTS, OUTPUT ARRAY LENGTH EXPECTED TO BE SHORTER THAN INPUT ??? ❗️❗️❗️
Random Tests
makeValley
Log
input------ [ 63, -53, 70, 74, 49, 45, 79, 91, 47, -68, 100, 52, 19, 81, 36, 35, 14, 94, 32 ] ------end
expected [ Array(19) ] to deeply equal [ 94, 74, 49, 35, -53, 19, 45, 63, 81 ]
*/
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: HOW GREEN IS MY VALLEY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Input : an array of integers.

Output : this array, but sorted in such a way that there are two wings:

the left wing with numbers decreasing,

the right wing with numbers increasing.

the two wings have the same length. If the length of the array is odd the wings are around the bottom, if the length is even the bottom is considered to be part of the right wing.

each integer l of the left wing must be greater or equal to its counterpart r in the right wing, the difference l - r being as small as possible. In other words the right wing must be nearly as steep as the left wing.

The function is make_valley or makeValley or make-valley.

a = [79, 35, 54, 19, 35, 25]
make_valley(a) --> [79, 35, 25, *19*, 35, 54]
The bottom is 19, left wing is [79, 35, 25], right wing is [*19*, 35, 54].
79..................54
    35..........35
        25. 
          ..19

a = [67, 93, 100, -16, 65, 97, 92]
make_valley(a) --> [100, 93, 67, *-16*, 65, 92, 97]
The bottom is -16, left wing [100, 93, 67] and right wing [65, 92, 97] have same length.
100.........................97
    93..........
               .........92
        67......
               .....65
            -16     

a = [66, 55, 100, 68, 46, -82, 12, 72, 12, 38]
make_valley(a) --> [100, 68, 55, 38, 12, *-82*, 12, 46, 66, 72]
The bottom is -82, left wing is [100, 68, 55, 38, 12]], right wing is [*-82*, 12, 46, 66, 72].

a = [14,14,14,14,7,14]
make_valley(a) => [14, 14, 14, *7*, 14, 14]

a = [14,14,14,14,14]
make_valley(a) => [14, 14, *14*, 14, 14]
A counter-example:
a = [17, 17, 15, 14, 8, 7, 7, 5, 4, 4, 1]
A solution could be [17, 17, 15, 14, 8, 1, 4, 4, 5, 7, 7]
but the right wing [4, 4, 5, 7, 7] is much flatter than the left one 
[17, 17, 15, 14, 8].

Summing the differences between left and right wing:
(17-7)+(17-7)+(15-5)+(14-4)+(8-4) = 44

Consider the following solution:
[17, 15, 8, 7, 4, 1, 4, 5, 7, 14, 17]
Summing the differences between left and right wing:
(17-17)+(15-14)+(8-7)+(7-5)+(4-4) = 4
The right wing is nearly as steep as the right one.
*/
class G9645 {
    public static makeValley(arr: number[]): number[] {
        const descArr: number[] = arr.sort((a, b) => b - a);
        console.log(descArr);

        let leftWing: number[] = [];
        let rightWing: number[] = [];

        for (let i = 0; i < descArr.length; i += 2) {
            console.log(descArr[i]);
            leftWing.push(descArr[i]);
            descArr.splice(i, 1);
            i -= 1;
        }
        console.log("left;", leftWing);
        console.log(descArr);
        rightWing = descArr.reverse();
        console.log("right;", rightWing);

        const solution: number[] = leftWing.concat(rightWing);
        console.log("solution:", solution);

        return solution;
    }
}

// testing(solution.G964.makeValley([17, 17, 15, 14, 8, 7, 7, 5, 4, 4, 1]), [17, 15, 8, 7, 4, 1, 4, 5, 7, 14, 17]);
// testing(solution.G964.makeValley([20, 7, 6, 2]), [20, 6, 2, 7]);
// testing(solution.G964.makeValley([14, 10, 8]), [14, 8, 10]);
// testing(solution.G964.makeValley([20, 18, 17, 13, 12, 12, 10, 9, 4, 2, 2, 1, 1]), [20, 17, 12, 10, 4, 2, 1, 1, 2, 9, 12, 13, 18]);

// [17, 15, 8, 7, 4, 1, 4, 5, 7, 14, 17]);
// console.log(G9645.makeValley([17, 17, 15, 14, 8, 7, 7, 5, 4, 4, 1]));
// [20, 6, 2, 7]
// console.log(G9645.makeValley([20, 7, 6, 2]));
// ❗️❗️❗️
// to deeply equal [ 55, 16 ]
// console.log(G9645.makeValley([-50, 16, 55, 48, 68]));
// ❗️❗️❗️
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: CALCULATE MEAN AND CONCAT STRINGS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You will be given an array which will include both integers and characters.

Return an array of length 2 with a[0] representing the mean of the ten integers as a floating point number. There will always be 10 integers and 10 characters. Create a single string with the characters and return it as a[1] while maintaining the original order.

lst = ['u', '6', 'd', '1', 'i', 'w', '6', 's', 't', '4', 'a', '6', 'g', '1', '2', 'w', '8', 'o', '2', '0']
Here is an example of your return

[3.6, "udiwstagwo"]
In C# and Java the mean return is a double.
*/
const mean = (list: string[]): [number, string] => {
    // list
    // => ['6', '1', '6', '4','6', '1', '2', '8','2', '0']
    // => 36
    // 3.6
    const ave =
        list
            .filter((el) => /\d/.test(el))
            .map((numStr) => Number(numStr))
            .reduce((acc, curr) => acc + curr) /
        list.filter((el) => /\d/.test(el)).length;
    console.log(ave);

    // list
    // => ['u', 'd', 'i', 'w','s', 't', 'a', 'g','w', 'o']
    // =>
    const charStr: string = list.filter((el) => /[^0-9]/.test(el)).join("");
    console.log(charStr);

    const solution: [number, string] = [ave, charStr];

    return solution;
};

let list = [
    "u",
    "6",
    "d",
    "1",
    "i",
    "w",
    "6",
    "s",
    "t",
    "4",
    "a",
    "6",
    "g",
    "1",
    "2",
    "w",
    "8",
    "o",
    "2",
    "0",
];
//   console.log(`Testing  ${lst}`);
//   assert.equal(JSON.stringify(solution.mean(lst)),JSON.stringify([3.6, "udiwstagwo"]));
//   lst = ["0", "c", "7", "x", "6", "2", "3", "5", "w", "7", "0", "y", "v", "u", "h", "i", "n", "u", "0", "0"];
//   console.log(`Testing  ${lst}`);
//   assert.equal(JSON.stringify(solution.mean(lst)),JSON.stringify([3.0, "cxwyvuhinu"]));
//   lst = ["0", "u", "a", "y", "0", "a", "9", "q", "3", "v", "g", "7", "6", "4", "y", "d", "8", "6", "0", "d"];
//   console.log(`Testing  ${lst}`);
//   assert.equal(JSON.stringify(solution.mean(lst)),JSON.stringify([4.3, "uayaqvgydd"]));
//   lst = ["s", "n", "9", "l", "0", "m", "i", "z", "9", "7", "y", "4", "z", "3", "3", "k", "4", "1", "0", "k"];
//   console.log(`Testing  ${lst}`);
//   assert.equal(JSON.stringify(solution.mean(lst)),JSON.stringify([4.0, "snlmizyzkk"]));
//   lst = ["5", "v", "u", "k", "8", "4", "9", "b", "9", "g", "5", "z", "3", "f", "6", "u", "i", "6", "6", "t"];
//   console.log(`Testing  ${lst}`);
//   assert.equal(JSON.stringify(solution.mean(lst)),JSON.stringify([6.1, "vukbgzfuit"]));
//   lst = ["1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "a", "a", "d", "d", "g", "q", "u", "v", "y", "y"];
//   console.log(`Testing  ${lst}`);
//   assert.equal(JSON.stringify(solution.mean(lst)),JSON.stringify([0.9, "aaddgquvyy"]));
//   lst = ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "a", "a", "d", "d", "g", "q", "u", "v", "y", "y"];
//   console.log(`Testing  ${lst}`);
//   assert.equal(JSON.stringify(solution.mean(lst)),JSON.stringify([1.0, "aaddgquvyy"]));

// console.log(mean(list));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function mean2(lst: string[]): any[] {
    let sum: number = 0;
    let count: number = 0;
    let str: string = "";

    for (let ch of lst) {
        if (ch >= "0" && ch <= "9") {
            sum += +ch;
            count += 1;
        } else {
            str += ch; // In JS/TS, '+=' operator may be fastest concat.
        }
    }

    return [sum / count, str];
}

function mean3(lst: string[]): [number, string] {
    const a: number =
        lst.reduce((sum, x) => sum + (/\d+/.test(x) ? +x : 0), 0) / 10;
    const b: string = lst.join("").replace(/\d/g, "");
    return [a, b];
}

const mean4 = (arr: string[]): [number, string] => {
    const [numbers, letters] = [/\d/, /[a-zA-Z]/].map((regex) =>
        arr.filter((value) => regex.test(value))
    );
    return [
        numbers.reduce((acc, n) => acc + parseInt(n), 0) / numbers.length,
        letters.reduce((acc, s) => acc + s, ""),
    ];
};

function mean5(lst: string[]): [number, string] {
    let numbers: any[] = [];
    let strings: any[] = [];
    lst.forEach((it: any) => {
        Number.isFinite(+it) ? numbers.push(+it) : strings.push(it);
    });
    return [
        numbers.reduce((n1, n2) => n1 + n2) / numbers.length,
        strings.join(""),
    ];
}

function mean6(lst: string[]): [number, string] {
    let arrNum = lst.filter((x) => x.match(/[0-9]/g)).map(Number);

    let len = arrNum.length;
    let valmis = arrNum.reduce((a, b) => a + b, 0);

    let arrStr = lst
        .filter((x) => x.match(/[a-z]/g))
        .map(String)
        .join("");

    return [valmis / len, arrStr];
}

//   function mean7(lst: string[]): [number, string] {
//     let sum = 0, chars = "";
//     for (let i = 0; i < lst.length; i++) {
//       if (!isNaN(lst[i])) sum += parseInt(lst[i]);
//       else chars += lst[i];
//     }
//     return [sum / 10, chars];
//   }

function mean8(lst: string[]) {
    var total: number = 0,
        str: string = "";
    for (let val of lst) {
        val.charCodeAt(0) > 64 ? (str += val) : (total += parseInt(val));
    }
    return [total / 10, str];
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// ❗️❗️❗️ LOOK INTO OBJECT.ENTRIES/VALUES/KEYS ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: SPLIT THE BILL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: OBJECT.ENTRIES/VALUES/KEYS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
It's tricky keeping track of who is owed what when spending money in a group. Write a function to balance the books.

The function should take one parameter: an object/dict with two or more name-value pairs which represent the members of the group and the amount spent by each.
The function should return an object/dict with the same names, showing how much money the members should pay or receive.
Further points:

The values should be positive numbers if the person should receive money from the group, negative numbers if they owe money to the group.
If value is a decimal, round to two decimal places.
Translations and comments (and upvotes!) welcome.

Example
3 friends go out together: A spends £20, B spends £15, and C spends £10. The function should return an object/dict showing that A should receive £5, B should receive £0, and C should pay £5.

var group = {
    A: 20, 
    B: 15, 
    C: 10
}


splitTheBill(group) // returns {A: 5, B: 0, C: -5}
*/
const splitTheBill = (obj: {
    [k: string]: number;
}): { [k: string]: number } => {
    // [ [ 'A', 20 ], [ 'B', 15 ], [ 'C', 10 ] ]
    console.log(Object.values(obj));

    // [ 20, 15, 10 ] => 45 / 3 => 15
    const aveCost: number =
        Object.values(obj).reduce((acc, curr) => {
            return acc + curr;
        }) / Object.values(obj).length;

    // LOOP OVER VALUES AND SUBSTRACT AVECOST TO GET AMOUNT TO RECEIVE
    for (let key in obj) {
        obj[key] = Number((obj[key] - aveCost).toFixed(2));
    }

    // { A: 5, B: 0, C: -5 }
    return obj;
};

// {A: 5, B: 0, C: -5}
// console.log(splitTheBill({ A: 20, B: 15, C: 10 }));
// {A: 15, B: 0, X: -15}
// console.log(splitTheBill({A: 40, B: 25, X: 10}));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// function splitTheBill2(x: Object): Object {
//     let j = Object.keys(x).reduce((sum, key) => sum + x[key], 0);
//     let average = j / Object.keys(x).length;
//     const result = {};
//     for (let key in x)
//         result[key] = Number((x[key] - average).toFixed(2));
//     return result;
// }

type NameValObj = { [k: string]: number };
type MyTuple = [string, number];

export function splitTheBill3(x: NameValObj): NameValObj {
    const entries: MyTuple[] = Object.entries(x);
    const sum = entries.reduce((s, [_, v]) => s + v, 0);
    const average = sum / entries.length;

    return entries.reduce((result: NameValObj, [k, v]) => {
        result[k] = Number((v - average).toFixed(2));
        return result;
    }, {});
}

// function splitTheBill4(group: Record<string, number>): Record<string, number> {
//     const names = Object.keys(group);

//     const count = names.length;
//     const total = names.map(name => group[name]).reduce((total, x) => total + x, 0);
//     const average = total / count;

//     const groupBalance = {};
//     for (const name of names) {
//         const value = group[name] - average;
//         const roundedValue = Math.round(value * 100) / 100;
//         groupBalance[name] = roundedValue;
//     }

//     return groupBalance;
// }

function splitTheBill5(x: { [k: string]: number }): { [k: string]: number } {
    const output: { [k: string]: number } = {};
    let total = 0;
    let cnt = 0;
    for (const v of Object.values(x)) {
        total += v;
        cnt++;
    }
    let avg = total / cnt;

    for (const [k, v] of Object.entries(x)) {
        output[k] = Math.round((v - avg) * 100) / 100;
    }
    return output;
}

interface Bills {
    [P: string]: number;
}

const isFloat = (num: number): boolean => {
    return num % 1 !== 0;
};

export function splitTheBill6(x: Bills): Bills {
    //code away...

    const bills: [string, number][] = [];
    for (const key in x) {
        bills.push([key, x[key]]);
    }

    const totalAmount: number = bills.reduce(
        (acc: number, bill: [string, number]) => acc + bill[1],
        0
    );
    const amountPerPerson: number = totalAmount / bills.length;

    bills.forEach((bill: [string, number]) => {
        let diff: number = bill[1] - amountPerPerson;
        if (isFloat(diff)) {
            diff = parseFloat(diff.toFixed(2));
        }
        bill[1] = diff;
        x[bill[0]] = bill[1];
    });

    return x;
}

function splitTheBill9(x: { [k: string]: number }): {
    [k: string]: number;
} {
    const avg =
        Object.keys(x).reduce((accumulator, key) => accumulator + x[key], 0) /
        Object.keys(x).length;

    return Object.keys(x).reduce((accumulator, key) => {
        return {
            ...accumulator,
            [key]: +(x[key] - avg).toFixed(2),
        };
    }, {});
}

function splitTheBill7(x: { [k: string]: number }): { [k: string]: number } {
    const avg =
        Object.values(x).reduce((sum: number, num: number) => sum + num) /
        Object.values(x).length;
    for (const key in x) {
        x[key] = +(x[key] - avg).toFixed(2);
    }
    return x;
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: VERY EVEN NUMBERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: RECURSION, WHILE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
Write a function that returns true if the number is a "Very Even" number.

If a number is a single digit, then it is simply "Very Even" if it itself is even.

If it has 2 or more digits, it is "Very Even" if the sum of its digits is "Very Even".

Examples
number = 88 => returns false -> 8 + 8 = 16 -> 1 + 6 = 7 => 7 is odd 

number = 222 => returns true -> 2 + 2 + 2 = 6 => 6 is even

number = 5 => returns false

number = 841 => returns true -> 8 + 4 + 1 = 13 -> 1 + 3 => 4 is even
Note: The numbers will always be 0 or positive integers!
*/

// 1️⃣ WHILE LOOP
const isVeryEvenNumber = (num: number): boolean => {
    // SINGLE DIGIT:
    if (num < 10 && !(num & 1)) {
        return true;
    } else {
        // LARGER THAN 9: KEEP ADDING DIGITS UNTIL SINGLE DIGIT NUMBER IS PRODUCED
        while (num > 9) {
            const numArr: number[] = String(num)
                .split("")
                .map((el) => Number(el));
            const sum: number = numArr.reduce((acc, curr) => acc + curr);
            num = sum;
        }
    }

    // NOW, CHECK IF SINGLE DIGIT NUMBER IS EVEN:
    const solution: boolean = !(num & 1);

    return solution;
};

// 2️⃣ RECURSION
const isVeryEvenNumber2 = (num: number): boolean => {
    const numArr: number[] = String(num)
        .split("")
        .map((el) => Number(el));
    const sum: number = numArr.reduce((acc, curr) => acc + curr);
    num = sum;

    const solution: boolean = !(num & 1);

    return num < 10 ? solution : isVeryEvenNumber(num);
};

// true
// console.log(isVeryEvenNumber(3));
// console.log(isVeryEvenNumber(222));
// false
// console.log(isVeryEvenNumber(88));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function isVeryEvenNumber3(n: number): boolean {
    if (n < 10) {
        return n % 2 === 0;
    }
    n = [...String(n)].reduce((acc, el) => acc + Number(el), 0);
    return isVeryEvenNumber(n);
}

function isVeryEvenNumber4(n: number): boolean {
    return !n-- || (n % 9) % 2 === 1;
}

var isVeryEvenNumber5 = (n: number): boolean => !!((--n % 9) % 2);

const isVeryEvenNumber6 = (n: number): boolean => !n-- || (n % 9) % 2 === 1;

function isVeryEvenNumber7(n: number): boolean {
    while (n > 9) {
        let sumDigits = 0;
        while (n) {
            const d = n % 10;
            sumDigits += d;
            n = (n - d) / 10;
        }
        n = sumDigits;
    }
    return n % 2 === 0;
}

function isVeryEvenNumber8(n: number): boolean {
    if (n < 10) {
        return n % 2 === 0;
    }
    return isVeryEvenNumber(
        n
            .toString()
            .split("")
            .reduce((p, c) => (p += parseInt(c)), 0)
    );
}
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES ❗️❗️❗️ FILTER()
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: FREQUENCY SEQUENCE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ COUNT OCCURENCES OF CHAR IN STRING ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: https://www.techiedelight.com/count-occurrences-character-string-javascript/
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Return an output string that translates an input string s/$s by replacing each character in s/$s with a number representing the number of times that character occurs in s/$s and separating each number with the character(s) sep/$sep.

freqSeq("hello world", "-"); // => "1-1-3-3-2-1-1-2-1-3-1"
freqSeq("19999999", ":"); // => "1:7:7:7:7:7:7:7"
freqSeq("^^^**$", "x"); // => "3x3x3x2x2x1"
*/

// 1️⃣ ERROR: SyntaxError: Invalid regular expression: /*/: Nothing to repeat
// NOT WORKING WITH SPECIAL CHARACTERS !
const freqSeq = (str: string, sep: string): string => {
    const numArr: number[] = [];

    for (let char of str) {
        let regex = new RegExp(char, "g"); //  ❗️❗️❗️ JS REGEX OBJECT ❗️❗️❗️
        // [ 'h' ], [ 'e' ], [ 'l', 'l', 'l' ].... ==> 1, 1, 3...
        let occurence: number = str.match(regex)!.length;
        // h 1, e 1, l 3, l 3, o 2,...
        console.log(char, occurence);
        numArr.push(occurence);
    }

    // [1, 1, 3, 3, 2,1, 1, 2, 1, 3, 1]
    console.log(numArr);

    // "1-1-3-3-2-1-1-2-1-3-1"
    const solution: string = numArr.join(sep);

    return solution;
};

// 2️⃣ ✅  ❗️❗️❗️ COUNT OCCURENCES OF CHAR IN STRING WITH FILTER() ❗️❗️❗️
const freqSeq2 = (str: string, sep: string): string => {
    const numArr: number[] = [];

    for (let char of str) {
        const counter = [...str].filter((el) => el === char).length;
        numArr.push(counter);
    }

    const solution: string = numArr.join(sep);

    return solution;
};

/*

❗️❗️❗️ COUNT OCCURENCES OF CHAR IN STRING ❗️❗️❗️

1. Using Regex
Regular expressions are often used in JavaScript for matching a text with a pattern. The following code example demonstrates its usage to get the count of the characters in the string. It uses the match() method of the string instance.

var str = "A,B,C,D,E";
 
var count = (str.match(/\,/g) || []).length;
console.log(count);
 
    Output: 4

 
The match() method returns null if there were no matches. To avoid calling the length property on the null value, we have used the logical OR operator [].

2. Using String.prototype.split() function
Here, the idea is to split the string using the given character as a delimiter and determine the count using the resulting array’s length. This can be easily done using the split() method:

var str = "A,B,C,D,E";
var ch = ',';
 
var count = str.split(ch).length - 1;
console.log(count);
 
    Output: 4

3. Using Array.prototype.filter() function
Another alternative is to filter the array to allow only those values matching the given character. This would translate to a simple code below:

var str = "A,B,C,D,E";
var ch = ',';
 
var count = [...str].filter(x => x === ch).length;
console.log(count);
 

    Output: 4

*/

// assert.equal(solution.freqSeq("hello world", "-"), "1-1-3-3-2-1-1-2-1-3-1");
//     assert.equal(solution.freqSeq("19999999", ":"), "1:7:7:7:7:7:7:7");
//     assert.equal(solution.freqSeq("^^^**$", "x"), "3x3x3x2x2x1");

// console.log(freqSeq("hello world", "-"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: SEARCH FOR LETTERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ ARRAY.FILL, NEW REGEXP() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Create a function which accepts one arbitrary string as an argument, and return a string of length 26.

The objective is to set each of the 26 characters of the output string to either '1' or '0' based on the fact whether the Nth letter of the alphabet is present in the input (independent of its case).

So if an 'a' or an 'A' appears anywhere in the input string (any number of times), set the first character of the output string to '1', otherwise to '0'. if 'b' or 'B' appears in the string, set the second character to '1', and so on for the rest of the alphabet.

For instance:

"a   **&  cZ"  =>  "10100000000000000000000001"
*/
const change = (string: string): string => {
    const alphabet: string = "abcdefghijklmnopqrstuvwxyz";

    let solution: string = "";

    for (let char of alphabet) {
        // console.log(char);
        solution += string.toLowerCase().indexOf(char) > -1 ? "1" : "0";
    }

    // console.log(solution);

    return solution;
};

// "11000000000000000000000001"
// console.log(change("a **&  bZ"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ NEW REGEXP() ❗️❗️❗️
function change2(string: string): string {
    // ❓❓❓  new RegExp(`${x}`, "i") ❓❓❓
    return "abcdefghijklmnopqrstuvwxyz"
        .split("")
        .map((x) => (new RegExp(`${x}`, "i").test(string) ? "1" : "0"))
        .join("");
}

// ARRAY.FILL()
function change3(str: string): string {
    const result = Array(26).fill(0);
    for (const ch of str.toUpperCase()) {
        if (ch >= "A" && ch <= "Z") {
            result[ch.charCodeAt(0) - 65] = 1;
        }
    }
    return result.join("");
}

function change5(s: string): string {
    let returnStr = "";
    for (let i = 65; i < 91; i++) {
        if (s.toUpperCase().includes(String.fromCharCode(i))) {
            returnStr = returnStr.concat("1");
        } else {
            returnStr = returnStr.concat("0");
        }
    }
    return returnStr;
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: DRONE FLY-BY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: SUBSTRING(), REPEAT()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The other day I saw an amazing video where a guy hacked some wifi controlled lightbulbs by flying a drone past them. Brilliant.

In this kata we will recreate that stunt... sort of.

You will be given two strings: lamps and drone. lamps represents a row of lamps, currently off, each represented by x. When these lamps are on, they should be represented by o.

The drone string represents the position of the drone T (any better suggestion for character??) and its flight path up until this point =. The drone always flies left to right, and always begins at the start of the row of lamps. Anywhere the drone has flown, including its current position, will result in the lamp at that position switching on.

Return the resulting lamps string. See example tests for more clarity.
*/
// 1️⃣ THIS ONLY COUNTS "=" IN '====T'
const flyBy = (lampsArr: string, droneArr: string): string => {
    if (!/=/g.test(droneArr)) return lampsArr;

    const dist: number = droneArr.match(/=/g)!.length;

    const solution: string = `${"o".repeat(dist)}${lampsArr.substring(dist)}`;

    return solution;
};

// 2️⃣ ✅ JUST GET DRONEARR.LENGTH !!!
const flyBy2 = (lampsArr: string, droneArr: string): string => {
    const dist: number =
        lampsArr.length > droneArr.length ? droneArr.length : lampsArr.length;

    const solution: string = `${"o".repeat(dist)}${lampsArr.substring(dist)}`;

    return solution;
};

// assert.strictEqual(flyBy('xxxxxx', '====T'), 'ooooox');
//     assert.strictEqual(flyBy('xxxxxxxxx', '==T'), 'oooxxxxxx');
//     assert.strictEqual(flyBy('xxxxxxxxxxxxxxx', '=========T'), 'ooooooooooxxxxx');

// console.log(flyBy("xxxxxxxxx", "==T"));
// console.log(flyBy2("xxxxxx", "12345"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
const flyBy3 = (lamps: string, drone: string): string =>
    drone.length >= lamps.length
        ? "o".repeat(lamps.length)
        : "o".repeat(drone.length) + "x".repeat(lamps.length - drone.length);

function flyBy4(lamps: string, drone: string): string {
    const droneIndex = drone.length - 1;
    const lampsArray = lamps.split("");
    lampsArray.forEach((lamp, index) => {
        if (index <= droneIndex) {
            lampsArray[index] = "o";
        }
    });
    return lampsArray.join("");
}

function flyBy5(lamps: string, drone: string): string {
    return [...lamps].fill("o", 0, drone.length).join("");
}

function flyBy6(lamps: string, drone: string): string {
    return (
        "o".repeat(Math.min(drone.length, lamps.length)) +
        "x".repeat(Math.max(0, lamps.length - drone.length))
    );
}

function flyBy7(lamps: string, drone: string): string {
    let l = drone.length;
    while (l--) lamps = lamps.replace("x", "o");
    return lamps;
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: CORRECT THE TIME-STRING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: PADSTART, NEW DATE, TOLOCALETIMESTRING
// ❗️❗️❗️ REGEX MATCH EXACT TIME FORMAT ❗️❗️❗️
// ❗️❗️❗️ DECLARE ARRAY ELEMENTS TO VARIABLES ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A new task for you!

You have to create a method, that corrects a given time string.
There was a problem in addition, so many of the time strings are broken.
Time is formatted using the 24-hour clock, so from 00:00:00 to 23:59:59.
Examples
"09:10:01" -> "09:10:01"  
"11:70:10" -> "12:10:10"  
"19:99:99" -> "20:40:39"  
"24:01:01" -> "00:01:01"  
If the input-string is null or empty return exactly this value! (empty string for C++) If the time-string-format is invalid, return null. (empty string for C++)
*/
const timeCorrect = (timeStr: string | null): string | null => {
    // NOT NECESSARY
    // if (timeStr === null) return null;
    if (!timeStr) return timeStr;

    // MATCH dd:dd:dd FORMAT
    const re = /\d{2}:\d{2}:\d{2}/;
    // ALSO, CHECK LENGTH IS 8
    const isValidFormat: boolean = re.test(timeStr) && timeStr.length === 8;

    if (!isValidFormat) return null;

    // [ 9, 10, 1 ]
    const hmsArr: number[] = timeStr.split(":").map((str) => Number(str));

    // [ 9, 10, 1 ] => 33001
    const getSeconds = (numArr: number[]) => {
        return numArr[0] * 3600 + numArr[1] * 60 + numArr[2];
    };

    let totalSeconds: number = getSeconds(hmsArr);

    // COUNT HOURS, MINS AND SECS:   33001 =>  9 10 1
    let hour: number = 0,
        min: number = 0,
        sec: number = 0;

    if (totalSeconds > 3599) {
        hour += Math.floor(totalSeconds / 3600) % 24;
        totalSeconds = totalSeconds % 3600;
    }
    if (totalSeconds > 59) {
        min += Math.floor(totalSeconds / 60);
        totalSeconds = totalSeconds % 60;
    }
    sec = totalSeconds;

    // 9 10 1 - NEED TO PAD TO TWO AND FORMAT
    let solutionArr: number[] = [hour, min, sec];

    // 1 => "01"
    const padToTwo = (num: number): string => {
        return num < 10 ? `0${num}` : num.toString();
    };

    // [ '09', '10', '01' ]
    const padSolArr: string[] = solutionArr.map((num) => padToTwo(num));

    // 09:10:01
    const solution: string = padSolArr.join(":");

    return solution;
};

// it("Basic Tests", function() {
//     // Null or Empty
//     assert.equal(solution.timeCorrect(null), null);
//     assert.equal(solution.timeCorrect(""), "");

// // Invalid Format
//     assert.equal(solution.timeCorrect("001122"), null);
//     assert.equal(solution.timeCorrect("00;11;22"), null);
//     assert.equal(solution.timeCorrect("0a:1c:22"), null);

// // Correction Tests
//     assert.equal(solution.timeCorrect("09:10:01"), "09:10:01");
//     assert.equal(solution.timeCorrect("11:70:10"), "12:10:10");
//     assert.equal(solution.timeCorrect("19:99:09"), "20:39:09");
//     assert.equal(solution.timeCorrect("19:99:99"), "20:40:39");
//     assert.equal(solution.timeCorrect("24:01:01"), "00:01:01");
//     assert.equal(solution.timeCorrect("52:01:01"), "04:01:01");

// console.log(timeCorrect("52:01:01"));
// console.log(timeCorrect("001122"));
// console.log(timeCorrect(""));
// console.log(timeCorrect(null));
// console.log(timeCorrect("09:10:01"));
// console.log(timeCorrect("19:99:09"));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// ❗️❗️❗️ REGEX MATCH EXACT TIME FORMAT ❗️❗️❗️
function timeCorrect2(ts: String): string | null {
    if (ts === "") return "";
    if (ts === null || !ts.match(/^[0-9][0-9]\:[0-9][0-9]\:[0-9][0-9]$/))
        return null;
    // ❗️❗️❗️ DECLARE ARRAY ELEMENTS TO VARIABLES ❗️❗️❗️
    let [h, m, s] = ts.split(":").map((v) => parseInt(v));
    let temp: number = 0;
    [s, temp] = convToUp(s);
    [m, temp] = convToUp(m + temp);
    h = (h + temp) % 24;
    return [h, m, s]
        .map((v) => `0${v}`.substr(v.toString().length - 1))
        .join(":");
}

function convToUp(num: number): number[] {
    let s: number = num % 60;
    let temp: number = (num - s) / 60;
    return [s, temp];
}
//   ==========================================================

// ❗️❗️❗️ MATCH EXACT TIME FORMAT ❗️❗️❗️
function timeCorrect3(timestring: string | null): string | null {
    if (!timestring || timestring === "") return timestring;
    else if (!/^\d\d:\d\d:\d\d$/.test(timestring)) return null;
    let [h, m, s]: number[] = timestring.split(":").map((x) => +x);
    m += Math.floor(s / 60);
    h += Math.floor(m / 60);
    return [h % 24, m % 60, s % 60]
        .map((x) => ("" + x).padStart(2, "0"))
        .join(":");
}

function timeCorrect4(timestring: string): string | null {
    if (timestring === null || timestring === "") return timestring;
    if (!timestring.match(/^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]/)) return null;
    let [h, m, s] = timestring.split(":").map((s) => parseInt(s));
    if (s >= 60) {
        s -= 60;
        m++;
    }
    if (m >= 60) {
        m -= 60;
        h++;
    }
    h = h % 24;
    return `${h < 10 ? "0" + h : h}:${m < 10 ? "0" + m : m}:${s < 10 ? "0" + s : s
        }`;
}

const timeCorrect5 = (timestring: string | null): string | null => {
    if (timestring == "") return "";
    else if (!timestring) return null;

    const [house, minutes, seconds] = timestring.split(":").map(Number);
    if (!(house && minutes && seconds)) return null;

    return new Date(0, 0, 0, house, minutes, seconds).toLocaleTimeString(
        "en-GB",
        { hour12: false }
    );
};

function timeCorrect6(timestring: string | null): string | null {
    if (timestring === "") return "";
    if (timestring === null || !/\d{2}:\d{2}:\d{2}/.test(timestring))
        return null;

    let timeArr = timestring.split(":");
    let totalSeconds =
        (+timeArr[0] * 60 * 60 + +timeArr[1] * 60 + +timeArr[2]) % 86400;

    let hours = Math.floor(totalSeconds / 3600);
    let minutes = Math.floor((totalSeconds - hours * 3600) / 60);
    let seconds = totalSeconds - hours * 3600 - minutes * 60;

    return `${hours.toString().padStart(2, "0")}:${minutes
        .toString()
        .padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: EXTRA PERFECT NUMBERS (Special Numbers Series #7)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ODD NUMBERS UP TO N INCLUSIVE, STARTSWITH, ENDSWITHD
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Definition
Extra perfect number is the number that first and last bits are set bits.

Task
Given a positive integer N , Return the extra perfect numbers in range from 1 to N .
*/
const extraPerfect = (num: number): number[] => {
    let solution: number[] = [];
    for (let i = 0; i <= num; i += 1) {
        if (i & 1) {
            solution.push(i);
        }
    }
    return solution;
};

// it("Testing for 3", () => assert.deepEqual(extraPerfect(3), [1, 3]));
//   it("Testing for 5", () => assert.deepEqual(extraPerfect(5), [1, 3, 5]));
//   it("Testing for 7", () => assert.deepEqual(extraPerfect(7), [1, 3, 5, 7]));
//   it("Testing for 28", () => assert.deepEqual(extraPerfect(28), [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27]));
//   it("Testing for 39", () =>

// console.log(extraPerfect(15));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function extraPerfect2(n: number) {
    let r = [];
    for (let i = 1; i <= n; i++) {
        let b = i.toString(2);
        if (b[0] === "1" && b[b.length - 1] === "1") r.push(i);
    }
    return r;
}

function extraPerfect3(n: number) {
    let output = [];
    for (let i = 1; i <= n; i++) {
        if (
            i.toString(2).charAt(0) == "1" &&
            i.toString(2).charAt(i.toString(2).length - 1) == "1"
        ) {
            output.push(i);
        }
    }
    return output;
}

function extraPerfect4(n: number) {
    let res: number[] = [];
    for (let i = 1; i <= n; i++) {
        let bin = i.toString(2);
        if (bin.startsWith("1") && bin.endsWith("1")) res.push(i);
    }
    return res;
}

const extraPerfect5 = (n: number): number[] =>
    [...Array(n)].map((_, i) => i + 1).filter((n) => n % 2);

function extraPerfect6(n: number): number[] {
    let numbers = new Array<number>(Math.ceil(n / 2));
    for (let i = 0; i < numbers.length; i++) {
        numbers[i] = 2 * i + 1;
    }
    return numbers;
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: REPLACE EVERY NTH
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
Write a method, that replaces every nth char oldValue with char newValue.

Method:

replaceNth(text:string, n:number, oldValue:string, newValue:string):string
Example:
n:         2
oldValue: 'a'
newValue: 'o'
"Vader said: No, I am your father!" -> "Vader soid: No, I am your fother!"
  1     2          3        4       -> 2nd and 4th occurence are replaced
Your method has to be case sensitive!

As you can see in the example: The first changed is the 2nd 'a'. So the start is always at the nth suitable char and not at the first!

If n is 0 or negative or if it is larger than the count of the oldValue, return the original text without a change.

The text and the chars will never be null.
*/
const replaceNth = (
    str: string,
    nth: number,
    oldVal: string,
    newVal: string
): string => {
    const lettersArr: string[] = str.split("");
    // console.log(lettersArr);

    let counter: number = 0;

    for (let i = 0; i < lettersArr.length; i += 1) {
        const current = lettersArr[i];
        // console.log(current);
        if (current === oldVal) {
            counter += 1;
            console.log(current);
            if (counter % nth === 0) {
                lettersArr[i] = newVal;
            }
        }
    }
    console.log(counter);
    console.log(lettersArr);
    const solution: string = lettersArr.join("");
    return solution;
};

// "Vader soid: No, I am your fother!"
// console.log(replaceNth("Vader said: No, I am your father!", 2, "a", "o"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function replaceNth2(
    s: string,
    n: number,
    a: string,
    b: string,
    c = 0
): string {
    return s
        .split("")
        .map((e) => (e === a ? (++c === n ? ((c = 0) ? b : b) : e) : e))
        .join("");
}

function replaceNth3(
    text: string,
    n: number,
    oldValue: string,
    newValue: string
): string {
    let count = 0;
    return text.split("").reduce((acc, elm, index) => {
        if (elm === oldValue && n > 0) {
            count++;
            if (!(count % n)) return acc.concat(newValue);
        }
        return acc.concat(elm);
    }, "");
}

function replaceNth4(
    text: string,
    n: number,
    oldValue: string,
    newValue: string
): string {
    if (n < 1) return text;
    let matches = 0;
    return text.replace(
        new RegExp(oldValue, "g"),
        (match) => (matches++, matches % n ? match : newValue)
    );
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: SPOONERIZE ME
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: SWAP CHARACTERS IN WORDS, SLICE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A spoonerism is a spoken phrase in which the first letters of two of the words are swapped around, often with amusing results.

In its most basic form a spoonerism is a two word phrase in which only the first letters of each word are swapped:

"not picking" --> "pot nicking"

Your task is to create a function that takes a string of two words, separated by a space: words and returns a spoonerism of those words in a string, as in the above example. A "word" in the context of this kata can contain any of the letters A through Z in upper or lower case, and the numbers 0 to 9. Though spoonerisms are about letters in words in the domain of written and spoken language, numbers are included in the inputs for the random test cases and they require no special treatment.

NOTE: All input strings will contain only two words. Spoonerisms can be more complex. For example, three-word phrases in which the first letters of the first and last words are swapped: "pack of lies" --> "lack of pies" or more than one letter from a word is swapped: "flat battery --> "bat flattery" You are NOT expected to account for these, or any other nuances involved in spoonerisms.
*/
const spoonerize = (wordStr: string): string => {
    // [ 'n', 'o', 't' ],['p', 'i', 'c','k', 'i', 'n','g']
    const lettersArr: string[][] = wordStr
        .split(" ")
        .map((word) => word.split(""));

    // n p
    const first: string = lettersArr[0][0];
    const second: string = lettersArr[1][0];

    // // [ 'p', 'o', 't' ],['n', 'i', 'c','k', 'i', 'n','g']
    lettersArr[0][0] = second;
    lettersArr[1][0] = first;

    // pot nicking
    let solution: string = lettersArr
        .map((arr) => {
            return arr.join("");
        })
        .join(" ");

    return solution;
};

// "pot nicking"
// console.log(spoonerize("not picking"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function spoonerize2(words: string): string {
    const [word1, word2] = words.split(" ");
    const sword1 = `${word2[0]}` + word1.slice(1);
    const sword2 = `${word1[0]}` + word2.slice(1);

    return `${sword1} ${sword2}`;
}

function spoonerize3(words: string): string {
    let arr: string[] = words.split(" ");
    let a = arr[0][0];
    let b = arr[1][0];
    return b + arr[0].slice(1) + " " + a + arr[1].slice(1);
}

const spoonerize4 = (words: string): string => {
    const [a, b] = words.split(" ");
    return `${b.charAt(0)}${a.substr(1)} ${a.charAt(0)}${b.substr(1)}`;
};

// =====================================================
function spoonerize5(words: string): string {
    let [word1, word2]: string[] = words.split(" ");
    let spoonerizedWord1: string = spoonerizeWord(word1, word2);
    let spoonerizedWord2: string = spoonerizeWord(word2, word1);
    return `${spoonerizedWord1} ${spoonerizedWord2}`;
}

function spoonerizeWord(word1: string, word2: string): string {
    return `${word2[0]}${word1.slice(1)}`;
}
// =====================================================

function spoonerize7(words: string): string {
    let list: string[] = words.split(" ");
    let a: string = list[0][0];
    let b: string = list[1][0];
    return `${b + list[0].slice(1)} ${a + list[1].slice(1)}`;
}

function spoonerize8(words: string): string {
    const arr = words.split(" ");
    return [arr[1][0] + arr[0].slice(1), arr[0][0] + arr[1].slice(1)].join(" ");
}
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: HEAD, TAIL, INIT AND LAST
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ ARRAY METHODS, CLASS PROPERTIES(PRIVATE, PUBLIC, STATIC) ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Haskell has some useful functions for dealing with lists:

$ ghci
GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
λ head [1,2,3,4,5]
1
λ tail [1,2,3,4,5]
[2,3,4,5]
λ init [1,2,3,4,5]
[1,2,3,4]
λ last [1,2,3,4,5]
5
Your job is to implement these functions in your given language. Make sure it doesn't edit the array; that would cause problems! Here's a cheat sheet:

| HEAD | <----------- TAIL ------------> |
[  1,  2,  3,  4,  5,  6,  7,  8,  9,  10]
| <----------- INIT ------------> | LAST |

head [x] = x
tail [x] = []
init [x] = []
last [x] = x
Here's how I expect the functions to be called in your language:

head([1,2,3,4,5]); => 1
tail([1,2,3,4,5]); => [2,3,4,5]
Most tests consist of 100 randomly generated arrays, each with four tests, one for each operation. There are 400 tests overall. No empty arrays will be given. Haskell has QuickCheck tests
*/

// ❗️❗️❗️ SLICE RETURNS ARRAY ❗️❗️❗️
class Kata6 {
    // HEAD: 1
    public static head = (arr: number[]): number => {
        return arr[0];
    };
    // TAIL: [ 2, 3, 4, 5 ]
    public static tail = (arr: number[]): number[] => {
        return arr.slice(1);
    };

    // INIT: [ 1, 2, 3, 4 ]
    public static init = (arr: number[]): number[] => {
        return arr.slice(0, -1);
    };

    // LAST: 5
    public static last = (arr: number[]): number => {
        return arr[arr.length - 1];
    };
}

// console.log(Kata6.head([1, 2, 3, 4, 5]));
// console.log(Kata6.tail([1, 2, 3, 4, 5]));
// console.log(Kata6.init([1, 2, 3, 4, 5]));
// console.log(Kata6.last([1, 2, 3, 4, 5]));

//============= OTHER CODEWARS SOLUTIONS: =============

// class Kata61 {
//     public static head = (a) => a[0];
//     public static tail = (a) => a.slice(1);
//     public static init = (a) => a.slice(0, -1);
//     public static last = (a) => a[a.length - 1];
// }

const Kata62 = {
    head: <A>(arr: A[]): A => arr[0],
    tail: <A>(arr: A[]): A[] => arr.slice(1),
    init: <A>(arr: A[]): A[] => arr.slice(0, arr.length - 1),
    last: <A>(arr: A[]): A => arr[arr.length - 1],
};

class Kata63 {
    static head<T>([head, ..._]: T[]): T {
        return head;
    }
    static tail<T>([_, ...tail]: T[]): T[] {
        return tail;
    }
    static init<T>(arr: T[]): T[] {
        return arr.slice(0, -1);
    }
    static last<T>(arr: T[]): T {
        return arr.slice(-1)[0];
    }
}

class Kata64 {
    static tail = (arr: number[]): number[] => {
        return arr.slice(1, arr.length);
    };

    static init = (arr: number[]): number[] => {
        return arr.slice(0, -1);
    };

    static last = (arr: number[]): number => {
        return arr[arr.length - 1];
    };

    static head = (arr: number[]): number => {
        return arr[0];
    };
}

class Kata65 {
    static head(list: Array<Number> = []): Number {
        const a = list[0];
        return a;
    }

    static tail(list: Array<Number> = []): Array<Number> {
        const c: Array<Number> = [];
        for (let i = 1; i < list.length; i++) {
            c.push(list[i]);
        }
        return c;
    }

    static init(list: Array<Number> = []): Array<Number> {
        const c: Array<Number> = [];
        for (let i = 0; i < list.length - 1; i++) {
            c.push(list[i]);
        }
        return c;
    }

    static last(list: Array<Number> = []): Number {
        const a = list[list.length - 1];
        return a;
    }
}

class Kata66 {
    static head(array: Array<any>) {
        return array[0];
    }
    static tail(array: Array<any>) {
        let temp = [...array];
        temp.shift();
        return temp;
    }
    static init(array: Array<any>) {
        let temp = [...array];
        temp.pop();
        return temp;
    }
    static last(array: Array<any>) {
        let temp = [...array];
        return temp.pop();
    }
}

class Kata67 {
    static head<T>([head, ..._]: T[]): T {
        return head;
    }
    static tail<T>([_, ...tail]: T[]): T[] {
        return tail;
    }
    static init<T>(arr: T[]): T[] {
        return arr.slice(0, -1);
    }
    static last<T>(arr: T[]): T {
        return arr.slice(-1)[0];
    }
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: NUMBERS WITH THIS DIGIT INSIDE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ VARRAY.FROM() TO REPLACE LOOP, NEW REGEXP() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You have to search all numbers from inclusive 1 to inclusive a given number x, that have the given digit d in it.
The value of d will always be 0 - 9.
The value of x will always be greater than 0.

You have to return as an array

the count of these numbers,
their sum
and their product.

For example:
x = 11
d = 1
->
Numbers: 1, 10, 11
Return: [3, 22, 110]

If there are no numbers, which include the digit, return [0,0,0].
*/
const numbersWithDigitInside = (range: number, digit: number): number[] => {
    let matches: number[] = [];

    for (let i = 1; i <= range; i += 1) {
        if (i.toString().indexOf(digit.toString()) > -1) {
            matches.push(i);
        }
    }
    console.log(matches);

    if (matches.length === 0) return [0, 0, 0];

    const count: number = matches.length;
    const sum: number = matches.reduce((acc, curr) => acc + curr);
    const prod: number = matches.reduce((acc, curr) => acc * curr);

    const solution: number[] = [count, sum, prod];

    return solution;
};

// [ 0, 0, 0]
// console.log(numbersWithDigitInside(5, 6));
// [ 1, 6, 6]
// console.log(numbersWithDigitInside(7, 6));
// [ 2, 30, 200]
// console.log(numbersWithDigitInside(20, 0));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function numbersWithDigitInside2(x: number, d: number): number[] {
    let numbers: number[] = [];
    for (let i: number = 1; i <= x; i++) {
        if (~i.toString().indexOf(d.toString())) {
            numbers.push(i);
        }
    }
    return [
        numbers.length,
        numbers.reduce((a, b) => a + b, 0),
        numbers.length === 0 ? 0 : numbers.reduce((a, b) => a * b),
    ];
}

// ❗️❗️❗️ VARRAY.FROM() TO REPLACE LOOP, NEW REGEXP() ❗️❗️❗️
// function numbersWithDigitInside3(x, d) {
//     return Array
//         .from(Array(x), (x, i) => i + 1)
//         .reduce((r, e) => new RegExp(d).test(String(e)) ? [r[0] + 1, r[1] + e, r[2] ? r[2] * e : e] : r, [0, 0, 0]);
// }

function numbersWithDigitInside4(x: number, d: number): number[] {
    let numbers: number[] = [];
    for (let i = 1; i <= x; i++) {
        if (String(i).indexOf(String(d)) !== -1) {
            numbers.push(i);
        }
    }
    return [
        numbers.length,
        numbers.reduce((a: number, b: number) => a + b, 0),
        numbers.length === 0
            ? 0
            : numbers.reduce((a: number, b: number) => a * b),
    ];
}

function numbersWithDigitInside5(x: number, d: number): number[] {
    let count = 0,
        sum = 0,
        product = 0;

    for (let i = 1; i <= x; i++) {
        if (("" + i).indexOf("" + d) != -1) {
            count++;
            sum += i;
            product = (product == 0 ? 1 : product) * i;
        }
    }
    return [count, sum, product];
}

function numbersWithDigitInside6(x: number, d: number): number[] {
    const set: number[] = [];
    for (let i = 1; i <= x; i++) set.push(i);
    const match: number[] = set.filter(
        (test) => test.toString().indexOf(d.toString()) >= 0
    );
    return match.length
        ? [
            match.length,
            match.reduce((a, b) => a + b),
            match.reduce((a, b) => a * b),
        ]
        : [0, 0, 0];
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: HELP BOB COUNT LETTERS AND DIGITS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: COUNT LETTERS AND DIGITS, REPLACE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Bob is a lazy man.

He needs you to create a method that can determine how many letters (both uppercase and lowercase ASCII letters) and digits are in a given string.

Example:

"hel2!lo" --> 6

"wicked .. !" --> 6

"!?..A" --> 1
*/

const countLettersAndDigits = (str: string): number => {
    if (!/[a-z0-9]/gi.test(str)) return 0;

    const matches: string[] = str.match(/[a-z0-9]/gi)!;

    return matches.length;
};

// 6
// console.log(countLettersAndDigits("hel2!lo"));
// console.log(countLettersAndDigits("5>>a,!b!"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function countLettersAndDigits2(input: string): number {
    return [...input].map((it) => it.replace(/[^a-z0-9]/gi, "")).join("")
        .length;
}

function countLettersAndDigits3(input: string): number {
    return input.replace(/[^A-Za-z0-9]/g, "").length;
}

function countLettersAndDigits4(input: string): number {
    let temp: number = 0;
    input.split("").forEach((i) => (i.match(/^[a-z0-9]+$/i) ? temp++ : temp));
    return temp;
}

function countLettersAndDigits5(input: string): number {
    let countArr: Array<any> = input.match(/[0-9A-Za-z]/g) || [];
    return countArr.length;
}

function countLettersAndDigits6(input: string): number {
    const array = input.match(/[a-z0-9]/gi);

    return array ? array.length : 0;
}

function countLettersAndDigits7(input: string): number {
    return input.split("").filter(function (v) {
        if (48 <= v.charCodeAt(0) && v.charCodeAt(0) <= 57) return true; //1~9
        if (65 <= v.charCodeAt(0) && v.charCodeAt(0) <= 90) return true; //A~Z
        if (97 <= v.charCodeAt(0) && v.charCodeAt(0) <= 122) return true; //a~z

        return false;
    }).length;
}
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: SCALING SQUARED STRINGS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: STRING.REPEAT ALTERNATIVE, REPLACE(FUNCTON), LINEBREAK - \n NEWLINE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:  https://stackoverflow.com/questions/1877475/repeat-a-string-in-javascript-a-number-of-times
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You are given a string of n lines, each substring being n characters long. For example:

s = "abcd\nefgh\nijkl\nmnop"

We will study the "horizontal" and the "vertical" scaling of this square of strings.

A k-horizontal scaling of a string consists of replicating k times each character of the string (except '\n').

Example: 2-horizontal scaling of s: => "aabbccdd\neeffgghh\niijjkkll\nmmnnoopp"
A v-vertical scaling of a string consists of replicating v times each part of the squared string.

Example: 2-vertical scaling of s: => "abcd\nabcd\nefgh\nefgh\nijkl\nijkl\nmnop\nmnop"
Function scale(strng, k, v) will perform a k-horizontal scaling and a v-vertical scaling.

Example: a = "abcd\nefgh\nijkl\nmnop"
scale(a, 2, 3) --> "aabbccdd\naabbccdd\naabbccdd\neeffgghh\neeffgghh\neeffgghh\niijjkkll\niijjkkll\niijjkkll\nmmnnoopp\nmmnnoopp\nmmnnoopp"
Printed:

abcd   ----->   aabbccdd
efgh            aabbccdd
ijkl            aabbccdd
mnop            eeffgghh
                eeffgghh
                eeffgghh
                iijjkkll
                iijjkkll
                iijjkkll
                mmnnoopp
                mmnnoopp
                mmnnoopp
Task:
Write function scale(strng, k, v) k and v will be positive integers. If strng == "" return "".
*/
class G9643 {
    public static scale = (
        str: string,
        repeatChar: number,
        repeatSub: number
    ): string => {
        if (str.length === 0) return "";

        // DOUBLE EVERY CHAR [ 'abcd', 'efgh', 'ijkl', 'mnop' ]
        const subStrArr: string[] = str.split("\n");

        // [ 'aabbccdd\n', 'eeffgghh\n', 'iijjkkll\n', 'mmnnoopp\n' ]
        const horizontal: string[] = subStrArr
            // ❗️❗️❗️ REPLACE(FUNCTON) ❗️❗️❗️
            .map((sub) => {
                return sub
                    .replace(/./g, function (match) {
                        // return match.repeat(repeatChar);
                        // ❗️❗️❗️ STRING.REPEAT ALTERNATIVE ❗️❗️❗️
                        return Array(repeatChar + 1).join(match);
                    })
                    .concat("\n");
            });
        // DOUBLE EVERY SUBSTRING ['aabbccdd\naabbccdd\n','eeffgghh\neeffgghh\n',
        // 'iijjkkll\niijjkkll\n','mmnnoopp\nmmnnoopp\n']
        const vertical: string[] = horizontal.map((sub) => {
            // return sub.repeat(repeatSub);
            return Array(repeatSub + 1).join(sub);
        });
        const solution: string = vertical.join("").slice(0, -1);

        return solution;
    };
}

/*
❗️❗️❗️ STRING.REPEAT ALTERNATIVE❗️❗️❗️ CODEWARS GIVES ERROR: Property 'repeat' does not exist on type 'string'. (2339)
These days, the repeat string method is implemented almost everywhere. (It is not in Internet Explorer.) So unless you need to support older browsers, you can simply write:

❗️❗️❗️ 1️⃣   "a".repeat(10)

Before repeat, we used this hack:

❗️❗️❗️ 2️⃣    Array(11).join("a") // create string with 10 a's: "aaaaaaaaaa"

(Note that an array of length 11 gets you only 10 "a"s, since Array.join puts the argument between the array elements.)
*/

// "Kj\nKj\nSH\nSH"
// console.log(G9643.scale("Kj\nSH", 1, 2));
// "aabbccdd\naabbccdd\naabbccdd\neeffgghh\neeffgghh\neeffgghh\niijjkkll\niijjkkll\niijjkkll\nmmnnoopp\nmmnnoopp\nmmnnoopp"
// console.log(G9643.scale("abcd\nefgh\nijkl\nmnop", 2, 2));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const scale2 = (strng: string, k: number, n: number) =>
    strng
        .replace(/[^\n]/g, (x) => Array(k + 1).join(x))
        .replace(/[^\n]+/g, (x) =>
            Array(n + 1)
                .join("\n" + x)
                .trim()
        );

const scale3 = (strng: string, k: number, n: number) => {
    if (strng.length === 0) return "";
    var a = strng
        .split("\n")
        .map(function (x) {
            var y = x
                .split("")
                .map(function (z) {
                    return Array(k + 1).join(z);
                })
                .join("");
            return Array(n + 1).join(y + "\n");
        })
        .join("");
    return a.substring(0, a.length - 1);
};
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: NICE ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: SPLICE, MINUS ARRAY, ARR.SOME
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A Nice array is defined to be an array where for every value n in the array, there is also an element n - 1 or n + 1 in the array.

examples:

[2, 10, 9, 3] is a nice array because

 2 =  3 - 1
10 =  9 + 1
 3 =  2 + 1
 9 = 10 - 1

[4, 2, 3] is a nice array because

4 = 3 + 1
2 = 3 - 1
3 = 2 + 1 (or 3 = 4 - 1)

[4, 2, 1] is a not a nice array because

for n = 4, there is neither n - 1 = 3 nor n + 1 = 5
Write a function named isNice/IsNice that returns true if its array argument is a Nice array, else false. An empty array is not considered nice.
*/
class Kata1 {
    static isNice(arr: number[]): boolean {
        // INIT SOLUTION AS FALSE
        let solution: boolean = false;

        for (let i = 0; i < arr.length; i += 1) {
            // RESET NUM ARR TO ORIGINAL: [ 2, 10, 9, 3 ]
            const numArr: number[] = arr.slice();
            // REMOVE CURRENT NUM: [ 10, 9, 3 ] 2 IS REMOVED
            numArr.splice(i, 1);
            // CHECK IF SOME ELEMENT MEETS CONDITION: BOOLEAN
            solution = numArr.some(
                (el) => el + 1 === arr[i] || el - 1 === arr[i]
            );
            // AS SOON AS CURRENT NUM IS FALSE, STOP LOOP AND RETURN DEFAULT FALSE
            if (!solution) break;
        }

        // RETURN SOLUTION (true) IF ALL ITERATIONS HAVE RETURNED TRUE FOR SOLUION
        return solution;
    }
}

// true
// console.log(Kata1.isNice([2, 10, 9, 3]));
// false
// console.log(Kata1.isNice([8, 4, 5, 3]));

/*
iteration: 0 num: 2
   numArr: [ 2, 10, 9, 3 ]
       minus Array: [ 10, 9, 3 ]
iteration: 1 num: 10
   numArr: [ 2, 10, 9, 3 ]
       minus Array: [ 2, 9, 3 ]
iteration: 2 num: 9
   numArr: [ 2, 10, 9, 3 ]
       minus Array: [ 2, 10, 3 ]
iteration: 3 num: 3
   numArr: [ 2, 10, 9, 3 ]
       minus Array: [ 2, 10, 9 ]
true
iteration: 0 num: 8
   numArr: [ 8, 4, 5, 3 ]
       minus Array: [ 4, 5, 3 ]
false
*/

//============= OTHER CODEWARS SOLUTIONS: =============
function isNice2(arr: number[]) {
    let set = new Set(arr);

    return (
        arr.length !== 0 && arr.every((v) => set.has(v - 1) || set.has(v + 1))
    );
}

// const isNice3 = $ => $.length ? $.every(el => $.includes(el-1) || $.includes(el+1)) : false;

function isNice4(arr: number[]) {
    return (
        arr.length > 0 &&
        arr.every((n) => arr.includes(n - 1) || arr.includes(n + 1))
    );
}
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ TRY WITH WHILE LOOP ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: SEE U NEXT HAPPY YEAR - YEAR WITH DISTINCT DIGITS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: RECURSION, ❓❓❓ WHAT IS CYCLE ❓❓❓
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Scenario
You're saying good-bye your best friend , See you next happy year .

Happy Year is the year with only distinct digits , (e.g) 2018

Task
Given a year, Find The next happy year or The closest year You'll see your best friend!alt!alt

Notes
Year Of Course always Positive .
Have no fear , It is guaranteed that the answer exists .
It's not necessary that the year passed to the function is Happy one .
Input Year with in range (1000  ≤  y  ≤  9000)
Input >> Output Examples:
nextHappyYear (7712) ==> return (7801)
Explanation:
As the Next closest year with only distinct digits is 7801 .

nextHappyYear (8989) ==> return (9012)
Explanation:
As the Next closest year with only distinct digits is 9012 .

nextHappyYear (1001) ==> return (1023)
Explanation:
As the Next closest year with only distinct digits is 1023 .
*/
const nextHappyYear = (year: number): number => {
    year += 1;

    let digitsArr = year.toString().split("");
    let uniqueDigits = new Set<string>(digitsArr);

    // console.log(year, digitsArr, uniqueDigits);

    return digitsArr.length > uniqueDigits.size ? nextHappyYear(year) : year;
};

/*
console.log(nextHappyYear(1001));

1002 [ '1', '0', '0', '2' ] Set(3) { '1', '0', '2' }
1003 [ '1', '0', '0', '3' ] Set(3) { '1', '0', '3' }
1004 [ '1', '0', '0', '4' ] Set(3) { '1', '0', '4' }
1005 [ '1', '0', '0', '5' ] Set(3) { '1', '0', '5' }
1006 [ '1', '0', '0', '6' ] Set(3) { '1', '0', '6' }
1007 [ '1', '0', '0', '7' ] Set(3) { '1', '0', '7' }
1008 [ '1', '0', '0', '8' ] Set(3) { '1', '0', '8' }
1009 [ '1', '0', '0', '9' ] Set(3) { '1', '0', '9' }
1010 [ '1', '0', '1', '0' ] Set(2) { '1', '0' }
1011 [ '1', '0', '1', '1' ] Set(2) { '1', '0' }
1012 [ '1', '0', '1', '2' ] Set(3) { '1', '0', '2' }
1013 [ '1', '0', '1', '3' ] Set(3) { '1', '0', '3' }
1014 [ '1', '0', '1', '4' ] Set(3) { '1', '0', '4' }
1015 [ '1', '0', '1', '5' ] Set(3) { '1', '0', '5' }
1016 [ '1', '0', '1', '6' ] Set(3) { '1', '0', '6' }
1017 [ '1', '0', '1', '7' ] Set(3) { '1', '0', '7' }
1018 [ '1', '0', '1', '8' ] Set(3) { '1', '0', '8' }
1019 [ '1', '0', '1', '9' ] Set(3) { '1', '0', '9' }
1020 [ '1', '0', '2', '0' ] Set(3) { '1', '0', '2' }
1021 [ '1', '0', '2', '1' ] Set(3) { '1', '0', '2' }
1022 [ '1', '0', '2', '2' ] Set(3) { '1', '0', '2' }
1023 [ '1', '0', '2', '3' ] Set(4) { '1', '0', '2', '3' }
1023
*/

// 1023
// console.log(nextHappyYear(1001));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function nextHappyYear2(year: number): number {
    year += 1;
    while (new Set("" + year).size != 4) {
        year++;
    }
    return year;
}

function nextHappyYear3(year: number) {
    let res = year;
    do {
        res++;
    } while (
        +res
            .toString()
            .split("")
            .filter((el, i, arr) => arr.indexOf(el) === i)
            .join("") != res
    );
    return res;
}

function nextHappyYear4(year: number): number {
    while (3 > 2) {
        let shake = new Set(String(++year).split(""));
        if (shake.size === 4) break;
    }
    return year;
}

function nextHappyYear5(year: number): number {
    let digits_of_the_year = year.toString().split("").map(Number);

    do {
        year++;
        digits_of_the_year = year.toString().split("").map(Number);
    } while (
        digits_of_the_year[3] == digits_of_the_year[2] ||
        digits_of_the_year[3] == digits_of_the_year[1] ||
        digits_of_the_year[3] == digits_of_the_year[0] ||
        digits_of_the_year[2] == digits_of_the_year[1] ||
        digits_of_the_year[2] == digits_of_the_year[0] ||
        digits_of_the_year[1] == digits_of_the_year[0]
    );
    return year;
}

// ❓❓❓ WHAT IS CYCLE ❓❓❓
function nextHappyYear6(year: number) {
    cicle: for (let i = year + 1; i <= 9999; i++) {
        if (new Set(i.toString().split("")).size == 4) {
            return i;
            break cicle;
        }
    }
}

function nextHappyYear7(year: number): number {
    year++;
    const arr = Array.from(year.toString());
    if (new Set(arr).size !== arr.length) {
        return nextHappyYear(year);
    } else {
        return year;
    }
}

function nextHappyYear8(year: number) {
    while ([...new Set(("" + ++year).split(""))].length < 4) { }
    return year;
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: FILL THE HARD DISK DRIVE - Computer problem series #1
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:❗️❗️❗️  REDUCE WITH COUNTER OBJECT ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to determine how many files of the copy queue you will be able to save into your Hard Disk Drive. The files must be saved in the order they appear in the queue.

Input:
Array of file sizes (0 <= s <= 100)
Capacity of the HD (0 <= c <= 500)
Output:
Number of files that can be fully saved in the HD.
Examples:
save([4,4,4,3,3], 12) -> 3
# 4+4+4 <= 12, but 4+4+4+3 > 12
save([4,4,4,3,3], 11) -> 2
# 4+4 <= 11, but 4+4+4 > 11
Do not expect any negative or invalid inputs.
*/

const save = (sizesArr: number[], storage: number): number => {
    let freeSpace: number = storage,
        solution: number = 0;

    for (let i = 0; i < sizesArr.length; i += 1) {
        freeSpace -= sizesArr[i];
        if (freeSpace < 0) {
            break;
        }
        solution += 1;
    }

    return solution;
};

// 3
// console.log(save([4, 4, 4, 3, 3], 11));
// 0
// console.log(save([11, 13, 15, 17, 19], 8));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function save2(sizes: number[], hd: number) {
    return sizes.reduce((a, v) => {
        if ((hd -= v) >= 0) a++;
        return a;
    }, 0);
}

function save3(sizes: number[], hd: number) {
    let currentCapacity: number = 0;
    let totalSavedFiles: number = 0;
    for (let index = 0; index < sizes.length; index++) {
        if (currentCapacity + sizes[index] <= hd) {
            currentCapacity += sizes[index];
            totalSavedFiles += 1;
        } else {
            break;
        }
    }
    return totalSavedFiles;
}

// ❗️❗️❗️  REDUCE WITH COUNTER OBJECT ❗️❗️❗️
const save4 = (sizes: number[], hd: number): number =>
    sizes.reduce(
        ({ total, files }, n) => ({
            total: total + n,
            files: total + n <= hd ? files + 1 : files,
        }),
        { total: 0, files: 0 }
    ).files;

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: Simple Fun #2 - CIRCLE OF NUMBERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ MATH.TRUNC ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Consider integer numbers from 0 to n - 1 written down along the circle in such a way that the distance between any two neighbouring numbers is equal (note that 0 and n - 1 are neighbouring, too).

Given n and firstNumber/first_number/first-number, find the number which is written in the radially opposite position to firstNumber.

Example
For n = 10 and firstNumber = 2, the output should be 7



Input/Output
[input] integer n

A positive even integer.

Constraints: 4 ≤ n ≤ 1000.

[input] integer firstNumber/first_number/first-number

Constraints: 0 ≤ firstNumber ≤ n - 1

[output] an integer
*/
const circleOfNumbers = (num: number, firstNum: number): number => {
    return firstNum < num / 2 ? num / 2 + firstNum : firstNum - num / 2;
};
// 7
// console.log(circleOfNumbers(10, 2));
// console.log(circleOfNumbers(6, 3));
// console.log();
// console.log();
// console.log();

/*
❗️❗️❗️ MATH.TRUNC ❗️❗️❗️
Math.trunc(8.76) => 8
The Math.trunc() method returns the integer part of a number.

Note: This method will NOT round the number up/down to the nearest integer, but simply remove the decimals.
*/
//============= OTHER CODEWARS SOLUTIONS: =============

function circleOfNumbers2(n: number, firstNumber: number): number {
    return (firstNumber + n / 2) % n;
}

function circleOfNumbers3(n: number, firstNumber: number) {
    const result = firstNumber - n / 2;
    return result == 0 ? 0 : result > 0 ? 0 + result : n + result;
}

function circleOfNumbers4(n: number, firstNumber: number) {
    let midPoint = n / 2;
    let result = 0;
    if (firstNumber === midPoint) {
        return 0;
    }
    if (firstNumber > midPoint) {
        return firstNumber - midPoint;
    }
    return firstNumber + midPoint;
}

// ❗️❗️❗️ MATH.TRUNC ❗️❗️❗️
function circleOfNumbers5(n: number, firstNumber: number) {
    const stepSize = 360 / n;
    const stepCount = 180 / stepSize;
    return Math.trunc((firstNumber + stepCount) % n);
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: LOOKING FOR A BANEFACTOR
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The accounts of the "Fat to Fit Club (FFC)" association are supervised by John as a volunteered accountant. The association is funded through financial donations from generous benefactors. John has a list of the first n donations: [14, 30, 5, 7, 9, 11, 15] He wants to know how much the next benefactor should give to the association so that the average of the first n + 1 donations should reach an average of 30. After doing the math he found 149. He thinks that he could have made a mistake.

if dons = [14, 30, 5, 7, 9, 11, 15] then new_avg(dons, 30) --> 149

Could you help him?

Task
The function new_avg(arr, navg) should return the expected donation (rounded up to the next integer) that will permit to reach the average navg.

Should the last donation be a non positive number (<= 0) John wants us:

to return:

Nothing in Haskell, Elm
None in F#, Ocaml, Rust, Scala
-1 in C, D, Fortran, Nim, PowerShell, Go, Pascal, Prolog, Lua, Perl
or to throw an error (some examples for such a case):

IllegalArgumentException() in Clojure, Java
ArgumentException() in C#
echo ERROR in Shell
argument-error in Racket
std::invalid_argument in C++
ValueError in Python
So, he will clearly see that his expectations are not great enough. In "Sample Tests" you can see what to return.

Notes:
all donations and navg are numbers (integers or floats), arr can be empty.
See examples below and "Sample Tests" to see which return is to be done.
new_avg([14, 30, 5, 7, 9, 11, 15], 92) should return 645
new_avg([14, 30, 5, 7, 9, 11, 15], 2) 
should raise an error (ValueError or invalid_argument or argument-error or DomainError or ... ) 
or return `-1` or ERROR or Nothing or None depending on the language.
*/

// 1️⃣
const newAvg = (donations: number[], targetAvg: number): number => {
    // IF EMPTY ARRAY, RETURN TARGETAVG
    if (!donations.length) return targetAvg;
    // CALC EXPECTED SUM OF DONATIONS AFTER RECEIVING NEXT DONATION (+1)
    // 720 = 90 * (7 + 1)
    const targetSum: number = targetAvg * (donations.length + 1);
    // GET CURRENT SUM
    const currentSum: number = donations.reduce((acc, curr) => acc + curr);
    // SOLUTION = 720 - 92 ROUNDED UP TO NEAREST INT = 628
    const solution: number = Math.ceil(targetSum - currentSum);
    // IF AVE IS TOO LOW
    if (solution <= 0) throw new Error("Expected New Average is too low");

    return solution;
};
// 2️⃣
const newAvg2 = (dons: number[], targetAvg: number): number => {
    if (!dons.length) return targetAvg;

    const solution: number = Math.ceil(
        targetAvg * (dons.length + 1) - dons.reduce((acc, curr) => acc + curr)
    );

    if (solution <= 0) throw new Error("Expected New Average is too low");

    return solution;
};

// 628
// console.log(newAvg2([14, 30, 5, 7, 9, 11, 16], 90));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function newAvg3(arr: number[], newavg: number): number | string {
    const out = Math.ceil(
        newavg * (arr.length + 1) - arr.reduce((a, b) => a + b, 0)
    );
    if (out <= 0) {
        throw "Expected New Average is too low";
    }
    return out;
}

function newAvg4(arr: number[], newavg: number): any {
    const sum: number = arr.reduce((tot: number, val: number) => tot + val, 0);
    const don: number = (arr.length + 1) * newavg - sum;
    if (don < 0) {
        throw new Error("Expected New Average is too low");
    }
    return Math.ceil(don);
}

function newAvg5(arr: number[], newavg: number): any {
    let donate = Math.ceil(
        newavg * (arr.length + 1) - arr.reduce((a, b) => a + b, 0)
    );
    if (donate <= 0) throw "Expected New Average is too low";
    return donate;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: PRODUCT OF ARRAY  (Array Series #5)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ REDUCE WITH INITIAL VALUE ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
Given an array/list [] of integers , Construct a product array Of same size Such That prod[i] is equal to The Product of all the elements of Arr[] except Arr[i].

Notes
Array/list size is at least 2 .

Array/list's numbers Will be only Positives

Repetition of numbers in the array/list could occur.

Input >> Output Examples
productArray ({12,20}) ==>  return {20,12}
Explanation:
The first element in prod [] array 12 is the product of all array's elements except the first element

The second element 20 is the product of all array's elements except the second element .

productArray ({1,5,2}) ==> return {10,2,5}
Explanation:
The first element 10 is the product of all array's elements except the first element 1

The second element 2 is the product of all array's elements except the second element 5

The Third element 5 is the product of all array's elements except the Third element 2.

productArray ({10,3,5,6,2}) return ==> {180,600,360,300,900}
Explanation:
The first element 180 is the product of all array's elements except the first element 10

The second element 600 is the product of all array's elements except the second element 3

The Third element 360 is the product of all array's elements except the third element 5

The Fourth element 300 is the product of all array's elements except the fourth element 6

Finally ,The Fifth element 900 is the product of all array's elements except the fifth element 2
*/

// 1️⃣
const productArray = (nums: number[]): number[] => {
    const totalProd: number = nums.reduce((acc, curr) => acc * curr);

    const solution: number[] = nums.map((num) => totalProd / num);

    return solution;
};

// 2️⃣  SHORTER:
const productArray2 = (nums: number[]): number[] => {
    return nums.map((num) => nums.reduce((acc, curr) => acc * curr) / num);
};

// [20, 12]
// console.log(productArray([12, 20]));
// [216, 24, 162, 324]
// console.log(productArray2([3, 27, 4, 2]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ REDUCE WITH INITIAL VALUE ❗️❗️❗️
function productArray3(nums: number[]): number[] {
    let n: number = nums.reduce((a, b) => a * b, 1);
    return nums.map((x) => n / x);
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: CREDIT CARD ISSUER CHECKING (RANDOM TESTS NOT 100%)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: TEST, BEGINS, STARTSWITH
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: https://stackoverflow.com/questions/72768/how-do-you-detect-credit-card-type-based-on-number
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a credit card number we can determine who the issuer/vendor is with a few basic knowns.

Complete the function getIssuer() that will use the values shown below to determine the card issuer for a given card number. If the number cannot be matched then the function should return the string Unknown.

Where Issuer is defined with the following enum type.

enum Issuer {
  VISA = 'VISA',
  AMEX = 'AMEX',
  Mastercard = 'Mastercard',
  Discover = 'Discover',
  Unknown = 'Unknown',
}
Examples
getIssuer(4111111111111111) == "VISA"
getIssuer(4111111111111) == "VISA"
getIssuer(4012888888881881) == "VISA"
getIssuer(378282246310005) == "AMEX"
getIssuer(6011111111111117) == "Discover"
getIssuer(5105105105105100) == "Mastercard"
getIssuer(5105105105105106) == "Mastercard"
getIssuer(9111111111111111) == "Unknown"
*/

enum Issuer {
    VISA = "VISA",
    AMEX = "AMEX",
    Mastercard = "Mastercard",
    Discover = "Discover",
    Unknown = "Unknown",
}

const getIssuer = (cardNum: number): string => {
    const cardNumStr: string = cardNum.toString();

    let solution: string = "";

    interface StrKeyVal {
        [key: string]: any;
    }

    const re: StrKeyVal = {
        // electron: /^(4026|417500|4405|4508|4844|4913|4917)\d+$/,
        // maestro: /^(5018|5020|5038|5612|5893|6304|6759|6761|6762|6763|0604|6390)\d+$/,
        // dankort: /^(5019)\d+$/,
        // interpayment: /^(636)\d+$/,
        // unionpay: /^(62|88)\d+$/,
        VISA: /^4[0-9]{12}(?:[0-9]{3})?$/,
        Mastercard: /^5[1-5][0-9]{14}$/,
        AMEX: /^3[47][0-9]{13}$/,
        // diners: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
        Discover: /^6(?:011|5[0-9]{2})[0-9]{12}$/,
        // jcb: /^(?:2131|1800|35\d{3})\d{11}$/
    };

    for (let key in re) {
        if (re[key].test(cardNumStr)) {
            // solution = Issuer[key]; // ❗️❗️❗️ ERROR
            solution = key;
            break;
        } else {
            // solution = Issuer.Unknown; // ❗️❗️❗️ ARROR
            solution = "Unknown";
        }
    }

    return solution;
};

// Issuer.VISA
// console.log(getIssuer(4111111111111111));
// Issuer.AMEX
// console.log(getIssuer(378282246310005));
// Issuer.Unknown
// console.log(getIssuer(9111111111111111));
// console.log();

function detectCardType(number: string) {
    var re = {
        electron: /^(4026|417500|4405|4508|4844|4913|4917)\d+$/,
        maestro:
            /^(5018|5020|5038|5612|5893|6304|6759|6761|6762|6763|0604|6390)\d+$/,
        dankort: /^(5019)\d+$/,
        interpayment: /^(636)\d+$/,
        unionpay: /^(62|88)\d+$/,
        visa: /^4[0-9]{12}(?:[0-9]{3})?$/,
        mastercard: /^5[1-5][0-9]{14}$/,
        amex: /^3[47][0-9]{13}$/,
        diners: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
        discover: /^6(?:011|5[0-9]{2})[0-9]{12}$/,
        jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
    };

    // for (var key in re) {
    //     if (re[key].test(number)) {
    //         return key
    //     }
    // }
}

/*
The credit/debit card number is referred to as a PAN, or Primary Account Number. The first six digits of the PAN are taken from the IIN, or Issuer Identification Number, belonging to the issuing bank (IINs were previously known as BIN — Bank Identification Numbers — so you may see references to that terminology in some documents). These six digits are subject to an international standard, ISO/IEC 7812, and can be used to determine the type of card from the number.

Unfortunately the actual ISO/IEC 7812 database is not publicly available, however, there are unofficial lists, both commercial and free, including on Wikipedia.

Anyway, to detect the type from the number, you can use a regular expression like the ones below: Credit for original expressions

Visa: ^4[0-9]{6,}$ Visa card numbers start with a 4.

MasterCard: ^5[1-5][0-9]{5,}|222[1-9][0-9]{3,}|22[3-9][0-9]{4,}|2[3-6][0-9]{5,}|27[01][0-9]{4,}|2720[0-9]{3,}$ Before 2016, MasterCard numbers start with the numbers 51 through 55, but this will only detect MasterCard credit cards; there are other cards issued using the MasterCard system that do not fall into this IIN range. In 2016, they will add numbers in the range (222100-272099).

American Express: ^3[47][0-9]{5,}$ American Express card numbers start with 34 or 37.

Diners Club: ^3(?:0[0-5]|[68][0-9])[0-9]{4,}$ Diners Club card numbers begin with 300 through 305, 36 or 38. There are Diners Club cards that begin with 5 and have 16 digits. These are a joint venture between Diners Club and MasterCard and should be processed like a MasterCard.

Discover: ^6(?:011|5[0-9]{2})[0-9]{3,}$ Discover card numbers begin with 6011 or 65.

JCB: ^(?:2131|1800|35[0-9]{3})[0-9]{3,}$ JCB cards begin with 2131, 1800 or 35.

Unfortunately, there are a number of card types processed with the MasterCard system that do not live in MasterCard’s IIN range (numbers starting 51...55); the most important case is that of Maestro cards, many of which have been issued from other banks’ IIN ranges and so are located all over the number space. As a result, it may be best to assume that any card that is not of some other type you accept must be a MasterCard.

Important: card numbers do vary in length; for instance, Visa has in the past issued cards with 13 digit PANs and cards with 16 digit PANs. Visa’s documentation currently indicates that it may issue or may have issued numbers with between 12 and 19 digits. Therefore, you should not check the length of the card number, other than to verify that it has at least 7 digits (for a complete IIN plus one check digit, which should match the value predicted by the Luhn algorithm).

One further hint: before processing a cardholder PAN, strip any whitespace and punctuation characters from the input. Why? Because it’s typically much easier to enter the digits in groups, similar to how they’re displayed on the front of an actual credit card, i.e.

4444 4444 4444 4444
is much easier to enter correctly than

4444444444444444
There’s really no benefit in chastising the user because they’ve entered characters you don't expect here.

This also implies making sure that your entry fields have room for at least 24 characters, otherwise users who enter spaces will run out of room. I’d recommend that you make the field wide enough to display 32 characters and allow up to 64; that gives plenty of headroom for expansion.

*/

//============= OTHER CODEWARS SOLUTIONS: =============

const getIssuer2 = (x: number, $: string = x.toString()) =>
    (Number($.slice(0, 2)) === 34 || Number($.slice(0, 2)) === 37) &&
        $.length === 15
        ? "AMEX"
        : Number($.slice(0, 4)) === 6011 && $.length === 16
            ? "Discover"
            : Number($.slice(0, 2)) > 50 &&
                Number($.slice(0, 2)) < 56 &&
                $.length === 16
                ? "Mastercard"
                : Number($.slice(0, 1)) === 4 && ($.length === 13 || $.length === 16)
                    ? "VISA"
                    : "Unknown";

const getIssuer3 = (x: number): Issuer => {
    let cn: string = x.toString();
    switch (true) {
        case /^3[4,7]/.test(cn) && cn.length == 15:
            return Issuer.AMEX;
        case /^6011/.test(cn) && cn.length == 16:
            return Issuer.Discover;
        case /^5[1-5]/.test(cn) && cn.length == 16:
            return Issuer.Mastercard;
        case /^4/.test(cn) && (cn.length == 13 || cn.length == 16):
            return Issuer.VISA;
        default:
            return Issuer.Unknown;
    }
};

const getIssuer4 = (x: number) => {
    let str = x.toString();
    let len = str.length;
    let begin = { a: str.slice(0, 2), b: str.slice(0, 4), c: str.slice(0, 1) };
    if ((len === 16 || len === 13) && begin.c === "4") {
        return "VISA";
    } else if (
        len === 16 &&
        (begin.a === "51" ||
            begin.a === "52" ||
            begin.a === "53" ||
            begin.a === "54" ||
            begin.a === "55")
    ) {
        return "Mastercard";
    } else if (len === 16 && begin.b === "6011") {
        return "Discover";
    } else if (len === 15 && (begin.a === "34" || begin.a === "37")) {
        return "AMEX";
    }
    return "Unknown";
};

function getIssuer5(x: number): string {
    const test = (reg: RegExp): boolean => reg.test(`${x}`);
    if (test(/^(34|37)\d{13}$/)) return "AMEX";
    else if (test(/^6011\d{12}$/)) return "Discover";
    else if (test(/^(51|52|53|54|55)\d{14}$/)) return "Mastercard";
    else if (test(/^4((\d{12})|(\d{15}))$/)) return "VISA";
    return "Unknown";
}

const getIssuer6 = (x: number): string => {
    let creditCardNumber = x.toString();
    let ccFirstFour = creditCardNumber.substr(0, 4);
    let ccFirstTwo = creditCardNumber.substr(0, 2);
    let ccLength = creditCardNumber.length;

    enum Issuer {
        VISA = "VISA",
        AMEX = "AMEX",
        Mastercard = "Mastercard",
        Discover = "Discover",
        Unknown = "Unknown",
    }

    if (ccFirstFour == "6011" && ccLength == 16) {
        return Issuer.Discover;
    }
    if ((ccFirstTwo == "34" || ccFirstTwo == "37") && ccLength == 15) {
        return Issuer.AMEX;
    }
    if (
        creditCardNumber.substr(0, 1) == "4" &&
        (ccLength == 13 || ccLength == 16)
    ) {
        return Issuer.VISA;
    }
    if (
        (ccFirstTwo == "51" ||
            ccFirstTwo == "52" ||
            ccFirstTwo == "53" ||
            ccFirstTwo == "54" ||
            ccFirstTwo == "55") &&
        ccLength == 16
    ) {
        return Issuer.Mastercard;
    } else {
        return Issuer.Unknown;
    }
};

const getIssuer7 = (x: number): Issuer => {
    const s: string = x.toString();
    if (/^4(\d{12}|\d{15})$/.test(s)) return Issuer.VISA;
    if (/^3[4|7]\d{13}$/.test(s)) return Issuer.AMEX;
    if (/^6011\d{12}$/.test(s)) return Issuer.Discover;
    if (/^5[1-5]\d{14}$/.test(s)) return Issuer.Mastercard;
    return Issuer.Unknown;
};

const getIssuer9 = (x: number): Issuer => {
    if (String(x).length === 15 && /^34|37/.test(String(x))) return Issuer.AMEX;
    if (String(x).length === 16 && /^6011/.test(String(x)))
        return Issuer.Discover;
    if (String(x).length === 16 && /^51|^52|^53|^54|^55/.test(String(x)))
        return Issuer.Mastercard;
    if (String(x).length === 13 && /^4/.test(String(x))) return Issuer.VISA;
    if (String(x).length === 16 && /^4/.test(String(x))) return Issuer.VISA;

    return Issuer.Unknown;
};

const getIssuer10 = (x: number): Issuer => {
    const card_number = String(x);
    const data = [
        { type: Issuer.AMEX, begins: ["34", "37"], len: [15] },
        { type: Issuer.Discover, begins: ["6011"], len: [16] },
        {
            type: Issuer.Mastercard,
            begins: ["51", "52", "53", "54", "55"],
            len: [16],
        },
        { type: Issuer.VISA, begins: ["4"], len: [13, 16] },
    ];
    const res = data.find(
        (d) =>
            d.begins.some((b) => card_number.startsWith(b)) &&
            d.len.some((l) => card_number.length === l)
    );
    return res ? res.type : Issuer.Unknown;
};

const getIssuer8 = (x: number) =>
    Object.values(Issuer)[
    [
        /^4\d{12}(\d{3})?$/,
        /^3[47]\d{13}$/,
        /^5[1-5]\d{14}$/,
        /^6011\d{12}$/,
        /.*/,
    ].findIndex((p) => p.test(`${x}`))
    ];

const getIssuer11 = (x: number): Issuer => {
    const s = x.toString();
    if (s.length === 15 && (s.startsWith("34") || s.startsWith("37"))) {
        return Issuer.AMEX;
    } else if (s.length === 16 && s.startsWith("6011")) {
        return Issuer.Discover;
    } else if (
        s.length === 16 &&
        ["51", "52", "53", "54", "55"].includes(s.slice(0, 2))
    ) {
        return Issuer.Mastercard;
    } else if ((s.length === 13 || s.length === 16) && s.startsWith("4")) {
        return Issuer.VISA;
    } else {
        return Issuer.Unknown;
    }
};
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: LAST SURVIVOR - REMOVE CHARS FROM STRING IN ORDER OF APPEARANCE OF INXEX IN ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ SLICE() ❗️❗️❗️ REMOVE CHARS AT GIVEN INDEX FROM STRING ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You are given a string of letters and an array of numbers.
The numbers indicate positions of letters that must be removed, in order, starting from the beginning of the array.
After each removal the size of the string decreases (there is no empty space).
Return the only letter left.

Example:

let str = "zbk", arr = [0, 1]
    str = "bk", arr = [1]
    str = "b", arr = []
    return 'b'
Notes
The given string will never be empty.
The length of the array is always one less than the length of the string.
All numbers are valid.
There can be duplicate letters and numbers.
*/

// 1️⃣  WITH ARRAY SPLICE ❗️❗️❗️
const lastSurvivor = (letters: string, coords: number[]): string => {
    const lettersArr: string[] = letters.split("");

    coords.forEach((index) => {
        // DELETE CORRESPONDIN CHAR AT FOR EACH INDEX
        lettersArr.splice(index, 1);
    });

    // console.log("   lettersArr final:", lettersArr);

    return lettersArr[0];
};

// "b"
// console.log(lastSurvivor('kbc', [0, 1]));
// "a"
// console.log(lastSurvivor('abc', [1, 1]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function lastSurvivor2(letters: string, coords: number[]): string {
    return coords.reduce((s, p) => s.slice(0, p) + s.slice(p + 1), letters);
}

// 2️⃣ ❗️❗️❗️ WITH STRING SLICE() ❗️❗️❗️
function lastSurvivor3(letters: string, coords: number[]): string {
    coords.forEach((n) => {
        letters = letters.slice(0, n) + letters.slice(n + 1);
    });
    return letters;
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: RICE AND CHESSBOARD PROBLEM
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ TOSTRING(2).LENGTH, MATH.LOG2() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
I assume most of you are familiar with the ancient legend of the rice (but I see wikipedia suggests wheat, for some reason) problem, but a quick recap for you: a young man asks as a compensation only 1 grain of rice for the first square, 2 grains for the second, 4 for the third, 8 for the fourth and so on, always doubling the previous.

Your task is pretty straightforward (but not necessarily easy): given an amount of grains, you need to return up to which square of the chessboard one should count in order to get at least as many.

As usual, a few examples might be way better than thousands of words from me:

squaresNeeded(0) === 0
squaresNeeded(1) === 1
squaresNeeded(2) === 2
squaresNeeded(3) === 2
squaresNeeded(4) === 3
Input is always going to be valid/reasonable: ie: a non negative number; extra cookie for not using a loop to compute square-by-square (at least not directly) and instead trying a smarter approach [hint: some peculiar operator]; a trick converting the number might also work: impress me!

*/

const squaresNeeded = (numGrains: number): number => {
    if (!numGrains) return 0;

    let curr: number = 1,
        acc: number = 1,
        sqCounter: number = 1;

    while (acc < numGrains) {
        curr *= 2;
        // console.log("curr:", curr);
        acc += curr;
        // console.log("acc:", acc);
        sqCounter += 1;
        // console.log("sqCounter:", sqCounter);
    }

    // console.log("   solution:", sqCounter);

    return sqCounter;
};

// 3
// console.log(squaresNeeded(0));
// console.log(squaresNeeded(1));
// console.log(squaresNeeded(2));
// console.log(squaresNeeded(3));
// console.log(squaresNeeded(4));
// console.log(squaresNeeded(8));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ TOSTRING(2).LENGTH ❗️❗️❗️
// GRAINS = 4
// GRAINS.TOSTRING(2).LENGTH = 3 (4 IN BINARY IS "100")
// 4 && 3 => 3, 8 && 4 => 4
// RETURNS HOW MANY SQUARES NEEDED TO REACH NUMBER OF GRAINS
function squaresNeeded2(grains: number) {
    return grains && grains.toString(2).length;
}

// ❗️❗️❗️ LOG2(X) ❗️❗️❗️
// Example: What is log2(4000)?
// The answer completes the sentence:
// "4,000 is the result of 2 being raised to the power of..." The value of this expression is 11.965.
function squaresNeeded3(grains: number) {
    return grains ? Math.floor(Math.log2(grains) + 1) : 0;
}

function squaresNeeded4(grains: number) {
    // Search for 'sum of geometric series' and work backwards.
    // Eventually you get (sum + 1) equals (2 ** n)
    // log2 of (2 ** n) equals n.
    return Math.ceil(Math.log2(grains + 1));
}

function squaresNeeded5(grains: number) {
    let squares = 0;
    let squareSize = 1;
    let totalGrains = grains;
    while (totalGrains > 0) {
        totalGrains -= squareSize;
        squares++;
        squareSize *= 2;
    }

    return squares;
}

const squaresNeeded6 = (grains: number) => grains && ~~Math.log2(grains) + 1;

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: EVENS AND ODDS, EVENS TO BINARY ODDS TO HEX
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ CONVERT INTEGER TO BINARY/HEX ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
This kata is about converting numbers to their binary or hexadecimal representation:

If a number is even, convert it to binary.
If a number is odd, convert it to hex.
Numbers will be positive. The hexadecimal string should be lowercased.
*/

const evensAndOdds = (num: number): string => {
    // const binary: string = (num >>> 0).toString(2);
    const binary: string = num.toString(2);

    const hex: string = num.toString(16);

    return num & 1 ? hex : binary;
};

/*

❗️❗️❗️ CONVERT INTEGER TO BINARY ❗️❗️❗️ 
You can use Number.toString(2) function, but it has some problems when representing negative numbers. For example, (-1).toString(2) output is "-1".

To fix this issue, you can use the unsigned right shift bitwise operator (>>>) to coerce your number to an unsigned integer.

If you run (-1 >>> 0).toString(2) you will shift your number 0 bits to the right, which doesn't change the number itself but it will be represented as an unsigned integer. The code above will output "11111111111111111111111111111111" correctly.

This question has further explanation.

-3 >>> 0 (right logical shift) coerces its arguments to unsigned integers, which is why you get the 32-bit two's complement representation of -3.
*/

//   "10"
// console.log(evensAndOdds(2));
// "d"
// console.log(evensAndOdds(13));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const evensAndOdds2 = (n: number): string =>
    n % 2 === 0 ? n.toString(2) : n.toString(16);

function evensAndOdds3(n: number): string {
    return Number(n).toString(n % 2 == 0 ? 2 : 16);
}

// Shifting the n: number 0 bits to the right turns into unsigned int, thus converting negative numbers to positive
export const evensAndOdds4 = (n: number): string => {
    return n % 2 === 0 ? (n >>> 0).toString(2) : n.toString(16);
};

function evensAndOdds5(n: number): string {
    if (n & 1) {
        return n.toString(16);
    }
    return n.toString(2);
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: ODD-EVEN STRING SORT, (FIRST CHAR/ODDS/EVENS)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a string s. You have to return another string such that even-indexed and odd-indexed characters of s are grouped and groups are space-separated (see sample below)

Note: 
0 is considered to be an even index. 
All input strings are valid with no spaces
input: 'CodeWars'
output 'CdWr oeas'

S[0] = 'C'
S[1] = 'o'
S[2] = 'd'
S[3] = 'e'
S[4] = 'W'
S[5] = 'a'
S[6] = 'r'
S[7] = 's'
Even indices 0, 2, 4, 6, so we have 'CdWr' as the first group
odd ones are 1, 3, 5, 7, so the second group is 'oeas'
And the final string to return is 'Cdwr oeas'

*/

const sortMyString = (str: string): string => {
    let solution: string = "";
    let oddStr: string = "";
    let evenStr: string = "";

    for (let i = 0; i < str.length; i += 1) {
        let current: string = str[i];
        if ((i & 1) === 1) {
            oddStr += current;
        } else if ((i & 1) === 0) {
            evenStr += current;
        }
    }

    // console.log("odds:", oddStr, "evens:", evenStr);

    solution += evenStr + " " + oddStr;

    return solution;
};

// "CdWr oeas"
// console.log(sortMyString("CodeWars"));
// "YOU'RE CLEVER"
// console.log(sortMyString("YCOLUE'VREER"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function sortMyString2(S: string): string {
    var getEveryOtherLetter = (n: number) =>
        S.split("")
            .filter((_, i) => i % 2 === n)
            .join("");
    return `${getEveryOtherLetter(0)} ${getEveryOtherLetter(1)}`;
}

function sortMyString3(S: string): string {
    let even: string = "",
        odd: string = "";
    for (let i: number = 0; i < S.length; i++) {
        if (i === 0 || i % 2 === 0) even += S.charAt(i);
        else odd += S.charAt(i);
    }
    return even + " " + odd;
}

function sortMyString4(s: string): string {
    return (
        s
            .split("")
            .filter((_, i) => !(i % 2))
            .join("") +
        " " +
        s
            .split("")
            .filter((_, i) => i % 2)
            .join("")
    );
}

const sortMyString5 = (str: string): string =>
    [0, 1]
        .map((n) =>
            str
                .split("")
                .filter((_, index) => index % 2 === n)
                .join("")
        )
        .join(" ");

function sortMyString6(str: string): string {
    var a = str.split(""),
        sodd = [],
        seven = [];
    for (let i = 0; i < a.length; i++)
        if (i % 2 === 0) seven.push(a[i]);
        else sodd.push(a[i]);
    return seven.join("") + " " + sodd.join("");
}

function sortMyString7(S: string): string {
    let first = "",
        second = "",
        i;
    for (i = 0; i < S.length; i++) i & 1 ? (second += S[i]) : (first += S[i]);
    return `${first} ${second}`;
}

function sortMyString8(S: string): string {
    return (
        S.split("")
            .filter((e, i) => i % 2 === 0)
            .join("") +
        " " +
        S.split("")
            .filter((e, i) => i % 2 !== 0)
            .join("")
    );
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: MAXIMUM GAP (Array Series #4)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ MAP(EL, IDX, ARRAY) ❗️❗️❗️ CAN USE ACTUAL ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
Given an array/list [] of integers , Find The maximum difference between the successive elements in its sorted form.

Notes
Array/list size is at least 3 .

Array/list's numbers Will be mixture of positives and negatives also zeros_

Repetition of numbers in the array/list could occur.

The Maximum Gap is computed Regardless the sign.

Input >> Output Examples
maxGap ({13,10,5,2,9}) ==> return (4)
Explanation:
The Maximum Gap after sorting the array is 4 , The difference between 9 - 5 = 4 .
maxGap ({-3,-27,-4,-2}) ==> return (23)
Explanation:
The Maximum Gap after sorting the array is 23 , The difference between |-4- (-27) | = 23 .

Note : Regardless the sign of negativity .

maxGap ({-7,-42,-809,-14,-12}) ==> return (767)  
Explanation:
The Maximum Gap after sorting the array is 767 , The difference between | -809- (-42) | = 767 .

Note : Regardless the sign of negativity .

maxGap ({-54,37,0,64,640,0,-15}) //return (576)
Explanation:
The Maximum Gap after sorting the array is 576 , The difference between | 64 - 640 | = 576 .

Note : Regardless the sign of negativity .


*/

// 1️⃣
const maxGap = (numArr: number[]): number => {
    const sortedArr: number[] = numArr.sort((a, b) => a - b);
    let diffsArr: number[] = sortedArr
        .map((num, idx) => sortedArr[idx + 1] - num)
        .slice(0, -1);
    const solution: number = Math.max(...diffsArr);
    return solution;
};

// 2️⃣  COMPARE THIS WITH NUMBER 3 BELOW !!!
const maxGap2 = (numArr: number[]): number => {
    return Math.max(
        ...numArr
            .sort((a, b) => a - b)
            .map((num, idx) => numArr[idx + 1] - num)
            .slice(0, -1) // SLICE() TO REMOVE LAST ITEM NaN
    );
};

// 3️⃣ ❗️❗️❗️ MAP(EL, IDX, ARRAY) ❗️❗️❗️
const maxGap7 = (numArr: number[]): number => {
    return Math.max(
        ...numArr
            .sort((a, b) => a - b)
            .map((num, idx, arr) => arr[idx + 1] - num)
            .slice(0, -1)
    );
};

// 4
// console.log(maxGap([13, 10, 2, 9, 5]));
// console.log(maxGap2([13, 10, 2, 9, 5]));
// console.log(maxGap7([13, 10, 2, 9, 5]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ MAP(EL, IDX, ARRAY) ❗️❗️❗️
function maxGap6(nums: number[]) {
    return Math.max(
        ...nums
            .sort((a, b) => {
                return b - a;
            })
            .map((value, index, array) => {
                return index == array.length - 1 ? 0 : value - array[index + 1];
            })
    );
}

function maxGap3(nums: number[]): number {
    let arr: number[] = nums.slice().sort((x, y) => x - y);
    return Math.max(...arr.map((x, i, a) => a[i + 1] - x).slice(0, -1));
}

function maxGap4(nums: number[]) {
    const sorted = nums.sort((a, b) => b - a);
    let answer = Number.MIN_SAFE_INTEGER;

    for (let i = 0; i < sorted.length - 1; i++) {
        const temp = sorted[i] - sorted[i + 1];

        if (temp > answer) answer = temp;
    }
    return answer;
}

function maxGap5(nums: number[]): number {
    nums.sort((a, b) => b - a);
    let diff = 0;
    for (let i = 1; i < nums.length; i++) {
        if (Math.abs(nums[i] - nums[i - 1]) > diff) {
            diff = Math.abs(nums[i] - nums[i - 1]);
        }
    }
    return diff;
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: AVERAGE SCORES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ EVAL ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Create a function that returns the average of an array of numbers ("scores"), rounded to the nearest whole number. You are not allowed to use any loops (including for, for/in, while, and do/while loops).
*/

const average = (scoresArr: number[]): number => {
    return Math.round(
        scoresArr.reduce((acc, curr) => acc + curr) / scoresArr.length
    );
};

// var scores = [49, 3, 5, 300, 7];
// 73
// console.log(average(scores));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function average2(scores: number[]): number {
    // 1- Sum the values from the array
    const reducer = (total: number, currentValue: number) =>
        total + currentValue;
    const sumOfNumbers = scores.reduce(reducer);

    // 2- Get the length of the array
    const scoreLength = scores.length;
    // 3- Divide the array sum by the length
    return Math.round(sumOfNumbers / scoreLength);
}

function average3(scores: number[]): number {
    // ❗️❗️❗️ EVAL ❗️❗️❗️
    let sum = eval(scores.join("+"));
    let avg = sum / scores.length;
    return Math.round(avg);
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: MINIMUM STEPS  (Array Series #6)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ SORT() - MUTATES ORIGINAL, DON'T NEED TO SAVE TO VAR ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
Given an array of N integers, you have to find how many times you have to add up the smallest numbers in the array until their Sum becomes greater or equal to K.

Notes:
List size is at least 3.

All numbers will be positive.

Numbers could occur more than once , (Duplications may exist).

Threshold K will always be reachable.

Input >> Output Examples
minimumSteps({1, 10, 12, 9, 2, 3}, 6)  ==>  return (2)
Explanation:
We add two smallest elements (1 + 2), their sum is 3 .

Then we add the next smallest number to it (3 + 3) , so the sum becomes 6 .

Now the result is greater or equal to 6 , Hence the output is (2) i.e (2) operations are required to do this .

minimumSteps({8 , 9, 4, 2}, 23)  ==> return (3)
Explanation:
We add two smallest elements (4 + 2), their sum is 6 .

Then we add the next smallest number to it (6 + 8) , so the sum becomes 14 .

Now we add the next smallest number (14 + 9) , so the sum becomes 23 .

Now the result is greater or equal to 23 , Hence the output is (3) i.e (3) operations are required to do this .

minimumSteps({19,98,69,28,75,45,17,98,67}, 464)  ==>  return (8)
Explanation:
We add two smallest elements (19 + 17), their sum is 36 .

Then we add the next smallest number to it (36 + 28) , so the sum becomes 64 .

We need to keep doing this until the sum becomes greater or equal to K (464 in this case), which will require 8 Steps .

Expected Time Complexity O(n Log n)
*/

const minimumSteps = (numsArr: number[], tHold: number): number => {
    const ascArr: number[] = numsArr.sort((a, b) => a - b);

    let sum: number = 0,
        counter: number = 0;

    for (counter; counter < ascArr.length; counter += 1) {
        sum += ascArr[counter];
        if (sum >= tHold) break;
    }

    return counter;
};

// 1
// console.log(minimumSteps([4, 6, 3], 7));
// 3
// console.log(minimumSteps([8, 9, 10, 4, 2], 23));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function minimumSteps2(nums: number[], value: number) {
    var s = 0;
    var total = 0;
    // ❗️❗️❗️ SORT() - MUTATES ORIGINAL, DON'T NEED TO SAVE TO VAR ❗️❗️❗️
    nums.sort((n1, n2) => n1 - n2);

    for (let i = 0; i < nums.length; i++) {
        total += nums[i];
        s++;
        console.log(total);

        if (nums[0] >= value) {
            return 0;
        }

        if (total >= value) {
            return s - 1;
        }
    }
}

const minimumSteps3 = (nums: number[], value: number) =>
    nums
        .sort((a, b) => a - b)
        .reduce(
            (acc, item) => (acc[0] < value ? [acc[0] + item, acc[1] + 1] : acc),
            [0, -1]
        )[1];
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️  INCLUDE THIS IN EXAMPLES (MODULO/REMAINDER )❗️❗️❗️
// 4 % 10 => 4 !!! DIVIDEND < DIVISOR => DIVIDEND
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: INCREMENT EVERY ELEMENT BY ITS POSITION, IF GREATER THAN 10, REPLACE WITH SECOND DIGIT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given an input of an array of digits, return the array with each digit incremented by its position in the array: the first digit will be incremented by 1, the second digit by 2, etc. Make sure to start counting your positions from 1 ( and not 0 ).

Your result can only contain single digit numbers, so if adding a digit with its position gives you a multiple-digit number, only the last digit of the number should be returned.

Notes:
return an empty array if your array is empty
arrays will only contain numbers so don't worry about checking that
Examples:
[1, 2, 3]  -->  [2, 4, 6]   #  [1+1, 2+2, 3+3]

[4, 6, 9, 1, 3]  -->  [5, 8, 2, 5, 8]  #  [4+1, 6+2, 9+3, 1+4, 3+5]
                                       #  9+3 = 12  -->  2
*/

const incrementer = (numArr: number[]): number[] => {
    const solution: number[] = numArr.map((el, idx) => {
        const sum: number = el + (numArr.indexOf(el) + 1);
        return sum > 9 ? sum - 10 : sum;
    });

    return solution;
};

// [2, 4, 6]
// console.log(incrementer([1, 2, 3]));
// [5, 8, 0, 5, 8
// console.log(incrementer([4, 6, 7, 1, 3]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ 4 % 10 => 4 !!! DIVIDEND < DIVISOR => DIVIDEND ❗️❗️❗️
const incrementer2 = (nums: number[]): number[] =>
    nums.map((num, index) => (num + index + 1) % 10);

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️  INCLUDE THIS IN EXAMPLES (REGEX)❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: COMPARE STRINGS BY SUM OF CHARACTERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ REGEX MATCH NEGATED SET ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Compare two strings by comparing the sum of their values (ASCII character code).

For comparing treat all letters as UpperCase
null/NULL/Nil/None should be treated as empty strings
If the string contains other characters than letters, treat the whole string as it would be empty
Your method should return true, if the strings are equal and false if they are not equal.

Examples:
"AD", "BC"  -> equal
"AD", "DD"  -> not equal
"gf", "FG"  -> equal
"zz1", ""   -> equal (both are considered empty)
"ZzZz", "ffPFF" -> equal
"kl", "lz"  -> not equal
null, ""    -> equal

*/
const compare = (str1: string | null, str2: string | null): boolean => {
    //  !!! REPLACE LETTERS WITH SPACE AND CHECK LENGTH !!!
    const getStrVal = (str: string | null): number => {
        // const validStr: string = str?.replace(/[^A-Z]/ig, "");

        // ❗️❗️❗️ THESE TWO ARE REPLACED WITH !str BELOW ❗️❗️❗️
        // if (str === null) return 0;
        // if (str === "") return 0;
        // FILTER OUT INVALID INPUT (NON LETTER CHARACTERS / EMPTY STR / null)
        if (!str || /[^A-Z]/gi.test(str)) return 0;
        const upperCased: string = str.toUpperCase();
        let value: number = 0;

        for (let i = 0; i < upperCased.length; i++) {
            value += upperCased.charCodeAt(i);
        }

        return value;
    };

    console.table({
        value1: getStrVal(str1),
        value2: getStrVal(str2),
        isEqual: getStrVal(str1) === getStrVal(str2),
    });

    return getStrVal(str1) === getStrVal(str2);
};

/*
❗️❗️❗️ REGEX MATCH NEGATED SET "^" ❗️❗️❗️ MATCH ANY CHAR THAT IS NOT IN THE SET
Match letters only /[A-Z]/ig
Match anything not letters /[^A-Z]/ig
Match number only /[0-9]/g or /\d+/g
Match anything not number /[^0-9]/g or /\D+/g
Match anything not number or letter /[^A-Z0-9]/ig

*/

// true
// console.log(compare("aD", "Bc"));
// false
// console.log(compare("AD", "DD"));
// true
// console.log(compare("cx1", ""));
// console.log(compare(null, ""));
// console.log(compare("!!", "235"));
// console.log();
// console.log();

/*
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│ value1  │  133   │
│ value2  │  133   │
│ isEqual │  true  │
└─────────┴────────┘
true
*/

//============= OTHER CODEWARS SOLUTIONS: =============
function compare2(s1: string | null, s2: string | null): boolean {
    function fun(s: string | null): string {
        if (typeof s === "string" && s.replace(/[a-z]/gi, "") === "")
            return s.toUpperCase();
        return "";
    }

    const red = (s: string | null): number =>
        fun(s)
            .split("")
            .reduce((acc, el) => acc + el.charCodeAt(0), 0);

    return red(s1) === red(s2);
}

function compare3(s1: string | null, s2: string | null): boolean {
    function sum(str: string | null): number {
        if (!str || !str.length) {
            return 0;
        }
        let arr = str
            .toUpperCase()
            .split("")
            .map((c) => c.charCodeAt(0));
        if (
            !arr.every(
                (el) => el >= "A".charCodeAt(0) && el <= "Z".charCodeAt(0)
            )
        ) {
            return 0;
        }
        return arr.reduce((acc, el) => acc + el);
    }

    return sum(s1) === sum(s2);
}

//   function compare4(x, y):boolean {
//     return (x = [x, y]
//       .map(a => (/[^A-Za-z]/g.test(a) ? '' : a || '')
//       .toUpperCase()
//       .split('')
//       .reduce((s, e) => s + e.charCodeAt(), 0)))[0] === x[1];
//   }

function compare5(s1: string | null, s2: string | null): boolean {
    function count(x: string | null): number {
        let count = 0;
        if (x)
            for (let c of x.toUpperCase()) {
                const cc = c.charCodeAt(0);
                if (cc >= 65 && cc <= 90) count += cc;
                else return 0;
            }
        return count;
    }
    return count(s1) == count(s2);
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: RETURN THE CLOSEST NUMBER MULTIPLE OF 10
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ MATH.ROUND() ❗️❗️❗️ SET UP TYPE ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a number return the closest number to it that is divisible by 10.

Example input:

22
25
37
Expected output:

20
30
40
*/
const closestMultiple10 = (num: number) => {
    return Math.round(num / 10) * 10;
};

// ❗️❗️❗️ Math.round ROUNDS TO NEAREST INTEGER ❗️❗️❗️
//  1. DIVIDE BY 10 TO MAKE NUM DECIMAL 54 => 5.4
//  2. RUN Math.round()                 5.4 => 5
//  3. MULTIPLY BY 10                   5 => 50

// 50
// console.log(closestMultiple10(54));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function closestMultiple102(num: number) {
    let last: number = num % 10;
    if (last < 5) {
        num -= last;
    } else {
        num += 10 - last;
    }
    return num;
}

// Parameter 'n' implicitly has an 'any' type.ts(7006)
// const closestMultiple103 = n => {
//     let s = n < 0 ? -1 : 1;
//     n = n < 0 ? -n : n;
//     let a = (n / 10 | 0) * 10;
//     let b = a + 10;
//     return s * ((n - a >= b - n) ? b : a);
// };
// ----------------------------------------------------
// ❗️❗️❗️ SET UP TYPE ❗️❗️❗️ SEE OBJECTS IN TYPESCRIPT ❗️❗️❗️
type F10 = (num: number) => number;

const part10: F10 = (num) => {
    if (num < 5) return num * -1;
    return 10 - num;
};

export const closestMultiple104: F10 = (num) => {
    return num + part10(num % 10);
};

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: RECURSION #1 - FACTORIAL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: FACTORIAL, RECURSION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
This is a kata series that you can only solve using recursion.
##1 - Factorial

In mathematics, the factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example,

5! = 5 * 4 * 3 * 2 * 1 = 120.

The value of 0! is 1.

#Your task

You have to create the function factorial that receives n and returns n!. You have to use recursion.
*/

// 1️⃣
const factorialA = (n: number): number => {
    if (n < 2) {
        return 1;
    } else {
        return n * factorialA(n - 1);
    }
};

// 2️⃣
const factorialA2 = (n: number): number => {
    return n < 2 ? 1 : n * factorialA(n - 1);
};

// 120
// console.log(factorialA(5));
// 720
// console.log(factorialA2(6));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// const factorialA3 = (n: number, total: number = 1): number => {
//     if (n === 0) {
//         return 1;
//     }

//     if (n === 1) {
//         return total;
//     }

//     return factorial(n - 1, total * n)
// };

// const factorialA4 = (n: number): number => {
//     return (n > 0) ? n * this.factorial(n - 1) : 1;
// };

const factorialA5 = (n: number): number => {
    var fact = 1;

    function factorial(num: number): number {
        if (num > 0) {
            fact = fact * num;
            factorial(num - 1);
        }
        return fact;
    }
    return factorial(n);
};

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: DIGITAL CYPHER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: MAP(IDX)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Introduction
Digital Cypher assigns to each letter of the alphabet unique number. For example:

 a  b  c  d  e  f  g  h  i  j  k  l  m
 1  2  3  4  5  6  7  8  9 10 11 12 13
 n  o  p  q  r  s  t  u  v  w  x  y  z
14 15 16 17 18 19 20 21 22 23 24 25 26
Instead of letters in encrypted word we write the corresponding number, eg. The word scout:

 s  c  o  u  t
19  3 15 21 20
Then we add to each obtained digit consecutive digits from the key. For example. In case of key equal to 1939 :

   s  c  o  u  t
  19  3 15 21 20
 + 1  9  3  9  1
 ---------------
  20 12 18 30 21
  
   m  a  s  t  e  r  p  i  e  c  e
  13  1 19 20  5 18 16  9  5  3  5
+  1  9  3  9  1  9  3  9  1  9  3
  --------------------------------
  14 10 22 29  6 27 19 18  6  12 8
Task
Write a function that accepts str string and key number and returns an array of integers representing encoded str.

Input / Output
The str input string consists of lowercase characters only.
The key input number is a positive integer.

Example
Encode("scout",1939);  ==>  [ 20, 12, 18, 30, 21]
Encode("masterpiece",1939);  ==>  [ 14, 10, 22, 29, 6, 27, 19, 18, 6, 12, 8]
*/
const encode = (str: String, key: number): number[] => {
    const alphabet = "abcdefghijklmnopqrstuvwxyz";
    // SPLIT KEY INTO ARRAY OF DIGITS: [ 1, 9, 3, 9 ]
    const keyArr: number[] = key
        .toString()
        .split("")
        .map((el) => Number(el));
    // GET KEY LENGTH FOR SEQUENCING KEY: 4
    const seqLength: number = keyArr.length;
    // MAKE ARRAY OF CHARACTERS: [ 's', 'c', 'o', 'u', 't' ]
    const strArr: string[] = str.split("");
    // REPLACE EVERY ELEMENT WITH ITS POSITION IN THE ALPHABET: [ 19, 3, 15, 21, 20 ]
    const charPositionArr: number[] = strArr.map(
        (char) => alphabet.indexOf(char) + 1
    );

    // ADD CONSECUTIVE KEY DIGITS TO EACH DIGIT IN SEQUENCE (1,9,3,9,1,9,3,9,1...) [ 20, 12, 18, 30, 21 ]
    const encodedArr: number[] = charPositionArr.map(
        (el: number, idx) =>
            (el += idx < seqLength ? keyArr[idx] : keyArr[idx % seqLength])
    );

    return encodedArr;
};
// [ 20, 12, 18, 30, 21]
// console.log(encode("scout", 1939));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function encode2(str: String, n: number): number[] {
    const keys: number[] = n.toString().split("").map(Number);
    return str.split("").map((code, index) => {
        return (
            code.toLowerCase().charCodeAt(0) - 96 + keys[index % keys.length]
        );
    });
}

function encode3(str: string, n: number): number[] {
    return str
        .split("")
        .map((c) => c.charCodeAt(0) - 96)
        .map((c, idx) => c + parseInt(n.toString()[idx % n.toString().length]));
}

/*
function encode4(str: String, n: number): number[] {
    const decodedArray: number[] = [];
    const stringArray = str.split("");
    const codeArray = stringArray.map(letter => letter.charCodeAt(0) - 96);
    const numberArray = n.toString().split("").map(Number)
    let tempArray = [...numberArray];

    const result = codeArray.map(code => {
        if (!tempArray.length) tempArray = [...numberArray];

        // ❗️❗️❗️ Object is possibly 'undefined'.ts(2532) ❗️❗️❗️
        return code += tempArray.shift()
    })

    return result;
}
*/

/*
function encode5(str: String, n: number): number[] {
    const decodedArray: number[] = [];
    const code = {
        a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7, h: 8,
        i: 9, j: 10, k: 11, l: 12, m: 13, n: 14, o: 15,
        p: 16, q: 17, r: 18, s: 19, t: 20, u: 21, v: 22,
        w: 23, x: 24, y: 25, z: 26,
    }
    const stringArray = str.split("");
    // ❗️❗️❗️ error TS7053: Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ a: number; b: number; c: number; d: number; e: number; f: number; g: number; h: number; i: number; j: number; k: number; l: number; m: number; n: number; o: number; p: number; q: number; r: number; s: number; t: number; u: number; ... 4 more ...; z: number; }'.
    const codeArray = stringArray.map(letter => code[letter]);
    const numberArray = n.toString().split("").map(str => parseInt(str))
    let tempArray = [...numberArray];

    const result = codeArray.map(code => {
        if (!tempArray.length) tempArray = [...numberArray];

        return code += tempArray.shift()
    })

    return result;
}
*/
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: SIMPLE FUN - HOUSE NUMBERS SUM
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: FOR OF, BREAK
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
A boy is walking a long way from school to his home. To make the walk more fun he decides to add up all the numbers of the houses that he passes by during his walk. Unfortunately, not all of the houses have numbers written on them, and on top of that the boy is regularly taking turns to change streets, so the numbers don't appear to him in any particular order.

At some point during the walk the boy encounters a house with number 0 written on it, which surprises him so much that he stops adding numbers to his total right after seeing that house.

For the given sequence of houses determine the sum that the boy will get. It is guaranteed that there will always be at least one 0 house on the path.

Example
For inputArray = [5, 1, 2, 3, 0, 1, 5, 0, 2], the output should be 11.

The answer was obtained as 5 + 1 + 2 + 3 = 11.

Input/Output
[input] integer array inputArray

Constraints: 5 ≤ inputArray.length ≤ 50, 0 ≤ inputArray[i] ≤ 10.

[output] an integer
*/
const houseNumbersSum = (arr: number[]): number => {
    let solution: number = 0;
    for (let i = 0; i < arr.length; i++) {
        solution += arr[i];
        // if (arr[i] === 0) break;
        // OR:
        if (!arr[i]) break;
    }
    return solution;
};

// 11
// console.log(houseNumbersSum([5, 1, 2, 3, 0, 1, 5, 0, 2]));
// 13
// console.log(houseNumbersSum([4, 2, 1, 6, 0]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const houseNumbersSum2 = (arr: number[]): number =>
    arr.splice(0, arr.indexOf(0)).reduce((a, v) => a + v, 0);

function houseNumbersSum3(inputArray: number[]): number {
    let counter: number = 0;

    for (let i: number = 0; i < inputArray.length; i++) {
        if (inputArray[i] !== 0) {
            counter += inputArray[i];
        } else {
            break;
        }
    }
    return counter;
}

// ❗️❗️❗️ FOR OF ❗️❗️❗️
function houseNumbersSum4(inputArray: number[]): number {
    let sum: number = 0;
    4;
    for (let i of inputArray) {
        if (i === 0) break;
        sum += i;
    }
    return sum;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: NUMBERS IN STRINGS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: TEST(), MATCH(), ❓❓❓ SYMBOL ITERATOR ❓❓❓
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
n this Kata, you will be given a string that has lowercase letters and numbers. Your task is to compare the number groupings and return the largest number. Numbers will not have leading zeros.

For example, solve("gh12cdy695m1") = 695, because this is the largest of all number groupings.

Good luck!
*/

// 1️⃣
const solveC = (str: string): number => {
    // CHECK FOR NUMERIC DIGITS
    if (!/\d/g.test(str)) return 0;
    // FIND ALL DIGIT SUBSTRINGS AND CONVERT TO NUMBER
    const digitSubs: number[] = str.match(/\d+/g)!.map((el) => Number(el));
    // GET THE LARGEST ELEMENT
    // ❓❓❓ Type 'number[] | undefined' must have a '[Symbol.iterator]()' method that returns an iterator.ts(2488) ❓❓❓
    // console.log(Math.max(...digitSubs));
    const solution: number = Math.max(...digitSubs);
    return solution;
};

// 2️⃣ REFACTORED:
const solveC2 = (str: string): number => {
    return /\d/g.test(str)
        ? Math.max(...str.match(/\d+/g)!.map((el) => Number(el)))
        : 0;
};

// 695
// console.log(solveC2("gh12cdy695m1"));
// 9
// console.log(solveC2("2ti9iei7qhr5"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
const solveC3 = (s: string): number =>
    Math.max(...s.split(/[a-z]/g).map((el) => +el));

function solveC4(s: string) {
    return Math.max(...s.split(/\D+/).map((e) => Number(e)));
}

function solveC5(s: string): number {
    const numArray = s.replace(/\D+/g, " ").trim().split(" ").map(Number);
    return Math.max(...numArray);
}

function solveC6(s: string): number {
    const matches = s.match(/\d+/g)!;
    return Math.max(...matches.map((el) => Number(el)));
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: SPECIAL NUMBER (Special Numbers Series #5)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: TEST()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Definition
A number is a Special Number if it’s digits only consist 0, 1, 2, 3, 4 or 5

Given a number determine if it special number or not .

Notes
The number passed will be positive (N > 0) .

All single-digit numbers within the interval [1:5] are considered as special number.

Input >> Output Examples
specialNumber(2) ==> return "Special!!"
Explanation:
It's a single-digit number within the interval [1:5] .

specialNumber(9) ==> return "NOT!!"
Explanation:
Although, it's a single-digit number but Outside the interval [1:5] .

specialNumber(23) ==> return "Special!!"
Explanation:
All the number's digits formed from the interval [0:5] digits .

specialNumber(39) ==> return "NOT!!"
Explanation:
Although, there is a digit (3) Within the interval But the second digit is not (Must be ALL The Number's Digits ) .

specialNumber(59) ==> return "NOT!!"
Explanation:
Although, there is a digit (5) Within the interval But the second digit is not (Must be ALL The Number's Digits ) .

specialNumber(513) ==> return "Special!!"
specialNumber(709) ==> return "NOT!!"
*/
const specialNumber = (num: number) => {
    const numStr: string = num.toString();
    // console.log(numStr);
    // console.log(/[6-9]/g.test(numStr));
    return /[6-9]/g.test(numStr) ? "NOT!!" : "Special!!";
};

// "Special!!"
// console.log(specialNumber(234055));
// "NOT!!"
// console.log(specialNumber(6789));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
const specialNumbers = [0, 1, 2, 3, 4, 5].map((n) => n.toString());

export const specialNumber2 = (n: number): string =>
    n
        .toString()
        .split("")
        .every((n) => specialNumbers.includes(n))
        ? "Special!!"
        : "NOT!!";

function specialNumber3(n: number) {
    return /[^0-5]/.test(n.toString()) ? "NOT!!" : "Special!!";
}

function specialNumber4(n: number) {
    return n.toString().match(/[^0-5]/) ? "NOT!!" : "Special!!";
}
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: UNLUCKY DAYS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Friday 13th or Black Friday is considered as unlucky day. Calculate how many unlucky days are in the given year.

Find the number of Friday 13th in the given year.

Input: Year in Gregorian calendar as integer.

Output: Number of Black Fridays in the year as an integer.

Examples:

unluckyDays(2015) == 3
unluckyDays(1986) == 1

*/
function unluckyDays(year: number): number {
    return 1;
}

// 3
// console.log(unluckyDays(2015));
// 1
// console.log(unluckyDays(1986));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: PRODUCT OF MAXIMUMS IN ARRAY (Array Series #2)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ REDUCE WITH INITIAL VALUE ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
Given an array/list [] of integers , Find the product of the k maximal numbers.

Notes
Array/list size is at least 3 .

Array/list's numbers Will be mixture of positives , negatives and zeros

Repetition of numbers in the array/list could occur.

Input >> Output Examples
maxProduct ({4, 3, 5}, 2) ==>  return (20)
Explanation:
Since the size (k) equal 2 , then the subsequence of size 2 whose gives product of maxima is 5 * 4 = 20 .
maxProduct ({8, 10 , 9, 7}, 3) ==>  return (720)
Explanation:
Since the size (k) equal 3 , then the subsequence of size 3 whose gives product of maxima is 8 * 9 * 10 = 720 .
maxProduct ({10, 8, 3, 2, 1, 4, 10}, 5) ==> return (9600)
Explanation:
Since the size (k) equal 5 , then the subsequence of size 5 whose gives product of maxima is 10 * 10 * 8 * 4 * 3 = 9600 .
maxProduct ({-4, -27, -15, -6, -1}, 2) ==> return (4)
Explanation:
Since the size (k) equal 2 , then the subsequence of size 2 whose gives product of maxima is -4 * -1 = 4 .
maxProduct ({10, 3, -1, -27} , 3)  return (-30)
Explanation:
Since the size (k) equal 3 , then the subsequence of size 3 whose gives product of maxima is 10 * 3 * -1 = -30 .
*/

// 1️⃣
const maxProduct = (numbers: number[], size: number): number => {
    // SORT DESCENDING
    const descArr: number[] = numbers.sort((a, b) => b - a);
    // GRAB SUB-ARRAY STARTING AT INDEX 0, WITH size NUMBER OF ELEMENTS
    const factorsArr: number[] = descArr.slice(0, size);
    // MULTIPLY ELEMENTS
    let solution: number = factorsArr.reduce((acc, curr) => acc * curr);

    return solution;
};

// 2️⃣
const maxProduct2 = (numbers: number[], size: number): number => {
    return numbers
        .sort((a, b) => b - a)
        .slice(0, size)
        .reduce((acc, curr) => acc * curr);
};

// 20
// console.log(maxProduct([4, 3, 5], 2));
// 720
// console.log(maxProduct([10, 8, 7, 9], 3));
// 9600
// console.log(maxProduct([10, 2, 3, 8, 1, 10, 4], 5));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ REDUCE WITH INITIAL VALUE ❗️❗️❗️
function maxProduct3(numbers: number[], size: number) {
    return numbers
        .sort((a, b) => a - b)
        .slice(-size)
        .reduce((ret, val) => ret * val, 1);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: LONGEST VOWEL CHAIN
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: MATCH(AEIOU), SORT ARRAY BY LENGTH OF ELEMENTS, REGEX, TEST()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The vowel substrings in the word codewarriors are o,e,a,io. The longest of these has a length of 2. Given a lowercase string that has alphabetic characters only (both vowels and consonants) and no spaces, return the length of the longest vowel substring. Vowels are any of aeiou.

Good luck!
*/
const solveB = (str: string): number => {
    // ❗️❗️❗️ CHECK IF STRING HAS ANY VOWELS ❗️❗️❗️
    if (!/[aeiou]/g.test(str)) return 0;
    // !!! THIS IS NOW NOT NEEDED !!!
    // if (str.length < 1) return 0;
    const substrings: string[] = str.match(/[aeiou]+/g)!;
    const solution: number = substrings.sort((a, b) => b.length - a.length)[0]
        .length;
    return solution;
};

// 2
// console.log(solveB("codewarriors"));
// 3
// console.log(solveB("suoidea"));
// FIXED:❗️❗️❗️ TypeError: Cannot read property 'sort' of null ❗️❗️❗️
// console.log(solveB("fgfgfg"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
function solveB2(s: string): number {
    return Math.max(...(s.match(/[aeiou]+/gi) || []).map((x) => x.length));
}

const solveB3 = (str: string): number =>
    Math.max(...str.split(/[^aeiou]/i).map((x) => x.length));

function solveB4(str: string) {
    return str
        .split(/[^aeiou]+/)
        .reduce((acc, vowelChain) => Math.max(acc, vowelChain.length), 0);
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:   CHAR CODE CALCULATION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ REDUCE OF EMPTY ARRAY, STR.CHARCODEAT()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a string, turn each character into its ASCII character code and join them together to create a number - let's call this number total1:

'ABC' --> 'A' = 65, 'B' = 66, 'C' = 67 --> 656667
Then replace any incidence of the number 7 with the number 1, and call this number 'total2':

total1 = 656667
              ^
total2 = 656661
              ^
Then return the difference between the❗️❗️❗️  sum of the digits ❗️❗️❗️ in total1 and total2:

  (6 + 5 + 6 + 6 + 6 + 7)
- (6 + 5 + 6 + 6 + 6 + 1)
-------------------------
                       6
*/

export const calc = (str: string): number => {
    // ❗️❗️❗️ TypeError: Reduce of empty array with no initial value ❗️❗️❗️ CHECK FOR EMPTY ARRAY ❗️❗️❗️
    if (str.length < 1) return 0;
    const strArr: string[] = str.split("");
    let numStrConcat: string = "";
    //  CONCAT CHAR CODE FOR EACH CHAR TO numStrConcat
    strArr.forEach((char: string, idx) => {
        numStrConcat += str.charCodeAt(idx);
    });
    //  REPLACE ALL INSTANCES OF "7" WITH "1"
    const numStrMinusSeven: string = numStrConcat.replace(/7/g, "1");
    //  GET SUM OF DIGITS FOR BOTH STRINGS
    const total1: number = numStrConcat
        .split("")
        .map((el) => Number(el))
        .reduce((a, b) => a + b);
    const total2: number = numStrMinusSeven
        .split("")
        .map((el) => Number(el))
        .reduce((a, b) => a + b);
    //  SUBSTRACT
    const result: number = total1 - total2;

    return result;
};

// 6
// console.log(calc("ABC"));

// console.log(calc("abcdef"));
// console.log(calc("hkodededyvcmntdzdyqrbqhxipcynkjezcsxcbyjktjaugiwllioggxvwijjpqmoxngklpqvsphtsklcbugkpdlnwuinbfeqphpctbaqfmrorkxyrhvbnlfuyktrdnyavxjvublyqfgdopehfjgcvwmilrghgvnwkjeklaihsalcfdqtdsmzbtqocslkbrxycrdnxgoliezbiwobdvxcijtjkcwijjrygfucmpufpmxigjrnuhsckyqhehxvnmadkbrwqrbcjqlstamfmpmqgcurpdemyuqqearbnzpywaycwpntcwrndwxkadbdwgjqairzoplqiinrxgdzebebxlilekpqokdrhwhyrjlfpedqywfiaqjseorwpjhimazefhsypzvyxtjggytrawymqvkrrggpdezrdtotwqhizigvuvvkepskmajinldotdwnzwwplfyezkzxbmfclaisbpybnewwlnttgeezuhbnedugpjxtahmrlcoccfmwygbiosggjqrzxtibfthvucdfjxivfeijcjkgcfwusehzxtlqrphwizngcaefaktbzjuppdtloulpbqorxckntgumqwhqqotzltulsyzoxpqsjccewvxlrizjppnmeeihnwusjuhdpnwjjkucaizjxaspjxuypsybxywdwriwkynpgbzrbvszpntjkappmzhoywferhpyuaqcsbxozfyjmksvk"));
// console.log(calc(""));

//============= OTHER CODEWARS SOLUTIONS: =============

function calc2(str: string): number {
    return (
        [...str]
            .map((x) => x.charCodeAt(0))
            .join("")
            .split("")
            .filter((x) => x === "7").length * 6
    );
}

const calc3 = (x: string): number => {
    return (
        (x.replace(/./g, (x) => x.charCodeAt(0).toString()).match(/7/g) || [])
            .length * 6
    );
};

function calc4(str: string): number {
    return (
        Array.from(str, (c) => c.charCodeAt(0))
            .toString()
            .replace(/[^7]/g, "").length * 6
    );
}

const calc5 = (str: string): number => {
    const codes = str.split("").map((c: string) => c.charCodeAt(0));
    const total1 = codes.reduce((a, b) => a + b, 0);
    const total2 = codes
        .map((x) => +x.toString().replace(/7/g, "1"))
        .reduce((a, b) => a + b, 0);
    return total1 - total2;
};

// ===

function calc6(str: string): number {
    const charCodes = str.split("").map((char) => char.charCodeAt(0));
    return sum2(charCodes) - sum(charCodes.map(replace7with1));
}

function sum2(arr: number[]): number {
    return arr.reduce((total, x) => total + x, 0);
}

function replace7with1(num: number): number {
    return parseInt(num.toString().replace(/7/g, "1"));
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: WORD VALUES MULTIPLIED BY ITS POSITION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a string "abc" and assuming that each letter in the string has a value equal to its position in the alphabet, our string will have a value of 1 + 2 + 3 = 6. This means that: a = 1, b = 2, c = 3 ....z = 26.

You will be given a list of strings and your task will be to return the values of the strings as explained above multiplied by the position of that string in the list. For our purpose, position begins with 1.

nameValue ["abc","abc abc"] should return [6,24] because of [ 6 * 1, 12 * 2 ]. Note how spaces are ignored.

"abc" has a value of 6, while "abc abc" has a value of 12. Now, the value at position 1 is multiplied by 1 while the value at position 2 is multiplied by 2.

Input will only contain lowercase characters and spaces.
*/

const wordValue = (arr: string[]) => {
    const alphabet = "abcdefghijklmnopqrstuvwxyz";
    let solution: number[] = [];
    arr.forEach((word, idx) => {
        console.log(word);
        let letterArr: string[] = word.split("");
        console.log(letterArr);
        let wordVal: number = 0;
        letterArr.forEach((letter) => {
            // let wordVal: number = 0;
            let letterVal: number = alphabet.indexOf(letter) + 1;
            wordVal += letterVal;
            // console.table({
            //     word: word,
            //     letter: letter,
            //     value: letterVal,
            //     wordVal: wordVal,
            //     solution: solution,
            // });
        });
        solution.push(wordVal * (idx + 1));
    });
    // return solution.map((val, idx) => val * (idx + 1));
    return solution;
};

// [88, 12, 225]
// console.log(wordValue(["codewars", "abc", "xyz"]));
// console.log(wordValue(["lencsi", "mama", "papa"]));
// [6,24]
// console.log(wordValue(["abc", "abc abc"]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function wordValue2(arr: string[]): number[] {
    const w: string = " abcdefghijklmnopqrstuvwxyz";
    return arr.map(
        (x, i) =>
            x.split("").reduce((sum, y) => sum + w.indexOf(y), 0) * (i + 1)
    );
}

const wordValue3 = (arr: string[]) =>
    arr
        .map((a) =>
            a
                .split("")
                .map((c) => (c === " " ? 0 : c.charCodeAt(0) - 96))
                .reduce((z, x) => z + x, 0)
        )
        .map((e, i) => e * +[i + 1]);

function wordValue4(arr: string[]): number[] {
    let res: number[] = [];

    arr.forEach((str, ind) => {
        let sum = 0;
        for (let i = 0; i < str.length; i++) {
            str.charCodeAt(i) !== 32
                ? (sum += (str.charCodeAt(i) - 96) * (ind + 1))
                : 0;
        }
        res.push(sum);
    });

    return res;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: JUMPING NUMBER (Special Numbers Series #4)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ EVERY()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Definition
Jumping number is the number that All adjacent digits in it differ by 1.

Task
Given a number, Find if it is Jumping or not .

Warm-up (Highly recommended)
Playing With Numbers Series
Notes
Number passed is always Positive .

Return the result as String .

The difference between ‘9’ and ‘0’ is not considered as 1 .

All single digit numbers are considered as Jumping numbers.

Input >> Output Examples
jumpingNumber(9) ==> return "Jumping!!"
Explanation:
It's single-digit number
jumpingNumber(79) ==> return "Not!!"
Explanation:
Adjacent digits don't differ by 1
jumpingNumber(23) ==> return "Jumping!!"
Explanation:
Adjacent digits differ by 1
jumpingNumber(556847) ==> return "Not!!"
Explanation:
Adjacent digits don't differ by 1
jumpingNumber(4343456) ==> return "Jumping!!"
Explanation:
Adjacent digits differ by 1
jumpingNumber(89098) ==> return "Not!!"
Explanation:
Adjacent digits don't differ by 1
jumpingNumber(32) ==> return "Jumping!!"
Explanation:
Adjacent digits differ by 1
*/

const jumpingNumber = (num: number): string => {
    if (num < 10) return "Jumping!!";
    let isJumping: boolean = true;
    const digitArr: number[] = num
        .toString()
        .split("")
        .map((el) => Number(el));
    for (let i = 0; i < digitArr.length - 1; i++) {
        if (
            digitArr[i] + 1 !== digitArr[i + 1] &&
            digitArr[i] - 1 !== digitArr[i + 1]
        ) {
            isJumping = false;
            break;
        }
        console.table({
            current: digitArr[i],
            next: digitArr[i + 1],
            isJumping: isJumping,
        });
    }

    return isJumping ? "Jumping!!" : "Not!!";
};

// JUMPING
// console.log(jumpingNumber(12321));
// NOT
// console.log(jumpingNumber(79));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function jumpingNumber2(n: number) {
    let arr: number[] = String(n)
        .split("")
        .map((num) => Number(num));

    if (arr.length === 1) {
        return "Jumping!!";
    }
    for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] - arr[i + 1] !== 1 && arr[i + 1] - arr[i] !== 1) {
            return "Not!!";
        }
    }
    return "Jumping!!";
}

// ❗️❗️❗️ EVERY() ❗️❗️❗️
function jumpingNumber3(n: number): string {
    let arr: string[] = [...String(n)];
    return arr.slice(1).every((x, i) => Math.abs(+x - +arr[i]) == 1)
        ? "Jumping!!"
        : "Not!!";
}

function jumpingNumber4(n: number) {
    // your code here
    if (n < 10) {
        return "Jumping!!";
    }
    let arr = n.toString().split("").map(Number);

    for (let i = 0; i < arr.length - 1; i++) {
        if (Math.pow(arr[i] - arr[i + 1], 2) != 1) {
            return "Not!!";
        }
    }
    return "Jumping!!";
}

function jumpingNumber5(n: number) {
    return n
        .toString()
        .split("")
        .map((n) => parseInt(n))
        .every((digit, index, arr) =>
            index === 0 ? true : Math.abs(arr[index - 1] - arr[index]) === 1
        )
        ? "Jumping!!"
        : "Not!!";
}

// ❗️❗️❗️ REFACTOR ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: ARRAY LEADERS (Array Series #3)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: FILTER() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Definition
An element is leader if it is greater than The Sum all the elements to its right side.

Task
Given an array/list [] of integers , Find all the LEADERS in the array.

Notes
Array/list size is at least 3 .

Array/list's numbers Will be mixture of positives , negatives and zeros

Repetition of numbers in the array/list could occur.

Returned Array/list should store the leading numbers in the same order in the original array/list .

Input >> Output Examples
arrayLeaders ({1, 2, 3, 4, 0}) ==> return {4}
Explanation:
4 is greater than the sum all the elements to its right side

Note : The last element 0 is equal to right sum of its elements (abstract zero).

arrayLeaders ({16, 17, 4, 3, 5, 2}) ==> return {17, 5, 2}
Explanation:
17 is greater than the sum all the elements to its right side

5 is greater than the sum all the elements to its right side

Note : The last element 2 is greater than the sum of its right elements (abstract zero).

arrayLeaders ({5, 2, -1}) ==> return {5, 2}
Explanation:
5 is greater than the sum all the elements to its right side

2 is greater than the sum all the elements to its right side

Note : The last element -1 is less than the sum of its right elements (abstract zero).

arrayLeaders ({0, -1, -29, 3, 2}) ==> return {0, -1, 3, 2}
Explanation:
0 is greater than the sum all the elements to its right side

-1 is greater than the sum all the elements to its right side

3 is greater than the sum all the elements to its right side

Note : The last element 2 is greater than the sum of its right elements (abstract zero).
*/

const arrayLeaders = (numbers: number[]): number[] => {
    let leadersArr: number[] = [];
    const lastEl: number = numbers.length - 1;

    for (let i = 0; i < lastEl; i++) {
        let current: number = numbers[i];
        // console.table({
        //     idx: i,
        //     current: numbers[i],
        //     rest: numbers.slice(i + 1).reduce((a, b) => a + b),
        // });
        if (current > numbers.slice(i + 1).reduce((a, b) => a + b)) {
            // console.log(current);
            leadersArr.push(current);
        }
    }

    if (numbers[lastEl] > 0) {
        leadersArr.push(numbers[lastEl]);
    }

    return leadersArr;
};

// [17, 5, 2]
// console.log(arrayLeaders([16, 17, 4, 3, 5, 2]));
// console.log();
// console.log();
// console.log();

/*

arrayLeaders([16, 17, 4, 3, 5, 2])

┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│   idx   │   0    │
│ current │   16   │
│  rest   │   31   │
└─────────┴────────┘
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│   idx   │   1    │
│ current │   17   │
│  rest   │   14   │
└─────────┴────────┘
17
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│   idx   │   2    │
│ current │   4    │
│  rest   │   10   │
└─────────┴────────┘
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│   idx   │   3    │
│ current │   3    │
│  rest   │   7    │
└─────────┴────────┘
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│   idx   │   4    │
│ current │   5    │
│  rest   │   2    │
└─────────┴────────┘
5

[ 17, 5, 2 ]
*/

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ FILTER() ❗️❗️❗️
const arrayLeaders2 = (numbers: number[]) =>
    numbers.filter(
        (item, i) => item > numbers.slice(i + 1).reduce((a, b) => a + b, 0)
    );

function arrayLeaders3(numbers: number[]): number[] {
    return numbers.filter(
        (x, i) => x > numbers.slice(i + 1).reduce((a, b) => a + b, 0)
    );
}

function arrayLeaders4(numbers: number[]) {
    let sum = 0;
    const results = [];
    for (let i = numbers.length - 1; i >= 0; i--) {
        const current = numbers[i];
        if (current > sum) {
            results.push(current);
        }
        sum += current;
    }
    return results.reverse();
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: MAXIMUM TRIPLET SUM (Array Series #7)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
Given an array/list [] of n integers , find maximum triplet sum in the array Without duplications .

Notes :
Array/list size is at least 3 .

Array/list numbers could be a mixture of positives , negatives and zeros .

Repetition of numbers in the array/list could occur , So (duplications are not included when summing).

Input >> Output Examples
1- maxTriSum ({3,2,6,8,2,3}) ==> return (17)
Explanation:
As the triplet that maximize the sum {6,8,3} in order , their sum is (17)

Note : duplications are not included when summing , (i.e) the numbers added only once .

2- maxTriSum ({2,1,8,0,6,4,8,6,2,4}) ==> return (18)
Explanation:
As the triplet that maximize the sum {8, 6, 4} in order , their sum is (18) ,

Note : duplications are not included when summing , (i.e) the numbers added only once .

3- maxTriSum ({-7,12,-7,29,-5,0,-7,0,0,29}) ==> return (41)
Explanation:
As the triplet that maximize the sum {12 , 29 , 0} in order , their sum is (41) ,

Note : duplications are not included when summing , (i.e) the numbers added only once .
*/

const maxTriSum = (nums: number[]): number => {
    const unuqueNums = new Set<number>(nums);
    console.log(unuqueNums);
    const ascArr: number[] = Array.from(unuqueNums).sort((a, b) => b - a);
    console.log(ascArr);
    console.log(ascArr[0] + ascArr[1] + ascArr[2]);

    return ascArr[0] + ascArr[1] + ascArr[2];
};

// 17
// console.log(maxTriSum([3, 2, 6, 8, 2, 3]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function maxTriSum2(nums: number[]): number {
    return [...new Set(nums)]
        .sort((a, b) => b - a)
        .slice(0, 3)
        .reduce((c, d) => c + d, 0);
}

const maxTriSum3 = (nums: number[]) =>
    nums
        .filter((item, i) => nums.indexOf(item) == i)
        .sort((a, b) => (a < b ? 1 : -1))
        .slice(0, 3)
        .reduce((a, b) => a + b, 0);

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: NTH SMALLEST ELEMENT (Array Series #4) DON'T REMOVE DUPLICATES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Introduction and Warm-up (Highly recommended)
Playing With Lists/Arrays Series
Task
Given an array/list [] of integers , Find the Nth smallest element in this array of integers

Notes
Array/list size is at least 3 .

Array/list's numbers could be a mixture of positives , negatives and zeros .

Repetition in array/list's numbers could occur , so don't Remove Duplications .

Input >> Output Examples
nthSmallest({3,1,2} ,2) ==> return (2) 
Explanation:
Since the passed number is 2 , Then * the second smallest element in this array/list is 2*

nthSmallest({15,20,7,10,4,3} ,3) ==> return (7) 
Explanation:
Since the passed number is 3 , Then * the third smallest element in this array/list is 7*

nthSmallest({2,169,13,-5,0,-1} ,4) ==> return (2) 
Explanation:
Since the passed number is 4 , Then * the fourth smallest element in this array/list is 2*

nthSmallest({177,225,243,-169,-12,-5,2,92} ,5) ==> return (92) 
Explanation:
Since the passed number is 5 , Then * the fifth smallest element in this array/list is 92*


*/

const nthSmallest = (arr: number[], pos: number): number => {
    // SORT ASCENDING
    const ascArr: number[] = arr.sort((a, b) => a - b);
    // RETURN ELEMENT AT POSITION pos
    return ascArr[pos - 1];
};

// 7
// console.log(nthSmallest([15, 20, 7, 10, 4, 3], 3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function nthSmallest2(arr: number[], pos: number) {
    return arr.sort((a, b) => a - b)[--pos];
}

function nthSmallest3(arr: number[], pos: number) {
    return [...arr].sort((a, b) => a - b)[pos - 1];
}

function nthSmallest4(arr: number[], pos: number) {
    for (let i = 1; i < pos; i++) {
        arr.splice(arr.indexOf(Math.min(...arr)), 1);
    }
    return arr[arr.indexOf(Math.min(...arr))];
}

function nthSmallest5(arr: number[], pos: number) {
    var sortArray: Array<number> = arr.sort((a, b) => a - b);
    return sortArray[pos - 1];
}

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// ❗️❗️❗️ NOT SUBMITTED ON CODEWARS YET ❗️❗️❗️ REFACTOR ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: 16+18=214
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
For this kata you will have to forget how to add two numbers.

It can be best explained using the following meme:

Dayane Rivas adding up a sum while competing in the Guatemalan television show "Combate" in May 2016

In simple terms, our method does not like the principle of carrying over numbers and just writes down every number it calculates :-)

You may assume both integers are positive integers.

Examples
16+1821426+39515122+811103\large \begin{array}{lll} & 1 & 6 \\ + & 1 & 8 \\ \hline & 2 & 1 4 \\ \end{array} \qquad \large \begin{array}{lll} & 2 & 6 \\ + & 3 & 9 \\ \hline & 5 & 15 \\ \end{array} \qquad \large \begin{array}{lll} & 1 & 2 & 2 \\ + & & 8 & 1 \\ \hline & 1 & 10 & 3 \\ \end{array} 
+
​
*/

// const nyuszi: string = "🐰";
// console.log("maci ❤️ : ", nyuszi);

const add = (num1: number, num2: number): number => {
    const greater = Math.max(num1, num2).toString();
    // console.log(greater.length);

    const numStr1: string = num1.toString();
    const numStr2: string = num2.toString();
    let solutionArr: number[] = [];

    for (let i = 0; i < greater.length; i++) {
        console.log(
            "numbers: ",
            numStr1[numStr1.length - 1 - i],
            numStr2[numStr2.length - 1 - i]
        );
        let sum: number = 0;
        if (numStr1[numStr1.length - 1 - i] === undefined) {
            console.log("undefined");
            sum = Number(numStr2[numStr2.length - 1 - i]);
            // continue;
        } else if (numStr2[numStr2.length - 1 - i] === undefined) {
            console.log("undefined");
            sum = Number(numStr1[numStr1.length - 1 - i]);
            // continue;
        } else {
            sum =
                Number(numStr1[numStr1.length - 1 - i]) +
                Number(numStr2[numStr2.length - 1 - i]);
            // console.log("sum: ", sum);
        }
        console.log("sum: ", sum);
        solutionArr.unshift(sum);
    }
    console.log(solutionArr);

    return Number(solutionArr.join(""));
};

// 1 10 3 (1103)
// console.log(add(122, 81));
// 31499
// console.log(add(1222, 30277));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: TIDY NUMBER (Special Numbers Series #9)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Definition
A Tidy number is a number whose digits are in non-decreasing order.

Task
Given a number, Find if it is Tidy or not .
*/

const tidyNumber = (num: number): boolean => {
    // ARRANGE DIGITS IN INCREASING ORDER(STRING)
    const increasingNum = num
        .toString()
        .split("")
        .map((el) => Number(el))
        .sort((a, b) => a - b)
        .join("");

    // CONVERT TO NUMBER AND COMPARE TO INPUT NUMBER
    return parseInt(increasingNum) === num;
};

// TRUE
// console.log(tidyNumber(2789));
// FALSE
// console.log(tidyNumber(9672));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function tidyNumber2(num: number) {
    let s = "" + num;
    for (let i = 1; i < s.length; i++) {
        if (s[i] < s[i - 1]) {
            return false;
        }
    }
    return true;
}

const tidyNumber3 = (num: number) =>
    num == +[...String(num)].sort((a, b) => +a - +b).join("");

const tidyNumber4 = (n: number) => +[...String(n)].sort().join("") === n;
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: ALL INCLUSIVE?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ROTATE STRING,
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Input:

a string strng
an array of strings arr
Output of function contain_all_rots(strng, arr) (or containAllRots or contain-all-rots):

a boolean true if all rotations of strng are included in arr (C returns 1)
false otherwise (C returns 0)
Examples:
contain_all_rots(
  "bsjq", ["bsjq", "qbsj", "sjqb", "twZNsslC", "jqbs"]) -> true

contain_all_rots(
  "Ajylvpy", ["Ajylvpy", "ylvpyAj", "jylvpyA", "lvpyAjy", "pyAjylv", "vpyAjyl", "ipywee"]) -> false)
Note:
Though not correct in a mathematical sense

we will consider that there are no rotations of strng == ""
and for any array arr: contain_all_rots("", arr) --> true
Ref: https://en.wikipedia.org/wiki/String_(computer_science)#Rotations

*/

const containAllRots = (str: string, arr: string[]): boolean => {
    const strArr: string[] = str.split("");
    // GET ALL ROTATIONS AND COMPARE
    for (let i = 0; i < strArr.length; i++) {
        // ROTATE
        let currChar = strArr[0];
        strArr.splice(0, 1);
        strArr.push(currChar);
        // CONVERT TO STRING
        let currtRotationStr: string = strArr.join("");
        // COMPARE
        if (arr.indexOf(currtRotationStr) < 0) return false;
    }

    return true;
};

// true
// console.log(
// containAllRots("bsjq", ["bsjq", "qbsj", "sjqb", "twZNsslC", "jqbs"])
// );
// false
// console.log(
//     containAllRots("XjYABhR", [
//         "TzYxlgfnhf",
//         "yqVAuoLjMLy",
//         "BhRXjYA",
//         "YABhRXj",
//         "hRXjYAB",
//         "jYABhRX",
//         "XjYABhR",
//         "ABhRXjY",
//     ])
// );
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function containAllRots2($: string, arr: string[]): boolean {
    arr = arr.map((e) => e.toLowerCase());
    const arr$ = Array.from({ length: $.length }, (x) => $.toLowerCase()).map(
        (el, i) => el.slice(i) + el.slice(0, i)
    );
    return arr$.every((e) => arr.includes(e));
}

function containAllRots3(str: string, arr: string[]): boolean {
    const inputStrings = new Set(arr);
    return getRots(str).every((rotation) => inputStrings.has(rotation));
}

function getRots(str: string, res: string[] = []): string[] {
    if (res.length === str.length) return res;
    res.push(str);
    return getRots(str.slice(1) + str[0], res);
}

function containAllRots4(str: string, arr: string[]): boolean {
    for (let idx = 0; idx < str.length; idx += 1) {
        const rot = str.slice(idx) + str.slice(0, idx);
        if (!arr.includes(rot)) return false;
    }
    return true;
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: DISARIUM NUMBER - (Special Numbers Series #3)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Definition
Disarium number is the number that The sum of its digits powered with their respective positions is equal to the number itself.

Task
Given a number, Find if it is Disarium or not .

Warm-up (Highly recommended)
Playing With Numbers Series
Notes
Number passed is always Positive .
Return the result as String
Input >> Output Examples
disariumNumber(89) ==> return "Disarium !!"
Explanation:
Since , 81 + 92 = 89 , thus output is "Disarium !!"
disariumNumber(564) ==> return "Not !!"
Explanation:
Since , 51 + 62 + 43 = 105 != 564 , thus output is "Not !!"
*/

const disariumNumber = (num: number): string => {
    // CONVERT NUM TO ARRAY OF ITS NUMERIC DIGITS
    const digitsArr: number[] = num
        .toString()
        .split("")
        .map((el) => Number(el));

    // console.log(digitsArr);

    // RAISE EACH EL TO ITS POSITION'S POWER AND GET SUM OF ARRAY
    const pwrPosSum: number = digitsArr
        // POSITION 1 = 0 SO HAVE TO ADJUST BY ADDING 1
        .map((el, idx) => Math.pow(el, idx + 1))
        .reduce((a, b) => a + b);

    // console.log(pwrPosSum);

    return pwrPosSum === num ? "Disarium !!" : "Not !!";
};

// "Disarium !!"
// console.log(disariumNumber(89));
// "Not !!"
// console.log(disariumNumber(564));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function disariumNumber2(n: number): string {
    return String(n)
        .split("")
        .reduce((sum, x, i) => sum + parseInt(x) ** (i + 1), 0) === n
        ? "Disarium !!"
        : "Not !!";
}

const disariumNumber3 = (n: number): string =>
    n
        .toString()
        .split("")
        .map((value, index) => parseInt(value) ** (index + 1))
        .reduce((acc, n) => acc + n, 0) === n
        ? "Disarium !!"
        : "Not !!";

function disariumNumber4(n: number) {
    return String(n)
        .split("")
        .reduce(
            (prev, curr, index) => prev + Math.pow(Number(curr), index + 1),
            0
        ) === n
        ? "Disarium !!"
        : "Not !!";
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: BOILED EGGS - COOKING TIME
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You are the greatest chef on earth. No one boils eggs like you! Your restaurant is always full of guests, who love your boiled eggs. But when there is a greater order of boiled eggs, you need some time, because you have only one pot for your job. How much time do you need?

Your Task
Implement a function, which takes a non-negative integer, representing the number of eggs to boil. It must return the time in minutes (integer), which it takes to have all the eggs boiled.

Rules
you can put at most 8 eggs into the pot at once
it takes 5 minutes to boil an egg
we assume, that the water is boiling all the time (no time to heat up)
for simplicity we also don't consider the time it takes to put eggs into the pot or get them out of it
Example (Input --> Output)
0 --> 0
5 --> 5
10 --> 10
*/

// 1️⃣ ✅
const cookingTime = (eggs: number): number => {
    if (eggs === 0) return 0;
    // CALC HOW MANY ROUNDS NEEDED(EGGS/8 ROUNDED UP TO NEAREST INT)
    const rounds: number = Math.ceil(eggs / 8);
    const time: number = rounds * 5;
    return time;
};

// 2️⃣ ✅ REFACTOR WITH TERNARY
const cookingTime2 = (eggs: number): number => {
    return eggs < 1 ? 0 : Math.ceil(eggs / 8) * 5;
};

// console.log(cookingTime(7));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: STRONG NUMBER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: FACTORIAL()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Definition
Strong number is the number that the sum of the factorial of its digits is equal to number itself.

For example: 145, since
1! + 4! + 5! = 1 + 24 + 120 = 145
So, 145 is a Strong number.

Task
Given a number, Find if it is Strong or not.

Warm-up (Highly recommended)
Playing With Numbers Series
Notes
Number passed is always Positive.
Return the result as String
Input >> Output Examples
strong_num(1) ==> return "STRONG!!!!"
Explanation:
Since , the sum of its digits' factorial of (1) is equal to number itself (1) , Then its a Strong .

strong_num(123) ==> return "Not Strong !!"
Explanation:
Since the sum of its digits' factorial of 1! + 2! + 3! = 9 is not equal to number itself (123) , Then it's Not Strong .

strong_num(2)  ==>  return "STRONG!!!!"
Explanation:
Since the sum of its digits' factorial of 2! = 2 is equal to number itself (2) , Then its a Strong .

strong_num(150) ==> return "Not Strong !!"
Explanation:
Since the sum of its digits' factorial of 1! + 5! + 0! = 122 is not equal to number itself (150), Then it's Not Strong .


*/

const strongNumber = (num: number): string => {
    const factorial = (n: number): number => {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    };
    // console.log(factorial(4));
    const numArr: number[] = num
        .toString()
        .split("")
        .map((el) => Number(el));
    console.log(numArr);

    const factSum: number = numArr
        .map((digit) => {
            return factorial(digit);
        })
        .reduce((a, b) => a + b);
    console.log(factSum);

    return num === factSum ? "STRONG!!!!" : "Not Strong !!";
};

//   NOT STRONG
// console.log(strongNumber(7));
// console.log(strongNumber(145));

// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

/*
const strongNumber2 = (num: number): string => {
    var arr: number[] = [];
  
    function factorial(n: number) { 
        return n <= 1 ? 1 : n * factorial(n - 1)
    }
  
    return num === String(num).split('')
        .map((e) => Number(e))
        .map((e) => factorial(e))
        .reduce((a, b) => a + b) ? "STRONG!!!!" : "Not Strong !!";
  };




  function fac(n: number){
    return n < 2 ? 1 : n * fac(n - 1)
  }
  
  export const strongNumber3 = (num: number): string => {
    return String(num).split("").reduce((a, b) => a + fac(+b), 0) === num ? "STRONG!!!!" : "Not Strong !!";
}; 
  */

const factorial3 = (n: number): number => (n === 0 ? 1 : n * factorial(n - 1));

export const strongNumber4 = (num: number): string =>
    num ===
        num
            .toString()
            .split("")
            .reduce((acc, value) => acc + factorial(parseInt(value)), 0)
        ? "STRONG!!!!"
        : "Not Strong !!";
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:   GOING TO THE CINEMA
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ACCUMULATOR WHILE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
My friend John likes to go to the cinema. He can choose between system A and system B.

System A : he buys a ticket (15 dollars) every time
System B : he buys a card (500 dollars) and a first ticket for 0.90 times the ticket price, 
then for each additional ticket he pays 0.90 times the price paid for the previous ticket.
Example:
If John goes to the cinema 3 times:

System A : 15 * 3 = 45
System B : 500 + 15 * 0.90 + (15 * 0.90) * 0.90 + (15 * 0.90 * 0.90) * 0.90 ( = 536.5849999999999, no rounding for each ticket)
John wants to know how many times he must go to the cinema so that the final result of System B, when rounded up to the next dollar, will be cheaper than System A.

The function movie has 3 parameters: card (price of the card), ticket (normal price of a ticket), perc (fraction of what he paid for the previous ticket) and returns the first n such that

ceil(price of System B) < price of System A.
More examples:
movie(500, 15, 0.9) should return 43 
    (with card the total price is 634, with tickets 645)
movie(100, 10, 0.95) should return 24 
    (with card the total price is 235, with tickets 240)
*/

class G964c {
    public static movie(prePaid: number, ticket: number, perc: number): number {
        let counter: number = 0, // SOLUTION
            sysA: number = 0, // A
            sysB: number = prePaid, // B
            currDiscPrice: number = ticket; // TRACK CURRENT PRICE FOR sysB
        // ROUND UP sysB WHEN CHECKING CONDITION
        while (Math.ceil(sysB) >= sysA) {
            // console.table({ sysA: sysA, sysB: sysB, counter: counter });
            sysA += ticket; // UPDATE sysA
            currDiscPrice *= perc; // CALC CURRENT DISC PRICE
            sysB += currDiscPrice; // UPDATE sysB
            counter++; // INCREMENT COUNTER
            // console.table({
            //     sysA: sysA,
            //     sysB: sysB,
            //     "sysB rounded up: ": Math.ceil(sysB),
            //     counter: counter,
            // });
        }

        return counter;
    }
}

/*
G964c.movie(0, 10, 0.95)
┌───────────────────┬────────┐
│      (index)      │ Values │
├───────────────────┼────────┤
│       sysA        │   10   │
│       sysB        │  9.5   │
│ sysB rounded up:  │   10   │
│      counter      │   1    │
└───────────────────┴────────┘
┌───────────────────┬────────┐
│      (index)      │ Values │
├───────────────────┼────────┤
│       sysA        │   20   │
│       sysB        │ 18.525 │
│ sysB rounded up:  │   19   │
│      counter      │   2    │
└───────────────────┴────────┘
2
*/

// 43
// console.log(G964c.movie(500, 15, 0.9));
// 2
// console.log(G964c.movie(0, 10, 0.95));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G964c1 {
    public static movie(card: number, ticket: number, perc: number): number {
        let i: number = 0;
        while (Math.ceil(card) >= ticket * i) {
            card += ticket * perc ** i;
            i++;
        }
        return i - 1;
    }
}

class G964c2 {
    public static movie(card: number, ticket: number, perc: number): number {
        let k = 1,
            i = 1;
        while (Math.ceil(card + ticket * perc * k) >= ticket * i) {
            k += Math.pow(perc, i);
            i++;
        }
        return i;
    }
}

class G964c3 {
    public static movie(card: number, ticket: number, perc: number): number {
        var cardPrice: number = card + ticket;
        var ticketPrice: number = ticket;
        var previousTicket: number = ticket;
        var i: number = 1;
        while (Math.ceil(cardPrice) >= ticketPrice) {
            ticketPrice += ticket;
            previousTicket *= perc;
            cardPrice += previousTicket;
            i += 1;
        }
        return i - 1;
    }
}

/*
class G964c4 {
    
    public static movie(card: number, ticket: number, perc: number): number {
        let lastN = 0;
        let n = 0;
        let count = 0;
        while(true) {
          lastN = n;
          let costA = G964.systemA(ticket, n);
          let costB = G964.systemB(card, ticket, perc, n);
          if(roundup(costB) >= roundup(costA)) {
            if(Math.abs(costB - costA) < ticket) {
              n++;
            } else {
            n += Math.ceil((costB - costA)/ticket);
            }
          } else {
              break;
          }
          if(count++ > 20) break;
        }
        return n;
    };
    
    public static systemA(ticket, n) {
        return ticket*n;
    }    
    
    public static systemB(card, ticket, perc, n) {
        return card + ticket*perc*(1-Math.pow(perc,n))/(1-perc);
    }
    
    public static costDifference(card: number, ticket: number, perc: number, n: number) {
        return (G964.systemB(card, ticket, perc, n)) - (G964.systemA(ticket, n));
    }
}

function roundup(x): number {
    return Math.ceil(x);
}
*/

class G964c5 {
    public static movie(card: number, ticket: number, perc: number): number {
        let counter = 1;
        let ticketTotal = ticket;

        let currentTicketPrice = ticket * perc;

        let cardTotal = card + currentTicketPrice;

        while (ticketTotal <= Math.ceil(cardTotal)) {
            counter++;

            ticketTotal += ticket;

            currentTicketPrice *= perc;
            cardTotal += currentTicketPrice;
        }

        return counter;
    }
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️  INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:   ORDERED COUNT OF CHARACTERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: COUNT OCCURENCES IN ARRAY, OBJECT.ENTRIES(), SET(), LOOP OVER SET
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Count the number of occurrences of each character and return it as a list of tuples in order of appearance. For empty output return an empty list.

Example:

orderedCount("abracadabra") == [['a', 5], ['b', 2], ['r', 2], ['c', 1], ['d', 1]]
*/

// 1️⃣  !!! THIS IS NOT IN ORDER OF APPEARANCE FOR NUMBER STRING !!!
// WORKS WITH ALPABETIC STRINGS
const orderedCount = (text: string): [string, number][] => {
    let solution: [string, number][] = [];

    interface StingKey {
        [key: string]: number;
    }

    const counterObj: StingKey = {};

    text.split("").forEach(
        (num) => (counterObj[num] = (counterObj[num] || 0) + 1)
    );

    console.log(counterObj);

    Object.entries(counterObj).forEach(([key, value]) => {
        console.log([key, value]);
        solution.push([key, value]);
    });

    return solution;
};

// 2️⃣
const orderedCount2 = (text: string): [string, number][] => {
    const strArr: string[] = text.split("");
    let solution: [string, number][] = [];

    interface StringNumber {
        [key: string]: number;
    }

    const counterObj: StringNumber = {};

    strArr.forEach((num) => (counterObj[num] = (counterObj[num] || 0) + 1));

    console.log(counterObj);

    // Object.entries(counterObj).forEach(([key, value]) => {
    //     console.log([key, value]);
    //     solution.push([key, value]);
    // });

    // LOOP OVER strArr TO PRESERVE ORIGINAL ORDER ???
    // REMOVE DUPLICATES [2, 3, 3, 3, 1, 2] => [2, 3, 1]
    // AND LOOP OVER SET:
    const uniqueElements = new Set<string>(strArr);
    console.log(uniqueElements);

    uniqueElements.forEach((el) => {
        console.log(el, counterObj[el]);
        solution.push([el, counterObj[el]]);
    });

    return solution;
};

// [['a', 5], ['b', 2], ['r', 2], ['c', 1], ['d', 1]]
// console.log(orderedCount("abracadabra"));
// [ [ '2', 2 ], [ '3', 3 ], [ '1', 1 ] ]
// console.log(orderedCount2("233312"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function orderedCount3(text: string): [string, number][] {
    return [...new Set(text)].map((x: string) => [x, text.split(x).length - 1]);
}

function orderedCount4(t: string): [string, number][] {
    return [...new Set(t.split(""))].map((e) => [
        e,
        t.split("").filter((v) => v == e).length,
    ]);
}

function orderedCount5(text: string): [string, number][] {
    const arr = text.split("").filter((el, i, arr) => arr.indexOf(el) === i);
    return arr.map((value, index) => {
        return [value, text.split("").filter((val) => val === value).length];
    });
}

function orderedCount6(text: string): [string, number][] {
    return text
        .split("")
        .filter((el, i) => text.indexOf(el) === i)
        .map((item) => [item, text.split(item).length - 1]);
}

function orderedCount7(text: string): [string, number][] {
    let m: any = {};
    let output: any = [];

    for (let i of text) {
        if (!(i in m)) {
            m[i] = 1;
        } else {
            m[i] += 1;
        }
    }

    for (let i of text) {
        if (i in m) {
            output.push([i, m[i]]);
            delete m[i];
        }
    }

    return output;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: GROWING PLANT - Simple Fun #74
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: BREAK OUT OF WHILE LOOP
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
Each day a plant is growing by upSpeed meters. Each night that plant's height decreases by downSpeed meters due to the lack of sun heat. Initially, plant is 0 meters tall. We plant the seed at the beginning of a day. We want to know when the height of the plant will reach a certain level.

Example
For upSpeed = 100, downSpeed = 10 and desiredHeight = 910, the output should be 10.

After day 1 --> 100
After night 1 --> 90
After day 2 --> 190
After night 2 --> 180
After day 3 --> 280
After night 3 --> 270
After day 4 --> 370
After night 4 --> 360
After day 5 --> 460
After night 5 --> 450
After day 6 --> 550
After night 6 --> 540
After day 7 --> 640
After night 7 --> 630
After day 8 --> 730
After night 8 --> 720
After day 9 --> 820
After night 9 --> 810
After day 10 --> 910 
For upSpeed = 10, downSpeed = 9 and desiredHeight = 4, the output should be 1.

Because the plant reach to the desired height at day 1(10 meters).

After day 1 --> 10
Input/Output
[input] integer upSpeed

A positive integer representing the daily growth.

Constraints: 5 ≤ upSpeed ≤ 100.

[input] integer downSpeed

A positive integer representing the nightly decline.

Constraints: 2 ≤ downSpeed < upSpeed.

[input] integer desiredHeight

A positive integer representing the threshold.

Constraints: 4 ≤ desiredHeight ≤ 1000.

[output] an integer

The number of days that it will take for the plant to reach/pass desiredHeight (including the last day in the total count).
*/

const growingPlant = (up: number, down: number, target: number): number => {
    if (
        up < 5 ||
        up > 100 ||
        down < 2 ||
        down >= up ||
        target < 4 ||
        target > 1000
    ) {
        return 0;
    }

    let actualHeigth = 0,
        counter = 0;

    while (actualHeigth <= target) {
        actualHeigth += up;
        counter++;
        if (actualHeigth >= target) {
            // ❗️ REFACTOR: END RETURN STATEMENT NEVER RUNS ❗️
            // return counter;

            // VS:

            // ❗️ STOP LOOP AND RETURN AT END OF FUNCTION ❗️
            break;
        }
        actualHeigth -= down;

        // console.table({
        //     up: up,
        //     down: down,
        //     actualHeigth: actualHeigth,
        //     counter: counter,
        // });
    }

    return counter;
};

// 10
// console.log(growingPlant(100, 10, 410));
// console.log(growingPlant(10, 10, 410));
// 1
// console.log(growingPlant(10, 9, 4));
// console.log();
// console.log();

/*
growingPlant(100, 10, 410)
┌──────────────┬────────┐
│   (index)    │ Values │
├──────────────┼────────┤
│      up      │  100   │
│     down     │   10   │
│ actualHeigth │   90   │
│   counter    │   1    │
└──────────────┴────────┘
┌──────────────┬────────┐
│   (index)    │ Values │
├──────────────┼────────┤
│      up      │  100   │
│     down     │   10   │
│ actualHeigth │  180   │
│   counter    │   2    │
└──────────────┴────────┘
┌──────────────┬────────┐
│   (index)    │ Values │
├──────────────┼────────┤
│      up      │  100   │
│     down     │   10   │
│ actualHeigth │  270   │
│   counter    │   3    │
└──────────────┴────────┘
┌──────────────┬────────┐
│   (index)    │ Values │
├──────────────┼────────┤
│      up      │  100   │
│     down     │   10   │
│ actualHeigth │  360   │
│   counter    │   4    │
└──────────────┴────────┘
5
*/

//============= OTHER CODEWARS SOLUTIONS: =============

function growingPlant2(up: number, down: number, h: number): number {
    let count: number = 1;
    let a: number = up;
    while (a < h) {
        count++;
        a = a - down + up;
    }
    return count;
}

function growingPlant3(up: number, down: number, target: number): number {
    let height = up;
    let days = 1;
    while (height < target) {
        height += up - down;
        days++;
    }
    return days;
}

function growingPlant4(up: number, down: number, h: number): number {
    return Math.max(Math.ceil((h - down) / (up - down)), 1);
}

function growingPlant5(up: number, down: number, h: number): number {
    let meters = 0;
    let day = 0;
    while (meters < h) {
        day++;
        meters += up;
        if (meters >= h) return day;
        meters -= down;
    }
    return day;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: ROTATE FOR A MAX
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Let us begin with an example:

Take a number: 56789. Rotate left, you get 67895.

Keep the first digit in place and rotate left the other digits: 68957.

Keep the first two digits in place and rotate the other ones: 68579.

Keep the first three digits and rotate left the rest: 68597. Now it is over since keeping the first four it remains only one digit which rotated is itself.

You have the following sequence of numbers:

56789 -> 67895 -> 68957 -> 68579 -> 68597

and you must return the greatest: 68957.

Task
Write function max_rot(n) which given a positive integer n returns the maximum number you got doing rotations similar to the above example.

So max_rot (or maxRot or ... depending on the language) is such as:

max_rot(56789) should return 68957

max_rot(38458215) should return 85821534
*/

class G964B {
    public static maxRot = (num: number): number => {
        console.log(num);
        // GET HOW MANY TIMES NUM WILL BE ROTATED
        const numRotations: number = num.toString().length - 1;
        const numArr = num.toString().split("");
        // NOT NECESSARY AS ORIGINAL NUM IS NOW ADDED TO VERSIONSARR TO COMPARE
        // if (numArr[1] === "0" || num < 10) return num;

        // ARRAY FOR ALL VARIATIONS
        let versionsArr = [];

        for (let i = 0; i < numRotations; i++) {
            // CURRENT DIGIT TO SHIFT
            let rotateDigit = numArr[i];
            // REMOVE iTH DIGIT
            numArr.splice(i, 1);
            // ADD IT TO END OF ARRAY
            numArr.push(rotateDigit);
            //  console.log("CURRENT DIGITS: ", numArr);
            // CONVERT TO NUMBER
            let number: number = parseInt(numArr.join(""));
            // PUSH INTO versionsArr
            versionsArr.push(number);

            // console.table({
            //     rotateDigit: rotateDigit,
            //     number: number
            // })
        }

        // ADD ORIGINAL INPUT NUM TO versionsArr AND GET LARGEST NUMBER
        return Math.max(...versionsArr.concat(num));
    };
}

/*
553188569
┌─────────────┬───────────┐
│   (index)   │  Values   │
├─────────────┼───────────┤
│ rotateDigit │    '5'    │
│   number    │ 531885695 │
└─────────────┴───────────┘
┌─────────────┬───────────┐
│   (index)   │  Values   │
├─────────────┼───────────┤
│ rotateDigit │    '3'    │
│   number    │ 518856953 │
└─────────────┴───────────┘
┌─────────────┬───────────┐
│   (index)   │  Values   │
├─────────────┼───────────┤
│ rotateDigit │    '8'    │
│   number    │ 518569538 │
└─────────────┴───────────┘
┌─────────────┬───────────┐
│   (index)   │  Values   │
├─────────────┼───────────┤
│ rotateDigit │    '5'    │
│   number    │ 518695385 │
└─────────────┴───────────┘
┌─────────────┬───────────┐
│   (index)   │  Values   │
├─────────────┼───────────┤
│ rotateDigit │    '9'    │
│   number    │ 518653859 │
└─────────────┴───────────┘
┌─────────────┬───────────┐
│   (index)   │  Values   │
├─────────────┼───────────┤
│ rotateDigit │    '3'    │
│   number    │ 518658593 │
└─────────────┴───────────┘
┌─────────────┬───────────┐
│   (index)   │  Values   │
├─────────────┼───────────┤
│ rotateDigit │    '5'    │
│   number    │ 518658935 │
└─────────────┴───────────┘
┌─────────────┬───────────┐
│   (index)   │  Values   │
├─────────────┼───────────┤
│ rotateDigit │    '3'    │
│   number    │ 518658953 │
└─────────────┴───────────┘
553188569
*/

// 553188569
// console.log(G964B.maxRot(553188569));
// 988103115
// console.log(G964B.maxRot(1));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

/*
class G964B1 {
    public static maxRot(n) {

        let arrResult = [];
        arrResult.push(n);

        let arrNum = n.toString().split('');
        let i = 0;
        while (arrNum.length >= i) {
            arrNum.push(...arrNum.splice(i, 1));

            arrResult.push(arrNum.join(''));
            i++;
        }

        return arrResult.sort().pop();
    }
}




class G964B2 {
    public static maxRot = ($) => Math.max(...($ = `${$}`.split(``)).reduce((a, b, i) =>
        a.concat([a[i].slice(0, i).concat(a[i].slice(i + 1))
            .concat(a[i].slice(i, i + 1))]), [$]).map(el => el.join('')));
}




class G964B3 {
    public static maxRot(n: number) {
        var s: string = String(n)
        var max = Number(s)

        for (var i = 0; i < s.length; i++) {
            s = s.substr(0, i) + rot(s.substr(i))
            var num = Number(s)
            if (num > max) max = num
        }

        return max

        /////////////////////////

        function rot(s: string) {
            return s.substr(1) + s.substr(0, 1)
        }
    }
}



class G964B4 {
    public static maxRot = n =>
        Math.max(...(n = String(n).split(''))
            .reduce((r, _, i) =>
                r.concat([r[i].slice(0, i)
                    .concat(r[i].slice(i + 1))
                    .concat(r[i].slice(i, i + 1))]), [n])
            .map(e => e.join('')));
}



class G964B5 {
    public static maxRot(n) {
        let arr = n.toString().split('');
        const length = arr.length;
        let results = [];
        for (let i = 0; i < length; i++) {
            // the results are pushed here to include the initial number
            results.push(Number(arr.join('')));
            // cut and paste the rotating number
            let cache = arr.splice(i, 1);
            arr.push(cache[0])
            cache = [];
        }
        return Math.max.apply(null, results);
    }
}



class G964B6 {
    public static maxRot(n) {
        let digits = `${n}`, max = n;

        for (let i = 0; i < digits.length; i++) {

            //  rotate the next digit
            digits = digits.substr(0, i) //  before the rotated digit
                + digits.substr(i + 1)     //  after rotated digit
                + digits.substr(i, 1);     //  the rotated digit

            max = Math.max(max, parseInt(digits));
        }

        return max;
    }
}


class G964B7 {
    public static maxRot(n) {
        let str = n.toString()
        let max = n;
        for (let i = 0; i < str.length; i++) {
            str = str.slice(0, i) + str.slice(i + 1) + str.charAt(i)
            max = Math.max(max, parseInt(str));
        };
        return max;
    }
}



class G964B8 {
    public static maxRot(n) {
        const arrNum = n.toString().split('');
        const resArr = [];
        for (let i = 0; i < arrNum.length - 1; i++) {
            arrNum.push(arrNum.splice(i, 1)[0]);
            resArr.push(Number(arrNum.join('')));
        }
        return Math.max(n, ...resArr);
    }
}
*/

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: SORT OUT MEN FROM BOYS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ CREATE SET TYPE, ❗️❗️❗️ SET(),
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Scenario
Now that the competition gets tough it will Sort out the men from the boys .

Men are the Even numbers and Boys are the odd!alt!alt
Task
Given an array/list [] of n integers , Separate The even numbers from the odds , or Separate the men from the boys!alt!alt
Notes
Return an array/list where Even numbers come first then odds

Since , Men are stronger than Boys , Then Even numbers in ascending order While odds in descending .

Array/list size is at least 4 .

Array/list numbers could be a mixture of positives , negatives .

Have no fear , It is guaranteed that no Zeroes will exists .!alt
Repetition of numbers in the array/list could occur , So (duplications are not included when separating).

Input >> Output Examples:
menFromBoys ({7, 3 , 14 , 17}) ==> return ({14, 17, 7, 3}) 
Explanation:
Since , { 14 } is the even number here , So it came first , then the odds in descending order {17 , 7 , 3} .

menFromBoys ({-94, -99 , -100 , -99 , -96 , -99 }) ==> return ({-100 , -96 , -94 , -99})
Explanation:
Since , { -100, -96 , -94 } is the even numbers here , So it came first in *ascending order *, then the odds in descending order { -99 }

Since , (Duplications are not included when separating) , then you can see only one (-99) was appeared in the final array/list .

menFromBoys ({49 , 818 , -282 , 900 , 928 , 281 , -282 , -1 }) ==> return ({-282 , 818 , 900 , 928 , 281 , 49 , -1})
Explanation:
Since , {-282 , 818 , 900 , 928 } is the even numbers here , So it came first in ascending order , then the odds in descending order { 281 , 49 , -1 }

Since , (Duplications are not included when separating) , then you can see only one (-282) was appeared in the final array/list .
*/

// ! [...EVENS ASCENDING, ...ODDS DESCENDING] REMOVE DUPLICATES !
const menFromBoys = (arr: number[]): number[] => {
    // ❗️❗️❗️ CREATE SET TYPE ❗️❗️❗️ Type 'unknown' is not assignable to type 'number'.ts(2322)
    let uniqueOdds = new Set<number>(),
        uniqueEvens = new Set<number>();
    arr.forEach((int) => {
        (int & 1) === 1 ? uniqueOdds.add(int) : uniqueEvens.add(int);
    });
    const oddsArr = [...uniqueOdds].sort((a, b) => b - a);
    const evensArr = [...uniqueEvens].sort((a, b) => a - b);

    // console.table({
    //     input: arr,
    //     uniqueOdds: [uniqueOdds],
    //     uniqueEvens: [uniqueEvens],
    //     oddsArr: [oddsArr],
    //     evensArr: [evensArr],
    // });

    const solution: number[] = [...evensArr, ...oddsArr];
    return solution;
};

// [14, 17, 7, 3]
// console.log((menFromBoys([7, 3, 14, 17]));
// [2, 90, 95, 43, 37]
// console.log(menFromBoys([37, 2, 43, 95, 90, 37]));

/*

FILTER OUT DUPLICATES WITH SET 
CREATE ASC/DESC SORTED SUB-ARRAYS
MERGE SUB-ARRAYS FOR SOLUTION

INPUT: [37, 2, 43, 95, 90, 37]
┌─────────────┬───────────────────────┬───┬────┬────┬────┬────┐
│   (index)   │           0           │ 1 │ 2  │ 3  │ 4  │ 5  │
├─────────────┼───────────────────────┼───┼────┼────┼────┼────┤
│    input    │          37           │ 2 │ 43 │ 95 │ 90 │ 37 │
│ uniqueOdds  │ Set(3) { 37, 43, 95 } │   │    │    │    │    │
│ uniqueEvens │   Set(2) { 2, 90 }    │   │    │    │    │    │
│   oddsArr   │    [ 95, 43, 37 ]     │   │    │    │    │    │
│  evensArr   │       [ 2, 90 ]       │   │    │    │    │    │
└─────────────┴───────────────────────┴───┴────┴────┴────┴────┘
SOLUTION: [ 2, 90, 95, 43, 37 ]
*/

//============= OTHER CODEWARS SOLUTIONS: =============

function menFromBoys2(arr: number[]) {
    let urr = [...new Set(arr)];
    return [
        ...urr.filter((x) => Math.abs(x % 2) == 0).sort((a, b) => a - b),
        ...urr.filter((x) => Math.abs(x % 2) == 1).sort((a, b) => b - a),
    ];
}

function menFromBoys3(arr: number[]): number[] {
    let ar: number[] = [...new Set(arr)];
    return ar
        .filter((x) => x % 2 === 0)
        .sort((a, b) => a - b)
        .concat(...ar.filter((x) => x % 2).sort((a, b) => b - a));
}

function menFromBoys4(arr: number[]): number[] {
    const [even, odd] = [new Set<number>(), new Set<number>()];

    for (const x of arr) {
        x % 2 ? odd.add(x) : even.add(x);
    }

    return [...even]
        .sort((a, b) => a - b)
        .concat([...odd].sort((a, b) => b - a));
}

function menFromBoys5(arr: number[]): number[] {
    return arr
        .reduce(
            ([even, odd], x) => {
                x % 2 ? odd.add(x) : even.add(x);
                return [even, odd];
            },
            [new Set<number>(), new Set<number>()]
        )
        .map((set, i) =>
            [...set].sort(i % 2 ? (a, b) => b - a : (a, b) => a - b)
        )
        .flat();
}

const menFromBoys6 = (arr: number[]): number[] => [
    ...new Set(
        arr
            .filter((e) => e % 2 === 0)
            .sort((a, b) => a - b)
            .concat(arr.filter((a) => a % 2).sort((a, b) => b - a))
    ),
];
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: BALANCED NUMBER (Special Numbers Series #1 )
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ GENERICS ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Definition
Balanced number is the number that * The sum of all digits to the left of the middle digit(s) and the sum of all digits to the right of the middle digit(s) are equal*.

Task
Given a number, Find if it is Balanced or not .

Warm-up (Highly recommended)
Playing With Numbers Series
Notes
If the number has an odd number of digits then there is only one middle digit, e.g. 92645 has middle digit 6; otherwise, there are two middle digits , e.g. 1301 has middle digits 3 and 0

The middle digit(s) should not be considered when determining whether a number is balanced or not, e.g 413023 is a balanced number because the left sum and right sum are both 5.

Number passed is always Positive .

Return the result as String

Input >> Output Examples
(balanced-num 7) ==> return "Balanced"
Explanation:
Since , The sum of all digits to the left of the middle digit (0)

and the sum of all digits to the right of the middle digit (0) are equal , then It's Balanced

(balanced-num 295591) ==> return "Not Balanced"
Explanation:
Since , The sum of all digits to the left of the middle digits (11)

and the sum of all digits to the right of the middle digits (10) are Not equal , then It's Not Balanced

Note : The middle digit(s) are 55 .

(balanced-num 959) ==> return "Balanced"
Explanation:
Since , The sum of all digits to the left of the middle digits (9)

and the sum of all digits to the right of the middle digits (9) are equal , then It's Balanced

Note : The middle digit is 5 .

(balanced-num 27102983) ==> return "Not Balanced"
Explanation:
Since , The sum of all digits to the left of the middle digits (10)

and the sum of all digits to the right of the middle digits (20) are Not equal , then It's Not Balanced

Note : The middle digit(s) are 02 .


*/

const balancedNum = (num: number) => {
    if (num < 100) return "Balanced";

    // CONVERT TO STRING
    const numStr: string = String(num);
    // GET LENGTH
    const length: number = numStr.length;

    // GET BOTH SIDES AS STRING
    const getLeftNumStr = (numStr: string): string => {
        let leftStr =
            (length & 1) === 1
                ? numStr.slice(0, (length - 1) / 2)
                : numStr.slice(0, length / 2 - 1);

        return leftStr;
    };

    const getRightNumStr = (numStr: string): string => {
        let rightStr =
            (length & 1) === 1
                ? numStr.slice((length - 1) / 2 + 1)
                : numStr.slice(length / 2 + 1);

        return rightStr;
    };

    // GET VALUE OF SUM OF NUMERIC DIGITS
    const leftSum: number = getLeftNumStr(numStr)
        .split("")
        .map((strDigit) => Number(strDigit))
        .reduce((a, b) => a + b);

    const rightSum: number = getRightNumStr(numStr)
        .split("")
        .map((strDigit) => Number(strDigit))
        .reduce((a, b) => a + b);

    /*
      console.table({
          input: num,
          numStr: numStr,
          length: length,
          middleDigitIdxOdd: (length - 1) / 2,
          middleDigitOdd: numStr[(length - 1) / 2],
          middleDigitsIdxEven: [length / 2 - 1, length / 2],
          middleDigitsEven: [numStr[length / 2 - 1], numStr[length / 2]],
          leftNumStr: getLeftNumStr(numStr),
          rightNumStr: getRightNumStr(numStr),
          leftSum: leftSum,
          rightSum: rightSum,
          isBalanced: leftSum === rightSum
      })
      */

    // COMPARE SIDES AND RETURN SOLUTION STRING
    return leftSum === rightSum ? "Balanced" : "Not Balanced";
};

// balanced
// console.log(balancedNum(56239814));
// not balanced
// console.log(balancedNum(1230987));
// console.log();
// console.log();

/*

56239814 EVEN LENGTH
┌─────────────────────┬─────┬─────┬────────────┐
│       (index)       │  0  │  1  │   Values   │
├─────────────────────┼─────┼─────┼────────────┤
│        input        │     │     │  56239814  │
│       numStr        │     │     │ '56239814' │
│       length        │     │     │     8      │
│  middleDigitIdxOdd  │     │     │    3.5     │
│   middleDigitOdd    │     │     │ undefined  │
│ middleDigitsIdxEven │  3  │  4  │            │
│  middleDigitsEven   │ '3' │ '9' │            │
│     leftNumStr      │     │     │   '562'    │
│     rightNumStr     │     │     │   '814'    │
│       leftSum       │     │     │     13     │
│      rightSum       │     │     │     13     │
│     isBalanced      │     │     │    true    │
└─────────────────────┴─────┴─────┴────────────┘
Balanced

1230987 ODD LENGTH
┌─────────────────────┬───────────┬───────────┬───────────┐
│       (index)       │     0     │     1     │  Values   │
├─────────────────────┼───────────┼───────────┼───────────┤
│        input        │           │           │  1230987  │
│       numStr        │           │           │ '1230987' │
│       length        │           │           │     7     │
│  middleDigitIdxOdd  │           │           │     3     │
│   middleDigitOdd    │           │           │    '0'    │
│ middleDigitsIdxEven │    2.5    │    3.5    │           │
│  middleDigitsEven   │ undefined │ undefined │           │
│     leftNumStr      │           │           │   '123'   │
│     rightNumStr     │           │           │   '987'   │
│       leftSum       │           │           │     6     │
│      rightSum       │           │           │    24     │
│     isBalanced      │           │           │   false   │
└─────────────────────┴───────────┴───────────┴───────────┘
Not Balanced

*/

//============= OTHER CODEWARS SOLUTIONS: =============

function balancedNum2(number: number): "Balanced" | "Not Balanced" {
    const numbers = (number + "").split("").map((digit) => parseInt(digit));
    const length = numbers.length;
    if (length <= 2) return "Balanced";

    const left = numbers.slice(0, Math.floor(length / 2 - 0.5));
    const right = numbers.slice(Math.ceil(length / 2 + 0.5), length);

    return left.reduce((a, b) => a + b) == right.reduce((a, b) => a + b)
        ? "Balanced"
        : "Not Balanced";
}

function balancedNum3(number: number): string {
    let s: string = number.toString();
    let n: number = Math.floor((s.length - 1) / 2);
    return !n ||
        [...s.slice(0, n)].reduce((a, b) => a + +b, 0) ==
        [...s.slice(-n)].reduce((a, b) => a + +b, 0)
        ? "Balanced"
        : "Not Balanced";
}

function balancedNum4(number: number) {
    const numArray = number.toString().split("");
    let forwardSum = 0;
    let backwardSum = 0;
    for (let i = 0; i < numArray.length / 2 - 1; i++) {
        forwardSum += parseInt(numArray[i]);
        backwardSum += parseInt(numArray[numArray.length - 1 - i]);
    }

    return forwardSum === backwardSum ? "Balanced" : "Not Balanced";
}

// =====================================================
function balancedNum5(num: number): string {
    const [leftSum, rightSum] = splitMiddle(numToArray(num)).map(sum);

    return leftSum === rightSum ? "Balanced" : "Not Balanced";
}

function numToArray(num: number, res: number[] = []): number[] {
    if (num === 0) return res;
    res.push(num % 10);
    return numToArray(Math.trunc(num / 10), res);
}

// ❗️❗️❗️ GENERICS ❗️❗️❗️
function splitMiddle<T>(arr: T[]): [T[], T[]] {
    const middle = Math.floor(arr.length / 2);
    return [
        arr.slice(0, middle - (arr.length % 2 ? 0 : 1)),
        arr.slice(middle + 1),
    ];
}

function sum(arr: number[]): number {
    return arr.reduce((total, x) => total + x, 0);
}
// =====================================================

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️  INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: RULE OF DIVISIBILITY BY 7
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: RECURSION, SUBSTRING()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A number m of the form 10x + y is divisible by 7 if and only if x − 2y is divisible by 7. In other words, subtract twice the last digit from the number formed by the remaining digits. Continue to do this until a number known to be divisible by 7 is obtained; you can stop when this number has at most 2 digits because you are supposed to know if a number of at most 2 digits is divisible by 7 or not.

The original number is divisible by 7 if and only if the last number obtained using this procedure is divisible by 7.

Examples:
1 - m = 371 -> 37 − (2×1) -> 37 − 2 = 35 ; thus, since 35 is divisible by 7, 371 is divisible by 7.

The number of steps to get the result is 1.

2 - m = 1603 -> 160 - (2 x 3) -> 154 -> 15 - 8 = 7 and 7 is divisible by 7.

3 - m = 372 -> 37 − (2×2) -> 37 − 4 = 33 ; thus, since 33 is not divisible by 7, 372 is not divisible by 7.

4 - m = 477557101->47755708->4775554->477547->47740->4774->469->28 and 28 is divisible by 7, so is 477557101. The number of steps is 7.

Task:
Your task is to return to the function seven(m) (m integer >= 0) an array (or a pair, depending on the language) of numbers, the first being the last number m with at most 2 digits obtained by your function (this last m will be divisible or not by 7), the second one being the number of steps to get the result.

Forth Note:
Return on the stack number-of-steps, last-number-m-with-at-most-2-digits

Examples:
seven(371) should return [35, 1]
seven(1603) should return [7, 2]
seven(477557101) should return [28, 7]
*/

// 1️⃣

// GLOBAL COUNTER VARIABLE TO COUNT HOW MANY TIMES FUNCTION RUNS
let cycleCount: number = 0;

// ❗️❗️❗️ RETURNS number WHEN CALLED AGAIN, AND number[] WHEN SOLUTION IS FOUND ❗️❗️❗️
const seven = (num: number): number | number[] => {
    if (num === 0) return [0, 0];

    // CONVERT TO STRING IN ORDER TO BE ABLE TO EXTRACT DIGITS
    const numStr: string = num.toString();
    // GRAB LAST DIGIT AND REMAINING DIGITS
    let lastDigit: number = Number(numStr.slice(-1));
    let remainingDigits: number = Number(
        // ❗️❗️❗️ SUBSTRING() ❗️❗️❗️
        numStr.substring(0, numStr.length - 1)
    );

    // GET REMAINDER AFTER SUBSTRACTING LASTDIGIT TWICE
    let remainder: number = remainingDigits - lastDigit * 2;
    // INCREMENT CYCLECOUNT
    cycleCount++;
    // INITIALIZE SOLUTION ARRAY
    let solution: number[] = [remainder, cycleCount];

    console.table({
        numStr: numStr,
        lastDigit: lastDigit,
        remainingDigits: remainingDigits,
        remainder: remainder,
        cycleCount: cycleCount,
        solution: [solution],
    });

    // IF REMAINDER IS REDUCED TO MAX 2 DIGITS
    if (remainder < 100) {
        // RESET COUNTER
        cycleCount = 0;
        // RETURN
        return solution;
    }

    // ❗️❗️❗️ RECURSION ❗️❗️❗️
    // OTHERWISE, IF REMAINDER IS NOT REDUCED TO 2 DIGITS
    // RETURN FUNCION WITH REMAINDER
    return seven(remainder);

    // !!! THIS TERNARY IS NOT NECESSARY !!
    // return remainder > 99 ? seven(remainder) : remainder;
};

// 35, 1
// console.log(seven(371));
// [10, 2]
// console.log(seven(1021));
// [28, 7]
// console.log(seven(477557101));

/*

seven(477557101)
┌─────────────────┬─────────────────┬─────────────┐
│     (index)     │        0        │   Values    │
├─────────────────┼─────────────────┼─────────────┤
│     numStr      │                 │ '477557101' │
│    lastDigit    │                 │      1      │
│ remainingDigits │                 │  47755710   │
│    remainder    │                 │  47755708   │
│   cycleCount    │                 │      1      │
│    solution     │ [ 47755708, 1 ] │             │
└─────────────────┴─────────────────┴─────────────┘
┌─────────────────┬────────────────┬────────────┐
│     (index)     │       0        │   Values   │
├─────────────────┼────────────────┼────────────┤
│     numStr      │                │ '47755708' │
│    lastDigit    │                │     8      │
│ remainingDigits │                │  4775570   │
│    remainder    │                │  4775554   │
│   cycleCount    │                │     2      │
│    solution     │ [ 4775554, 2 ] │            │
└─────────────────┴────────────────┴────────────┘
┌─────────────────┬───────────────┬───────────┐
│     (index)     │       0       │  Values   │
├─────────────────┼───────────────┼───────────┤
│     numStr      │               │ '4775554' │
│    lastDigit    │               │     4     │
│ remainingDigits │               │  477555   │
│    remainder    │               │  477547   │
│   cycleCount    │               │     3     │
│    solution     │ [ 477547, 3 ] │           │
└─────────────────┴───────────────┴───────────┘
┌─────────────────┬──────────────┬──────────┐
│     (index)     │      0       │  Values  │
├─────────────────┼──────────────┼──────────┤
│     numStr      │              │ '477547' │
│    lastDigit    │              │    7     │
│ remainingDigits │              │  47754   │
│    remainder    │              │  47740   │
│   cycleCount    │              │    4     │
│    solution     │ [ 47740, 4 ] │          │
└─────────────────┴──────────────┴──────────┘
┌─────────────────┬─────────────┬─────────┐
│     (index)     │      0      │ Values  │
├─────────────────┼─────────────┼─────────┤
│     numStr      │             │ '47740' │
│    lastDigit    │             │    0    │
│ remainingDigits │             │  4774   │
│    remainder    │             │  4774   │
│   cycleCount    │             │    5    │
│    solution     │ [ 4774, 5 ] │         │
└─────────────────┴─────────────┴─────────┘
┌─────────────────┬────────────┬────────┐
│     (index)     │     0      │ Values │
├─────────────────┼────────────┼────────┤
│     numStr      │            │ '4774' │
│    lastDigit    │            │   4    │
│ remainingDigits │            │  477   │
│    remainder    │            │  469   │
│   cycleCount    │            │   6    │
│    solution     │ [ 469, 6 ] │        │
└─────────────────┴────────────┴────────┘
┌─────────────────┬───────────┬────────┐
│     (index)     │     0     │ Values │
├─────────────────┼───────────┼────────┤
│     numStr      │           │ '469'  │
│    lastDigit    │           │   9    │
│ remainingDigits │           │   46   │
│    remainder    │           │   28   │
│   cycleCount    │           │   7    │
│    solution     │ [ 28, 7 ] │        │
└─────────────────┴───────────┴────────┘
[ 28, 7 ]
*/

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️  INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:   BUILD A SQUARE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ LINEBREAK "\n" (ADD NEW LINE TO CONSOLE OUTPUT) ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
I will give you an integer. Give me back a shape that is as long and wide as the integer. The integer will be a whole number between 1 and 50.

Example
n = 3, so I expect a 3x3 square back just like below as a string:

+++
+++
+++
*/

const generateShape = (int: number): string => {
    if (int === 1) return "+";

    let solution: string = "";

    for (let i = 0; i < int; i++) {
        // ❗️❗️❗️ LINE BREAK ❗️❗️❗️
        let row: string = i >= 1 ? "\n" + "+".repeat(int) : "+".repeat(int);
        solution += row;
    }

    return solution;
};

//   ADD LINE BREAK TO EVERY ROW BUT FIRST

// console.log(generateShape(3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ LINE BREAK ❗️❗️❗️
function generateShape2(int: number): string {
    return `${"+".repeat(int)}\n`.repeat(int).slice(0, -1);
}

function generateShape3(int: number): string {
    return Array(int)
        .fill(Array(int + 1).join("+"))
        .join("\n");
}

function generateShape4(int: number): string {
    var array = [];
    for (let i = 0; i < int; i++) {
        array.push("+".repeat(int));
    }

    return array.join("\n");
}

function generateShape5(int: number): string {
    let result: string = "";
    for (let i: number = 0; i < int; i++) result += "+".repeat(int) + "\n";
    return result.slice(0, result.length - 1);
}

function generateShape6(size: number): string {
    return new Array(size).fill(new Array(size).fill("+").join("")).join("\n");
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: AUTOMORPHIC NUMBER (Special Numbers Series #6)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ ENDSWITH ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Definition
A number is called Automorphic number if and only if its square ends in the same digits as the number itself.

Task
Given a number determine if it Automorphic or not .

Warm-up (Highly recommended)
Playing With Numbers Series
Notes
The number passed to the function is positive
Input >> Output Examples
autoMorphic (25) -->> return "Automorphic" 
Explanation:
25 squared is 625 , Ends with the same number's digits which are 25 .

autoMorphic (13) -->> return "Not!!"
Explanation:
13 squared is 169 , Not ending with the same number's digits which are 69 .

autoMorphic (76) -->> return "Automorphic"
Explanation:
76 squared is 5776 , Ends with the same number's digits which are 76 .

autoMorphic (225) -->> return "Not!!"
Explanation:
225 squared is 50625 , Not ending with the same number's digits which are 225.

*/

const automorphic = (num: number): string => {
    const numStr: string = num.toString();
    const numStrLength: number = numStr.length;

    const sqStr: string = Math.pow(num, 2).toString();

    // console.table({
    //     numStr: numStr,
    //     numStrLength: numStrLength,
    //     sqStr: sqStr,
    //     isAutoMorphic: numStr == sqStr.slice(-numStrLength),
    // });

    return numStr === sqStr.slice(-numStrLength) ? "Automorphic" : "Not!!";
};

//  CONVERT BOTH TO STRING
//  GET LENGTH OF num (THIS WILL BE THE NUMBER OF LAST DIGITS OF sqStr TO COMPARE  num WITH)
//  COMPARE AND RETURN RESULT STRING

/*
┌───────────────┬─────────┐
│    (index)    │ Values  │
├───────────────┼─────────┤
│    numStr     │  '225'  │
│ numStrLength  │    3    │
│     sqStr     │ '50625' │
│ isAutoMorphic │  false  │
└───────────────┴─────────┘
Not!!
┌───────────────┬──────────┐
│    (index)    │  Values  │
├───────────────┼──────────┤
│    numStr     │  '625'   │
│ numStrLength  │    3     │
│     sqStr     │ '390625' │
│ isAutoMorphic │   true   │
└───────────────┴──────────┘
Automorphic
*/

// console.log(automorphic(3));
// console.log(automorphic(225));
// console.log(automorphic(625));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ ENDSWITH ❗️❗️❗️
function automorphic2(n: number): string {
    return String(n ** 2).endsWith(String(n)) ? "Automorphic" : "Not!!";
}

// // 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩

// TITLE: SIMPLE BEADS COUNT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Two red beads are placed between every two blue beads. There are N blue beads. After looking at the arrangement below work out the number of red beads.

@ @@ @ @@ @ @@ @ @@ @ @@ @

Implement count_red_beads(n) (in PHP count_red_beads($n); in Java, Javascript, TypeScript, C, C++ countRedBeads(n)) so that it returns the number of red beads.
If there are less than 2 blue beads return 0.
*/

const countRedBeads = (num: number): number => {
    return num <= 1 ? 0 : (num - 1) * 2;
};

// console.log(countRedBeads(1));
// console.log(countRedBeads(3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function countRedBeads2(n: number): number {
    return Math.max(0, (n - 1) * 2);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: INVITE MORE WOMEN - Simple Fun 152
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: EVAL,
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
King Arthur and his knights are having a New Years party. Last year Lancelot was jealous of Arthur, because Arthur had a date and Lancelot did not, and they started a duel.

To prevent this from happening again, Arthur wants to make sure that there are at least as many women as men at this year's party. He gave you a list of integers of all the party goers.

Arthur needs you to return true if he needs to invite more women or false if he is all set.

Input/Output
[input] integer array L ($a in PHP)
An array (guaranteed non-associative in PHP) representing the genders of the attendees, where -1 represents women and 1 represents men.

2 <= L.length <= 50

[output] a boolean value

true if Arthur need to invite more women, false otherwise.
*/

const inviteMoreWomen = (guestsArr: number[]): boolean => {
    return guestsArr.reduce((acc, curr) => acc + curr) > 0;
};

// console.log(inviteMoreWomen([1, -1, 1]));
// console.log(inviteMoreWomen([1, -1]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ EVAL ❗️❗️❗️
function inviteMoreWomen2(L: number[]): boolean {
    return eval(L.join("+")) > 0;
}

function inviteMoreWomen3(L: number[]): boolean {
    return (
        L.filter((num) => num > 0).length > L.filter((num) => num < 0).length
    );
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: SUM OF CUBES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: RECURSION ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function that takes a positive integer n, sums all the cubed values from 1 to n, and returns that sum.

Assume that the input n will always be a positive integer.

Examples: (Input --> output)

2 --> 9 (sum of the cubes of 1 and 2 is 1 + 8)
3 --> 36 (sum of the cubes of 1, 2, and 3 is 1 + 8 + 27)
*/

const sumCubes = (num: number): number => {
    let result: number = 0;

    for (let i = 1; i <= num; i++) {
        result += Math.pow(i, 3);
    }

    return result;
};

// console.log(sumCubes(2));
// console.log(sumCubes(3));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function sumCubes2(n: number): number {
    let res = 0;
    for (let i = 0; i <= n; i += 1) {
        res += i ** 3;
    }
    return res;
}

// ❗️❗️❗️ RECURSION ❗️❗️❗️
function sumCubes3(n: number): number {
    if (n == 1) {
        return 1;
    } else {
        return Math.pow(n, 3) + sumCubes(n - 1);
    }
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: ALPHABET SYMMETRY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: CHARCODEAT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Consider the word "abode". We can see that the letter a is in position 1 and b is in position 2. In the alphabet, a and b are also in positions 1 and 2. Notice also that d and e in abode occupy the positions they would occupy in the alphabet, which are positions 4 and 5.

Given an array of words, return an array of the number of letters that occupy their positions in the alphabet for each word. For example,

solve(["abode","ABc","xyzD"]) = [4, 3, 1]
See test cases for more examples.

Input will consist of alphabet characters, both uppercase and lowercase. No spaces.

Good luck!
*/

const solveA = (arr: string[]): number[] => {
    let solution: number[] = [];

    arr.map((el) => el.toLowerCase()).forEach((word) => {
        let counter: number = 0;

        for (let i = 0; i < word.length; i++) {
            let position: number = i;
            let charCode: number = word.charCodeAt(i) - 97;
            // console.table({
            //     char: word[i],
            //     position: position,
            //     charCode: charCode,
            //     match: position === charCode,
            // });
            if (position === charCode) counter++;
        }
        solution.push(counter);
    });

    return solution;
};

//  CASE INSENSITIVE (LOWERCASE)
//  LOOP OVER ARRAY
//      INNER LOOP WILL ITERATE OVER EACH WORD
//          COMPARE CHAR POSITION TO ITS CHARCODE(-97)
//          IF THEY MATCH:
//              INCREMENT COUNTER FOR WORD
//  PUSH COUNTER INTO SOLUTION IN FOREACH
//  RETURN SOLUTION

//

/*
["IAMDEFANDJKL", "thedefgh", "xyzDEFghijabc"]
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'i'   │
│ position │   0    │
│ charCode │   8    │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'a'   │
│ position │   1    │
│ charCode │   0    │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'm'   │
│ position │   2    │
│ charCode │   12   │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'd'   │
│ position │   3    │
│ charCode │   3    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'e'   │
│ position │   4    │
│ charCode │   4    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'f'   │
│ position │   5    │
│ charCode │   5    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'a'   │
│ position │   6    │
│ charCode │   0    │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'n'   │
│ position │   7    │
│ charCode │   13   │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'd'   │
│ position │   8    │
│ charCode │   3    │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'j'   │
│ position │   9    │
│ charCode │   9    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'k'   │
│ position │   10   │
│ charCode │   10   │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'l'   │
│ position │   11   │
│ charCode │   11   │
│  match   │  true  │
└──────────┴────────┘
thedefgh
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  't'   │
│ position │   0    │
│ charCode │   19   │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'h'   │
│ position │   1    │
│ charCode │   7    │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'e'   │
│ position │   2    │
│ charCode │   4    │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'd'   │
│ position │   3    │
│ charCode │   3    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'e'   │
│ position │   4    │
│ charCode │   4    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'f'   │
│ position │   5    │
│ charCode │   5    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'g'   │
│ position │   6    │
│ charCode │   6    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'h'   │
│ position │   7    │
│ charCode │   7    │
│  match   │  true  │
└──────────┴────────┘
xyzdefghijabc
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'x'   │
│ position │   0    │
│ charCode │   23   │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'y'   │
│ position │   1    │
│ charCode │   24   │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'z'   │
│ position │   2    │
│ charCode │   25   │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'd'   │
│ position │   3    │
│ charCode │   3    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'e'   │
│ position │   4    │
│ charCode │   4    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'f'   │
│ position │   5    │
│ charCode │   5    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'g'   │
│ position │   6    │
│ charCode │   6    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'h'   │
│ position │   7    │
│ charCode │   7    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'i'   │
│ position │   8    │
│ charCode │   8    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'j'   │
│ position │   9    │
│ charCode │   9    │
│  match   │  true  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'a'   │
│ position │   10   │
│ charCode │   0    │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'b'   │
│ position │   11   │
│ charCode │   1    │
│  match   │ false  │
└──────────┴────────┘
┌──────────┬────────┐
│ (index)  │ Values │
├──────────┼────────┤
│   char   │  'c'   │
│ position │   12   │
│ charCode │   2    │
│  match   │ false  │
└──────────┴────────┘
[ 6, 5, 7 ]
*/

// [4, 3, 1]
// console.log(solveA(["abode", "ABc", "xyzD"]));
// console.log(solveA(["ABCABC"]));

// [ 6, 5, 7 ]
// console.log(solveA(["IAMDEFANDJKL", "thedefgh", "xyzDEFghijabc"]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function solveA2(arr: string[]) {
    const alphabet: string = "abcdefghijklmnopqrstuvwxyz";
    return arr.map((s) =>
        s
            .split("")
            .reduce(
                (t, c, i) => (c.toLowerCase() === alphabet[i] ? t + 1 : t),
                0
            )
    );
}

function solveA3(arr: string[]): number[] {
    return arr.map((str) => {
        var count = 0;
        var i = str.length;

        while (i > 0) {
            i--;
            if ((str.charCodeAt(i) & 31) == i + 1) count++;
        }

        return count;
    });
}

const solveA4 = (arr: string[]) =>
    arr.map((x) =>
        x
            .split("")
            .reduce(
                (acc, item, i) =>
                    acc + (item.toLowerCase().charCodeAt(0) - 97 == i ? 1 : 0),
                0
            )
    );

function solveA5(arr: string[]) {
    const alphabet: string[] = "abcdefghijklmnopqrstuvwxyz".split("");

    return arr.map((word) => {
        return word
            .toLowerCase()
            .split("")
            .reduce((acc, char, i) => {
                const isPositionMatch = alphabet[i] === char;
                return acc + (isPositionMatch ? 1 : 0);
            }, 0);
    });
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: MINIMIZE SUM OF ARRAY - Array Series #1
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: SORT, SPLICE, REDUCE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
Given an array of integers , Find the minimum sum which is obtained from summing each Two integers product .

Notes
Array/list will contain positives only .
Array/list will always has even size
Input >> Output Examples
minSum({5,4,2,3}) ==> return (22) 
Explanation:
The minimum sum obtained from summing each two integers product , 5*2 + 3*4 = 22
minSum({12,6,10,26,3,24}) ==> return (342)
Explanation:
The minimum sum obtained from summing each two integers product , 26*3 + 24*6 + 12*10 = 342
minSum({9,2,8,7,5,4,0,6}) ==> return (74)
Explanation:
The minimum sum obtained from summing each two integers product , 9*0 + 8*2 +7*4 +6*5 = 74
*/

const minSum = (arr: number[]): number | string => {
    if ((arr.length & 1) === 1) return "odd number of array elements!";

    let sum: number = 0;
    const ascArr = arr.sort((a, b) => a - b);
    console.log(ascArr);
    for (let i = 0; i < ascArr.length / 2; i++) {
        // console.table({ first: ascArr[i], last: ascArr[ascArr.length - 1 - i] });
        sum += ascArr[i] * ascArr[ascArr.length - 1 - i];
    }

    return sum;
};

//  ! MULTIPLY LARGEST BY SMALLEST !

//  SORT ARRAY NUMERICALLY ASCENDING (OR DESCENDING)
//  LOOP OVER FIRST HALF OF ARRAY
//      MULTIPLY FIRST EL BY LAST, THEN SECOND BY LAST-1 ETC...AND ADD PRODUCT TO SUM

// 22
// console.log(minSum([5, 4, 2, 3]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function minSum2(arr: number[]) {
    let sum = 0;
    const nums = [...arr];
    while (nums.length !== 0) {
        const max = Math.max(...nums);
        const min = Math.min(...nums);
        sum += max * min;
        nums.splice(nums.indexOf(max), 1);
        nums.splice(nums.indexOf(min), 1);
    }
    return sum;
}

function minSum3(arr: number[]) {
    return [...arr]
        .sort((a, b) => a - b)
        .reduce((sum, x, _, sorted) => sum + x * sorted.pop()!, 0);
}

function minSum4(arr: number[]): number {
    return arr
        .sort((a: number, b: number) => a - b)
        .reduce(
            (acc: number, currVal: number, index: number, a: number[]) =>
                acc + (currVal * a[a.length - 1 - index]) / 2,
            0
        );
}

function minSum5(arr: number[]): number {
    return arr
        .sort((a: number, b: number) => a - b)
        .reduce(
            (acc: number, currVal: number, index: number, a: number[]) =>
                acc + (currVal * a[a.length - 1 - index]) / 2,
            0
        );
}

// ❗️❗️❗️ LOOK INTO REDUCE AND MAP ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: AVARAGES OF NUMBERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ MAP(), REDUCE(), ISARRAY(), SLICE(0, -1) ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
#Get the averages of these numbers

Write a method, that gets an array of integer-numbers and return an array of the averages of each integer-number and his follower, if there is one.

Example:

Input:  [ 1, 3, 5, 1, -10]
Output:  [ 2, 4, 3, -4.5]
If the array has 0 or 1 values or is null, your method should return an empty array.

Have fun coding it and please don't forget to vote and rank this kata! :-)
*/

// ❗️❗️❗️ (numArr![i] ❗️❗️❗️
// const averages = (numArr: number[] | null): number[] => {
//     for (let i = 0; i < numArr!.length - 1; i++) {
//         let pairAve: number = (numArr![i] + numArr![i + 1]) / 2;
//         console.log(pairAve);
//     }

//     return [1];
// };

const averages = (numArr: number[] | null): number[] => {
    if (!numArr || numArr.length < 2) return [];

    let solution: number[] = [];

    for (let i = 0; i < numArr.length - 1; i++) {
        let pairAve: number = (numArr[i] + numArr[i + 1]) / 2;
        solution.push(pairAve);
    }

    return solution;
};

// console.log(averages([1, 3, 5, 1, -10]));
// console.log(averages([1, 3]));
// console.log(averages([]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// REDUCE()
function averages2(numbers: number[]): number[] {
    let avrgs: number[] = [];
    if (!numbers || numbers.length <= 1) {
        return avrgs;
    }

    numbers.reduce((a, b) => {
        avrgs.push((a + b) / 2);
        return b;
    });

    return avrgs;
}

// ISARRAY(), MAP
// ❗️❗️❗️ slice(0, -1) WILL GET RID OF LAST ELEMENT NAN [2,4,3,-4.5,NaN] ❗️❗️❗️
// ❗️❗️❗️ slice(0, numbers.length -1) === slice(0, -1) ❗️❗️❗️
function averages3(numbers: number[]): number[] {
    return Array.isArray(numbers)
        ? numbers
            .map((item, index) => (item + numbers[index + 1]) / 2)
            .slice(0, -1)
        : [];
}

function averages4(numbers: number[] | null): number[] {
    if (numbers === null) return [];
    return numbers.slice(1).map((x, i) => (numbers[i] + x) / 2);
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️  INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: ALPHABETICAL ADDITION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ CHARCODEAT(), STRING.FROMCHARCODE(), REDUCE(INITIAL VALUE), SPREAD ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to add up letters to one letter.

The function will be given a variable amount of arguments, each one being a letter to add.

Notes:
Letters will always be lowercase.
Letters can overflow (see second to last example of the description)
If no letters are given, the function should return 'z'
Examples:
addLetters('a', 'b', 'c') = 'f'
addLetters('a', 'b') = 'c'
addLetters('z') = 'z'
addLetters('z', 'a') = 'a'
addLetters('y', 'c', 'b') = 'd' // notice the letters overflowing
addLetters() = 'z'
*/

/*
a	097	01100001	A	065	01000001
b	098	01100010	B	066	01000010
c	099	01100011	C	067	01000011
d	100	01100100	D	068	01000100
e	101	01100101	E	069	01000101
f	102	01100110	F	070	01000110
g	103	01100111	G	071	01000111
h	104	01101000	H	072	01001000
i	105	01101001	I	073	01001001
j	106	01101010	J	074	01001010
k	107	01101011	K	075	01001011
l	108	01101100	L	076	01001100
m	109	01101101	M	077	01001101
n	110	01101110	N	078	01001110
o	111	01101111	O	079	01001111
p	112	01110000	P	080	01010000
q	113	01110001	Q	081	01010001
r	114	01110010	R	082	01010010
s	115	01110011	S	083	01010011
t	116	01110100	T	084	01010100
u	117	01110101	U	085	01010101
v	118	01110110	V	086	01010110
w	119	01110111	W	087	01010111
x	120	01111000	X	088	01011000
y	121	01111001	Y	089	01011001
z	122	01111010	Z	090	01011010

*/

const addLetters = (...letters: string[]): string => {
    if (letters.length === 0) return "z";

    const charCodeSum = letters
        .map((char) => char.charCodeAt(0) - 96)
        .reduce((acc, curr) => acc + curr, 0); // 26 FOR "z"

    if (charCodeSum % 26 === 0) return "z";

    return charCodeSum > 26
        ? String.fromCharCode((charCodeSum % 26) + 96)
        : String.fromCharCode(charCodeSum + 96);
};

//  SOLUTION WITH COMMENTS:

const addLetters2 = (...letters: string[]): string => {
    // ❗️❗️❗️ SPREAD ARGUMENTS ❗️❗️❗️
    console.log(...letters); // a b c
    console.log(letters); // [ 'a', 'b', 'c' ]

    // RETURN Z FOR EMPTY ARRAY
    if (letters.length === 0) return "z";

    // ❗️❗️❗️ CHARCODEAT()
    const charCodeSum = letters
        .map((char) => char.charCodeAt(0) - 96) // [1(97-96), 2(98-96)...3]
        .reduce((acc, curr) => acc + curr, 0); // [6(1+2+3)]
    console.log(charCodeSum);
    console.log(charCodeSum % 26);

    // IF SUM IS MULTIPLIES OF 26 RETURN Z AS SUM % 26 WILL RESULT IN CHARCODE(0)
    if (charCodeSum % 26 === 0) return "z";

    // STRING.FROMCHARCODE()
    return charCodeSum > 26
        ? String.fromCharCode((charCodeSum % 26) + 96) // OVERLAP (MORE THAN 26)
        : String.fromCharCode(charCodeSum + 96);
};

// z
// console.log(addLetters(addLetters("f", "g", "a", "r", "t")));
// d
// console.log(addLetters(['y', 'c', 'b']));

// z FOR EMPTY ARRAY OR NO ARGUMENTS
// console.log(addLetters());

// f
// console.log(console.log(addLetters("s", "k", "g", "u", "z")));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function addLetters3(...letters: string[]): string {
    const aCode: number = "a".charCodeAt(0);
    const zCode: number = "z".charCodeAt(0);
    const mod: number = zCode - aCode + 1;

    const normalizeCharCode = (letter: string): number =>
        letter.charCodeAt(0) - aCode + 1;
    const normalizeCharCodes: number[] = letters.map(normalizeCharCode);

    const add = (a: number, b: number): number => a + b;
    const value: number = normalizeCharCodes.reduce(add, 0);

    const finalCharCode: number = ((value - 1 + mod) % mod) + aCode;
    return String.fromCharCode(finalCharCode);
}

const addLetters4 = (...letters: string[]) =>
    String.fromCharCode(
        (letters.reduce((acc, val) => acc + val.charCodeAt(0) - 96, 0) % 26 ||
            26) + 96
    );

const alphabet = "abcdefghijklmnopqrstuvwxyz";

const addLetters5 = (...letters: string[]): string =>
    letters.length === 0
        ? "z"
        : alphabet[
        (letters.reduce((acc, c) => acc + (alphabet.indexOf(c) + 1), 0) -
            1) %
        alphabet.length
        ];

function addLetters6(...letters: string[]) {
    // your code here
    if (letters.length === 0) return "z"; // account for empty input array
    const letterArray = "abcdefghijklmnopqrstuvwxyz".split(""); // create array for index reference
    let sum = 0;
    for (const letter of letters) {
        sum += letterArray.indexOf(letter) + 1; // add +1 to compensate for index 0 start logic
    }
    let remainder = sum % 26;
    if (remainder === 0) return "z";
    else return letterArray[remainder - 1];
}

function addLetters7(...letters: string[]) {
    const sum =
        letters.map((c) => c.charCodeAt(0) - 96).reduce((a, b) => a + b, 0) %
        26;

    return sum === 0 ? "z" : String.fromCharCode(96 + sum);
}

function addLetters8(...letters: string[]) {
    const s = "zabcdefghijklmnopqrstuvwxy";
    let sum = 0;
    for (let l of letters) {
        sum += s.indexOf(l);
    }
    return s[sum % 26];
}

function addLetters9(...letters: string[]) {
    if (!letters || letters.length < 1) return "z";
    if (letters.length === 1) return letters[0];

    const num: number =
        letters
            .map((ch) => ch.charCodeAt(0) - 96)
            .reduce((sum, curr) => sum + curr, 0) % 26;

    if (num === 0) return "z";
    else return String.fromCharCode(num + 96);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: POWER OF TWO
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:❗️❗️❗️  MATH.LOG() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Complete the function power_of_two/powerOfTwo (or equivalent, depending on your language) that determines if a given non-negative integer is a power of two. From the corresponding Wikipedia entry:

a power of two is a number of the form 2n where n is an integer, i.e. the result of exponentiation with number two as the base and integer n as the exponent.

You may assume the input is always valid.

Examples
power_of_two?(1024) # true
power_of_two?(4096) # true
power_of_two?(333)  # false
Beware of certain edge cases - for example, 1 is a power of 2 since 2^0 = 1 and 0 is not a power of 2.
*/

const isPowerOfTwo = (num: number): boolean => {
    if (num === 1) return true;
    if ((num & 1) === 1) return false;
    // KEEP DIVIDING NUM BY 2
    while (num > 1) {
        num = num / 2;
    }

    // console.log(num);

    // IF NUM / 2 EQUALS 1 RETURN true, OTHERWISE false
    return num === 1;

    // OR:

    // return num === 1
    //     ? true
    //     : false;
};

// console.log(isPowerOfTwo(23));
// console.log(isPowerOfTwo(18));
// console.log(isPowerOfTwo(4096));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function isPowerOfTwo2(n: number): boolean {
    return Number.isInteger(Math.log2(n));
}

const isPowerOfTwo3 = (n: number): boolean => Math.log2(n) % 1 === 0;

function isPowerOfTwo4(n: number): boolean {
    return n === 2 || n === 1 ? true : n < 2 ? false : isPowerOfTwo(n / 2);
}

function isPowerOfTwo5(n: number): boolean {
    for (let i = 0; true; i++) {
        const pow = Math.pow(2, i);
        if (pow === n) {
            return true;
        } else if (pow > n) {
            return false;
        }
    }
}

function isPowerOfTwo6(n: number): boolean {
    while (n > 2 && n % 2 == 0) n = n / 2;

    return n == 2 || n == 1;
}

// TITLE:  OVER THE ROAD
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
You've just moved into a perfectly straight street with exactly n identical houses on either side of the road. Naturally, you would like to find out the house number of the people on the other side of the street. The street looks something like this:

Street
1|   |6
3|   |4
5|   |2
Evens increase on the right; odds decrease on the left. House numbers start at 1 and increase without gaps. When n = 3, 1 is opposite 6, 3 opposite 4, and 5 opposite 2.

Example (address, n --> output)
Given your house number address and length of street n, give the house number on the opposite side of the street.

1, 3 --> 6
3, 3 --> 4
2, 3 --> 5
3, 5 --> 8
Note about errors
If you are timing out, running out of memory, or get any kind of "error", read on. Both n and address could get upto 500 billion with over 200 random tests. If you try to store the addresses of 500 billion houses in a list then you will run out of memory and the tests will crash. This is not a kata problem so please don't post an issue. Similarly if the tests don't complete within 12 seconds then you also fail.

To solve this, you need to think of a way to do the kata without making massive lists or huge for loops. Read the discourse for some inspiration :)
*/

const overTheRoad = (address: number, n: number): number => {
    return n * 2 + 1 - address;
};

//  OPPOSITE NUMBERS ADD UP TO TWICE THE LENGTH OF STREET PLUS 1
//  SUBSTRACT YOUR address FROM THAT SUM TO GET RESULT

// console.log(overTheRoad(1, 3));
// console.log(overTheRoad(3, 3));
// console.log(overTheRoad(7, 11));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function overTheRoad2(address: number, n: number): number {
    // Good luck!
    if (address % 2 === 0) {
        return 1 + 2 * (n - address / 2);
    } else {
        return 2 * n - (address - 1);
    }
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  EVEN NUMBERS IN AN ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: BITWISE AND, FILTER()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given an array of digitals numbers, return a new array of length number containing the last even numbers from the original array (in the same order). The original array will be not empty and will contain at least "number" even numbers.

For example:

([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) => [4, 6, 8]
([-22, 5, 3, 11, 26, -6, -7, -8, -9, -8, 26], 2) => [-8, 26]
([6, -25, 3, 7, 5, 5, 7, -3, 23], 1) => [6]
*/

const evenNumbers = (array: number[], n: number): number[] => {
    return array.filter((el) => (el & 1) === 0).slice(-n);
};

//  FILTER OUT ODD NUMBERS
//  RETURN SUB ARRAY OF LAST n ELEMENTS (SLICE WITH NEGATIVE IDX)

// console.log(evenNumbers([1, 2, 3, 4, 5, 6, 7, 8, 9], 3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function isEven2(n: number): boolean {
    return n % 2 === 0;
}

function evenNumbers2(array: number[], n: number): number[] {
    return array.filter(isEven2).slice(-n);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SPEED CONTROL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  BITWISE OR TO ROUND DOWN, MATH.MAX() WITH SPREAD
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
In John's car the GPS records every s seconds the distance travelled from an origin (distances are measured in an arbitrary but consistent unit). For example, below is part of a record with s = 15:

x = [0.0, 0.19, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25]
The sections are:

0.0-0.19, 0.19-0.5, 0.5-0.75, 0.75-1.0, 1.0-1.25, 1.25-1.50, 1.5-1.75, 1.75-2.0, 2.0-2.25
We can calculate John's average hourly speed on every section and we get:

[45.6, 74.4, 60.0, 60.0, 60.0, 60.0, 60.0, 60.0, 60.0]
Given s and x the task is to return as an integer the *floor* of the maximum average speed per hour obtained on the sections of x. If x length is less than or equal to 1 return 0 since the car didn't move.

Example:
with the above data your function gps(s, x)should return 74

Note
With floats it can happen that results depends on the operations order. To calculate hourly speed you can use:

(3600 * delta_distance) / s.
*/

class G965a1 {
    public static gps = (secInt: number, distArr: number[]): number => {
        // secInterval: SECONDS
        // distArr: KMS
        let speedsArr = [];

        for (let i = 1; i < distArr.length; i++) {
            let curr = distArr[i],
                prev = distArr[i - 1];
            let sectionDist = curr - prev;
            let sectAveSpeed = (3600 / secInt) * sectionDist;
            // console.table(
            //     { time: secInt, dist: sectionDist, speed: sectAveSpeed }
            // );
            speedsArr.push(sectAveSpeed);
        }

        console.log(speedsArr);

        return Math.max(...speedsArr) | 0;
    };
}

//  CALCULATE AVERAGE SPEED FOR EACH SECTION WITH LOOP
//  PUSH IT INTO speedsArray AS sectAveSpeed
//  FIND LARGEST NUMBER(SPEED) IN speedsArray AND ROUND IT DOWN TO NEAREST INT
//  BITWISE OR "|" WILL ROUND DOWN DECIMALS: 3.345 | 0  =>  3

// s = 15;
// u = 74;
// console.log(G965a1.gps(15, [0.0, 0.19, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25]));

// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G965a2 {
    public static gps = (seconds: number, sections: number[]): number => {
        if (sections.length <= 1) return 0;

        const sectionSpeeds = sections
            .map((start, index) => start - (sections[index - 1] || 0))
            .map((distance) => (3600 * distance) / seconds);

        return Math.floor(Math.max(...sectionSpeeds));
    };
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  NO ODDITIES HERE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: BITWISE AND "&" (EVEN OR ODD)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a small function that returns the values of an array that are not odd.

All values in the array will be integers. Return the good values in the order they are given.
*/

const noOdds = (values: number[]): number[] => {
    return values.filter((el) => {
        return (el & 1) === 0;
    });
};

//  BITWISE AND "&" OPERATOR
//  n & 1
//  RETURNS 1 IF n IS ODD
//  RETURNS 0 IF n IS EVEN

// console.log(noOdds( [0,1] ));
// console.log(noOdds([0, 1, 2, 3]));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function noOdds2(values: number[]): number[] {
    return values.filter((i) => !(i % 2));
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PARTS OF A LIST
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: SLICE(), GET 2 SUB ARRAYS OF ARR AS STRING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function partlist that gives all the ways to divide a list (an array) of at least two elements into two non-empty parts.

Each two non empty parts will be in a pair (or an array for languages without tuples or a structin C - C: see Examples test Cases - )
Each part will be in a string
Elements of a pair must be in the same order as in the original array.
Examples of returns in different languages:
a = ["az", "toto", "picaro", "zone", "kiwi"] -->
[["az", "toto picaro zone kiwi"], ["az toto", "picaro zone kiwi"], ["az toto picaro", "zone kiwi"], ["az toto picaro zone", "kiwi"]] 
or
 a = {"az", "toto", "picaro", "zone", "kiwi"} -->
{{"az", "toto picaro zone kiwi"}, {"az toto", "picaro zone kiwi"}, {"az toto picaro", "zone kiwi"}, {"az toto picaro zone", "kiwi"}}
or
a = ["az", "toto", "picaro", "zone", "kiwi"] -->
[("az", "toto picaro zone kiwi"), ("az toto", "picaro zone kiwi"), ("az toto picaro", "zone kiwi"), ("az toto picaro zone", "kiwi")]
or 
a = [|"az", "toto", "picaro", "zone", "kiwi"|] -->
[("az", "toto picaro zone kiwi"), ("az toto", "picaro zone kiwi"), ("az toto picaro", "zone kiwi"), ("az toto picaro zone", "kiwi")]
or
a = ["az", "toto", "picaro", "zone", "kiwi"] -->
"(az, toto picaro zone kiwi)(az toto, picaro zone kiwi)(az toto picaro, zone kiwi)(az toto picaro zone, kiwi)"

*/

class G964a {
    public static partlist = (arr: string[]): string[][] => {
        let solution: string[][] = [];

        for (let i = 0; i < arr.length - 1; i++) {
            // console.log(arr.slice(0, i + 1).join(" "));
            // console.log(arr.slice(i + 1).join(" "));

            let subArr: string[] = [];
            subArr.push(
                arr.slice(0, i + 1).join(" "),
                arr.slice(i + 1).join(" ")
            );

            // subArr.push(arr.slice(0, i + 1).join(" "));
            // subArr.push(arr.slice(i + 1).join(" "));

            solution.push(subArr);
        }

        return solution;
    };
}

//  INITIALIZE SOLUTION ARR
//  LOOP OVER arr
//      CREATE subArr FOR EACH ITARATION
//      PUSH FIRST SUB ARRAY OF arr INTO subArr ENDING WITH arr[i]
//      PUSH SECOND SUB ARRAY OF arr INTO subArr STARTING WITH arr[i + 1]
//      PUSH subArr INTO solution
//  RETURN solution

// console.log(G964a.partlist(["a", "b", "c", "d", "e"]));
// console.log(G964a.partlist(["I", "wish", "I", "hadn't", "come"]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G964a2 {
    public static partlist(arr: string[]): string[][] {
        return arr
            .map((s, i, a) => [
                a.slice(0, i + 1).join(" "),
                a.slice(i + 1, a.length).join(" "),
            ])
            .slice(0, arr.length - 1);
    }
}

class G964a3 {
    public static partlist(arr: string[]): string[][] {
        return arr
            .slice(1)
            .map((x, i) => [
                arr.slice(0, i + 1).join(" "),
                arr.slice(i + 1).join(" "),
            ]);
    }
}

class G964a4 {
    public static partlist(arr: string[]): string[][] {
        const x = arr.map((word, idx) => {
            return [
                arr.slice(0, idx + 1).join(" "),
                arr.slice(idx + 1, arr.length).join(" "),
            ];
        });
        return x.slice(0, -1);
    }
}

// INCLUDE THIS IN EXAMPLES FOR MATCH() WITH POSSIBLE EMPTY ARR
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ REFACTOR THIS, MAKE IT WORK WITH STR.MATCH() ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  BUMPS IN THE ROAD
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your car is old, it breaks easily. The shock absorbers are gone and you think it can handle about 15 more bumps before it dies totally.

Unfortunately for you, your drive is very bumpy! Given a string showing either flat road ("_") or bumps ("n"), work out if you make it home safely. 15 bumps or under, return "Woohoo!", over 15 bumps return "Car Dead".
*/

const bump = (road: string): string => {
    // const bumps: number[] = road.match(/n/g);
    // console.log(bumps);

    // return bumps.length > 15
    //     ? "Car Dead"
    //     : "Woohoo!";

    let counter: number = 0;

    for (let i = 0; i < road.length; i++) {
        if (road[i] === "n") {
            counter++;
            if (counter > 15) return "Car Dead";
        }
    }

    return "Woohoo!";
};

// console.log(bump("n"));
// console.log(bump("_nnnnnnn_n__n______nn__nn_nnn"));
// console.log(bump("_"));

// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function bump2(x: string): string {
    return x.split("").filter((a) => a === "n").length <= 15
        ? "Woohoo!"
        : "Car Dead";
}

function bump3(x: string): string {
    return x.replace(/_/g, "").length > 15 ? `Car Dead` : `Woohoo!`;
}

function bump4(x: string): string {
    return x
        .split("")
        .reduce((total, n) => (n === "n" ? total + 1 : total), 0) > 15
        ? "Car Dead"
        : "Woohoo!";
}

// ❗️❗️❗️ MATCH() ❗️❗️❗️
function bump5(x: string): string {
    const arr: string[] = x.match(/[n+]/g) || [];
    return arr.length <= 15 ? "Woohoo!" : "Car Dead";
}

function bump6(x: string): string {
    return (x.match(/n/g) || []).length > 15 ? "Car Dead" : "Woohoo!";
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  MAXIMUM PRODUCT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  ❗️❗️❗️ SPREAD ARRAY FOR MATH.MAX() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Task
Given an array of integers , Find the maximum product obtained from multiplying 2 adjacent numbers in the array.

Notes
Array/list size is at least 2.

Array/list numbers could be a mixture of positives, negatives also zeroes .

Input >> Output Examples
adjacentElementsProduct([1, 2, 3]); ==> return 6
Explanation:
The maximum product obtained from multiplying 2 * 3 = 6, and they're adjacent numbers in the array.
adjacentElementsProduct([9, 5, 10, 2, 24, -1, -48]); ==> return 50
Explanation:
Max product obtained from multiplying 5 * 10 = 50 .

adjacentElementsProduct([-23, 4, -5, 99, -27, 329, -2, 7, -921])  ==>  return -14
Explanation:
The maximum product obtained from multiplying -2 * 7 = -14, and they're adjacent numbers in the array.
*/

const adjacentElementsProduct = (arr: number[]): number => {
    let productsArr: number[] = [];

    for (let i = 0; i < arr.length - 1; i++) {
        let adjacentProd: number = arr[i] * arr[i + 1];
        productsArr.push(adjacentProd);
    }

    // ❗️❗️❗️ SPREAD ARRAY FOR MATH.MAX() TO AVOID ERROR: ❗️❗️❗️
    // Argument of type 'number[]' is not assignable to parameter of type 'number'.ts(2345)
    return Math.max(...productsArr);
};

// console.log(adjacentElementsProduct([1, 5, 10, 9]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const adjacentElementsProduct2 = (arr: number[]): number =>
    Math.max(
        ...arr.map((value, index) =>
            index === arr.length - 1
                ? value * arr[index - 1]
                : value * arr[index + 1]
        )
    );

function adjacentElementsProduct3(arr: number[]): number {
    return Math.max(...arr.slice(1).map((x, i) => x * arr[i]));
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  JS ARRAY FILTER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The solution would work like the following:

getEvenNumbers([2,4,5,6]) // should == [2,4,6]
*/

const getEvenNumbers = (numbersArray: number[]): number[] => {
    return numbersArray.filter((num) => {
        return (num & 1) === 0;
    });
};

// console.log(getEvenNumbers([1, 2, 3, 6, 8, 10]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const getEvenNumbers2 = (numbersArray: number[]): number[] => {
    return numbersArray.filter((x) => x % 2 === 0);
};

const isEven = (num: number): boolean => num % 2 == 0;
const getEvenNumbers3 = (nums: number[]): number[] => nums.filter(isEven);

const getEvenNumbers4 = (numbersArray: number[]): number[] => {
    return numbersArray.filter((cond) => 0 === cond % 2);
};
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SUM OF TRIANGULAR NUMBERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to return the sum of Triangular Numbers up-to-and-including the nth Triangular Number.

Triangular Number: "any of the series of numbers (1, 3, 6, 10, 15, etc.) obtained by continued summation of the natural numbers 1, 2, 3, 4, 5, etc."

[01]
02 [03]
04 05 [06]
07 08 09 [10]
11 12 13 14 [15]
16 17 18 19 20 [21]
e.g. If 4 is given: 1 + 3 + 6 + 10 = 20.

Triangular Numbers cannot be negative so return 0 if a negative number is given.
*/

const sumTriangularNumbers = (n: number): number => {
    let sum: number = 0,
        triNum: number = 0;

    for (let i = 1; i <= n; i++) {
        triNum = triNum + i;
        sum += triNum;
    }

    return sum;
};

//  START LOOP AT 1, IN EVERY ITERATION:
//     INCREMENT triNum BY triNum + 1 (1, 3, 6, 10...)
//     INCREMENT sum BY trinum (1, 4, 10, 20...)
//  RETURN sum

//   56
// console.log(sumTriangularNumbers(1));
// console.log(sumTriangularNumbers(2));
// console.log(sumTriangularNumbers(3));
// console.log(sumTriangularNumbers(4));
// 7140
// console.log(sumTriangularNumbers(34));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function sumTriangularNumbers2(n: number): number {
    return n <= 0 ? 0 : (n * (n + 1) * (n + 2)) / 6;
}

//   Function lacks ending return statement and return type does not include 'undefined'.ts(2366)

//   function sumTriangularNumbers3(n:number):number {

//     if (n < 1) return 0;

//     if (n == 1)
//       return 1;
//     while (n > 0) {
//       return (n * (n +1) / 2) + sumTriangularNumbers(n-1);
//     }
//   }

function sumTriangularNumbers4(n: number): number {
    return Array.from({ length: n })
        .map((value, index) => ((1 + index + 1) * (index + 1)) / 2)
        .reduce((pre, current) => pre + current, 0);
}

function sumTriangularNumbers5(n: number): number {
    let result = 0;
    for (let i = 0; i <= n; i++) {
        result += (i * (i + 1)) / 2;
    }
    return result;
}

function sumTriangularNumbers6(n: number): number {
    let sum = 0;
    for (let i = 1, j = 1; i <= n; i++, j += i) {
        sum += j;
    }
    return sum;
}

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:  MOVES IN SQUARED STRINGS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You are given a string of n lines, each substring being n characters long: For example:

s = "abcd\nefgh\nijkl\nmnop"

We will study some transformations of this square of strings.

Vertical mirror: vert_mirror (or vertMirror or vert-mirror)
vert_mirror(s) => "dcba\nhgfe\nlkji\nponm"
Horizontal mirror: hor_mirror (or horMirror or hor-mirror)
 hor_mirror(s) => "mnop\nijkl\nefgh\nabcd"
or printed:

vertical mirror   |horizontal mirror   
abcd --> dcba     |abcd --> mnop 
efgh     hgfe     |efgh     ijkl 
ijkl     lkji     |ijkl     efgh 
mnop     ponm     |mnop     abcd 
Task:
Write these two functions
and

high-order function oper(fct, s) where

fct is the function of one variable f to apply to the string s (fct will be one of vertMirror, horMirror)

Examples:
s = "abcd\nefgh\nijkl\nmnop"
oper(vert_mirror, s) => "dcba\nhgfe\nlkji\nponm"
oper(hor_mirror, s) => "mnop\nijkl\nefgh\nabcd"
Note:
The form of the parameter fct in oper changes according to the language. You can see each form according to the language in "Sample Tests".

Bash Note:
The input strings are separated by , instead of \n. The output strings should be separated by \r instead of \n. See "Sample Tests".
*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PREDICT YOUR AGE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  ❗️❗️❗️ ARGUMENTS / SPREAD ❗️❗️❗️, MATH.TRUNC()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
My grandfather always predicted how old people would get, and right before he passed away he revealed his secret!

In honor of my grandfather's memory we will write a function using his formula!

Take a list of ages when each of your great-grandparent died.
Multiply each number by itself.
Add them all together.
Take the square root of the result.
Divide by two.
Example
predictAge(65, 60, 75, 55, 60, 63, 64, 45) === 86
Note: the result should be rounded down to the nearest integer.

Some random tests might fail due to a bug in the JavaScript implementation. Simply resubmit if that happens to you.
*/

// const predictAge = (
//     age1:number,
//     age2:number,
//     age3:number,
//     age4:number,
//     age5:number,
//     age6:number,
//     age7:number,
//     age8:number
// ): number => {

//   return 0;
// };

const predictAge = (...args: number[]): number => {
    // ❗️❗️❗️
    // console.log(args);

    return Math.floor(
        Math.sqrt(
            args
                .map((num) => Math.pow(num, 2))
                .reduce((acc, curr) => acc + curr)
        ) / 2
    );
};

//  GET arguments ARRAY
//  SQUARE ALL ELEMENTS WITH map
//  GET SUM WITH reduce
//  DIVIDE BY 2

//  GET SQUARE ROOT OF SUM
//  ROUND DOWN TO NEAREST INTEGER

// 86
// console.log(predictAge(65,60,75,55,60,63,64,45));
// 79
// console.log(predictAge(32,54,76,65,34,63,64,45));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// Rest parameter 'a' implicitly has an 'any[]' type.ts(7019)

// const predictAge2=(...a)=>Math.sqrt(a.reduce((b,c)=>b+c*c,0))>>1

function predictAge3(...ages: number[]): number {
    return Math.trunc(
        Math.sqrt(ages.map((x) => x * x).reduce((a, b) => a + b, 0)) / 2
    );
}

//   Cannot find name 'arguments'.ts(2304)
// Block-scoped variable 'number' used before its declaration.ts(2448)

//   predictAge4(age1:number, age2:number, age3:number,age4:number,age5:number,age6:number,age7:number,age8:number): number{
//     let args = Array.prototype.slice.call(arguments)
//     const sum = args.map(arg => {
//     return arg * arg
//     }).reduce((a,b) => a + b, 0)
//     const square = Math.sqrt(sum)
//     const total = Math.floor(square / 2)
//     return total;
//   };

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIND MOST DIGITS IN NUMBER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  SORT(), REDUCE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Find the number with the most digits.

If two numbers in the argument array have the same number of digits, return the first one in the array.
*/

class Kata {
    static findLongest(arr: number[]): number {
        // 1️⃣
        return arr.sort((a, b) => String(b).length - String(a).length)[0];

        // 2️⃣  ❗️❗️❗️    REFACTOR THIS WITH ARRAY.FIND() ❗️❗️❗️
        let solution: number = -1;
        const sortedArr = [...arr].sort((a, b) => b - a);
        // console.log(arr);
        console.log(sortedArr);
        const maxLength: number = String(sortedArr[0]).length;
        console.log(maxLength);
        // const findLength = (num: number): number => {
        //     console.table({ maxLength: maxLength, number: num });
        //     // return String(num).length === maxLength;
        //     console.log(String(num).length === maxLength);
        //     // if (String(num).length === length) return num;
        //     return String(num).length === maxLength
        //         ? num
        //         : -1;
        // }
        console.log(arr);
        // return arr.find(function (num: number): number {
        //     return String(num).length === maxLength
        //         ? num
        //         : -1;
        // })!;

        for (let i = 0; i < arr.length; i++) {
            if (String(arr[i]).length === maxLength) {
                solution = arr[i];
                break;
            }
        }
        return solution;
    }
}

//  SORT arr BY THE LENGTH OF ELEMENTS(CONVERTED TO STRING)
//  RETURN FIRST ELEMENT OF SORTED-BY-LENGTH ARRAY

// console.log(Kata.findLongest([1, 10, 100, 400, 56, 800]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// REDUCE()
class Kata5 {
    static findLongest(array: number[]): number {
        return array.reduce((a, b) =>
            a.toString().length < b.toString().length ? b : a
        );
    }
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SORTED? YES, NO, HOW? ASCENDING/DESCENDING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  SORT(),
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Complete the method which accepts an array of integers, and returns one of the following:

"yes, ascending" - if the numbers in the array are sorted in an ascending order
"yes, descending" - if the numbers in the array are sorted in a descending order
"no" - otherwise
You can assume the array will always be valid, and there will always be one correct answer.
*/

const isSortedAndHow = (arr: number[]): string => {
    let isAscending: boolean = false;
    let isDescending: boolean = false;
    let solution: string = "no";

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] >= arr[i - 1]) {
            isAscending = true;
        } else {
            break;
        }
        if (i === arr.length - 1 && isAscending) {
            solution = "yes, ascending";
        }
    }

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] <= arr[i - 1]) {
            isDescending = true;
        } else {
            break;
        }
        if (i === arr.length - 1 && isDescending) {
            solution = "yes, descending";
        }
    }

    return solution;
};

// console.log(isSortedAndHow([1, 2]));
// console.log(isSortedAndHow([15, 7, 3, -8]));
// console.log(isSortedAndHow([4, 2, 30]));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function isSortedAndHow2(array: number[]): string {
    let ascending = true,
        descending = true;
    for (var i = 1; i < array.length; i++) {
        if (array[i - 1] < array[i]) descending = false;
        if (array[i - 1] > array[i]) ascending = false;
        if (!ascending && !descending) return "no";
    }
    if (ascending) return "yes, ascending";
    return "yes, descending";
}

function isSortedAndHow3(array: number[]): string {
    if (array.every((x, i, a) => i === 0 || a[i - 1] <= x))
        return "yes, ascending";
    if (array.every((x, i, a) => i === 0 || a[i - 1] >= x))
        return "yes, descending";
    return "no";
}

function isSortedAndHow4(array: number[]): string {
    return [...array].sort((a, b) => a - b).join("") === array.join("")
        ? "yes, ascending"
        : [...array]
            .sort((a, b) => a - b)
            .reverse()
            .join("") === array.join("")
            ? "yes, descending"
            : "no";
}

function isSortedAndHow5(array: number[]): string {
    let isAsc: boolean = true;
    let isDesc: boolean = true;
    let i: number = 0;

    while (i + 1 < array.length) {
        if (array[i] > array[i + 1]) isAsc = false;
        if (array[i] < array[i + 1]) isDesc = false;

        i++;
    }

    if (isAsc) return "yes, ascending";
    else if (isDesc) return "yes, descending";
    else return "no";
}

function isSortedAndHow6(array: number[]): string {
    const asc: number[] = [...array].sort((a, b) => a - b);
    const dsc: number[] = [...array].sort((a, b) => b - a);
    switch (array.toString()) {
        case asc.toString():
            return "yes, ascending";
        case dsc.toString():
            return "yes, descending";
        default:
            return "no";
    }
}

function isSortedAndHow7(array: number[]): string {
    if ([...array].sort((a, b) => a - b).join("") === array.join("")) {
        return "yes, ascending";
    } else if ([...array].sort((a, b) => b - a).join("") === array.join("")) {
        return "yes, descending";
    } else {
        return "no";
    }
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SUM OF ANGLES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Find the total sum of internal angles (in degrees) in an n-sided simple polygon. N will be greater than 2.

If a convex polygon has n sides, then its interior angle sum is given by the following equation: S = ( n −2) × 180°.
*/

const angle = (n: number): number => {
    return (n - 2) * 180;
};

// console.log(angle(3));
// console.log(angle(4));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FACTORIAL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

const factorial = (num: number) => {
    let nthFact = 1;

    for (let i = 1; i <= num; i++) {
        nthFact *= i;
    }

    return nthFact;
};

// console.log(factorial(4));
// console.log(factorial(0));
// console.log(factorial(7));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function factorial2(n: number): number {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  EVAPORATION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  DO WHILE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
This program tests the life of an evaporator containing a gas.

We know the content of the evaporator (content in ml), the percentage of foam or gas lost every day (evap_per_day) and the threshold (threshold) in percentage beyond which the evaporator is no longer useful. All numbers are strictly positive.

The program reports the nth day (as an integer) on which the evaporator will be out of use.

Example:
evaporator(10, 10, 5) -> 29
Note:
Content is in fact not necessary in the body of the function "evaporator", you can use it or not use it, as you wish. Some people might prefer to reason with content, some other with percentages only. It's up to you but you must keep it as a parameter because the tests have it as an argument.
*/

const evaporator = (cont: number, dayEvap: number, thresH: number): number => {
    let contentLeft = cont;
    const minQuantity = cont * (thresH / 100);
    let daysLeft: number = 0;

    while (contentLeft >= minQuantity) {
        contentLeft -= contentLeft * (dayEvap / 100);
        daysLeft++;
    }

    return daysLeft;
};

//  INITIALIZE VARIABLES
//  KEEP DECREMENTING contentLeft WHILE IT IS GREATER OR EQUAL TO minQuantity
//  RETURN daysLeft

// 22
// console.log(evaporator(10, 10, 10));
// 29
// console.log(evaporator(10, 10, 5));

//============= OTHER CODEWARS SOLUTIONS: =============

function evaporator2(
    content: number,
    evap_per_day: number,
    threshold: number
): number {
    return Math.ceil(
        Math.log(threshold / 100) / Math.log(1 - evap_per_day / 100)
    );
}

function evaporator3(
    content: number,
    evapPerDay: number,
    threshold: number
): number {
    const reverseFactor = 1 / (1 - evapPerDay / 100);
    return Math.ceil(-Math.log(threshold / 100) / Math.log(reverseFactor));
}

function evaporator4(
    content: number,
    evapPerDay: number,
    threshold: number
): number {
    const full = content;
    let days = 0;

    do {
        content -= (content / 100) * evapPerDay;
        days++;
    } while (content > (full / 100) * threshold);

    return days;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FLATTEN AND SORT AN NESTED ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  TWO DIMENSIONAL ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

//  ❗️❗️❗️ HAD TO CHANGE TARGET PROPERTY IN COMPILER OPTIONS TO "es2019" OR LATER  FOR flat() ❗️❗️❗️
/*
Given a two-dimensional array of integers, return the flattened version of the array with all the integers in the sorted (ascending) order.

Example:

Given [[3, 2, 1], [4, 6, 5], [], [9, 7, 8]], your function should return [1, 2, 3, 4, 5, 6, 7, 8, 9].
*/

const flattenAndSort = (inputArray: number[][]): number[] => {
    // 1️⃣  ❗️❗️❗️ THIS IS NOT WORKING IN CODEWARS ❗️❗️❗️
    // return inputArray
    //     .flat()
    //     .sort((a, b) => a - b);

    // 2️⃣
    return inputArray
        .reduce((acc, curr) => acc.concat(curr), [])
        .sort((a, b) => a - b);
};

// console.log(flattenAndSort([]));
// console.log(flattenAndSort([[], []]));
// console.log(flattenAndSort([[], [1]]));
// console.log(flattenAndSort([[3, 2, 1], [7, 9, 8], [6, 4, 5]]));
// console.log(flattenAndSort([[1, 3, 5], [100], [2, 4, 6]]));

//============= OTHER CODEWARS SOLUTIONS: =============

function flattenAndSort2(inputArray: number[][]): number[] {
    return inputArray.flat().sort((a, b) => a - b);
}

// const flattenAndSort3 = (a: number[][]): number[] => [].concat(...a).sort((a, b) => a - b);

function flattenAndSort4($: number[][]): number[] {
    return $.toString()
        .split(",")
        .filter((e) => e)
        .map(Number)
        .sort((a, b) => a - b);
}

function flattenAndSort5(inputArray: number[][]): number[] {
    let numbers: number[] = [];
    for (const tuple of inputArray) {
        numbers = [...tuple, ...numbers];
    }

    return numbers.sort((a, b) => a - b);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  CHECK COUPON - STRING DATE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  ENUM, DATE.PARSE(), NEW DATE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Story
Your online store likes to give out coupons for special occasions. Some customers try to cheat the system by entering invalid codes or using expired coupons.

Task
Your mission:
Write a function called checkCoupon which verifies that a coupon code is valid and not expired.

A coupon is no more valid on the day AFTER the expiration date. All dates will be passed as strings in this format: "MONTH DATE, YEAR".

Examples:
checkCoupon("123", "123", "July 9, 2015", "July 9, 2015")  ===  true
checkCoupon("123", "123", "July 9, 2015", "July 2, 2015")  ===  false
*/

const checkCoupon = (
    usrCode: string,
    validCode: string,
    currDate: string,
    expDate: string
): boolean => {
    const isValidCode: boolean = usrCode === validCode;
    let isValidDate: boolean = true;

    enum months {
        January = 1,
        February,
        March,
        April,
        May,
        June,
        July,
        August,
        September,
        October,
        November,
        December,
    }

    const extractDate = (date: string): string[] => {
        return date.replace(/,/g, "").split(" ");
    };

    const currYear: number = Number(extractDate(currDate)[2]);
    const expYear: number = Number(extractDate(expDate)[2]);

    // ❗️❗️❗️ HAVE TO USE ANY, string WILL THROW AN ERROR WHEN ACCESSING VALUE BY KEY (months[currMonth]) ❗️❗️❗️
    const currMonth: any = extractDate(currDate)[0];
    const currMonthIdx: any = months[currMonth];
    const expMonth: any = extractDate(expDate)[0];
    const expMonthIdx: any = months[expMonth];

    const currDay: number = Number(extractDate(currDate)[1]);
    const expDay: number = Number(extractDate(expDate)[1]);

    console.table({
        currYear: currYear,
        expYear: expYear,
        currMonth: currMonth,
        currMonthIdx: currMonthIdx,
        expMonth: expMonth,
        expMonthIdx: expMonthIdx,
        currDay: currDay,
        expDay: expDay,
    });

    //  YEAR PLUS
    if (expYear > currYear) {
        isValidDate = true;
        //  YEAR SAME
    } else if (expYear === currYear) {
        if (expMonthIdx > currMonthIdx) {
            isValidDate = true;
        } else if (expMonthIdx === currMonthIdx) {
            if (expDay >= currDay) {
                isValidDate = true;
            } else {
                isValidDate = false;
            }
        } else {
            isValidDate = false;
        }
        //  YEAR INVALID
    } else {
        isValidDate = false;
    }

    return isValidCode && isValidDate;
};

/*

isvalidCode WILL CHECK IF CODES MATCH
INITIALIZE isValidDate
ASSIGN NUMERIC VALUES TO MONTHS FOR COMPARISON
extractDate WILL CONVERT STRING TO ARRAY ["September", "5", "2015"]
STORE YEAR, MONTH INDEX AND DAY IN VARIABLES (CONVERTED TO NUMBER)
┌──────────────┬───────────┐
│   (index)    │  Values   │
├──────────────┼───────────┤
│   currYear   │   2014    │
│   expYear    │   2014    │
│  currMonth   │ 'January' │
│ currMonthIdx │     1     │
│   expMonth   │ 'January' │
│ expMonthIdx  │     1     │
│   currDay    │     5     │
│    expDay    │     1     │
└──────────────┴───────────┘
if BLOCK DETERMINES IF DATE IS VALID
RETURN TRUE IF BOTH CODE AND DATE ARE VALID, OTHERWISE FALSE

*/

// console.log(checkCoupon('123', '123', 'September 5, 2014', 'October 1, 2014'));
// console.log(checkCoupon('123a', '123', 'September 5, 2014', 'October 1, 2014'));
// console.log(checkCoupon('12abcd3', '12abcd3', 'January 5, 2014', 'January 1, 2014'));

//============= OTHER CODEWARS SOLUTIONS: =============

function checkCoupon2(
    enteredCode: string,
    correctCode: string,
    currentDate: string,
    expirationDate: string
): boolean {
    return (
        enteredCode === correctCode &&
        Date.parse(currentDate) <= Date.parse(expirationDate)
    );
}

function checkCoupon3(
    enteredCode: string,
    correctCode: string,
    currentDate: string,
    expirationDate: string
): boolean {
    let cDate = new Date(currentDate);
    let expDate = new Date(expirationDate);
    return enteredCode === correctCode && cDate <= expDate ? true : false;
}

function checkCoupon4(
    enteredCode: string,
    correctCode: string,
    currentDate: string,
    expirationDate: string
): boolean {
    const isValidCode = enteredCode === correctCode;
    const isValidDate = new Date(currentDate) <= new Date(expirationDate);
    return isValidCode && isValidDate;
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ROW WEIGHTS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REDUCE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Scenario
Several people are standing in a row divided into two teams.
The first person goes into team 1, the second goes into team 2, the third goes into team 1, and so on.

Task
Given an array of positive integers (the weights of the people), return a new array/tuple of two integers, where the first one is the total weight of team 1, and the second one is the total weight of team 2.

Notes
Array size is at least 1.
All numbers will be positive.
Input >> Output Examples
rowWeights([13, 27, 49])  ==>  return (62, 27)
Explanation:
The first element 62 is the total weight of team 1, and the second element 27 is the total weight of team 2.

rowWeights([50, 60, 70, 80])  ==>  return (120, 140)
Explanation:
The first element 120 is the total weight of team 1, and the second element 140 is the total weight of team 2.

rowWeights([80])  ==>  return (80, 0)
Explanation:
The first element 80 is the total weight of team 1, and the second element 0 is the total weight of team 2.
*/

const rowWeights = (arr: number[]): number[] => {
    let arr1: number[] = [],
        arr2: number[] = [];

    arr.forEach((num, idx) => {
        idx & 1 ? arr1.push(num) : arr2.push(num);
    });

    return [arr2.reduce((a, b) => a + b), arr1.reduce((a, b) => a + b)];
};

//  INITIALIZE ARRAYS WITH 0 IN CASE arr HAS ONLY ONE ELEMENT
//  LOOP THROUGH INPUT arr
//      CHECK IF idx IS ODD (!!! idx & 1 RETURNS 1 IF idx IS ODD !!!)
//          IF SO, PUSH num TO arr1
//          OTHERWISE, PUSH num TO arr2
//  RETURN [SUM OF BOTH arr1 AND arr2]

// console.log(rowWeights([50, 60, 70, 80]));

//============= OTHER CODEWARS SOLUTIONS: =============

function rowWeights2(arr: number[]) {
    return arr.reduce((r, e, i) => ((r[i % 2] += e), r), [0, 0]);
}

function rowWeights3(arr: number[]): [number, number] {
    let even: number = arr.reduce((sum, x, i) => sum + (!(i % 2) ? x : 0), 0);
    let odd: number = arr.reduce((sum, x, i) => sum + (i % 2 ? x : 0), 0);
    return [even, odd];
}

function rowWeights4(arr: number[]) {
    return arr.reduce(
        (a: number[], c: number, i: number) =>
            i % 2 ? [a[0], a[1] + c] : [a[0] + c, a[1]],
        [0, 0]
    );
}

function rowWeights5(arr: number[]): number[] {
    return arr.reduce(
        (sumOfWeights, weight, i) => {
            sumOfWeights[i % 2] += weight;
            return sumOfWeights;
        },
        [0, 0]
    );
}

function rowWeights6(arr: number[]) {
    const res = [0, 0];

    arr.forEach((x, i) => {
        if (i % 2 === 0) {
            res[0] += x;
        } else {
            res[1] += x;
        }
    });

    return res;
}

function rowWeights7(arr: number[]) {
    let arr1 = 0;
    let arr2 = 0;
    arr.forEach((value, index) =>
        index % 2 ? (arr2 += value) : (arr1 += value)
    );
    return [arr1, arr2];
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SORT ARRAY NUMERICALLY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  SORT()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Finish the solution so that it sorts the passed in array of numbers. If the function passes in an empty array or null/nil value then it should return an empty array.

For example:

solution([1, 2, 10, 50, 5]); // should return [1, 2, 5, 10, 50]
solution([]); // should return []
*/

const sortNumbers = (numsArr: number[]): number[] => {
    return numsArr.sort((a, b) => a - b);
};

// console.log(sortNumbers([1, 2, 10, 50, 5]));

//============= OTHER CODEWARS SOLUTIONS: =============

function sortNumbers2(nums: number[]): number[] {
    return nums ? nums.sort((a, b) => a - b) : [];
}

function sortNumbers3(nums: number[]): number[] {
    return nums === null ? [] : nums.sort((left, right) => left - right);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  	REMOVE DUPLICATES FROM STRING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REDUCE(), FILTER(), SET(), ARRAY.FROM()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to remove all duplicate words from a string, leaving only single (first) words entries.

Example:

Input:

'alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta'

Output:

'alpha beta gamma delta'
*/

// ❗️❗️❗️ .reduce((acc: string[], curr) SPECIFY TYPE FOR acc ❗️❗️❗️
const removeDuplicateWords = (str: string): string => {
    return str
        .split(" ")
        .reduce(
            (acc: string[], curr) =>
                acc.includes(curr) ? acc : [...acc, curr],
            []
        )
        .join(" ");
};

// console.log(removeDuplicateWords('alpha beta beta gamma gamma gamma delta alpha beta beta gamma gamma gamma delta'))

//============= OTHER CODEWARS SOLUTIONS: =============

function removeDuplicateWords2(s: string): string {
    return Array.from(new Set(s.split(" "))).join(" ");
}

function removeDuplicateWords3(s: string): string {
    return s
        .split(" ")
        .filter((v, i, a) => a.indexOf(v) === i)
        .join(" ");
}

function removeDuplicateWords4(s: string): string {
    return [...new Set(s.match(/[a-z]+/gi) || [])].join(" ");
}

function removeDuplicateWords5(s: string): string {
    const wordArray = s.split(" ");
    const wordSet = new Set(wordArray);
    const result = Array.from(wordSet).join(" ");
    return result;
}

function removeDuplicateWords6(s: string): string {
    let result: string[] = [];
    s.split(" ").forEach((string, index) => {
        if (result.indexOf(string) === -1) {
            result.push(string);
        }
    });
    return result.join(" ");
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ALTERNATE CAPITALIZATION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a string, capitalize the letters that occupy even indexes and odd indexes separately, and return as shown below. Index 0 will be considered even.

For example, capitalize("abcdef") = ['AbCdEf', 'aBcDeF']. See test cases for more examples.

The input will be a lowercase string with no spaces.
*/

const capitalize = (str: string): string[] => {
    let odds: string = "",
        evens: string = "";

    for (let i = 0; i < str.length; i++) {
        evens += i % 2 === 0 ? str[i].toUpperCase() : str[i];
        odds += i % 2 > 0 ? str[i].toUpperCase() : str[i];
    }

    return [evens, odds];
};

//  INITIALIZE EMPTY STRINGS FOR BOTH WORDS
//  LOOP OVER str
//      BUILD evens
//      BUILD odds
// RETURN SOLUTION AS ARRAY OF STRINGS

// console.log(capitalize("abcdef"));

//============= OTHER CODEWARS SOLUTIONS: =============

const capitalize2 = (s: string) => [
    [...s].map((l, i) => (i % 2 ? l : l.toUpperCase())).join(""),
    [...s].map((l, i) => (i % 2 ? l.toUpperCase() : l)).join(""),
];

function capitalize3(s: string) {
    const output = ["", ""];
    s.split("").forEach((letter, index) => {
        output[0] += index % 2 ? letter : letter.toUpperCase();
        output[1] += !(index % 2) ? letter : letter.toUpperCase();
    });
    return output;
}

function capitalize4(s: string) {
    return [...s].reduce(
        (acc, curr, indx) => {
            const isEven = indx % 2 == 0;
            acc[0] += curr[isEven ? "toUpperCase" : "toLowerCase"]();
            acc[1] += curr[!isEven ? "toUpperCase" : "toLowerCase"]();
            return acc;
        },
        ["", ""]
    );
}

function capitalize5(s: string): Array<string> {
    return [
        s
            .split("")
            .map((letter, i) =>
                i % 2 === 0 ? letter.toUpperCase() : letter.toLowerCase()
            )
            .join(""),
        s
            .split("")
            .map((letter, i) =>
                i % 2 !== 0 ? letter.toUpperCase() : letter.toLowerCase()
            )
            .join(""),
    ];
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  MAXIMUM LENGTH DIFFERENCE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You are given two arrays a1 and a2 of strings. Each string is composed with letters from a to z. Let x be any string in the first array and y be any string in the second array.

Find max(abs(length(x) − length(y)))

If a1 and/or a2 are empty return -1 in each language except in Haskell (F#) where you will return Nothing (None).

Example:
a1 = ["hoqq", "bbllkw", "oox", "ejjuyyy", "plmiis", "xxxzgpsssa", "xxwwkktt", "znnnnfqknaz", "qqquuhii", "dvvvwz"]
a2 = ["cccooommaaqqoxii", "gggqaffhhh", "tttoowwwmmww"]
mxdiflg(a1, a2) --> 13
Bash note:
input : 2 strings with substrings separated by ,
output: number as a string
*/

// 1️⃣
class G964 {
    // 1️⃣
    public static mxdiflg = (a1: string[], a2: string[]): number => {
        if (!a1.length || !a2.length) return -1;

        const shortest1: number = Math.min(...a1.map((word) => word.length));
        const longest1: number = Math.max(...a1.map((word) => word.length));
        const shortest2: number = Math.min(...a2.map((word) => word.length));
        const longest2: number = Math.max(...a2.map((word) => word.length));

        return Math.max(
            Math.abs(shortest1 - longest2),
            Math.abs(longest1 - shortest2)
        );
    };

    // 2️⃣
    public static mxdiflg2 = (a1: string[], a2: string[]): number => {
        if (!a1.length || !a2.length) return -1;

        const getShortest = (arr: string[]) =>
            Math.min(...arr.map((word): number => word.length));
        const getLongest = (arr: string[]) =>
            Math.max(...arr.map((word): number => word.length));

        const shortest1 = getShortest(a1);
        const longest1 = getLongest(a1);
        const shortest2 = getShortest(a2);
        const longest2 = getLongest(a2);

        return Math.max(
            Math.abs(shortest1 - longest2),
            Math.abs(longest1 - shortest2)
        );
    };

    // 3️⃣
    public static mxdiflg3 = (a1: string[], a2: string[]): number => {
        if (!a1.length || !a2.length) return -1;

        // REFACTOR getShortest / getShortest
        const getMinMax = (arr: string[], output: string): number => {
            // ❗️❗️❗️ HAVE TO USE ENDING RETURN STATEMENT WITH TERNARY ❗️❗️❗️
            // if (output === "min") return Math.min(...arr.map((word): number => word.length));
            // if (output === "max") return Math.max(...arr.map((word): number => word.length));

            return output === "min"
                ? Math.min(...arr.map((word): number => word.length))
                : Math.max(...arr.map((word): number => word.length));
        };

        const shortest1 = getMinMax(a1, "min");
        const longest1 = getMinMax(a1, "max");
        const shortest2 = getMinMax(a2, "min");
        const longest2 = getMinMax(a2, "max");

        return Math.max(
            Math.abs(shortest1 - longest2),
            Math.abs(longest1 - shortest2)
        );
    };

    // 4️⃣  FINAL:
    public static mxdiflg4 = (a1: string[], a2: string[]): number => {
        const getMinMax = (arr: string[], output: string): number => {
            return output === "min"
                ? Math.min(...arr.map((word): number => word.length))
                : Math.max(...arr.map((word): number => word.length));
        };

        const shortest1 = getMinMax(a1, "min");
        const longest1 = getMinMax(a1, "max");
        const shortest2 = getMinMax(a2, "min");
        const longest2 = getMinMax(a2, "max");

        return a1.length && a2.length // (!a1.length || !a2.length)
            ? Math.max(
                Math.abs(shortest1 - longest2),
                Math.abs(longest1 - shortest2)
            )
            : -1;
    };
}

//  getMinMax WILL CALCULATE THE LENGTH OF THE LONGEST OR SHORTEST ELEMENT OF ARRAY PASSED IN
//  CALCULATE LONGEST AND SHORTEST ELEMENTS FOR BOTH ARRAYS
//  CHECK ARRAY LENGTHS
//      IF BOTH VALID, RETURN MAX DIFFERENCE
//      OTHERWISE, -1

// var s1 = ["hoqq", "bbllkw", "oox", "ejjuyyy", "plmiis", "xxxzgpsssa", "xxwwkktt", "znnnnfqknaz", "qqquuhii", "dvvvwz"];
// var s2 = ["cccooommaaqqoxii", "gggqaffhhh", "tttoowwwmmww"];

// const s1 = ['ejjjjmmtthh',
//     'zxxuueeg',
//     'aanlljrrrxx',
//     'dqqqaaabbb',
//     'oocccffuucccjjjkkkjyyyeehh']

// const s2 = ['bbbaaayddqbbrrrv']

// console.log(G964.mxdiflg(s1, s2));

//============= OTHER CODEWARS SOLUTIONS: =============

/*

export class G964 {
  
    public static mxdiflg = (a1, a2) => {
        let max = -1;
        for (let x of a1) {
          for (let y of a2) {
            max = Math.max(Math.abs(x.length - y.length), max);
          }
        }
        
        return max;
    }
}


export class G964 {
    public static mxdiflg = (a1, a2) => {
      if (!a1.length || !a2.length) return -1;
      const x = Math.max(...a1.map(v => v.length)) - Math.min(...a2.map(v => v.length));
      const y = Math.max(...a2.map(v => v.length)) - Math.min(...a1.map(v => v.length));
      return x > y ? x : y;
    }
  }



  export class G964 {
    public static mxdiflg = (a1, a2) => !a1.length || !a2.length ? -1 : Math.max(...a1.map(s1 => Math.max(...a2.map(s2 => Math.abs(s1.length - s2.length)))));
}

*/

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIX STRING CASE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
In this Kata, you will be given a string that may have mixed uppercase and lowercase letters and your task is to convert that string to either lowercase only or uppercase only based on:

make as few changes as possible.
if the string contains equal number of uppercase and lowercase letters, convert the string to lowercase.
For example:

solve("coDe") = "code". Lowercase characters > uppercase. Change only the "D" to lowercase.
solve("CODe") = "CODE". Uppercase characters > lowecase. Change only the "e" to uppercase.
solve("coDE") = "code". Upper == lowercase. Change all to lowercase.
More examples in test cases. Good luck!
*/

// 1️⃣  ❗️❗️❗️ THIS WORKS IN IDE BUT THROWS ERROR IN CODEWARS ❗️❗️❗️
// (OBJECT IS POSSIBLY NULL)

// const solve = (str: string) => {

//     const capitals: number | undefined = str.match(/[A-Z]/g)?.length;

//     if (capitals) {
//         return capitals > str.length / 2 ? str.toUpperCase() : str.toLowerCase();
//     } else {
//         return str.toLowerCase();
//     }

// }

// 2️⃣ ✅ SOLVED WITH DIFFERENT LOGIC:
const solve = (str: string) => {
    let upperC: number = 0;

    for (const letter of str) {
        if (/[A-Z]/.test(letter)) upperC++;
    }

    return upperC > str.length / 2 ? str.toUpperCase() : str.toLowerCase();
};

// console.log(solve("code"));
// console.log(solve("CODe"));
// console.log(solve("COde"));
// console.log(solve("Code"));

//============= OTHER CODEWARS SOLUTIONS: =============

function solve2(s: string) {
    let uppercaseCount = s
        .split("")
        .filter((letter) => letter === letter.toUpperCase()).length;
    return uppercaseCount > s.length / 2 ? s.toUpperCase() : s.toLowerCase();
}

// ❗️❗️❗️ MATCH(REGEX || []) ❗️❗️❗️
function solve3(s: string): string {
    return (s.match(/[a-z]/g) || []).length >= s.length / 2
        ? s.toLowerCase()
        : s.toUpperCase();
}

const solve4 = (s: string) => {
    const upperCs = s.split("").filter((x) => x == x.toUpperCase());
    return upperCs.length > s.length / 2 ? s.toUpperCase() : s.toLowerCase();
};

function solve5(s: string) {
    return s.replace(/[a-z]/g, "").length > s.length / 2
        ? s.toUpperCase()
        : s.toLowerCase();
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FORM THE MINIMUM (SMALLEST NUMBER WITHOUT DUPLICATION)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  SET(), ARRAY.FROM()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a list of digits, return the smallest number that could be formed from these digits, using the digits only once (ignore duplicates).

Notes:
Only positive integers will be passed to the function (> 0 ), no negatives or zeros.
Input >> Output Examples
minValue ({1, 3, 1})  ==> return (13)
Explanation:
(13) is the minimum number could be formed from {1, 3, 1} , Without duplications

minValue({5, 7, 5, 9, 7})  ==> return (579)
Explanation:
(579) is the minimum number could be formed from {5, 7, 5, 9, 7} , Without duplications

minValue({1, 9, 3, 1, 7, 4, 6, 6, 7}) return  ==> (134679)
Explanation:
(134679) is the minimum number could be formed from {1, 9, 3, 1, 7, 4, 6, 6, 7} , Without duplications
*/

const minValue = (values: number[]): number => {
    //1️⃣
    // const uniques = new Set(values);
    // const incrOrder = Array.from(uniques).sort();
    // let numStr = "";
    // incrOrder.forEach((digit) => {
    //     numStr += digit;
    // })
    // return Number(numStr);

    // 2️⃣
    // const uniques = new Set(values);
    // return Number(Array.from(uniques).sort().join(""));

    // 3️⃣
    return Number(Array.from(new Set(values)).sort().join(""));
};

//  REMOVE DUPLICATES USING Set
//  MAKE ARRAY FROM UNUQUE VALUES
//  SORT ARRAY IN ASCENDING ORDER
//  JOIN INTO STRING
//  CONVERT TO NUMBER

// console.log(minValue([4, 7, 5, 7]));
// console.log(minValue([6, 7, 8, 7, 6, 6]));

//============= OTHER CODEWARS SOLUTIONS: =============

const minValue2 = (values: Array<number>): number => {
    return +[...new Set(values)].sort().join("");
};

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SMALL ENOUGH?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  EVERY()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You will be given an array and a limit value. You must check that all values in the array are below or equal to the limit value. If they are, return true. Else, return false.

You can assume all values in the array are numbers.
*/

const smallEnough = (arr: number[], limit: number): boolean => {
    // const checkLimit = (num: number) => num <= limit;

    // return arr.every(checkLimit);

    return arr.every((num: number) => num <= limit);
};

// console.log(smallEnough([101, 45, 75, 105, 99, 107], 107));
// console.log(smallEnough([78, 117, 110, 99, 104, 117, 107, 115], 100));

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  CHECK THE EXAM
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  SWITCH(), NESTED TERNARY, CONTINUE, MATH.MAX()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The first input array is the key to the correct answers to an exam, like ["a", "a", "b", "d"]. The second one contains a student's submitted answers.

The two arrays are not empty and are the same length. Return the score for this array of answers, giving +4 for each correct answer, -1 for each incorrect answer, and +0 for each blank answer, represented as an empty string (in C the space character is used).

If the score < 0, return 0.

For example:

checkExam(["a", "a", "b", "b"], ["a", "c", "b", "d"]) → 6
checkExam(["a", "a", "c", "b"], ["a", "a", "b",  ""]) → 7
checkExam(["a", "a", "b", "c"], ["a", "a", "b", "c"]) → 16
checkExam(["b", "c", "b", "a"], ["",  "a", "a", "c"]) → 0
*/

const checkExam = (array1: string[], array2: string[]): number => {
    let score: number = 0;

    for (let i = 0; i < array2.length; i++) {
        switch (array2[i]) {
            case "":
                score += 0;
                break;
            case array1[i]:
                score += 4;
                break;
            default:
                score += -1;
        }
    }

    return score < 0 ? 0 : score;
};

// console.log(checkExam(["a", "a", "b", "b"], ["a", "c", "b", "d"]));
// console.log(checkExam(["a", "a", "c", "b"], ["a", "a", "b", ""]));
// console.log(checkExam(["a", "a", "b", "c"], ["a", "a", "b", "c"]));
// console.log(checkExam(["b", "c", "b", "(a"], ["", "a", "a", "c"]));

//============= OTHER CODEWARS SOLUTIONS: =============

function checkExam2(array1: string[], array2: string[]): number {
    let result = 0;

    array2.forEach((item, index) => {
        item === array1[index]
            ? (result += 4)
            : item === ""
                ? (result += 0)
                : (result -= 1);
    });

    return Math.max(result, 0);
}

function checkExam3(array1: string[], array2: string[]): number {
    let score = 0;
    for (let i = 0; i < array1.length; i++) {
        if (array2[i] === "") continue;
        else if (array1[i] === array2[i]) score += 4;
        else score--;
    }
    return score > 0 ? score : 0;
}

function checkExam4(array1: string[], array2: string[]): number {
    return Math.max(
        0,
        array2.reduce(
            (a, b, i) => a + (b == "" ? 0 : b === array1[i] ? 4 : -1),
            0
        )
    );
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SUM DIGITS OF NUMBER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function named sumDigits which takes a number as input and returns the sum of the absolute value of each of the number's decimal digits.

For example: (Input --> Output)

10 --> 1
99 --> 18
-32 --> 5
Let's assume that all numbers in the input will be integer values.
*/

const sumDigits = (num: number): number => {
    return Math.abs(num)
        .toString()
        .split("")
        .map((digit) => Number(digit))
        .reduce((a, b) => a + b);
};

//  GET ABSOLUTE VALUE
//  CONVERT TO STRING
//  SPLIT INTO ARRAY OF STRINGS
//  CONVERT TO ARRAY OF NUMBERS
//  GET SUM

// console.log(sumDigits(453));
// console.log(sumDigits(-32));

//============= OTHER CODEWARS SOLUTIONS: =============

function sumDigits2(number: number): number {
    return Math.abs(number)
        .toString()
        .split("")
        .reduce((acc, digit) => parseInt(digit) + acc, 0);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  GIVEN A DIVISOR AND BOUND FOUND LARGEST INT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a Divisor and a Bound , Find the largest integer N , Such That ,

Conditions :
N is divisible by divisor

N is less than or equal to bound

N is greater than 0.

Notes
The parameters (divisor, bound) passed to the function are only positive values .
It's guaranteed that a divisor is Found .
Input >> Output Examples
maxMultiple (2,7) ==> return (6)
Explanation:
(6) is divisible by (2) , (6) is less than or equal to bound (7) , and (6) is > 0
*/

const maxMultiple = (divisor: number, bound: number): number => {
    let solution: number = 0;

    for (let num = bound; num > 0; num--) {
        if (num % divisor === 0) {
            solution = num;
            break;
        }
    }

    return solution;
};

//  START LOOP AT bound, DECREMENT BY 1
//  RETURN FIRST num THAT IS DIVISIBLE BY divisor

// console.log(maxMultiple(37, 200));

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️
function maxMultiple2(divisor: number, bound: number) {
    return bound - (bound % divisor);
}

function maxMultiple3(divisor: number, bound: number) {
    return Math.floor(bound / divisor) * divisor;
}

function maxMultiple4(divisor: number, bound: number) {
    for (let n = bound; n > 0; n -= 1) if (n % divisor === 0) return n;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  GET TWO LARGEST NUMBERS OF ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  FILTER() TO REMOVE DUPLICATES, SORT() NUMERICALLY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The two oldest ages function/method needs to be completed. It should take an array of numbers as its argument and return the two highest numbers within the array. The returned value should be an array in the format [second oldest age, oldest age].

The order of the numbers passed in could be any order. The array will always include at least 2 items. If there are two or more oldest age, then return both of them in array format.

For example:

two_oldest_ages( 4, {1, 2, 10, 8}, result) // should fill result array with {8, 10}
*/

const twoOldestAges = (ages: number[]): number[] => {
    return (
        ages
            // .filter((curr, index) => ages.indexOf(curr) === index)
            .sort((a, b) => b - a)
            .slice(0, 2)
            .reverse()
    );
};

//  FILTER WILL REMOVE DUPLICATES IF NEEDED
// SORT ARRAY DESCENDING NUMERICALLY
// GET FIRST TWO ELEMENTS
// REVERSE

// console.log(twoOldestAges([1, 5, 87, 45, 8, 8, 87]));
// console.log(twoOldestAges([1, 5, 87, 45, 8, 8]));

//============= OTHER CODEWARS SOLUTIONS: =============

const twoOldestAges2 = (ages: any) =>
    ages.sort((a: any, b: any) => a - b).slice(ages.length - 2);

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  COUNT NUMBER OF DIVISORS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Count the number of divisors of a positive integer n.

Random tests go up to n = 500000.

Examples (input --> output)
4 --> 3 (1, 2, 4)
5 --> 2 (1, 5)
12 --> 6 (1, 2, 3, 4, 6, 12)
30 --> 8 (1, 2, 3, 5, 6, 10, 15, 30)
*/

const divisors = (num: number): number => {
    if (num === 1) return 1;

    const divisors: number[] = [];

    for (let i = 1; i <= num / 2; i++) {
        let divisor1: number = i,
            divisor2: number = num / i;

        if (Number.isInteger(num / divisor1)) {
            // console.table({ divisor1: i, divisor2: num / i });

            if (!divisors.includes(divisor1)) {
                if (divisor1 === divisor2) {
                    divisors.push(divisor1);
                } else {
                    divisors.push(divisor1, divisor2);
                }
            }
        }
    }

    // console.log(divisors, divisors.length);
    return divisors.length;
};

//  LOOP OVER INTEGERS UP TO num / 2
//     IF num CAN BE DIVIDED BY divisor1
//        IF divisors ARRAY DOES NOT INCLUDE divisor1
//            IF divisor1 EQUALS divisor2
//                ONLY PUSH divisor1 TO AVOID DUPLICATES (8*8=64)
//            OTHERWISE
//                PUSH BOTH DIVISORS

//  RETURN LENGTH OF ARRAY AS RESULT

// console.log(divisors(1));
// console.log(divisors(64));
// console.log(divisors(4));

//============= OTHER CODEWARS SOLUTIONS: =============

function divisors2(n: number) {
    let steps = 0;

    for (let i = 0; i <= n; i++) {
        if (n % i === 0) steps++;
    }

    return steps;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  COUNT DIGIT APPEARING IN SQUARES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REGEXP OBJECT, MATCH()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Take an integer n (n >= 0) and a digit d (0 <= d <= 9) as an integer.

Square all numbers k (0 <= k <= n) between 0 and n.

Count the numbers of digits d used in the writing of all the k**2.

Call nb_dig (or nbDig or ...) the function taking n and d as parameters and returning this count.

Examples:
n = 10, d = 1 
the k*k are 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100
We are using the digit 1 in: 1, 16, 81, 100. The total count is then 4.

nb_dig(25, 1) returns 11 since
the k*k that contain the digit 1 are:
1, 16, 81, 100, 121, 144, 169, 196, 361, 441.
So there are 11 digits 1 for the squares of numbers between 0 and 25
*/

const nbDig = (num: number, digit: number): number => {
    let counter: number = 0;
    const regex = new RegExp(String(digit), "g");

    for (let i = 0; i <= num; i++) {
        let squareStr = String(Math.pow(i, 2));
        const matches = squareStr.match(regex);
        // console.table({
        //     square: squareStr,
        //     digit: String(digit),
        //     matches: matches?.length
        // });
        if (matches) counter += matches.length;
    }

    return counter;
};

//  CREATE JS REGEXP OBJECT FOR digit
//  LOOP OVER INTEGERS UP TO AND ICLUDING num
//      CALC SQUARE, CONVERT TO STRING AN SAVE TO VAR squareStr
//      GET ARRAY OF MATCHES (matches)
//      IF matches ARRAY IS NOT EMPTY
//          INCREMENT counter BY matches.length
//  RETURN counter AS RESULT

// 6
// console.log(nbDig(11, 1));

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  BREAKING CHOCOLEATE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to split the chocolate bar of given dimension n x m into small squares. Each square is of size 1x1 and unbreakable. Implement a function that will return minimum number of breaks needed.

For example if you are given a chocolate bar of size 2 x 1 you can split it to single squares in just one break, but for size 3 x 1 you must do two breaks.

If input data is invalid you should return 0 (as in no breaks are needed if we do not have any chocolate to split). Input will always be a non-negative integer.
*/

const breakChocolate = (n: number, m: number): number => {
    return n * m > 1 ? n * m - 1 : 0;
};

// console.log(breakChocolate(5, 5));

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  DONT GIVE ME FIVE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REGEX.TEST()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
In this kata you get the start number and the end number of a region and should return the count of all numbers except numbers with a 5 in it. The start and the end number are both inclusive!

Examples:

1,9 -> 1,2,3,4,6,7,8,9 -> Result 8
4,17 -> 4,6,7,8,9,10,11,12,13,14,16,17 -> Result 12
The result may contain fives. ;-)
The start number will always be smaller than the end number. Both numbers can be also negative!
*/

const dontGiveMeFive = (start: number, end: number): number => {
    let counter = 0;

    for (let i = start; i <= end; i++) {
        if (!/5/g.test(String(i))) {
            counter++;
        }
    }

    return counter;
};

//  TEST FOR A MATCH IN STRING(NUM) FOR "5"
//      IF NO MATCH, INCREMENT COUNTER
//  RETURN COUNTER AS RESULT

// return /^(\d{4}|\d{6})$/.test(pin);

// console.log(dontGiveMeFive(1, 9));
// console.log(dontGiveMeFive(4, 17));

//============= OTHER CODEWARS SOLUTIONS: =============

function dontGiveMeFive2(start: number, end: number): number {
    return Array.from(
        { length: end - start + 1 },
        (ix, it) => it + start
    ).filter((it) => !/5/.test(it + "")).length;
}

function dontGiveMeFive3(start: number, end: number): number {
    return Array.from({ length: end - start + 1 }, (_, i) => i + start).filter(
        (x) => !/5/.test(`${x}`)
    ).length;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  REVERSE WORDS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Complete the function that accepts a string parameter, and reverses each word in the string. All spaces in the string should be retained.

Examples
"This is an example!" ==> "sihT si na !elpmaxe"
"double  spaces"      ==> "elbuod  secaps"

*/

const reverseWords = (str: string): string => {
    return str
        .split(" ")
        .map((word) => word.split("").reverse().join(""))
        .join(" ");
};

// console.log(reverseWords('The quick brown fox jumps over the lazy dog.'));

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SUM OF THE FIRST NTH TERM OF SERIES ROUNDED TO 2 DIGITS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  TOFIXED(2), TRACKING MULTIPLE VARIABLES IN FOR LOOP
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to write a function which returns the sum of following series upto nth term(parameter).

Series: 1 + 1/4 + 1/7 + 1/10 + 1/13 + 1/16 +...
Rules:
You need to round the answer to 2 decimal places and return it as String.

If the given value is 0 then it should return 0.00

You will only be given Natural Numbers as arguments.

Examples:(Input --> Output)
1 --> 1 --> "1.00"
2 --> 1 + 1/4 --> "1.25"
5 --> 1 + 1/4 + 1/7 + 1/10 + 1/13 --> "1.57"
*/

const SeriesSum = (num: number): string => {
    let sum: number = 0;

    for (let i = 0, denominator = 1; i < num; i++, denominator += 3) {
        sum += 1 / denominator;
    }

    return String(sum.toFixed(2));
};

// TRACK/INCREMENT NUM AND DENOMINATOR IN LOOP
// INCREMENT SUM WITH 1 / DENOMINATOR NUM TIMES
// ROUND DOWN TO TWO DIGITS AND CONVERT NO STRING

// console.log(SeriesSum(1));
// console.log(SeriesSum(2));
// console.log(SeriesSum(3));

//============= OTHER CODEWARS SOLUTIONS: =============

function SeriesSum2(n: number): string {
    return [...Array(n).keys()]
        .map((k) => 1 / (k * 3 + 1))
        .reduce((acc, n) => acc + n, 0)
        .toFixed(2);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  STRING END WITH?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  ENDSWITH()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Complete the solution so that it returns true if the first argument(string) passed in ends with the 2nd argument (also a string).

Examples:

solution('abc', 'bc') // returns true
solution('abc', 'd') // returns false
*/

const solution = (str: string, ending: string): boolean => {
    return str.endsWith(ending);
};

// console.log(solution('abcde', 'cde'));
// console.log(solution('abcde', 'rde'));

//============= OTHER CODEWARS SOLUTIONS: =============

function solution2(str: string, ending: string): boolean {
    return !ending.length || str.slice(-ending.length) === ending;
}

function solution3(str: string, ending: string): boolean {
    const strSubstring = str.slice(str.length - ending.length);
    return strSubstring === ending; // TODO: complete
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ODD OR EVEN (SUM OF ARRAY)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REDUCE(), BITWISE AND (ODD OR EVEN), DOUBLE NESTED TERNARY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a list of integers, determine whether the sum of its elements is odd or even.

Give your answer as a string matching "odd" or "even".

If the input array is empty consider it as: [0] (array with a zero).
*/

// num(1) & 1 => 1   RETURNS  1 IF N IS ODD
// num(2) & 1 => 0   RETURNS 0 IF N IS EVEN

const oddOrEven = (array: number[]): string => {
    // if (array.length === 0) return "even";
    // return array.reduce((a, b) => a + b) & 1
    //     ? "odd"
    //     : "even";

    return array.length > 0
        ? array.reduce((a, b) => a + b) & 1
            ? "odd"
            : "even"
        : "even";
};

// console.log(oddOrEven([0, -1, -3]));
// console.log(oddOrEven([0, -1, -4]));
// console.log(oddOrEven([]));

//============= OTHER CODEWARS SOLUTIONS: =============

function oddOrEven2(array: number[]) {
    return array.reduce((acc, it) => acc + it, 0) % 2 ? "odd" : "even";
}

const oddOrEven3 = (array: number[]) =>
    array.reduce((acc, curr) => (acc += curr), 0) % 2 === 0 ? "even" : "odd";

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  NUMBER OF PEOPLE ON THE BUS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REDUCE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
There is a bus moving in the city, and it takes and drop some people in each bus stop.

You are provided with a list (or array) of integer pairs. Elements of each pair represent number of people get into bus (The first item) and number of people get off the bus (The second item) in a bus stop.

Your task is to return number of people who are still in the bus after the last bus station (after the last array). Even though it is the last bus stop, the bus is not empty and some people are still in the bus, and they are probably sleeping there :D

Take a look on the test cases.

Please keep in mind that the test cases ensure that the number of people in the bus is always >= 0. So the return integer can't be negative.

The second value in the first integer array is 0, since the bus is empty in the first bus stop.
*/

const number = (busStops: [number, number][]): number => {
    let counter: number = 0;

    busStops.forEach((stop) => {
        counter += stop[0];
        counter -= stop[1];
    });

    return counter;
};

// console.log(number([[10, 0], [3, 5], [5, 8]]));
// console.log(number([[3, 0], [9, 1], [4, 10], [12, 2], [6, 1], [7, 10]]));

//============= OTHER CODEWARS SOLUTIONS: =============

function number2(busStops: number[][]): number {
    return busStops.reduce((rem, [on, off]) => rem + (on - off), 0);
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SUM OF ODD NUMBERS IN TRIANGLE OF CONS. ODD NUMS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given the triangle of consecutive odd numbers:

             1
          3     5
       7     9    11
   13    15    17    19
21    23    25    27    29
...
Calculate the sum of the numbers in the nth row of this triangle (starting at index 1) e.g.: (Input --> Output)

1 -->  1
2 --> 3 + 5 = 8
*/

function rowSumOddNumbers(n: number): number {
    return Math.pow(n, 3);
    //     return n ** 3;
}

// FIRST SOLUTION IN JS:

// const rowSumOddNumbers2 = (n) => {
//     const firstOfRow = n + Math.pow(n - 1, 2);
//     const subTotal = firstOfRow * n;
//     let increments = 0;
//     for (let j = 0; j <= n * 2 - 2; j += 2) {
//         increments = increments + j;
//     }
//     total = subTotal + increments;
//     return total;
// };

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  IS THIS A TRIANGLE?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Implement a function that accepts 3 integer values a, b, c. The function should return true if a triangle can be built with the sides of given length and false in any other case.

(In this case, all triangles must have surface greater than 0 to be accepted).
*/

const isTriangle = (a: number, b: number, c: number): boolean => {
    return a + b > c && a + c > b && b + c > a;
};

//   SUM OF ANY TWO SIDES MUST BE GREATER THAN THIRD SIDE

// console.log(isTriangle(1, 2, 2));
// console.log(isTriangle(7, 2, 2));

//============= OTHER CODEWARS SOLUTIONS: =============

const isTriangle2 = (a: number, b: number, c: number): boolean =>
    a + b <= c || a + c <= b || b + c <= a ? false : true;

function isTriangle3(a: number, b: number, c: number): boolean {
    return a + b <= c ? false : a + c <= b ? false : b + c <= a ? false : true;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  REGEX VALIDATE PIN CODE (4 OR 6 DIGITS)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REGEX
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

const validatePin = (pin: string): boolean => {
    // if (pin.length === 4 && pin.match(/\d/g)!.length === 4) return true;
    // if (pin.length === 6 && pin.match(/\d/g)!.length === 6) return true;
    // return false;

    return (
        (pin.length === 4 && pin.match(/\d/g)!.length === 4) ||
        (pin.length === 6 && pin.match(/\d/g)!.length === 6)
    );
};

// console.log(validatePin("12345654yw"));
// console.log(validatePin("123456"));
// console.log(validatePin("12345a"));
// console.log(validatePin("1234"));
// console.log(validatePin("-1234"));

//============= OTHER CODEWARS SOLUTIONS: =============

export class Kata2 {
    static pinFormat: RegExp = new RegExp(/^\d{4}(\d{2})?$/);

    static validatePin(pin: string): boolean {
        return Kata2.pinFormat.test(pin);
    }
}

export class Kata3 {
    static validatePin(pin: string) {
        return /^(\d{4}|\d{6})$/.test(pin);
    }
}

export class Kata4 {
    static validatePin(pin: string): boolean {
        const digits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
        if (pin.length !== 4 && pin.length !== 6) {
            return false;
        }

        for (let index = 0; index < pin.length; index++) {
            if (!digits.includes(pin[index])) {
                return false;
            }
        }
        return true;
    }
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// In DNA strings, symbols "A" and "T" are complements of each other, as "C" and "G". You function receives one side of the DNA (string, except for Haskell); you need to return the other complementary side. DNA strand is never empty or there is no DNA at all (again, except for Haskell).

// More similar exercise are found here: http://rosalind.info/problems/list-view/ (source)

// Example: (input --> output)

// "ATTGC" --> "TAACG"
// "GTAT" --> "CATA"
// dnaStrand []        `shouldBe` []
// dnaStrand [A,T,G,C] `shouldBe` [T,A,C,G]
// dnaStrand [G,T,A,T] `shouldBe` [C,A,T,A]
// dnaStrand [A,A,A,A] `shouldBe` [T,T,T,T]

const dnaStrand = (dna: string): string => {
    const arr = dna.split("");

    arr.map((el, i) => {
        switch (el) {
            case "A":
                arr[i] = "T";
                break;
            case "T":
                arr[i] = "A";
                break;
            case "C":
                arr[i] = "G";
                break;
            case "G":
                arr[i] = "C";
        }
    });

    console.log(arr.join(""));
    return arr.join("");
};

// dnaStrand("ATCG");

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️
// export class Kata {
//     static dnaStrand(dna: string) {
//       return dna.replace(/./g, (c)=>({A:'T',T:'A',G:'C',C:'G'})[c]);
//     }
// }

// ❗️❗️❗️ if you want a replaced with x, b with y and c with z, you can do something like this:

// var chars = {'a':'x','b':'y','c':'z'};
// var s = '234abc567bbbbac';
// s = s.replace(/[abc]/g, m => chars[m]);
// console.log(s);
// Output: 234xyz567yyyyxz

// ❗️❗️❗️
// let dummyString = 'Javascript^ is$ the most popular _language';
// newString = dummyString.replace(/[_^$]/g, charactersToReplace => ({'^': '', '_': ':', '$' : '+' })[charactersToReplace]);

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  JADEN CASE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// Jaden Smith, the son of Will Smith, is the star of films such as The Karate Kid (2010) and After Earth (2013). Jaden is also known for some of his philosophy that he delivers via Twitter. When writing on Twitter, he is known for almost always capitalizing every word. For simplicity, you'll have to capitalize each word, check out how contractions are expected to be in the example below.

// Your task is to convert strings to how they would be written by Jaden Smith. The strings are actual quotes from Jaden Smith, but they are not capitalized in the same way he originally typed them.

// Example:

// Not Jaden-Cased: "How can mirrors be real if our eyes aren't real"
// Jaden-Cased:     "How Can Mirrors Be Real If Our Eyes Aren't Real"

// 🟩
// String.prototype.toJadenCase = function (str: string ): string {

//     //  ❗️❗️❗️ TypeError: Cannot read property 'split' of undefined ❗️❗️❗️
//     //  return str.split(" ").map((word) => word.replace(word[0], word[0].toUpperCase())).join(" ");

//     // ❗️❗️❗️ USE this KEYWORD: ❗️❗️❗️
//     return this.split(" ").map((word) => word.replace(word[0], word[0].toUpperCase())).join(" ");

// };
// 🟩

// STRING -> ARR(WORDS) -> CAPITALIZE EACH WORD IN ARRAY -> JOIN INTO STRING WITH " "
const toJadenCase = (str: string): string => {
    console.log(
        str
            .split(" ")
            .map((word) => word.replace(word[0], word[0].toUpperCase()))
            .join(" ")
    );

    // ❗️❗️❗️ HAVE TO USE this IN CODEWARS SOLUTION ❗️❗️❗️
    return str
        .split(" ")
        .map((word) => word.replace(word[0], word[0].toUpperCase()))
        .join(" ");
};

// toJadenCase("How can mirrors be real if our eyes aren't real");
// toJadenCase("a b A B");

//============= OTHER CODEWARS SOLUTIONS: =============

// String.prototype.toJadenCase = function () {
//     return this.replace(/(?:^|\s)\S/g, firstLetter => firstLetter.toUpperCase());
// };

// const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1)
// String.prototype.toJadenCase = function() {
//   return this.split(' ').map(capitalize).join(' ')
// }

// String.prototype.toJadenCase = function () {
//     return this.replace(/^.|\s./gi, $ => $.toUpperCase())
// };

// String.prototype.toJadenCase = function () {
//     let temp = this;

//     if (temp === null || temp.length === 0) {
//       return null;
//     }

//     let result = '';

//     for (let i = 0; i < temp.length; i++) {
//       let x = temp[i];
//       if (i === 0) {
//         x = x.toUpperCase();
//       } else if (temp[i - 1] === ' ') {
//         x = x.toUpperCase();
//       }
//       result += x;
//     }

//     return result;
//   };

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SHORTEST WORD'S LENGTH
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// STR -> ARR(STR) -> SORT ARR BY LENGTH OF WORDS -> GRAB LENGTH OF FIRST ELEMENT
const findShort = (str: string): number => {
    return str.split(" ").sort((a, b) => {
        return a.length - b.length;
    })[0].length;
};

findShort("bitcoin take over the world maybe who knows perhaps");

//============= OTHER CODEWARS SOLUTIONS: =============

// export function findShort(s: string): number {
//     return Math.min(...s.split(" ").map((w) => w.length));
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  X's AND O's
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// Check to see if a string has the same amount of 'x's and 'o's. The method must return a boolean and be case insensitive. The string can contain any char.

// Examples input/output:

// XO("ooxx") => true
// XO("xooxx") => false
// XO("ooxXm") => true
// XO("zpzpzpp") => true // when no 'x' and 'o' is present should return true
// XO("zzoo") => false

const xo = (str: string): boolean => {
    const xS = str.toLowerCase().match(/x/g); // GET x's
    const oS = str.toLowerCase().match(/o/g); // GET o's
    if (xS && oS) {
        // IF BOTH FOUND:
        return xS.length === oS.length; // CHECK IF THEIR LENGTHS EQUAL (bool)
    } else if (xS || oS) {
        // IF ONLY ONE FOUND:
        return false; // false
    } else {
        // IF NEITHER FOUND
        return true; // true
    }
};

//============= OTHER CODEWARS SOLUTIONS: =============

// export function xo(str: string) {
// 	return str.toLowerCase().split('x').length == str.toLowerCase().split('o').length;
//   }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  IS ISOGRAM?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// STRING -> ARRAY OF LOWERCASED LETTERS -> SET (DUPLICATES REMOVED)
// COMPARE NUMBER OF ELEMENTS IN SET AND ORIGINAL STRING
// RETURN TRUE IF EQUAL, OTHERWISE FALSE
const isIsogram = (str: string): boolean => {
    const lettersSet = new Set(str.toLowerCase().split(""));
    return lettersSet.size === str.length;
};

//============= OTHER CODEWARS SOLUTIONS: =============

// export function isIsogram (str: string): boolean {
// 	return (new Set(str.toLowerCase())).size === str.length
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  IS SQUARE?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

function isSquare(num: number): boolean {
    return Number.isInteger(Math.sqrt(num));
}

//============= OTHER CODEWARS SOLUTIONS: =============

// export default (n: number): boolean => (Math.sqrt(n) % 1 === 0);

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

const getMiddle = (str: string): string => {
    const halfLength = str.length / 2;
    const isEvenLength = str.length % 2 === 0;

    // console.log(isEvenLength
    // 	? str.substring(halfLength - 1, halfLength + 1)
    // 	: str.charAt((str.length - 1) / 2)
    // )

    return isEvenLength
        ? str.substring(halfLength - 1, halfLength + 1)
        : str.charAt((str.length - 1) / 2);
};

// getMiddle("abcde");
// getMiddle("abcd");

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// NUM -> STR -> ARR(STR) -> ARR(NUM) -> ARR(SORTED) -> ARR(REVERSED) -> STRING -> NUM
const descendingOrder = (n: Number): number => {
    // JAVASCRIPT:

    // console.log(
    //     n
    //         .toString()
    //         .split("")
    //         .map(Number)
    //         .sort()
    //         .reverse()
    //         .map(String)
    //         .join("") * 1		// ❗️❗️❗️ *1 NOT WORKING IN TS ❗️❗️❗️
    // );

    return Number(
        n.toString().split("").map(Number).sort().reverse().map(String).join("")
    );
};

descendingOrder(123456789);

//============= OTHER CODEWARS SOLUTIONS: =============

// export function descendingOrder(n: number | null | undefined): number | null | undefined {
//   return n ? parseInt(n.toString().split("").sort().reverse().join("")) : n;
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  MUMBLING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// EMPTY ARR FOR SOLUTION
// SPLIT INTO ARRAY AND LOWERCASE
// REPEAT index + 1 TIMES AND CAPITALIZE FIRST LETTER THEN PUSH INTO SOLUTION ARRAY
// JOIN INTO STRING WITH "-"
const accum = (str: string): string => {
    const repsArr: string[] = [];
    const letters = str.split("").map((el) => el.toLowerCase());
    letters.forEach((letter, i) => {
        let rep = letter
            .repeat(i + 1)
            .replace(letter[0], letter[0].toUpperCase());
        repsArr.push(rep);
    });
    console.log(repsArr.join("-"));
    return repsArr.join("-");
};

// accum("ZpglnRxqenU");

//============= OTHER CODEWARS SOLUTIONS: =============

// export function accum(s: string): string {
// 	return s.split('')
// 	.map((elem, index) => elem.toUpperCase() + (elem.toLowerCase()).repeat(index))
// 	.join('-');
//   }

//   export function accum(s: string): string {
// 	return s.split("").map((value, index) => (value.toUpperCase() + value.toLowerCase().repeat(index))).join("-");
//   }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// SPLIT INTO ARRAY -> CONVERT TO NUM -> FIND MAX/MINN
const highAndLow = (numbers: string): string => {
    const numArr = numbers.split(" ").map((num) => Number(num));
    // console.log(`${Math.max(...numArr)} ${Math.min(...numArr)}`);
    return `${Math.max(...numArr)} ${Math.min(...numArr)}`;
};

highAndLow("1 2 3 4 -6");
// highAndLow("8 3 -5 42 -1 0 0 -9 4 7 4 -4");

//============= OTHER CODEWARS SOLUTIONS: =============

// export class Kata {
// 	static highAndLow(numbers: string) {
// 	  const max = Math.max(...numbers.split(' ').map(i => +i));
// 	  const min = Math.min(...numbers.split(' ').map(i => +i));

// 	  return `${max} ${min}`;

// 	}
// }

// export class Kata
// {
//   static highAndLow(numbers: string)
//   {
//     let splitted = numbers.split(" ").map(Number);
//     let low = Math.min( ...splitted );
//     let high = Math.max( ...splitted );
//     return high + " " + low;
//   }
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  DISEMVOWEL STRING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// REMOVE ALL VOWELS:
const disemvowel = (str: string): string => {
    return str.replace(/[aeiou]/gi, "");
};

//============= OTHER CODEWARS SOLUTIONS: =============

// export class Kata {
//   static disemvowel(str: string) {
//     var vowels: string = 'AEIOUaeiou';
//     return str.split('').filter(v => !vowels.includes(v)).join('')
//   }
// }

// export class Kata {
//   static readonly LETTERS_LIST = new RegExp('a|e|i|o|u', 'gi');

//   static disemvowel(str: string) {
//     return str.replace(Kata.LETTERS_LIST, '');
//   }
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SQUARE DIGITS OF NUMBER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

const squareDigits = (num: number): number => {
    let solution;
    // solution = num
    //     .toString()
    //     .split("")
    //     .map((el) => Number(el))
    //     .map((el) => Math.pow(el, 2))
    //     .map((el) => el.toString())
    //     .join("")

    solution = num
        .toString()
        .split("")
        .map((el) => Math.pow(Number(el), 2).toString())
        .join("");

    console.log(Number(solution));
    return Number(solution);
};

// squareDigits(9119);

//============= OTHER CODEWARS SOLUTIONS: =============

// export class Kata {
//     static squareDigits(num: number) {
//       return +num.toString().split('').map(i=>+i*+i).join('');
//     }
// }

// export class Kata {
//     static squareDigits(num: number) {
//       return +num.toString()
//                  .split('')
//                  .map(n => Math.pow(+n,2))
//                  .join('');
//     }
// }

// export class Kata {
//     static squareDigits(num: number): number {
//       return +num.toString().split('').map((n)=>(+n)**2).join('')
//     }
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  COUNT VOWELS IN STRING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// export class Kata {
//     static getCount = (str: string): number => {
//       return str.split("").filter((el) => el.match(/[aeiou]/gi)).length;
//     }
//   }

// SPLIT INTO ARRAY -> FIND VOWELS -> GET LENGTH OF VOWELS ARRAY
const getCount = (str: string): number => {
    return str.split("").filter((el) => el.match(/[aeiou]/gi)).length;
};

//============= OTHER CODEWARS SOLUTIONS: =============

//   export class Kata {
//     static getCount(str: string) {
//       let list = str.match(/[aeiou]/gi);
//       return list ? list.length : 0;
//     }
//   }

// export class Kata {
//     static getCount(str: string) : number {
//       return str.split('').filter(c => /[aeiou]/i.test(c)).length
//     }
//   }
