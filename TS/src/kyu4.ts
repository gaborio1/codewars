// ❗️❗️❗️ ✅  ❓❓❓
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============


// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  NEXT BIGGER NUMBER WITH SAME DIGITS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Create a function that takes a positive integer and returns the next bigger number that can be formed by rearranging its digits. For example:

12 ==> 21
513 ==> 531
2017 ==> 2071
nextBigger(num: 12)   // returns 21
nextBigger(num: 513)  // returns 531
nextBigger(num: 2017) // returns 2071
If the digits can't be rearranged to form a bigger number, return -1 (or nil in Swift):

9 ==> -1
111 ==> -1
531 ==> -1
nextBigger(num: 9)   // returns nil
nextBigger(num: 111) // returns nil
nextBigger(num: 531) // returns nil
*/


const nextBigger = (num: number): number => {

    const digitsArr: number[] = String(num).split("").map((digit) => Number(digit));
    let solutionArr: number[] = [];
    const numStr: string = String(num);
    let matchArr: number[] = [];

    for (let i = numStr.length - 1; i >= 0; i--) {

        let digit: number = Number(numStr[i]);
        matchArr.unshift(digit);
        const largestSub: number = Number([...matchArr].sort().reverse().join(""));
        const actualSub: number = Number(matchArr.join(""));

        if (actualSub !== largestSub) {
            break;
        }
    }

    if (Number(matchArr.join("")) === Number([...matchArr].sort().reverse().join(""))) return -1;

    for (let i = 0; i < digitsArr.length - matchArr.length; i++) {
        solutionArr.push(digitsArr[i]);
    }

    const matcArrFirstDigit: number = matchArr[0];
    let nextLargestDigit: number;
    const sortedMatchArr: number[] = [...matchArr].sort();

    for (let i = 0; i < sortedMatchArr.length; i++) {

        if (sortedMatchArr[i] > matcArrFirstDigit) {
            nextLargestDigit = sortedMatchArr[i];
            solutionArr.push(nextLargestDigit);
            sortedMatchArr.splice(i, 1);
            break;
        }
    }

    return Number(solutionArr.concat(sortedMatchArr).join(""));

}

// WITH COMMENTS:
const nextBigger2 = (num: number): number => {

    // CONVERT num TO ARRAY OF DIGITS
    const digitsArr: number[] = String(num).split("").map((digit) => Number(digit));
    // console.log(digitsArr);

    // INITIALIZE SOLUTION ARRAY
    let solutionArr: number[] = [];

    // CONVERT num TO STRING
    const numStr: string = String(num);
    // INITIALIZE matchArr FOR DIGITS THAT NEED REARRANGING
    let matchArr: number[] = [];
    // let actualMatch: number = 0;

    // LOOP OVER numStr IN REVERSE
    for (let i = numStr.length - 1; i >= 0; i--) {

        // EACH DIGIT
        let digit: number = Number(numStr[i]);
        // console.log(digit);

        // PUSH DIGIT INTO matchArr
        matchArr.unshift(digit);
        // console.log(matchArr);

        // FIND LARGEST POSSIBLE NUM THAT CAN BE FORMED USING DIGITS
        const largestSub: number = Number([...matchArr].sort().reverse().join(""));
        // console.log("largestNumber: " + largest);

        // ACTUAL SUB-NUMBER
        const actualSub: number = Number(matchArr.join(""));
        // console.log("actualSub: " + actualSub);

        if (actualSub !== largestSub) {
            // console.log("match found");
            break;
        }
    }

    // console.log("matchArr: " + matchArr);
    // console.log("digitsArr: " + digitsArr);

    // COMPARE matchArr WITH matchArr(DESCENDING), IF NO LARGER NUMBER CAN BE FORMED, RETURN -1
    if (Number(matchArr.join("")) === Number([...matchArr].sort().reverse().join(""))) return -1;

    // PUPULATE solutionArr 1️⃣
    // PUSH DIGITS THAT DON'T NEED CHANGING (LEFT SIDE DIGITS) INTO SOLUTION ARRAY
    for (let i = 0; i < digitsArr.length - matchArr.length; i++) {
        solutionArr.push(digitsArr[i]);
    }

    // console.log("solutionArrInit: " + solutionArr);

    // console.log("matchArr: " + matchArr);

    // GET FIRST DIGIT OF MATCHARR (IT HAS TO BE REPLACED NEXT LARGEST NUMBER IN matchArr)
    const matcArrFirstDigit: number = matchArr[0];
    // console.log("matcArrFirstDigit: " + matcArrFirstDigit);

    // PUPULATE solutionArr 2️⃣
    // GET NEXT LARGEST DIGIT OF sortedMatchArr AND PUSH IT INTO SOLUTION ARRAY
    let nextLargestDigit: number;
    const sortedMatchArr: number[] = [...matchArr].sort();
    for (let i = 0; i < sortedMatchArr.length; i++) {
        if (sortedMatchArr[i] > matcArrFirstDigit) {
            nextLargestDigit = sortedMatchArr[i];
            // console.log(nextLargestDigit);
            solutionArr.push(nextLargestDigit);
            // DELETE nextLargestDigit FROM sortedMatchArr
            sortedMatchArr.splice(i, 1);
            // console.log("sortedMinusArrSplice: " + sortedMatchArr);
            break;
        }
    }

    // console.log("solutionArr: " + solutionArr.concat(sortedMatchArr));

    // PUPULATE solutionArr 3️⃣
    // ADD sortedMatchArr TO solutionArr AND CONVERT TO NUMBER
    return Number(solutionArr.concat(sortedMatchArr).join(""));

}

// console.log(nextBigger(29));
// console.log(nextBigger(12));
// console.log(nextBigger(414));
// console.log(nextBigger(59884848459853));
// console.log(nextBigger(544));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function nextBigger3(n: number): number {
    const digitArray = Array.from(String(n), Number);
    let swapped = false;
    let i = digitArray.length - 1;

    for (i; i > 0 && !swapped; i--) {
        if (digitArray[i] > digitArray[i - 1]) {
            const j = i + findIndexOfNextBiggerDigit(digitArray.slice(i), digitArray[i - 1])
            let temp = digitArray[j]
            digitArray[j] = digitArray[i - 1]
            digitArray[i - 1] = temp
            swapped = true
        }
    }

    if (!swapped) return -1

    return Number(partialSort(digitArray, i).join(''))
}

function findIndexOfNextBiggerDigit(arr: number[], threshold: number): number {
    let minDigit = arr[0]
    let minDigitIndex = 0

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > threshold && arr[i] < minDigit) {
            minDigit = arr[i]
            minDigitIndex = i
        }
    }

    return minDigitIndex
}

function partialSort(arr: number[], start: number) {
    const sortedPart = arr.slice(start + 1).sort()
    return arr.slice(0, start + 1).concat(sortedPart)
}

// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰


function nextBigger4(num: number): number {
    if (
        num < 12 ||
        num % 1 !== 0 ||
        /^(\d)\1+$/.test(num.toString()) ||
        /^9*8*7*6*5*4*3*2*1*0*$/.test(num.toString())
    ) return -1;

    const numStr: string = sortAsString(num);
    let nextNum: number = num;
    let isNextBigger: boolean = false;

    while (!isNextBigger) {
        if (numStr === sortAsString(++nextNum)) isNextBigger = true;
    }

    return nextNum;
}

function sortAsString(num: number): string {
    return num.toString().split('').sort().join('');
}

// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰


const nextBigger5 = (n: number) => {
    let max = maxify(n);
    while (++n <= max) {
        if (maxify(n) === max) {
            return n;
        }
    }
    return -1;
};

const maxify = (n: number) => {
    return +[...`${n}`]
        .map(n => +n)
        .sort((a, b) => b - a)
        .join('')
        .replace(/^(0+)([1-9])/, '$2$1')
};

// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

function nextBigger6(n: number): number {
    const originalArr = ("" + n).split("").sort().join("")
    let newArr = ""
    let current = n + 1;
    if (n.toString().split('').join('') == [...n.toString().split('')].sort().reverse().join('')) return -1;
    while (originalArr !== newArr) {
        newArr = ("" + current).split("").sort().join("")
        current++;
    }
    return current - 1;
}

// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

function sortedDigits(n: number): string[] {
    let arr = n.toString().split('');
    arr.sort(function (a: string, b: string): number { return b.localeCompare(a); });
    return arr;
};

export function nextBigger7(n: number): number {
    let arr = sortedDigits(n);
    let max = parseInt(arr.join(''), 10);
    for (let i = n + 1; i <= max; i++) {
        if (sortedDigits(i).every((x, j) => x === arr[j])) {
            return i;
        }
    }
    return -1;
}