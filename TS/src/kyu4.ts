// ❗️❗️❗️ ✅  ❓❓❓
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:  STRINGS MIX
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given two strings s1 and s2, we want to visualize how different the two strings are. We will only take into account the lowercase letters (a to z). First let us count the frequency of each lowercase letters in s1 and s2.

s1 = "A aaaa bb c"

s2 = "& aaa bbb c d"

s1 has 4 'a', 2 'b', 1 'c'

s2 has 3 'a', 3 'b', 1 'c', 1 'd'

So the maximum for 'a' in s1 and s2 is 4 from s1; the maximum for 'b' is 3 from s2. In the following we will not consider letters when the maximum of their occurrences is less than or equal to 1.

We can resume the differences between s1 and s2 in the following string: "1:aaaa/2:bbb" where 1 in 1:aaaa stands for string s1 and aaaa because the maximum for a is 4. In the same manner 2:bbb stands for string s2 and bbb because the maximum for b is 3.

The task is to produce a string in which each lowercase letters of s1 or s2 appears as many times as its maximum if this maximum is strictly greater than 1; these letters will be prefixed by the number of the string where they appear with their maximum value and :. If the maximum is in s1 as well as in s2 the prefix is =:.

In the result, substrings (a substring is for example 2:nnnnn or 1:hhh; it contains the prefix) will be in decreasing order of their length and when they have the same length sorted in ascending lexicographic order (letters and digits - more precisely sorted by codepoint); the different groups will be separated by '/'. See examples and "Example Tests".

Hopefully other examples can make this clearer.

s1 = "my&friend&Paul has heavy hats! &"
s2 = "my friend John has many many friends &"
mix(s1, s2) --> "2:nnnnn/1:aaaa/1:hhh/2:mmm/2:yyy/2:dd/2:ff/2:ii/2:rr/=:ee/=:ss"

s1 = "mmmmm m nnnnn y&friend&Paul has heavy hats! &"
s2 = "my frie n d Joh n has ma n y ma n y frie n ds n&"
mix(s1, s2) --> "1:mmmmmm/=:nnnnnn/1:aaaa/1:hhh/2:yyy/2:dd/2:ff/2:ii/2:rr/=:ee/=:ss"

s1="Are the kids at home? aaaaa fffff"
s2="Yes they are here! aaaaa fffff"
mix(s1, s2) --> "=:aaaaaa/2:eeeee/=:fffff/1:tt/2:rr/=:hh"
*/

class G964 {

    // public static mix = (s1, s2) => {

    // }
}

// console.log(G964.mix("Are they here", "yes, they are here"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:  SUM OF INTERVALS 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function called sumIntervals/sum_intervals() that accepts an array of intervals, and returns the sum of all the interval lengths. Overlapping intervals should only be counted once.

Intervals
Intervals are represented by a pair of integers in the form of an array. The first value of the interval will always be less than the second value. Interval example: [1, 5] is an interval from 1 to 5. The length of this interval is 4.

Overlapping Intervals
List containing overlapping intervals:

[
   [1,4],
   [7, 10],
   [3, 5]
]
The sum of the lengths of these intervals is 7. Since [1, 4] and [3, 5] overlap, we can treat the interval as [1, 5], which has a length of 4.

Examples:
sumOfIntervals([[1, 5], [10, 15], [-1, 3]]) // => 11

sumOfIntervals([[1, 5]]) // => 4 
*/

const sumOfIntervals = (intervals: [number, number][]): number => {
    return 1;
  }

// 4
// console.log(sumOfIntervals([[1, 5]]));
// 8
// console.log(sumOfIntervals([[1, 5], [6, 10]]));
// 4
// console.log(sumOfIntervals([[1, 5], [1, 5]]));
// 7
// console.log(sumOfIntervals([[1, 4], [7, 10], [3, 5]]));

// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============


// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  NEXT BIGGER NUMBER WITH SAME DIGITS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Create a function that takes a positive integer and returns the next bigger number that can be formed by rearranging its digits. For example:

12 ==> 21
513 ==> 531
2017 ==> 2071
nextBigger(num: 12)   // returns 21
nextBigger(num: 513)  // returns 531
nextBigger(num: 2017) // returns 2071
If the digits can't be rearranged to form a bigger number, return -1 (or nil in Swift):

9 ==> -1
111 ==> -1
531 ==> -1
nextBigger(num: 9)   // returns nil
nextBigger(num: 111) // returns nil
nextBigger(num: 531) // returns nil
*/


const nextBigger = (num: number): number => {

    const digitsArr: number[] = String(num).split("").map((digit) => Number(digit));
    let solutionArr: number[] = [];
    const numStr: string = String(num);
    let matchArr: number[] = [];

    for (let i = numStr.length - 1; i >= 0; i--) {

        let digit: number = Number(numStr[i]);
        matchArr.unshift(digit);
        const largestSub: number = Number([...matchArr].sort().reverse().join(""));
        const actualSub: number = Number(matchArr.join(""));

        if (actualSub !== largestSub) {
            break;
        }
    }

    if (Number(matchArr.join("")) === Number([...matchArr].sort().reverse().join(""))) return -1;

    for (let i = 0; i < digitsArr.length - matchArr.length; i++) {
        solutionArr.push(digitsArr[i]);
    }

    const matcArrFirstDigit: number = matchArr[0];
    let nextLargestDigit: number;
    const sortedMatchArr: number[] = [...matchArr].sort();

    for (let i = 0; i < sortedMatchArr.length; i++) {

        if (sortedMatchArr[i] > matcArrFirstDigit) {
            nextLargestDigit = sortedMatchArr[i];
            solutionArr.push(nextLargestDigit);
            sortedMatchArr.splice(i, 1);
            break;
        }
    }

    return Number(solutionArr.concat(sortedMatchArr).join(""));

}

// WITH COMMENTS:
const nextBigger2 = (num: number): number => {

    // CONVERT num TO ARRAY OF DIGITS
    const digitsArr: number[] = String(num).split("").map((digit) => Number(digit));
    // console.log(digitsArr);

    // INITIALIZE SOLUTION ARRAY
    let solutionArr: number[] = [];

    // CONVERT num TO STRING
    const numStr: string = String(num);
    // INITIALIZE matchArr FOR DIGITS THAT NEED REARRANGING
    let matchArr: number[] = [];
    // let actualMatch: number = 0;

    // LOOP OVER numStr IN REVERSE
    for (let i = numStr.length - 1; i >= 0; i--) {

        // EACH DIGIT
        let digit: number = Number(numStr[i]);
        // console.log(digit);

        // PUSH DIGIT INTO matchArr
        matchArr.unshift(digit);
        // console.log(matchArr);

        // FIND LARGEST POSSIBLE NUM THAT CAN BE FORMED USING DIGITS
        const largestSub: number = Number([...matchArr].sort().reverse().join(""));
        // console.log("largestNumber: " + largest);

        // ACTUAL SUB-NUMBER
        const actualSub: number = Number(matchArr.join(""));
        // console.log("actualSub: " + actualSub);

        if (actualSub !== largestSub) {
            // console.log("match found");
            break;
        }
    }

    // console.log("matchArr: " + matchArr);
    // console.log("digitsArr: " + digitsArr);

    // COMPARE matchArr WITH matchArr(DESCENDING), IF NO LARGER NUMBER CAN BE FORMED, RETURN -1
    if (Number(matchArr.join("")) === Number([...matchArr].sort().reverse().join(""))) return -1;

    // PUPULATE solutionArr 1️⃣
    // PUSH DIGITS THAT DON'T NEED CHANGING (LEFT SIDE DIGITS) INTO SOLUTION ARRAY
    for (let i = 0; i < digitsArr.length - matchArr.length; i++) {
        solutionArr.push(digitsArr[i]);
    }

    // console.log("solutionArrInit: " + solutionArr);

    // console.log("matchArr: " + matchArr);

    // GET FIRST DIGIT OF MATCHARR (IT HAS TO BE REPLACED NEXT LARGEST NUMBER IN matchArr)
    const matcArrFirstDigit: number = matchArr[0];
    // console.log("matcArrFirstDigit: " + matcArrFirstDigit);

    // PUPULATE solutionArr 2️⃣
    // GET NEXT LARGEST DIGIT OF sortedMatchArr AND PUSH IT INTO SOLUTION ARRAY
    let nextLargestDigit: number;
    const sortedMatchArr: number[] = [...matchArr].sort();
    for (let i = 0; i < sortedMatchArr.length; i++) {
        if (sortedMatchArr[i] > matcArrFirstDigit) {
            nextLargestDigit = sortedMatchArr[i];
            // console.log(nextLargestDigit);
            solutionArr.push(nextLargestDigit);
            // DELETE nextLargestDigit FROM sortedMatchArr
            sortedMatchArr.splice(i, 1);
            // console.log("sortedMinusArrSplice: " + sortedMatchArr);
            break;
        }
    }

    // console.log("solutionArr: " + solutionArr.concat(sortedMatchArr));

    // PUPULATE solutionArr 3️⃣
    // ADD sortedMatchArr TO solutionArr AND CONVERT TO NUMBER
    return Number(solutionArr.concat(sortedMatchArr).join(""));

}

// console.log(nextBigger(29));
// console.log(nextBigger(12));
// console.log(nextBigger(414));
// console.log(nextBigger(59884848459853));
// console.log(nextBigger(544));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function nextBigger3(n: number): number {
    const digitArray = Array.from(String(n), Number);
    let swapped = false;
    let i = digitArray.length - 1;

    for (i; i > 0 && !swapped; i--) {
        if (digitArray[i] > digitArray[i - 1]) {
            const j = i + findIndexOfNextBiggerDigit(digitArray.slice(i), digitArray[i - 1])
            let temp = digitArray[j]
            digitArray[j] = digitArray[i - 1]
            digitArray[i - 1] = temp
            swapped = true
        }
    }

    if (!swapped) return -1

    return Number(partialSort(digitArray, i).join(''))
}

function findIndexOfNextBiggerDigit(arr: number[], threshold: number): number {
    let minDigit = arr[0]
    let minDigitIndex = 0

    for (let i = 1; i < arr.length; i++) {
        if (arr[i] > threshold && arr[i] < minDigit) {
            minDigit = arr[i]
            minDigitIndex = i
        }
    }

    return minDigitIndex
}

function partialSort(arr: number[], start: number) {
    const sortedPart = arr.slice(start + 1).sort()
    return arr.slice(0, start + 1).concat(sortedPart)
}

// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰


function nextBigger4(num: number): number {
    if (
        num < 12 ||
        num % 1 !== 0 ||
        /^(\d)\1+$/.test(num.toString()) ||
        /^9*8*7*6*5*4*3*2*1*0*$/.test(num.toString())
    ) return -1;

    const numStr: string = sortAsString(num);
    let nextNum: number = num;
    let isNextBigger: boolean = false;

    while (!isNextBigger) {
        if (numStr === sortAsString(++nextNum)) isNextBigger = true;
    }

    return nextNum;
}

function sortAsString(num: number): string {
    return num.toString().split('').sort().join('');
}

// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰


const nextBigger5 = (n: number) => {
    let max = maxify(n);
    while (++n <= max) {
        if (maxify(n) === max) {
            return n;
        }
    }
    return -1;
};

const maxify = (n: number) => {
    return +[...`${n}`]
        .map(n => +n)
        .sort((a, b) => b - a)
        .join('')
        .replace(/^(0+)([1-9])/, '$2$1')
};

// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

function nextBigger6(n: number): number {
    const originalArr = ("" + n).split("").sort().join("")
    let newArr = ""
    let current = n + 1;
    if (n.toString().split('').join('') == [...n.toString().split('')].sort().reverse().join('')) return -1;
    while (originalArr !== newArr) {
        newArr = ("" + current).split("").sort().join("")
        current++;
    }
    return current - 1;
}

// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

function sortedDigits(n: number): string[] {
    let arr = n.toString().split('');
    arr.sort(function (a: string, b: string): number { return b.localeCompare(a); });
    return arr;
};

export function nextBigger7(n: number): number {
    let arr = sortedDigits(n);
    let max = parseInt(arr.join(''), 10);
    for (let i = n + 1; i <= max; i++) {
        if (sortedDigits(i).every((x, j) => x === arr[j])) {
            return i;
        }
    }
    return -1;
}