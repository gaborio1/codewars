// ❗️❗️❗️ ✅  ❓❓❓
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// 🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: SUMS OF PARTS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Let us consider this example (array written in general format):

ls = [0, 1, 3, 6, 10]

Its following parts:

ls = [0, 1, 3, 6, 10]
ls = [1, 3, 6, 10]
ls = [3, 6, 10]
ls = [6, 10]
ls = [10]
ls = []
The corresponding sums are (put together in a list): [20, 20, 19, 16, 10, 0]

The function parts_sums (or its variants in other languages) will take as parameter a list ls and return a list of the sums of its parts as defined above.

Other Examples:
ls = [1, 2, 3, 4, 5, 6] 
parts_sums(ls) -> [21, 20, 18, 15, 11, 6, 0]

ls = [744125, 935, 407, 454, 430, 90, 144, 6710213, 889, 810, 2579358]
parts_sums(ls) -> [10037855, 9293730, 9292795, 9292388, 9291934, 9291504, 9291414, 9291270, 2581057, 2580168, 2579358, 0]
*/

function partsSums(ls: number[]): number[] {
    return [1];
}

// [20, 20, 19, 16, 10, 0]
// console.log(partSums([0, 1, 3, 6, 10]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: MAKE THE DEADFISH SWIM
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a simple parser that will parse and run Deadfish.

Deadfish has 4 commands, each 1 character long:

i increments the value (initially 0)
d decrements the value
s squares the value
o outputs the value into the return array
Invalid characters should be ignored.

parse("iiisdoso") => [8, 64]
*/

/** return the output array and ignore all non-op characters */
function parse(data: string): number[] {
    return [1];
}

// [8, 64]
// console.log(parse("iiisdoso"));
// console.log(parse("iiisxxxdoso"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: HELP THE BOOKSELLER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A bookseller has lots of books classified in 26 categories labeled A, B, ... Z. Each book has a code c of 3, 4, 5 or more characters. The 1st character of a code is a capital letter which defines the book category.

In the bookseller's stocklist each code c is followed by a space and by a positive integer n (int n >= 0) which indicates the quantity of books of this code in stock.

For example an extract of a stocklist could be:

L = {"ABART 20", "CDXEF 50", "BKWRK 25", "BTSQZ 89", "DRTYM 60"}.
or
L = ["ABART 20", "CDXEF 50", "BKWRK 25", "BTSQZ 89", "DRTYM 60"] or ....
You will be given a stocklist (e.g. : L) and a list of categories in capital letters e.g :

M = {"A", "B", "C", "W"} 
or
M = ["A", "B", "C", "W"] or ...
and your task is to find all the books of L with codes belonging to each category of M and to sum their quantity according to each category.

For the lists L and M of example you have to return the string (in Haskell/Clojure/Racket a list of pairs):

(A : 20) - (B : 114) - (C : 50) - (W : 0)
where A, B, C, W are the categories, 20 is the sum of the unique book of category A, 114 the sum corresponding to "BKWRK" and "BTSQZ", 50 corresponding to "CDXEF" and 0 to category 'W' since there are no code beginning with W.

If L or M are empty return string is "" (Clojure and Racket should return an empty array/list instead).

Note:
In the result codes and their values are in the same order as in M.
*/

// class G964C {
//     public static stockList = (listOfArt, listOfCat) => {
//         // your code
//     };
// }

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: REVERSE OR ROTATE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: FLAT()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The input is a string str of digits. Cut the string into chunks (a chunk here is a substring of the initial string) of size sz (ignore the last chunk if its size is less than sz).

If a chunk represents an integer such as the sum of the cubes of its digits is divisible by 2, reverse that chunk; otherwise rotate it to the left by one position. Put together these modified chunks and return the result as a string.

If

sz is <= 0 or if str is empty return ""
sz is greater (>) than the length of str it is impossible to take a chunk of size sz hence return "".
Examples:
revrot("123456987654", 6) --> "234561876549"
revrot("123456987653", 6) --> "234561356789"
revrot("66443875", 4) --> "44668753"
revrot("66443875", 8) --> "64438756"
revrot("664438769", 8) --> "67834466"
revrot("123456779", 8) --> "23456771"
revrot("", 8) --> ""
revrot("123456779", 0) --> "" 
revrot("563000655734469485", 4) --> "0365065073456944"
Example of a string rotated to the left by one position:
s = "123456" gives "234561".
*/

// "563000655734469485" LENGTH: 22
// "0365065073456944"   LENGTH: CHUNK(4) * 5 = 20

class G964B {
    public static revrot = (str: string, chunkSize: number): string => {
        if (chunkSize <= 0 || str.length === 0) return "";

        let numArr: number[] = str.split("").map((el) => parseInt(el));
        console.log(numArr);
        // ❓❓❓ WILL NOT ACCEPT type: number , type: any IS OK ❓❓❓
        //  let chunksArr: any = [];
        let chunksArr = [];
        // LOOP ONLY RUNS LENGTH / CHUNKSIZE TIMES
        for (let i = 0; i < str.length; i += chunkSize) {
            // ONLY GET CHUNKS WITH MINIMUM LENGTH OF chunkSize
            if (numArr.length >= chunkSize) {
                chunksArr.push(numArr.slice(0, chunkSize));
            }
            // DELETE FIRST chunkSize ELEMENTS
            numArr.splice(0, chunkSize);
        }

        // [ [ 5, 6, 3, 0 ], [ 0, 0, 6, 5 ], [ 5, 7, 3, 4 ], [ 4, 6, 9, 4 ] ]
        // console.log("before: ", chunksArr);

        // CHECK IF CHUNKS MEETS CONDITION
        chunksArr.forEach((chunk: number[]) => {
            // sum of the cubes of its digits is divisible by 2 ???
            let condition = Number.isInteger(
                chunk.map((num) => Math.pow(num, 3)).reduce((a, b) => a + b) / 2
            );
            if (condition) {
                // REVERSE [ 5, 6, 3, 0 ] => [ 0, 3, 6, 5 ]
                chunk = chunk.reverse();
            } else {
                // ROTATE [ 0, 0, 6, 5 ] => [ 0, 6, 5, 0 ]
                let firstDigit = chunk[0];
                chunk.splice(0, 1);
                chunk.push(firstDigit);
            }
        });

        // [ [ 0, 3, 6, 5 ], [ 0, 6, 5, 0 ], [ 7, 3, 4, 5 ], [ 6, 9, 4, 4 ] ]
        // console.log("after: ", chunksArr);

        // FLATTEN ARRAY AND JOIN INTO STRING
        const solution: string = chunksArr
            // ❗️❗️❗️ HAVE TO USE reduce() ON CODEWARS ❗️❗️❗️
            // .reduce((acc, val) => acc.concat(val), [])
            .flat()
            .join(""); // 0365065073456944

        return solution;
    };
}

/*
❗️❗️❗️ Property 'flat' does not exist on type 'any[]'. (2339) ❗️❗️❗️

You should add es2019 or es2019.array to your --lib setting for TypeScript to recognize array.flat() and flatMap().

Example:

{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "es2019"
    ]
  }
}

To flat single level array:

arr.reduce((acc, val) => acc.concat(val), []);

To flat multi level array

function flatDeep(arr, d = 1) {
   return d > 0 ? arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), []) : arr.slice();
};
*/

// "5630 0065 5734 4694 85" ==>
// "0365 0650 7345 6944"
// console.log(G964B.revrot("563000655734469485", 4));
// console.log(G964B.revrot("565635", 0));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

/*
class G964B3 {
    public static revrot(str: string, sz: number) {
        if (sz <= 0 || str == "" || sz > str.length) return "";
        let chunk = str.slice(0, sz).split('');
        const divisibleBy2 = chunk.reduce((a, b) => { return a + Math.pow(parseInt(b), 3) }, 0) % 2 == 0;
        divisibleBy2 ? chunk = chunk.reverse() : chunk.push(chunk.shift());
        return chunk.join('') + G964.revrot(str.slice(sz, str.length), sz);
    }
}


class G964B4 {
    public static revrot(str, sz) {
        if (sz <= 0 || str === '' || sz > str.length) return '';
        const chunks: string[] = str.match(new RegExp(`.{${sz}}`, 'g'));
        const test = (chunk: string) => chunk.split('').reduce((a: number, b: string) => a + Number(b)**3, 0) % 2 === 0 ? true : false;
        const reverse = (chunk: string) => chunk.split('').reverse().join('');
        const rotate = (chunk: string) => chunk.slice(1) + chunk[0];
        return chunks.map((chunk: string) => test(chunk) ? reverse(chunk) : rotate(chunk)).join('');
    }
}



class G964B5 {
    public static revrot(str, sz) {
        if(this.isInvalidInput(str, sz)) { return '' }

        const chunks: string[] = this.getChunks(str, sz);
        const newChunks = chunks.map(chunk => this.formatChunk(chunk, sz));
        
        return newChunks.join('');
        
    }
    
    private static isInvalidInput(str, sz) {
      return !str || !sz || str.length < sz;
    }
    
    private static getChunks(str: string, sz: number): string[] {
      return str.match(new RegExp('.{1,' + sz + '}', 'g'));
    }
    
    private static formatChunk(chunk: string, sz: number): string {
      if(chunk.length < sz) { 
        chunk = '';
        return '';
      }
      const splitChunk = chunk.split('');
      const shouldReverse = this.shouldReverseChunk(splitChunk);
      return shouldReverse ? this.reverseChunk(splitChunk) : this.rotateChunk(splitChunk);
    }
    
    private static shouldReverseChunk(splitChunk: string[]): boolean {
      const total = splitChunk.reduce((accumulator, currentValue) => accumulator + (+currentValue * +currentValue), 0);
      return +total % 2 === 0;
    }
    
    private static reverseChunk(splitChunk: string[]): string {
      return splitChunk.reverse().join('');
    }
    
    private static rotateChunk(splitChunk: string[]): string {
      const firstItem = splitChunk.shift();
      splitChunk.push(firstItem);
      return splitChunk.join('');
    }
}



class G964B6 {
    public static revrot(str, sz) {
        if (str === "" || sz === 0 || str.length < sz) {
            return "";
        }

        const processSlice = (s: string): string => {
            let chunks = [...s];
            const div2 = chunks.map((d) => Math.pow(parseInt(d), 3)).reduce((a, b) => a + b, 0) % 2 === 0;
            if (div2) {
                chunks.reverse();
            } else {
                chunks = [...chunks.slice(1), chunks[0]];
            }
            return chunks.join("");
          };

        return processSlice(str.slice(0, sz)) + G964B6.revrot(str.slice(sz), sz);
    }
}

*/

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  RECTANGLE INTO SQUARES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The drawing below gives an idea of how to cut a given "true" rectangle into squares ("true" rectangle meaning that the two dimensions are different).

alternative text

Can you translate this drawing into an algorithm?

You will be given two dimensions

a positive integer length
a positive integer width
You will return a collection or a string (depending on the language; Shell bash, PowerShell, Pascal and Fortran return a string) with the size of each of the squares.

Examples in general form:
(depending on the language)

  sqInRect(5, 3) should return [3, 2, 1, 1]
  sqInRect(3, 5) should return [3, 2, 1, 1]
  
  You can see examples for your language in **"SAMPLE TESTS".**
Notes:
lng == wdth as a starting case would be an entirely different problem and the drawing is planned to be interpreted with lng != wdth. (See kata, Square into Squares. Protect trees! http://www.codewars.com/kata/54eb33e5bc1a25440d000891 for this problem).

When the initial parameters are so that lng == wdth, the solution [lng] would be the most obvious but not in the spirit of this kata so, in that case, return None/nil/null/Nothing or return {} with C++, Array() with Scala, [] with Perl, Raku.

In that case the returned structure of C will have its sz component equal to 0.

Return the string "nil" with Bash, PowerShell, Pascal and Fortran.
*/

class G966 {
    public static sqInRect(length: number, width: number): number[] | null {
        if (length === width) return null;

        let solution: number[] = [];
        let descSides = [length, width].sort((a, b) => b - a);
        // console.log("descSides: ", descSides);

        while (descSides[0] > 0 && descSides[1] > 0) {
            //  COUNT HOW MANY SQUARES IT CONTAINS
            let numberOfSq: number = Math.floor(descSides[0] / descSides[1]);
            // console.log("squares found: ", numberOfSq);

            //  PUSH SQUARE INTO SOLUTION numberOfSq TIMES
            for (let i = 1; i <= numberOfSq; i++) {
                solution.push(descSides[1]);
            }
            // console.log("SOLUTION: ", solution);

            //  CALC NEW SMALLER SIDE (LONG / SHORT)
            let newSide: number = descSides[0] % descSides[1];
            // console.log("new side: ", newSide);

            // UPDATE ARRAY, SHORT(ARR[1]) IS NOW EQUAL TO NEWSIZE AND LONG IS PREVIOUS SHORT
            descSides[0] = newSide;
            descSides.sort((a, b) => b - a);
            // console.log("descSides: ", descSides);
        }

        return solution;
    }
}

/*

sides:  [ 5, 3 ]
descSides:  [ 5, 3 ]
squares found:  1
SOLUTION:  [ 3 ]
new side:  2
descSides:  [ 3, 2 ]

sides:  [ 3, 2 ]
descSides:  [ 3, 2 ]
squares found:  1
SOLUTION:  [ 2 ]
new side:  1
descSides:  [ 2, 1 ]

sides:  [ 2, 1 ]
descSides:  [ 2, 1 ]
squares found:  2
SOLUTION:  [ 1, 1 ]
new side:  0
descSides:  [ 1, 0 ]

sides:  [ 1, 0 ]
descSides:  [ 1, 0 ]
squares found:  Infinity

*/

// console.log(G964.sqInRect(5, 5));
// [ 3, 2, 1, 1 ]
// console.log(G966.sqInRect(5, 3));
// [ 14, 6, 6, 2, 2, 2 ]
// console.log(G966.sqInRect(20, 14));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G966a {
    public static sqInRect(l: number, w: number): number[] | null {
        if (l == w) return null;
        var sqs = [],
            tmp;
        while (l) {
            tmp = Math.min(w, l);
            l = Math.max(w, l);
            w = tmp;
            sqs.push(w);
            l -= w;
        }
        return sqs;
    }
}

class G966a1 {
    static sqInRect(l: number, w: number): number[] | null {
        if (l === w) return null;
        if (w > l) [l, w] = [w, l];
        return [w].concat(G966a1.sqInRect(l - w, w) || w);
    }
}

class G966a2 {
    public static sqInRect(l: number, w: number): number[] | null {
        let remainingSize: number = l * w;
        let shorterSide: number;
        const insideSqSides: Array<number> = [];

        if (l == w) {
            return null;
        }

        while (remainingSize > 0) {
            shorterSide = Math.min(l, w);
            remainingSize -= Math.pow(shorterSide, 2);

            l = shorterSide;
            w = remainingSize / l;

            insideSqSides.push(shorterSide);
        }

        return insideSqSides;
    }
}

// class G966a3 {
//     private static sq(l: number, w: number): number[] | null{
//       [l, w] = l > w ? [l, w] : [w, l];
//       return l === w ? [w] : [w, ...G966a3.sq(l - w, w)]
//     }
//     public static sqInRect(l: number, w: number): number[] {
//         // your code
//         return l === w ? null : G966a3.sq(l, w);
//     }
// }

// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  CAMEL CASE METHOD
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: CAPITALIZE FIRST LETTER, REPLACE(), MAP()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write simple .camelCase method (camel_case function in PHP, CamelCase in C# or camelCase in Java) for strings. All words must have their first letter capitalized without spaces.

For instance:

camelCase("hello case"); // => "HelloCase"
camelCase("camel case word"); // => "CamelCaseWord"

*/
const camelCase = (str: string): string => {
    /*
    return str
        ? str
            .trim()
            .split(" ")
            .map((word) => word.replace(word[0], word[0].toUpperCase()))
            .join("")
        : "";  
    */

    return str
        ? str
            .trim()
            .split(" ")
            .map((word) =>
                word
                    //   ❗️❗️❗️ DON'T NEED TO LOWERCASE, PRESERVE ORIGINAL FORMAT ❗️❗️❗️
                    //   .toLowerCase()
                    .replace(word[0], word[0].toUpperCase())
            )
            .join("")
        : "";

    // return "hello";
};

// ""
// console.log(camelCase(""));
// "TestCase"
// console.log(camelCase(" test case"));
// console.log(camelCase("camel case method"));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const camelCase2 = (str: string): string =>
    str
        .split(" ")
        .map((s) => (s ? s[0].toUpperCase() + s.slice(1) : ""))
        .join("");

function camelCase3(str: string): string {
    return str
        .replace(/\b\w/g, (str) => str.toUpperCase())
        .split(" ")
        .join("");
}

function camelCase4(str: string): string {
    return str
        .split(" ")
        .reduce(
            (acc, cur) => acc + cur.charAt(0).toUpperCase() + cur.slice(1),
            ""
        );
}

function camelCase5(str: string): string {
    return str
        .split(" ")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join("");
}

const camelCase6 = (str: string): string =>
    str
        .split(" ")
        .map((s) => s.replace(s.charAt(0), s.charAt(0).toUpperCase()))
        .join("");

function camelCase7(str: string): string {
    return str
        ? str
            .trim()
            .split(" ")
            .map((word) => word[0].toUpperCase() + word.substring(1))
            .join("")
        : "";
}

const camelCase8 = (str: string): string =>
    str
        .split(" ")
        .map((x) => x[0]?.toUpperCase().concat(x.slice(1)))
        .join("");

const camelCase9 = (str: string): string =>
    str
        .split(" ")
        .map((word) =>
            word.length ? word[0].toUpperCase() + word.slice(1) : ""
        )
        .join("");

// function camelCase(str: string): string {
//   return str
//          .split(' ')
//          .map(item =>  item.replace(/^./, item.charAt(0).toUpperCase()))
//          .join('');

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ REFACTOR AND COMMENT ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ROMAN NUMERALS DECODER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Create a function that takes a Roman numeral as its argument and returns its value as a numeric decimal integer. You don't need to validate the form of the Roman numeral.

Modern Roman numerals are written by expressing each decimal digit of the number to be encoded separately, starting with the leftmost digit and skipping any 0s. So 1990 is rendered "MCMXC" (1000 = M, 900 = CM, 90 = XC) and 2008 is rendered "MMVIII" (2000 = MM, 8 = VIII). The Roman numeral for 1666, "MDCLXVI", uses each letter in descending order.

Example:

solution('XXI'); // should return 21
Help:

Symbol    Value
I          1
V          5
X          10
L          50
C          100
D          500
M          1,000
Courtesy of rosettacode.org
*/

// interface Counter {
//     [key: string]: number;
// }

// const counterObj: Counter = {};

const solution0 = (roman: string): number => {
    // VALUES OBJ
    const romanValues = {
        I: 1,
        II: 2,
        III: 3,
        IV: 4,
        V: 5,
        VI: 6,
        VII: 7,
        VIII: 8,
        IX: 9,
        X: 10,
        XX: 20,
        XXX: 30,
        XL: 40,
        L: 50,
        XC: 90,
        C: 100,
        CC: 200,
        CCC: 300,
        CD: 400,
        D: 500,
        CM: 900,
        M: 1000,
        MM: 2000,
        MMM: 3000,
    };

    let result: number = 0;

    // FILTER OUT COMBINATIONS
    if (roman.indexOf("CM") > -1) {
        result += romanValues.CM;
        roman = roman.replace("CM", "");
    }
    if (roman.indexOf("CD") > -1) {
        result += romanValues.CD;
        roman = roman.replace("CD", "");
    }
    if (roman.indexOf("D") > -1) {
        result += romanValues.D;
        roman = roman.replace("D", "");
    }
    if (roman.indexOf("XC") > -1) {
        result += romanValues.XC;
        roman = roman.replace("XC", "");
    }
    if (roman.indexOf("XL") > -1) {
        result += romanValues.XL;
        roman = roman.replace("XL", "");
    }
    if (roman.indexOf("L") > -1) {
        result += romanValues.L;
        roman = roman.replace("L", "");
    }
    if (roman.indexOf("IX") > -1) {
        result += romanValues.IX;
        roman = roman.replace("IX", "");
    }
    if (roman.indexOf("IV") > -1) {
        result += romanValues.IV;
        roman = roman.replace("IV", "");
    }
    if (roman.indexOf("V") > -1) {
        result += romanValues.V;
        roman = roman.replace("V", "");
    }

    // COUNT SINGLES AND MULTIPLY BY VALUE. ERROR WITHOUT "!"
    if (roman.match(/M/g)) result += romanValues.M * roman.match(/M/g)!.length;
    if (roman.match(/C/g)) result += romanValues.C * roman.match(/C/g)!.length;
    if (roman.match(/X/g)) result += romanValues.X * roman.match(/X/g)!.length;
    if (roman.match(/I/g)) result += romanValues.I * roman.match(/I/g)!.length;

    return result;
};

function solution1(roman: string): number {
    var valRoman = {
        1: "I",
        4: "IV",
        5: "V",
        9: "IX",
        10: "X",
        40: "XL",
        50: "L",
        90: "XC",
        100: "C",
        400: "CD",
        500: "D",
        900: "CM",
        1000: "M",
    };

    // console.log(valRoman[40]);

    var romanVal = {
        I: 1,
        IV: 4,
        V: 4,
        IX: 9,
        x: 10,
        XL: 40,
        L: 50,
        XC: 90,
        C: 100,
        CD: 400,
        D: 500,
        CM: 900,
        M: 1000,
    };

    // console.log(romanVal.IV);

    const romanStrVal = {
        I: 1,
        II: 2,
        III: 3,
        IV: 4,
        V: 5,
        VI: 6,
        VII: 7,
        VIII: 8,
        IX: 9,
        X: 10,
        XX: 20,
        XXX: 30,
        XL: 40,
        L: 50,
        XC: 90,
        C: 100,
        CC: 200,
        CCC: 300,
        CD: 400,
        D: 500,
        CM: 900,
        M: 1000,
        MM: 2000,
        MMM: 3000,
    };

    // console.log(romanStrVal.XL);
    // console.log(romanStrVal[XL])  ERROR

    let result: number = 0;
    console.log(roman);

    if (roman.indexOf("CM") > -1) {
        result += romanStrVal.CM;
        roman = roman.replace("CM", "");
    }

    // if (roman.indexOf("MMM") > -1) {
    //     result += romanStrVal.MMM;
    //     roman = roman.replace("MMM", "")
    // }
    // if (roman.indexOf("MM") > -1) {
    //     result += romanStrVal.MM;
    //     roman = roman.replace("MM", "")
    // }
    // if (roman.indexOf("M") > -1) {
    //     result += romanStrVal.M;
    //     roman = roman.replace("M", "")
    // }

    if (roman.indexOf("CD") > -1) {
        result += romanStrVal.CD;
        roman = roman.replace("CD", "");
    }
    if (roman.indexOf("D") > -1) {
        result += romanStrVal.D;
        roman = roman.replace("D", "");
    }

    // if (roman.indexOf("CCC") > -1) {
    //     result += romanStrVal.CCC;
    //     roman = roman.replace("CCC", "");
    // }
    // if (roman.indexOf("CC") > -1) {
    //     result += romanStrVal.CC;
    //     roman = roman.replace("CC", "");
    // }
    // if (roman.indexOf("C") > -1) {
    //     result += romanStrVal.C;
    //     roman = roman.replace("C", "");
    // }

    if (roman.indexOf("XC") > -1) {
        result += romanStrVal.XC;
        roman = roman.replace("XC", "");
    }

    if (roman.indexOf("XL") > -1) {
        result += romanStrVal.XL;
        roman = roman.replace("XL", "");
    }
    if (roman.indexOf("L") > -1) {
        result += romanStrVal.L;
        roman = roman.replace("L", "");
    }

    if (roman.indexOf("IX") > -1) {
        result += romanStrVal.IX;
        roman = roman.replace("IX", "");
    }
    // if (roman.indexOf("XXX") > -1) {
    //     result += romanStrVal.XXX;
    //     roman = roman.replace("XXX", "");
    // }
    // if (roman.indexOf("XX") > -1) {
    //     result += romanStrVal.XX;
    //     roman = roman.replace("XX", "");
    // }
    // if (roman.indexOf("X") > -1) {
    //     result += romanStrVal.X;
    //     roman = roman.replace("X", "");
    // }

    if (roman.indexOf("IV") > -1) {
        result += romanStrVal.IV;
        roman = roman.replace("IV", "");
    }
    if (roman.indexOf("V") > -1) {
        result += romanStrVal.V;
        roman = roman.replace("V", "");
    }
    // if (roman.indexOf("III") > -1) {
    //     result += romanStrVal.III;
    //     roman = roman.replace("III", "");
    // }
    // if (roman.indexOf("II") > -1) {
    //     result += romanStrVal.II;
    //     roman = roman.replace("II", "");
    // }
    // if (roman.indexOf("I") > -1) {
    //     result += romanStrVal.I;
    //     roman = roman.replace("I", "");
    // }

    // roman = roman.replace(/CM|CD|D|XC|XL|L|IX|IV|V/g, "");

    const Ms: number | undefined = roman.match(/M/g)?.length;
    if (Ms) result += romanStrVal.M * Ms;
    // result += romanStrVal.M * Ms;
    // console.log("1000: ", Ms);

    const Cs: number | undefined = roman.match(/C/g)?.length;
    if (Cs) result += romanStrVal.C * Cs;
    // console.log("100: ", Cs);

    const Xs: number | undefined = roman.match(/X/g)?.length;
    if (Xs) result += romanStrVal.X * Xs;
    // console.log("10: ", Xs);

    const Is: number | undefined = roman.match(/I/g)?.length;
    if (Is) result += romanStrVal.I * Is;
    // console.log("1: ", Is);

    // console.log(result);
    console.log("roman: ", roman);

    return result;
}

// console.log(solution1("MDCCCXXIXII"));
// console.log(solution1("MDCLXVI"));
// console.log(solution1('MMCM'));
// console.log(solution('IV');
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const values: Record<string, number> = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000,
};

export function solution5(roman: string): number {
    let value = 0;
    for (let i = 0; i < roman.length; i++) {
        const current = values[roman[i]];
        const next = values[roman[i + 1]] || 0;
        if (current < next) {
            value -= current;
        } else {
            value += current;
        }
    }
    return value;
}

function solution8(roman: string): number {
    const symbols: any = {
        I: 1,
        V: 5,
        X: 10,
        L: 50,
        C: 100,
        D: 500,
        M: 1000,
    };
    return roman
        .split("")
        .map((e) => symbols[e])
        .reduce((p, c) => (p < c ? c - p : c + p));
}

//   function solution9(roman: string): number {
//     const table = {
//       M : 1000,
//       D: 500,
//       C: 100,
//       L: 50,
//       X: 10,
//       V: 5,
//       I: 1
//     }

//     return roman.split('').reduceRight((prev, cur, i, arr) => {
//       return table[arr[i+1]] > table[cur] ? prev - table[cur] : prev + table[cur];
//     }, 0);
//   }

// function solution10(roman: string): number {
//     let splitString : string[] = roman.split("");
//     let num : number = 0;
//     let previous: string;
//     for(var i = 0; i < splitString.length; i++)
//     {
//       if( splitString[i] == "I")
//       {
//         num += 1;
//       }
//       else if( splitString[i] == "V" && previous != "I")
//       {
//         num += 5;
//       }
//       else if( splitString[i] == "V" && previous == "I")
//       {
//         num += 3;
//       }
//       else if( splitString[i] == "X")
//       {
//         num += 10;
//       }
//       else if( splitString[i] == "L" && previous != "X")
//       {
//         num += 50;
//       }
//       else if( splitString[i] == "L" && previous == "X")
//       {
//         num += 30;
//       }
//       else if( splitString[i] == "C" && previous != "X")
//       {
//         num += 100;
//       }
//       else if( splitString[i] == "C" && previous == "X")
//       {
//         num += 80;
//       }
//       else if( splitString[i] == "D" && previous != "C")
//       {
//         num += 500;
//       }
//       else if( splitString[i] == "D" && previous == "C")
//       {
//         num += 300;
//       }
//       else if( splitString[i] == "M" && previous != "C")
//       {
//         num += 1000;
//       }
//       else if( splitString[i] == "M" && previous == "I")
//       {
//         num += 800;
//       }
//       previous = splitString[i];
//     }
//     return num;
//   }

function solution11(roman: string): number {
    const symbols: any = {
        I: 1,
        V: 5,
        X: 10,
        L: 50,
        C: 100,
        D: 500,
        M: 1000,
    };

    return roman
        .split("")
        .map((r: string, i: number, arr: string[]) =>
            r === "I" && ["V", "X"].includes(arr[i + 1]) ? -1 : symbols[r]
        )
        .reduce((a: number, b: number) => a + b);
}

function solution12(roman: string): number {
    // complete the solution by transforming the
    // string roman numeral into an integer
    const map = new Map([
        ["I", 1],
        ["IV", 4],
        ["V", 5],
        ["IX", 9],
        ["X", 10],
        ["XL", 40],
        ["L", 50],
        ["XC", 90],
        ["C", 100],
        ["CD", 400],
        ["D", 500],
        ["CM", 900],
        ["M", 1000],
    ]);
    let result = 0;

    for (let i = 0; i < roman.length; i++) {
        const twoSymbols = map.get(roman[i] + roman[i + 1]);
        const oneSymbol = map.get(roman[i]);
        if (twoSymbols) {
            i += 1;
        }
        result += twoSymbols || oneSymbol || 0;
    }

    return result;
}

//   function solution13(roman: string): number {
//     var dict = {M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1};
//    var result = 0;
//    while (roman.length > 0) {
//      for (var e in dict) {
//        if (roman.substring(0, 2) == e) {
//          result += dict[e];
//          roman = roman.substr(2);
//        } else if (roman.substring(0, 1) == e) {
//          result += dict[e];
//          roman = roman.substr(1);
//        }
//      }
//    }
//    return result;
//  }

function solution13(roman: string): number {
    const values: Record<string, number> = {
        I: 1,
        V: 5,
        X: 10,
        L: 50,
        C: 100,
        D: 500,
        M: 1000,
        CM: 900,
        CD: 400,
        XC: 90,
        XL: 40,
        IX: 9,
        IV: 4,
    };
    return roman
        .replace(/CM|CD|XC|XL|IX|IV|M|D|C|L|X|V|I/g, (r) => `,${values[r]},`)
        .split(/,+/)
        .reduce((sum: number, n: string) => sum + Number(n), 0);
}

function solution14(roman: string): number {
    const initial = 0;
    const numbers: number[] = roman.split("").map((letter) => {
        switch (letter) {
            case "I":
                return 1;
            case "V":
                return 5;
            case "X":
                return 10;
            case "L":
                return 50;
            case "C":
                return 100;
            case "D":
                return 500;
            case "M":
                return 1000;
            default:
                return 0;
        }
    });
    const result = numbers.reduce(function (
        valorAnterior,
        valorActual,
        indice
    ) {
        if (
            indice + 1 === numbers.length ||
            valorActual >= numbers[indice + 1]
        ) {
            return valorAnterior + valorActual;
        } else {
            return valorAnterior - valorActual;
        }
    },
        initial);
    return result;
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ REFACTOR THIS ❗️❗️❗️ AND COMMENT ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ROMAN NUMERALS ENCODER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: REPEAT(), MODULO
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Create a function taking a positive integer as its parameter and returning a string containing the Roman Numeral representation of that integer.

Modern Roman numerals are written by expressing each digit separately starting with the left most digit and skipping any digit with a value of zero. In Roman numerals 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC. 2008 is written as 2000=MM, 8=VIII; or MMVIII. 1666 uses each Roman symbol in descending order: MDCLXVI.

Example:

solution(1000); // should return 'M'
Help:

Symbol    Value
I          1
V          5
X          10
L          50
C          100
D          500
M          1,000
Remember that there can't be more than 3 identical symbols in a row.
*/

const solution2 = (num: number): string => {
    let roman: string = "";

    // console.table({ num: num, roman: roman });

    if (num >= 1000) {
        // GET INT NUMBER OF 1000s
        const v1000: number = (num / 1000) | 0;
        console.log("1000: " + v1000);
        // GET REMAINDER AFTER TAKING AWAY 1000s
        num = num % 1000;
        // REPEAT "M" V1000 TIMES
        roman += "M".repeat(v1000);
        // console.table({ num: num, roman: roman });
    }

    if (num >= 900) {
        num = num % 900;
        roman += "CM";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 500) {
        num = num % 500;
        roman += "D";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 400) {
        num = num % 400;
        roman += "CD";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 100) {
        const v100: number = (num / 100) | 0;
        console.log("100: " + v100);
        num = num % 100;
        roman += "C".repeat(v100);
        // console.table({ num: num, roman: roman });
    }

    if (num >= 90) {
        num = num % 90;
        roman += "XC";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 50) {
        num = num % 50;
        roman += "L";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 40) {
        num = num % 40;
        roman += "XL";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 10) {
        const v10: number = (num / 10) | 0;
        console.log("10: " + v10);
        num = num % 10;
        roman += "X".repeat(v10);
        // console.table({ num: num, roman: roman });
    }

    if (num >= 9) {
        num = num % 9;
        roman += "IX";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 5) {
        num = num % 5;
        roman += "V";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 4) {
        num = num % 4;
        roman += "IV";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 1) {
        const v1: number = (num / 1) | 0;
        // console.log("1: " + v1);
        num = num % 1;
        roman += "I".repeat(v1);
        // console.table({ num: num, roman: roman });
    }

    return num > 3999 ? "invalid input" : roman;
};

/*
3999
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│   num   │  3999  │
│  roman  │   ''   │
└─────────┴────────┘
1000: 3
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│   num   │  999   │
│  roman  │ 'MMM'  │
└─────────┴────────┘
900: 1
┌─────────┬─────────┐
│ (index) │ Values  │
├─────────┼─────────┤
│   num   │   99    │
│  roman  │ 'MMMCM' │
└─────────┴─────────┘
90: 1
┌─────────┬───────────┐
│ (index) │  Values   │
├─────────┼───────────┤
│   num   │     9     │
│  roman  │ 'MMMCMXC' │
└─────────┴───────────┘
9: 1
┌─────────┬─────────────┐
│ (index) │   Values    │
├─────────┼─────────────┤
│   num   │      0      │
│  roman  │ 'MMMCMXCIX' │
└─────────┴─────────────┘
MMMCMXCIX
*/

// console.log(solution2(3999));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ERROR:
// Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ M: number; CM: number; D: number; CD: number; C: number; XC: number; L: number; XL: number; X: number; IX: number; V: number; IV: number; I: number; } '.
//   No index signature with a parameter of type 'string' was found on type '{ M: number; CM: number; D: number; CD: number; C: number; XC: number; L: number; XL: number; X: number; IX: number; V: number; IV: number; I: number; }'.ts(7053)

// function solution3(number: number): string {
//     const ROMAN = {
//         M: 1000,
//         CM: 900,
//         D: 500,
//         CD: 400,
//         C: 100,
//         XC: 90,
//         L: 50,
//         XL: 40,
//         X: 10,
//         IX: 9,
//         V: 5,
//         IV: 4,
//         I: 1,
//     };

//     let result = "";
//     for (let k in ROMAN) {
//         result += k.repeat(Math.floor(number / ROMAN[k]));
//         number = number % ROMAN[k];
//     }

//     return result;
// }

function solution4(number: number): string {
    const nums: Array<number> = [
        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1,
    ];
    const romans: Array<string> = [
        "M",
        "CM",
        "D",
        "CD",
        "C",
        "XC",
        "L",
        "XL",
        "X",
        "IX",
        "V",
        "IV",
        "I",
    ];
    let result: string = "";

    for (let i: number = 0; i < nums.length; i++) {
        while (number >= nums[i]) {
            number -= nums[i];
            result += romans[i];
        }
    }

    return result;
}

// ERROR:
// Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ M: number; CM: number; D: number; CD: number; C: number; XC: number; L: number; XL: number; X: number; IX: number; V: number; IV: number; I: number; } '.
//   No index signature with a parameter of type 'string' was found on type '{ M: number; CM: number; D: number; CD: number; C: number; XC: number; L: number; XL: number; X: number; IX: number; V: number; IV: number; I: number; }'.ts(7053)

// function solution5(number: number): string {
//     let table = {
//         "1": "I",
//         "2": "II",
//         "3": "III",
//         "4": "IV",
//         "5": "V",
//         "6": "VI",
//         "7": "VII",
//         "8": "VIII",
//         "9": "IX",
//         "10": "X",
//         "20": "XX",
//         "30": "XXX",
//         "40": "XL",
//         "50": "L",
//         "60": "LX",
//         "70": "LXX",
//         "80": "LXXX",
//         "90": "XC",
//         "100": "C",
//         "200": "CC",
//         "300": "CCC",
//         "400": "CD",
//         "500": "D",
//         "600": "DC",
//         "700": "DCC",
//         "800": "DCCC",
//         "900": "CM",
//         "1000": "M",
//         "2000": "MM",
//         "3000": "MMM",
//     };
//     let output = "";
//     let str = number.toString();

//     for (let i = str.length - 1, zeros = ""; i >= 0; i--, zeros += "0") {
//         let current = str.charAt(i);
//         if (current !== "0") output = table[current + zeros] + output;
//     }

//     return output;
// }

function solution6(n: number): string {
    let thousands: string[] = ["", "M", "MM", "MMM"];
    let hundreds: string[] = [
        "",
        "C",
        "CC",
        "CCC",
        "CD",
        "D",
        "DC",
        "DCC",
        "DCCC",
        "CM",
    ];
    let tens: string[] = [
        "",
        "X",
        "XX",
        "XXX",
        "XL",
        "L",
        "LX",
        "LXX",
        "LXXX",
        "XC",
    ];
    let ones: string[] = [
        "",
        "I",
        "II",
        "III",
        "IV",
        "V",
        "VI",
        "VII",
        "VIII",
        "IX",
    ];

    let res: string = "";
    res += thousands[Math.floor(n / 1000)];
    res += hundreds[Math.floor(n / 100) % 10];
    res += tens[Math.floor(n / 10) % 10];
    res += ones[n % 10];
    return res;
}

function solution7(number: number): string {
    let returnString = "";
    const table = [
        { key: "M", value: 1000 },
        { key: "CM", value: 900 },
        { key: "D", value: 500 },
        { key: "CD", value: 400 },
        { key: "C", value: 100 },
        { key: "XC", value: 90 },
        { key: "L", value: 50 },
        { key: "XL", value: 40 },
        { key: "X", value: 10 },
        { key: "IX", value: 9 },
        { key: "V", value: 5 },
        { key: "IV", value: 4 },
        { key: "I", value: 1 },
    ];
    while (true) {
        const v = table.filter((v) => v.value <= number)[0];
        if (v == null) {
            break;
        }
        if (v !== null) {
            if (v.value <= number) {
                returnString += v.key;
                number = number - v.value;
            }
        }
    }
    return returnString;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  MEXICAN WAVE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Introduction
The wave (known as the Mexican wave in the English-speaking world outside North America) is an example of metachronal rhythm achieved in a packed stadium when successive groups of spectators briefly stand, yell, and raise their arms. Immediately upon stretching to full height, the spectator returns to the usual seated position.

The result is a wave of standing spectators that travels through the crowd, even though individual spectators never move away from their seats. In many large arenas the crowd is seated in a contiguous circuit all the way around the sport field, and so the wave is able to travel continuously around the arena; in discontiguous seating arrangements, the wave can instead reflect back and forth through the crowd. When the gap in seating is narrow, the wave can sometimes pass through it. Usually only one wave crest will be present at any given time in an arena, although simultaneous, counter-rotating waves have been produced. (Source Wikipedia)
Task
In this simple Kata your task is to create a function that turns a string into a Mexican Wave. You will be passed a string and you must return that string in an array where an uppercase letter is a person standing up. 
Rules
 1.  The input string will always be lower case but maybe empty.

 2.  If the character in the string is whitespace then pass over it as if it was an empty seat
Example
wave("hello") => []string{"Hello", "hEllo", "heLlo", "helLo", "hellO"}
*/

// ❗️❗️❗️ BOTH WORK ❗️❗️❗️
// function wave(str: string): Array<string> {
const wave = (str: string): string[] => {
    const strArr: string[] = str.split("");
    // console.log(strArr);
    let solution: string[] = [];

    strArr.forEach((letter, idx) => {
        let currentWaveArr: string[] = [...strArr];
        // console.table({ letter: letter, index: idx, strAtIdx: noSpaceStr[idx], upperCased: noSpaceStr[idx].toUpperCase() });
        if (letter !== " ") {
            currentWaveArr[idx] = currentWaveArr[idx].toUpperCase();
            // console.log(currentWave);
            solution.push(currentWaveArr.join(""));
        }
    });

    return solution;
};

//  SPLIT str INTO ARRAY
//  INITIALIZE solution AS EMPTY ARR
//  LOOP OVER strArr
//      CURRENT WORD(WAVE) IS A COPY OF strArr
//      IF CURRENT ELEMENT IS NOT A SPACE:
//          CONVERT currentWaveArr[idx] TO UPPERCASE
//          AND PUSH IT AS A STRING INTO solution
//  RETURN SOLUTION

/*
[
    'Two words',
    'tWo words',
    'twO words',
    'two Words',
    'two wOrds',
    'two woRds',
    'two worDs',
    'two wordS'
  ]
  */

// console.log(wave("hello"));
// console.log(wave("two words"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// function wave2(str: string): Array<string> {
//     return str.split("").reduce((wave, char, index) => {
//         if (char === " ") {
//             return wave;
//         }
//         wave.push(
//             str.slice(0, index) + char.toUpperCase() + str.slice(index + 1)
//         );
//         return wave;
//     }, [])
// }

function wave3(str: string): Array<string> {
    const result = [];
    for (let i = 0; i < str.length; i++) {
        if (str.charAt(i) === " ") {
            continue;
        }
        result.push(
            str.substring(0, i) +
            str.charAt(i).toUpperCase() +
            str.substring(i + 1)
        );
    }
    return result;
}

// function wave4(str: string): Array<string> {
//     return [...str].reduce((acc, s, i) => {
//         if (s !== ' ') {
//             acc.push(str.slice(0, i) + s.toUpperCase() + str.slice(i + 1));
//         }
//         return acc;
//     }, []);
// }

function wave5(str: string): Array<string> {
    let arr = [];
    for (let i = 0; i < str.length; i++) {
        let k = str.split("");
        k[i] = k[i].toUpperCase();
        if (str != k.join("")) {
            arr.push(k.join(""));
        }
    }
    return arr;
}

// function wave6(str: string): Array<string> {
//     return str.split('').reduce((result, item, index) => {
//         (item != ' ') && result.push(str.substr(0, index) + item.toUpperCase() + str.substr(index + 1));
//         return result;
//     }, []);
// }

function wave7(str: string): Array<string> {
    let finalArray: string[] = [];
    for (let i = 0; i < str.length; i++) {
        if (str[i] === " ") continue;
        let letters = str.split("");
        letters[i] = str[i].toUpperCase();
        finalArray.push(letters.join(""));
    }
    return finalArray;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  BOUNCING BALLS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A child is playing with a ball on the nth floor of a tall building. The height of this floor, h, is known.

He drops the ball out of the window. The ball bounces (for example), to two-thirds of its height (a bounce of 0.66).

His mother looks out of a window 1.5 meters from the ground.

How many times will the mother see the ball pass in front of her window (including when it's falling and bouncing?

Three conditions must be met for a valid experiment:
Float parameter "h" in meters must be greater than 0
Float parameter "bounce" must be greater than 0 and less than 1
Float parameter "window" must be less than h.
If all three conditions above are fulfilled, return a positive integer, otherwise return -1.

Note:
The ball can only be seen if the height of the rebounding ball is strictly greater than the window parameter.

Examples:
- h = 3, bounce = 0.66, window = 1.5, result is 3

- h = 3, bounce = 1, window = 1.5, result is -1 

(Condition 2) not fulfilled).
*/

const bouncingBall = (
    dropHeight: number,
    bounceRate: number,
    viewHeight: number
): number => {
    if (
        dropHeight <= 0 ||
        bounceRate <= 0 ||
        bounceRate >= 1 ||
        viewHeight <= 0 ||
        viewHeight >= dropHeight
    ) {
        return -1;
    }

    let actualBounce: number = dropHeight * bounceRate;
    let counter: number = 1;

    while (actualBounce > viewHeight) {
        actualBounce = actualBounce * bounceRate;
        counter += 2;
    }

    return counter;
};

//  3
// console.log(bouncingBall(3.0, 0.66, 1.5));
// 15
// console.log(bouncingBall(30.0, 0.66, 1.5));
// 21
// console.log(bouncingBall(30, 0.75, 1.5));
// 3
// console.log(bouncingBall(30, 0.4, 10));
// -1
// console.log(bouncingBall(3, 0.5, 4))

//============= OTHER CODEWARS SOLUTIONS: =============

function bouncingBall2(h: number, bounce: number, window: number): number {
    if (h <= 0 || bounce <= 0 || bounce >= 1 || window >= h) {
        return -1;
    }

    return 2 * Math.ceil(Math.log(window / h) / Math.log(bounce)) - 1;
}

function bouncingBall3(h: number, bounce: number, window: number): number {
    if (h <= 0 || bounce <= 0 || bounce >= 1 || window >= h) {
        return -1;
    }

    return 2 + bouncingBall3(h * bounce, bounce, window);
}

// ❗️❗️❗️ INCLUDE THIS IN CODEWARS EXAMPLES ❗️❗️❗️ (FIND(FUNCTION))
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  WHICH ARE IN
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  FIND(FUNCTION), FILTER()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given two arrays of strings a1 and a2 return a sorted array r in lexicographical order of the strings of a1 which are substrings of strings of a2.

Example 1:
a1 = ["arp", "live", "strong"]

a2 = ["lively", "alive", "harp", "sharp", "armstrong"]

returns ["arp", "live", "strong"]

Example 2:
a1 = ["tarp", "mice", "bull"]

a2 = ["lively", "alive", "harp", "sharp", "armstrong"]

returns []

Notes:
Arrays are written in "general" notation. See "Your Test Cases" for examples in your language.
In Shell bash a1 and a2 are strings. The return is a string where words are separated by commas.
Beware: r must be without duplicates.
*/

class G964a {
    public static inArray(a1: string[], a2: string[]): string[] {
        let solution: string[] = [];

        a1.forEach((subStr) => {
            const findSubStr = (word: string): boolean =>
                word.indexOf(subStr) >= 0;
            // ❗️❗️❗️ UNDEFINED NOT NEEDED IN CODEWARS ❗️❗️❗️
            let firstMatch: string | undefined = a2.find(findSubStr);
            if (firstMatch) solution.push(subStr);
        });

        return solution.sort();

        /*
                let solution: string[] = [];
        
                a1.forEach((sub) => {
        
                    const findSubStr = (word: string): boolean => {
                        return word.indexOf(sub) >= 0;
                    }
        
                    let firstMatch: string | undefined = a2.find(findSubStr);
        
                    if (firstMatch !== undefined) {
                        solution.push(sub);
                    }
        
                })
        
                return solution.sort();
        */
    }
}

//  INITIALIZE solution AS EMPTY ARRAY
//  LOOP THROUGH a1
//      findSubStr RETURNS true IF WORD HAS subStr IN IT
//      FIND firstMatch IN a2 (find() RETURNS FIRST ELEMENT THAT PASSES TEST IN findSubStr)
//      IF THERE'S A MATCH, PUSH subStr INTO solution
//  RETURN solution SORTED ALPHABETICALLY

// var a2 = ["lively", "alive", "harp", "sharp", "armstrong"];
// var a1 = ["arp", "live", "strong"];
// a1 = ["xyz", "live", "strong"];
// a1 = ["live", "strong", "arp"];
// a1 = ["hello", "goodbye"];

// console.log(G964a.inArray(a1, a2));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ FILTER() ❗️❗️❗️
class G964a2 {
    public static inArray(a1: string[], a2: string[]): string[] {
        return a1.filter((a) => a2.some((b) => b.includes(a))).sort();
    }
}

class G964a3 {
    public static inArray(a1: string[], a2: string[]): string[] {
        return a1.filter((x) => a2.join().indexOf(x) > -1).sort();
    }
}

class G964a4 {
    public static inArray(a1: string[], a2: string[]): string[] {
        const source = a2.join("#");
        return a1.filter((item) => source.indexOf(item) !== -1).sort();
    }
}

class G964a5 {
    public static inArray(a1: string[], a2: string[]): string[] {
        return a1.sort().filter((s) => a2.find((s2) => s2.includes(s)));
    }
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ARE THEY THE SAME?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  ❗️❗️❗️ SPREAD(NULL) ❗️❗️❗️ ERROR: Type 'number[] | null' must have a '[Symbol.iterator]()' method that returns an iterator.ts(2488)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given two arrays a and b write a function comp(a, b) (orcompSame(a, b)) that checks whether the two arrays have the "same" elements, with the same multiplicities (the multiplicity of a member is the number of times it appears). "Same" means, here, that the elements in b are the elements in a squared, regardless of the order.

Examples
Valid arrays
a = [121, 144, 19, 161, 19, 144, 19, 11]  
b = [121, 14641, 20736, 361, 25921, 361, 20736, 361]
comp(a, b) returns true because in b 121 is the square of 11, 14641 is the square of 121, 20736 the square of 144, 361 the square of 19, 25921 the square of 161, and so on. It gets obvious if we write b's elements in terms of squares:

a = [121, 144, 19, 161, 19, 144, 19, 11] 
b = [11*11, 121*121, 144*144, 19*19, 161*161, 19*19, 144*144, 19*19]
Invalid arrays
If, for example, we change the first number to something else, comp is not returning true anymore:

a = [121, 144, 19, 161, 19, 144, 19, 11]  
b = [132, 14641, 20736, 361, 25921, 361, 20736, 361]
comp(a,b) returns false because in b 132 is not the square of any number of a.

a = [121, 144, 19, 161, 19, 144, 19, 11]  
b = [121, 14641, 20736, 36100, 25921, 361, 20736, 361]
comp(a,b) returns false because in b 36100 is not the square of any number of a.

Remarks
a or b might be [] or {} (all languages except R, Shell).
a or b might be nil or null or None or nothing (except in C++, COBOL, Crystal, D, Dart, Elixir, Fortran, F#, Haskell, Nim, OCaml, Pascal, Perl, PowerShell, Prolog, PureScript, R, Racket, Rust, Shell, Swift).
If a or b are nil (or null or None, depending on the language), the problem doesn't make sense so return false.

Note for C
The two arrays have the same size (> 0) given as parameter in fun
*/

// 1️⃣
const comp = (a1: number[] | null, a2: number[] | null): boolean => {
    // ❗️❗️❗️ CHECK FOR NULL FIRST ❗️❗️❗️
    return a1 === null || a2 === null
        ? false
        : String([...a1].sort((a, b) => a - b).map((el) => Math.pow(el, 2))) ===
        String([...a2].sort((a, b) => a - b));
};

// 2️⃣
const comp2 = (a1: number[] | null, a2: number[] | null): boolean => {
    // ❗️❗️❗️ CHECK FOR NULL FIRST ❗️❗️❗️
    if (a1 === null || a2 === null) return false;

    const ascending1: number[] = [...a1].sort((a, b) => a - b);
    const ascending1Squared: number[] = ascending1.map((el) => Math.pow(el, 2));
    const ascending2: number[] = [...a2].sort((a, b) => a - b);

    return String(ascending1Squared) === String(ascending2);
};

//  RETURN FALSE IF EMPTY ARRAY
//  OTHERWISE, SORT BOTH ARRAYS NUMERICALLY ASCENDING, SQUARE ELEMENTS IN a1
//  CONVERT BOTH TO STRING AND COMPARE

/* ❗️❗️❗️ SPREAD NULL:
I think you cannot spread null, you should check on whether your argument is null either:

before it gets into this function, and then you can change the type to string

do it in the function, before you spread the argument
❗️❗️❗️ 
*/

// TRUE
// var a1: number[] = [121, 144, 19, 161, 19, 144, 19, 11];
// var a2: number[] = [11 * 11, 121 * 121, 144 * 144, 19 * 19, 161 * 161, 19 * 19, 144 * 144, 19 * 19];

// FALSE
var b1 = [121, 144, 19, 161, 19, 144, 19, 11];
var b2 = [
    11 * 21,
    121 * 121,
    144 * 144,
    19 * 19,
    161 * 161,
    19 * 19,
    144 * 144,
    19 * 19,
];

// console.log(comp(a1, a2));
// console.log(comp(b1, b2));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function comp3(a1: number[] | null, a2: number[] | null): boolean {
    if (!(a1 && a2) || a1.length !== a2.length) return false;
    return (
        a1
            .map((x) => x * x)
            .sort()
            .toString() === a2.sort().toString()
    );
}

function comp4(a1: number[] | null, a2: number[] | null): boolean {
    return (
        !!a1 &&
        !!a2 &&
        a1
            .map((x) => x * x)
            .sort()
            .join() == a2.sort().join()
    );
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  CONSECUTIVE STRINGS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  NESTED FOR(), ❗️❗️❗️ SORT(), REDUCE() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You are given an array(list) strarr of strings and an integer k. Your task is to return the first longest string consisting of k consecutive strings taken in the array.

Examples:
strarr = ["tree", "foling", "trashy", "blue", "abcdef", "uvwxyz"], k = 2

Concatenate the consecutive strings of strarr by 2, we get:

treefoling   (length 10)  concatenation of strarr[0] and strarr[1]
folingtrashy ("      12)  concatenation of strarr[1] and strarr[2]
trashyblue   ("      10)  concatenation of strarr[2] and strarr[3]
blueabcdef   ("      10)  concatenation of strarr[3] and strarr[4]
abcdefuvwxyz ("      12)  concatenation of strarr[4] and strarr[5]

Two strings are the longest: "folingtrashy" and "abcdefuvwxyz".
The first that came is "folingtrashy" so 
longest_consec(strarr, 2) should return "folingtrashy".

In the same way:
longest_consec(["zone", "abigail", "theta", "form", "libe", "zas", "theta", "abigail"], 2) --> "abigailtheta"
*/

const longestConsec = (strArr: string[], numWords: number): string => {
    if (strArr.length === 0 || numWords < 1 || numWords > strArr.length) {
        return "";
    }

    let concatArr: string[] = [];

    for (let i = 0; i < strArr.length - numWords + 1; i++) {
        let concatWord: string = "";

        for (let j = 0; j < numWords; j++) {
            let nextWord = strArr[i + j];
            concatWord += nextWord;
        }

        concatArr.push(concatWord);
    }

    // ❗️❗️❗️  concatArrCopy.sort WILL MUTATE ORIGINAL ARRAY SO HAVE TO COPY IT ❗️❗️❗️
    const concatArrCopy = [...concatArr];
    const sortedArr = concatArrCopy.sort((a, b) => b.length - a.length);
    const longest = sortedArr[0].length;
    let solution = "";

    for (let i = 0; i < concatArr.length; i++) {
        if (concatArr[i].length === longest) {
            solution = concatArr[i];
            break;
        }
    }

    return solution;
};

/*
  RETURN EMPTY STRING IF n = 0 or k > n or k <= 0
  PUSH ALL CONCATENATED STRINGS INTO concatArr (OUTER LOOP WILL STOP AT LAST IDX - numWords)
  MAKE A COPY OF concatArr
  SORT concatArrCopy BY LENGTH OF ELEMENTS (DESCENDING, LONGEST TO SHORTEST)
  GET LENGTH OF LONGEST (FIRST) ELEMENT - longest
  LOOP THROUGH ORIGINAL concatArr AND FIND FIRST STRING THAT HAS THE LENGTH OF longest
  RETURN IT AS SOLUTION
*/

/*
❗️❗️❗️
You need to copy the array before you sort it. One way with es6:

const sorted = [...arr].sort();
The spread-syntax as array literal (copied from mdn):

var arr = [1, 2, 3];
var arr2 = [...arr]; // like arr.slice()
❗️❗️❗️
*/

// "abigailtheta"
// console.log(longestConsec(["zone", "abigail", "theta", "form", "libe", "zas"], 2));
// "ixoyx3452zzzzzzzzzzzz"
// console.log(longestConsec(["it", "wkppv", "ixoyx", "3452", "zzzzzzzzzzzz"], 3));
// "oocccffuucccjjjkkkjyyyeehh"
// console.log(longestConsec(["ejjjjmmtthh", "zxxuueeg", "aanlljrrrxx", "dqqqaaabbb", "oocccffuucccjjjkkkjyyyeehh"], 1));
// console.log(longestConsec(["ac", "c", "aaa", "aaa", "hg", "abc", "def", "sd", "abc", "abc"], 2));
// console.log(longestConsec([], 2));

//============= OTHER CODEWARS SOLUTIONS: =============

function longestConsec2(strarr: string[], k: number): string {
    if (strarr.length === 0 || k > strarr.length || k <= 0) return "";
    // ❗️❗️❗️ REDUCE() ❗️❗️❗️
    return strarr
        .map((currentValue, index, array) =>
            array.slice(index, index + k).join("")
        )
        .reduce((acc, cur) => (cur.length > acc.length ? cur : acc));
}

function longestConsec3(strarr: string[], k: number): string {
    if (!(strarr && strarr.length) || k <= 0 || strarr.length < k) {
        return "";
    }
    // ❗️❗️❗️ REDUCE() ❗️❗️❗️
    return strarr.reduce((acc, cur, i, arr) => {
        let concatinated = arr.slice(i, i + k).join("");
        return acc.length < concatinated.length ? concatinated : acc;
    }, "");
}

function longestConsec4(strarr: string[], k: number): string {
    let max = "";
    const n = strarr.length;

    for (let i = 0; i <= n - k && k > 0 && k <= n; i++) {
        const newStr = strarr.slice(i, i + k).join("");
        max = max.length >= newStr.length ? max : newStr;
    }
    return max;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  BUILD PILE OF CUBES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: WHILE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to construct a building which will be a pile of n cubes. The cube at the bottom will have a volume of n^3, the cube above will have volume of (n-1)^3 and so on until the top which will have a volume of 1^3.

You are given the total volume m of the building. Being given m can you find the number n of cubes you will have to build?

The parameter of the function findNb (find_nb, find-nb, findNb, ...) will be an integer m and you have to return the integer n such as n^3 + (n-1)^3 + ... + 1^3 = m if such a n exists or -1 if there is no such n.

Examples:
findNb(1071225) --> 45

findNb(91716553919377) --> -1
*/

const findNb = (num: number): number => {
    let total: number = num;
    let base: number = 1;

    while (total > 0) {
        total -= Math.pow(base, 3);
        base++;
    }

    return total < 0 ? -1 : base - 1;
};

//  SET total TO BE INPUT NUMBER num
//  START OFF base(ACTS AS A COUNTER) AT 1
//  WHILE total IS GREATER THAN 0
//      DECREMENT BY base(COUNTER) CUBED
//      INCREMENT base BY 1
// CHECK IF TOTAL HAS GONE BELOW 0
//      IF SO, RETURN -1
//      OTHERWISE RETURN base - 1

// console.log(findNb(100));
// 2022
// console.log(findNb(4183059834009));
// -1
// console.log(findNb(24723578342962))

//============= OTHER CODEWARS SOLUTIONS: =============

function findNb2(m: number): number {
    var n = 0;
    while (m > 0) m -= Math.pow(++n, 3);
    return m ? -1 : n;
}

function findNb3(m: number): number {
    let sum = 0;
    let i = 1;

    for (; sum < m; i++) {
        sum += Math.pow(i, 3);
    }

    return sum === m ? i - 1 : -1;
}

function findNb4(m: number): number {
    let n = 1;
    while (m > 0) {
        m = m - n ** 3;
        if (m === 0) return n;
        n++;
    }
    return -1;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PLAYING WITH DIGITS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Some numbers have funny properties. For example:

89 --> 8¹ + 9² = 89 * 1

695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2

46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51

Given a positive integer n written as abcd... (a, b, c, d... being digits) and a positive integer p

we want to find a positive integer k, if it exists, such as the sum of the digits of n taken to the successive powers of p is equal to k * n.
In other words:

Is there an integer k such as : (a ^ p + b ^ (p+1) + c ^(p+2) + d ^ (p+3) + ...) = n * k

If it is the case we will return k, if not return -1.

Note: n and p will always be given as strictly positive integers.

dig_pow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1
dig_pow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k
dig_pow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2
dig_pow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
*/

class G964 {
    public static digPow = (num: number, pow: number): number => {
        const digitArr = String(num).split("").map(Number);

        let sum = 0;

        // for (let i = 0; i < digitArr.length; i++) {
        //     sum += Math.pow(digitArr[i], i + pow);
        // }

        digitArr.forEach((digit, idx) => {
            sum += Math.pow(digit, idx + pow);
        });

        console.log("sum: " + sum);

        return sum % num === 0 ? sum / num : -1;
    };
}

//  CONVERT num TO ARRAY OF NUMBER DIGITS
//  INITIALIZE sum WITH VALUE OF 0
//  LOOP THROUGH digitArr
//      RAISE EACH DIGIT TO ITS SUCCESSIVE POWERS OF pow (INCREMENT POW BY idx)
//  CHECK IF sum CAN BE DIVIDED BY num
//      IF SO, RETURN INTEGER sum / num AS SOLUTION
//      OTHERWISE RETURN -1

// console.log(G964.digPow(89, 1));
// console.log(G964.digPow(695, 2));
// console.log(G964.digPow(46288, 3));
// console.log(G964.digPow(92, 1));

//============= OTHER CODEWARS SOLUTIONS: =============

/*

class G964 {

    public static digPow = (n, p) => {
        var x = n.toString().split("").reduce((s, d, i) => s + Math.pow(d, p + i), 0)
        return x % n ? -1 : x / n;
    }

}



class G964 {

    public static digPow = (n, p) => {
        var x = n.toString().split("").reduce((s, d, i) => s + Math.pow(d, p + i), 0)
        return x % n ? -1 : x / n;
    }
}



class G964 {

    public static digPow = (n: number, p: number) => {
        const sum = ('' + n).split('').reduce((sum, digit, i) => sum += Math.pow(+digit, p + i), 0);
        const k = sum / n;
        return Number.isInteger(k) ? k : -1;
    }
}

*/

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  VALID BRACES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: REGEXP, WHILE(), REPLACE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function that takes a string of braces, and determines if the order of the braces is valid. It should return true if the string is valid, and false if it's invalid.

This Kata is similar to the Valid Parentheses Kata, but introduces new characters: brackets [], and curly braces {}. Thanks to @arnedag for the idea!

All input strings will be nonempty, and will only consist of parentheses, brackets and curly braces: ()[]{}.

What is considered Valid?
A string of braces is considered valid if all braces are matched with the correct brace.

Examples
"(){}[]"   =>  True
"([{}])"   =>  True
"(}"       =>  False
"[(])"     =>  False
"[({})](]" =>  False
*/

// /\(\)|\[\]|\{\}/g

const validBraces = (braces: string): boolean => {
    if (braces.length % 2 > 0) return false;

    const bracePair = /\(\)|\[\]|\{\}/;

    let str: string = braces;

    while (bracePair.test(str)) {
        str = str.replace(bracePair, "");
    }

    console.log("str: " + str);

    return str.length === 0;
};

//  RETURN FALSE IF UNVALID INPUT LENGTH
//  SAVE MATCHING PAIRS TO VAR bracePair
//  COPY braces TO str
//  WHILE MATCH IS FOUND (ANY OF THE THREE)
//      REMOVE PAIR FROM str
//  IF str CAN BE REDUCED TO EMPTY STRING, RETURN true, OTHERWISE false

// console.log(validBraces("()[]{}"));
// console.log(validBraces("({[{}]})"));
// console.log(validBraces("[(])"));
// console.log(validBraces("[(])"));

//============= OTHER CODEWARS SOLUTIONS: =============

function validBraces2(braces: string): boolean {
    if (braces.length % 2 !== 0) return false;
    let count = braces.length;
    braces = braces.replace("()", "");
    braces = braces.replace("[]", "");
    braces = braces.replace("{}", "");
    if (braces.length === 0) return true;
    if (braces.length === count) return false;
    return validBraces(braces);
}

function validBraces3(braces: string): boolean {
    let tempBraces = braces;
    for (let i = 0; i <= braces.length / 2; i++) {
        tempBraces = tempBraces.replace(/(\(\))|(\[\])|(\{\})/g, "");
    }
    return !tempBraces;
}

function validBrace4(braces: string): boolean {
    [...braces].forEach(
        () =>
        (braces = braces
            .replace("()", "")
            .replace("{}", "")
            .replace("[]", ""))
    );
    return !braces;
}

const validBraces5 = (braces: string): boolean => {
    const s = braces.replace(/\(\)|\[\]|\{\}/g, "");
    if (s.length === 0) return true;
    else if (s === braces) return false;
    else return validBraces(s);
};

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: OBJECT.ENTRIES()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a string of words, you need to find the highest scoring word.
 
Each letter of a word scores points according to its position in the alphabet: a = 1, b = 2, c = 3 etc.
 
You need to return the highest scoring word as a string.
 
If two words score the same, return the word that appears earliest in the original string.
 
All letters will be lowercase and all inputs will be valid.
*/

const high = (str: string): string => {
    const alphabet = [
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
    ];
    //  CALCULATE SCORE FOR WORD
    const getScore = (str: string): number => {
        let score: number = 0;
        str.split("").forEach((char) => {
            score += alphabet.indexOf(char) + 1;
        });
        return score;
    };

    interface Counter {
        [key: string]: number;
    }

    const counterObj: Counter = {};
    //  CREATE COUNTER OBJ { word: score, word: score ... }
    str.split(" ").forEach((word) => {
        counterObj[word] = getScore(word);
    });
    //  SORT OBJECT ENTRIES BY THEIR SECOND ELEMENT (INDEX 1 / VALUE)
    //  RETURN INDEX 0 OF ELEMENT AT INDEX 0
    //  [[ 'volcano', 82 ], [ 'climbing', 69 ], [ 'what', 52 ]... ]
    console.log(Object.entries(counterObj).sort((a, b) => b[1] - a[1])[0][0]);
    return Object.entries(counterObj).sort((a, b) => b[1] - a[1])[0][0];
};

// high('what time are we climbing up the volcano');

//============= OTHER CODEWARS SOLUTIONS: =============

const VALUE_OFFSET = 96;
const calcValue = (word: string): number => {
    return word
        .split("")
        .reduce((sum, char) => sum + char.charCodeAt(0) - VALUE_OFFSET, 0);
};
const high2 = (str: string): string => {
    return str
        .split(" ")
        .reduce((max, word) => (calcValue(word) > calcValue(max) ? word : max));
};

const alphabet = "abcdefghijklmnopqrstuvwxyz";
const getLetterScore = (str: string): number => alphabet.indexOf(str) + 1;
const getWordScore = (str: string): number =>
    str
        .split("")
        .map(getLetterScore)
        .reduce((acc, n) => acc + n, 0);

const high3 = (str: string): string =>
    str
        .split(" ")
        .reduce((acc, value) =>
            getWordScore(value) > getWordScore(acc) ? value : acc
        );

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  BUILD TOWER - MULTIPLE VARIABLES IN FOR LOOP
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Build Tower
Build Tower by the following given argument:
number of floors (integer and always greater than 0).
 
Tower block is represented as *
 
towerBuilder(3)
 
[
  '  *  ', 
  ' *** ', 
  '*****'
]
*/

const towerBuilder = (nFloors: number): string[] => {
    const absoluteWidth = nFloors + (nFloors - 1);
    const building: string[] = [];

    for (let floors = 1, blocks = 1; floors <= nFloors; floors++, blocks += 2) {
        let floorStr: string = "";
        // console.table({floors: floors, blocks: blocks});
        let leadTrailSpaces = (absoluteWidth - blocks) / 2;

        floorStr =
            " ".repeat(leadTrailSpaces) +
            "*".repeat(blocks) +
            " ".repeat(leadTrailSpaces);

        // console.log(floorStr);

        building.push(floorStr);
    }

    console.log(building);

    return building;
};

/*
 
 CALCULATE ABSOLUTE WIDTH OF PYRAMID (WIDTH OF BASE)
 INITAILIZE ARRAY FOR BUILDING (SOLUTION)
 
 LOOP OVER FLOORS WHILE KEEPING TRACK OF NUMBER OF BLOCKS IN EACH ITERATION
    EMPTY STRING FOR EACH FLOOR STRING
    CALCULATE LEADING/TRAILING SPACES
    
    BUILD COMPLETE FLOOR: LEADING SPACES + BLOCKS + TRAILING SPACES
    
    PUSH NEW FLOOR INTO BUILDING ARRAY
    
  RETURN BUILDING
 
  [
  '           *           ',
  '          ***          ',
  '         *****         ',
  '        *******        ',
  '       *********       ',
  '      ***********      ',
  '     *************     ',
  '    ***************    ',
  '   *****************   ',
  '  *******************  ',
  ' ********************* ',
  '***********************'
]
  
*/

// towerBuilder(1);
// towerBuilder(12);

//============= OTHER CODEWARS SOLUTIONS: =============

const towerBuilder2 = (nFloors: number): string[] => {
    return Array.from(
        { length: nFloors },
        (_, i) =>
            `${" ".repeat(nFloors - i - 1)}${"*".repeat(2 * i + 1)}${" ".repeat(
                nFloors - i - 1
            )}`
    );
};

const towerBuilder3 = (nFloors: number): string[] => {
    return Array.from({ length: nFloors }, (_, index) => {
        const spaces = " ".repeat(nFloors - 1 - index);
        return `${spaces}${"*".repeat(index * 2 + 1)}${spaces}`;
    });
};

const towerBuilder4 = (n: number): string[] => {
    const result: string[] = [];
    for (let i = 1; i <= n; i++) {
        result.push(
            " ".repeat(n - i) + "*".repeat(i * 2 - 1) + " ".repeat(n - i)
        );
    }
    return result;
};

const towerBuilder5 = (n: number): string[] => {
    return new Array(n).fill("").map((_, i) => {
        let spaces = " ".repeat(n - i - 1);
        return spaces + "*".repeat(2 * i + 1) + spaces;
    });
};

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIND MISSING LETTER IN ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a method that takes an array of consecutive (increasing) letters as input and that returns the missing letter in the array.
 
You will always get an valid array. And it will be always exactly one letter be missing. The length of the array will always be at least 2.
The array will always contain letters in only one case.
 
Example:
 
['a','b','c','d','f'] -> 'e' ['O','Q','R','S'] -> 'P'
 
["a","b","c","d","f"] -> "e"
["O","Q","R","S"] -> "P"
(Use the English alphabet with 26 letters!)
*/

const findMissingLetter = (arr: string[]): string => {
    let solution: string = "";
    const alphabet = [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
    ];
    const startIdx = alphabet.indexOf(arr[0]);

    for (let i = 1; i < arr.length; i++) {
        if (alphabet[startIdx + i] !== arr[i]) {
            solution = alphabet[startIdx + i];
            break;
        }
    }

    return solution;
};

//  startIdx: THIS IS WHERE LOOP STARTS COMPARING TWO PARALLEL ARRAYS
//  IF CURRENT ALPHABET ELEMENT !== CURRENT INPUT ARRAY ELEMENT
//      SAVE CURRENT ALPHABET ELEMENT AS SOLUTION AND BREAK LOOP
//  RETURN SOLUTION

findMissingLetter(["a", "b", "c", "d", "f"]);
findMissingLetter(["O", "Q", "R", "S"]);

//============= OTHER CODEWARS SOLUTIONS: =============

// !!! Function lacks ending return statement and return type does not include 'undefined'.ts(2366) !!!
// function findMissingLetter2(array:string[]):string
// {
//     for(let i = 0; i < array.length; i++) {
//         if(array[i].charCodeAt(0) + 1 != array[i+1].charCodeAt(0))
//             return String.fromCharCode(array[i].charCodeAt(0) + 1);
//     }
// }

function findMissingLetter3(array: string[]): string {
    const isUpper = array[0] == array[0].toUpperCase();

    let expectedLetter = "";
    for (const letter of array) {
        if (expectedLetter != "" && letter != expectedLetter)
            return expectedLetter;

        expectedLetter = String.fromCharCode(letter.charCodeAt(0) + 1);
    }

    throw "Nothing missing";
}

function findMissingLetter4(letters: string[]): string {
    const first = letters.shift()!.charCodeAt(0) + 1;
    const offset = letters.findIndex((l, i) => l.charCodeAt(0) !== i + first);
    return String.fromCharCode(first + offset);
}

function findMissingLetter5(array: string[]) {
    const alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    return alphabet
        .substr(alphabet.indexOf(array[0]))
        .split("")
        .find((curr, idx) => curr != array[idx]);
}

// !!! Type 'undefined' is not assignable to type 'string'.ts(2322) !!!
// function findMissingLetter6(array:string[]):string
// {
//    let ret;
//     array.map(item => item.charCodeAt(0))
//         .reduce((prev, cur, curIndex) =>
//         {
//             if (cur - prev > 1) {
//                 ret = String.fromCharCode(cur-1)
//             }
//             return cur
//         })

//     return ret
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  UNUQUE NUMBER IN ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
There is an array with some numbers. All numbers are equal except for one. Try to find it!
 
findUniq([ 1, 1, 1, 2, 1, 1 ]) === 2
findUniq([ 0, 0, 0.55, 0, 0 ]) === 0.55
It’s guaranteed that array contains at least 3 numbers.
 
The tests contain some very huge arrays, so think about performance.
*/

// 1️⃣  LOOP THROUGH ALL ELEMENTS:

// const findUniq = (arr: number[]): number => {

//     let solution: number = 0;

//     for (let i = 0; i < arr.length; i++) {

//         if (i < arr.length - 2) {
//             if (arr[i] !== arr[i + 1] && arr[i] !== arr[i + 2]) {
//                 console.log("odd one found: " + arr[i]);
//                 solution = arr[i];
//                 break;
//             }
//         } else if (i === arr.length - 2) {
//             if (arr[i] !== arr[i + 1] && arr[i] !== arr[i - 1]) {
//                 console.log("odd one found: " + arr[i]);
//                 solution = arr[i];
//                 break;
//             }
//         } else if (i === arr.length - 1) {
//             if (arr[i] !== arr[i - 1] && arr[i] !== arr[i - 2]) {
//                 console.log("odd one found: " + arr[i]);
//                 solution = arr[i];
//             }
//         }

//     }

//     console.log("solution: " + solution);
//     return solution;

// }

// 2️⃣  CHECK FIRST AND LAST ELEMENT FIRST
// THEN LOOP THROUGH MIDDLE ELEMENTS
const findUniq = (arr: number[]): number => {
    const arrLength: number = arr.length;

    let solution: number = 0;

    if (arr[0] !== arr[1] && arr[0] !== arr[2]) {
        solution = arr[0];
    }

    if (
        arr[arrLength - 1] !== arr[arrLength - 2] &&
        arr[arrLength - 1] !== arr[arrLength - 3]
    ) {
        solution = arr[arrLength - 1];
    }

    for (let i = 1; i < arrLength - 1; i++) {
        if (arr[i] !== arr[i + 1] && arr[i] !== arr[i - 1]) {
            solution = arr[i];
            break;
        }
    }

    return solution;
};

// findUniq([2, 1, 1, 1, 1, 1]);
// findUniq([1, 2, 1, 1, 1, 1]);
// findUniq([1, 1, 2, 1, 1, 1]);
// findUniq([1, 1, 1, 2, 1, 1]);
// findUniq([1, 1, 1, 1, 2, 1]);
// findUniq([1, 1, 1, 1, 1, 2]);

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️
function findUniq3(arr: Array<number>): number {
    arr = arr.sort();
    return arr[0] == arr[1] ? arr[arr.length - 1] : arr[0];
}
// ❗️❗️❗️

// "!"
function findUniq4(arr: Array<number>): number {
    const x = arr[arr[0] == arr[1] ? 0 : 2];
    return arr.find((y) => y != x)!;
}

// "!"
function findUniq5(arr: Array<number>): number {
    return arr.find((n) => arr.indexOf(n) === arr.lastIndexOf(n))!;
}

// "!"
function findUniq6(arr: Array<number>): number {
    var arr = arr.sort();
    return arr[0] == arr[1] ? arr.pop()! : arr[0];
}

function findUniq7(arr: Array<number>): number {
    return arr.filter((el) => arr.indexOf(el) == arr.lastIndexOf(el))[0];
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  NARCISSISTIC NUMBER - DOES MY NUMBER LOOK BIG IN THIS?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A Narcissistic Number is a positive number which is the sum of its own digits, each raised to the power of the number of digits in a given base. In this Kata, we will restrict ourselves to decimal (base 10).
 
For example, take 153 (3 digits), which is narcisstic:
 
    1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153
and 1652 (4 digits), which isn't:
 
    1^4 + 6^4 + 5^4 + 2^4 = 1 + 1296 + 625 + 16 = 1938
The Challenge:
 
Your code must return true or false (not 'true' and 'false') depending upon whether the given number is a Narcissistic number in base 10. This may be True and False in your language, e.g. PHP.
 
Error checking for text strings or other invalid inputs is not required, only valid positive non-zero integers will be passed into the function.
*/

const narcissistic = (num: number): boolean => {
    const exp: number = num.toString().length;
    const digitArr: number[] = num.toString().split("").map(Number);
    const powerSum: number = digitArr
        .map((base) => Math.pow(base, exp))
        .reduce((a, b) => a + b);
    return powerSum === num;
};

//  GET EXPONENT
//  CONVERT NUM TO ARRAY OF DIGITS(number)
//  CALCULATE SUM OF DIGITS RAISED TO EXP
//  COMPARE NUM AND ITS POWERSUM, RETURN boolean RESULT

narcissistic(7);
narcissistic(153);
narcissistic(1634);
narcissistic(16342);

//============= OTHER CODEWARS SOLUTIONS: =============

function narcissistic2(value: number): boolean {
    const str = String(value);
    let acc = 0;
    str.split("").forEach((x) => (acc += Math.pow(+x, str.length)));
    return acc === value;
}

function narcissistic3(value: number): boolean {
    const digits = String(value).split("");

    return (
        digits.reduce(
            (acc, current) => acc + Math.pow(Number(current), digits.length),
            0
        ) === value
    );
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  IS PANGRAM
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A pangram is a sentence that contains every single letter of the alphabet at least once. For example, the sentence "The quick brown fox jumps over the lazy dog" is a pangram, because it uses the letters A-Z at least once (case is irrelevant).
 
Given a string, detect whether or not it is a pangram. Return True if it is, False if not. Ignore numbers and punctuation.
*/

// 1️⃣ FIRST ATTEMPT:
// const isPangram = (phrase: string): boolean => {

//     if (phrase.length < 26) return false;

//     const alphabet: string[] = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];

//     let solution: boolean = true;

//     for (let i = 0; i < alphabet.length; i++) {
//         if (phrase.toLowerCase().indexOf(alphabet[i]) < 0) {
//             solution = false;
//             break;
//         }
//     }

//     return solution;

// }

/*
RETURN FALSE IF LENGTH IS LESS THAN ALPHABET LENGTH
LOOP OVER ALPHABET AND CHECK IF EACH LETTER(LOWERCASED) IS FOUND IN PHRASE
    IF NOT FOUND, STOP LOOP AND RETURN SOLUTION AS FALSE
*/

// 2️⃣ SECOND ATTEMPT:
const isPangram = (phrase: string): boolean => {
    const lettersArr: string[] = phrase.toLowerCase().match(/[a-z]/g)!;
    const lettersSet = new Set(lettersArr);
    return lettersSet.size === 26;
};
/*
MATCH ALL LETTERS(LOWERCASED) INTO ARRAY
MAKE A SET OUT OF THE ARRAY TO REMOVE DUPLICATES
IF SET SIZE IS 26 RETURN true, OTHERWISE false
*/

// isPangram("The quick brown fox jumps over the lazy dog.");
// isPangram("This is not a pangram.");

//  !!! FILTER ALL LETTERS INTO ARRAY !!!
/* 
let onlyLettersArray = message.split('').filter(char => /[a-zA-Z]/.test(char));
let onlyLettersArray = message.replace(/[^a-z]+/gi, '').split('');
let arr = "Learning is fun!  1233  ashdgahsgdh".match(/[A-Za-z]/g);
8?
 
//============= OTHER CODEWARS SOLUTIONS: =============
 
const isPangram3 = (phrase: string): boolean => new Set(phrase.toLowerCase().match(/[a-z]/g)).size === 26;
 
 
const isPangram4 = (phrase: string): boolean => ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
    .every(l => phrase.toLowerCase().includes(l))
 
 
function isPangram5(phrase: string): boolean {
    let newString: Set<string> = new Set((phrase.replace(/\W|\d/g, '')).toLowerCase());
    if (newString.size == 26) {
        return true;
    } else {
        return false;
    }
}
 
 
// 
 
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIRST N ELEMENTS OF TRIBONACCI SEQUENCE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
 
/*
As the name may already reveal, it works basically like a Fibonacci, but summing the last 3 (instead of 2) numbers of the sequence to generate the next. And, worse part of it, regrettably I won't get to hear non-native Italian speakers trying to pronounce it :(
 
    So, if we are to start our Tribonacci sequence with [1, 1, 1] as a starting input (AKA signature), we have this sequence:
    
    [1, 1 ,1, 3, 5, 9, 17, 31, ...]
    But what if we started with [0, 0, 1] as a signature? As starting with [0, 1] instead of [1, 1] basically shifts the common Fibonacci sequence by once place, you may be tempted to think that we would get the same sequence shifted by 2 places, but that is not the case and we would get:
    
    [0, 0, 1, 1, 2, 4, 7, 13, 24, ...]
    Well, you may have guessed it by now, but to be clear: you need to create a fibonacci function that given a signature array/list, returns the first n elements - signature included of the so seeded sequence.
    
    Signature will always contain 3 numbers; n will always be a non-negative number; if n == 0, then return an empty array (except in C return NULL) and be ready for anything else which is not clearly specified ;)
*/

const tribonacci = (
    [a, b, c]: [number, number, number],
    n: number
): number[] => {
    if (n === 0) return [];
    if (n === 1) return [a];
    if (n === 2) return [a, b];
    if (n === 3) return [a, b, c];

    const triArr = [a, b, c];

    for (let i = 3; i < n; i++) {
        let length = triArr.length;
        triArr.push(
            triArr[length - 1] + triArr[length - 2] + triArr[length - 3]
        );
    }

    return triArr;
};

/*
RETURN [], [a], [a, b] OR [a, b, c] IF n IS 0, 1, 2 OR 3
INITALIZE TRIARR WITH a, b and c
CALCULATE AND PUSH NEXT ELEMENT BY SUMMING LAST 3 ELEMENTS
RETURN TRIARR AS SOLUTION
*/

// tribonacci([1, 1, 1], 10);
// tribonacci([1, 1, 1], 4);
// tribonacci([3, 2, 1], 10);

//============= OTHER CODEWARS SOLUTIONS: =============

function tribonacci2(s: Array<number>, n: number): number[] {
    for (let i = 0; s.length < n; i++) s.push(s[i] + s[i + 1] + s[i + 2]);
    return s.slice(0, n);
}

function tribonacci3([a, b, c]: [number, number, number], n: number): number[] {
    if (n == 0) return [];
    if (n == 1) return [a];
    if (n == 2) return [a, b];
    if (n == 3) return [a, b, c];
    var result: number[] = [a, b, c];
    for (var i = 3; i < n; i++) {
        result[i] = result[i - 1] + result[i - 2] + result[i - 3];
    }
    return result;
}

const tribonacci4 = (
    [a, b, c]: [number, number, number],
    n: number
): number[] => (n < 1 ? [] : [a].concat(tribonacci([b, c, a + b + c], n - 1)));

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIND EVEN INDEX - EQUAL SIDES OF ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// You are going to be given an array of integers. Your job is to take that array and find an index N where the sum of the integers to the left of N is equal to the sum of the integers to the right of N. If there is no index that would make this happen, return -1.

// For example:

// Let's say you are given the array {1,2,3,4,3,2,1}:
// Your function will return the index 3, because at the 3rd position of the array, the sum of left side of the index ({1,2,3}) and the sum of the right side of the index ({3,2,1}) both equal 6.

// Let's look at another one.
// You are given the array {1,100,50,-51,1,1}:
// Your function will return the index 1, because at the 1st position of the array, the sum of left side of the index ({1}) and the sum of the right side of the index ({50,-51,1,1}) both equal 1.

// Last one:
// You are given the array {20,10,-80,10,10,15,35}
// At index 0 the left side is {}
// The right side is {10,-80,10,10,15,35}
// They both are equal to 0 when added. (Empty arrays are equal to 0 in this problem)
// Index 0 is the place where the left side and right side are equal.

// Note: Please remember that in most programming/scripting languages the index of an array starts at 0.

// Input:
// An integer array of length 0 < arr < 1000. The numbers in the array can be any integer positive or negative.

// Output:
// The lowest index N where the side to the left of N is equal to the side to the right of N. If you do not find an index that fits these rules, then you will return -1.

// Note:
// If you are given an array with multiple answers, return the lowest correct index.

const findEvenIndex = (arr: number[]): number => {
    const sum = arr.reduce((a, b) => a + b);
    let counterLeft: number = 0;
    let solution: number = -1;

    //     for (let i = 0; i < arr.length; i++) {

    //         let current = arr[i];
    //         let previous = arr[i - 1];
    //         let sideSum = (sum - current) / 2;

    //         counterLeft += previous ? previous : 0;

    //         if (sideSum === counterLeft) {
    //             solution = i;
    //         }

    //     }

    arr.forEach((current, i) => {
        let previous = arr[i - 1];
        let sideSum = (sum - current) / 2;
        // NO PREVIOUS FOR IDX 0 (ITS undefined) THEREFORE COUNTERLEFT IS 0
        counterLeft += previous ? previous : 0;

        if (sideSum === counterLeft) {
            solution = i;
        }

        console.table({
            current: current,
            sideSum: sideSum,
            counter: counterLeft,
        });
        if (sideSum === counterLeft) {
            console.log("solution found at idx : ", i);
            solution = i;
        }
    });

    return solution;
};

// findEvenIndex([1, 2, 3, 4, 3, 2, 1]);
// findEvenIndex([1,100,50,-51,1,1]);
// findEvenIndex([1,8,1]);
// findEvenIndex([20, 10, 30, 10, 10, 15, 35]);
// findEvenIndex([20, 10, -80, 10, 10, 15, 35]);

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// ❗️❗️❗️  INCLUDE THIS IN PROJECTS/TYPESCRIPT ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  YOUR ORDER PLEASE (REARRANGE WORDS BY NUMBER FOUND IN THEM)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// Your task is to sort a given string. Each word in the string will contain a single number. This number is the position the word should have in the result.

// Note: Numbers can be from 1 to 9. So 1 will be the first word (not 0).

// If the input string is empty, return an empty string. The words in the input String will only contain valid consecutive numbers.

// Examples
// "is2 Thi1s T4est 3a"  -->  "Thi1s is2 3a T4est"
// "4of Fo1r pe6ople g3ood th5e the2"  -->  "Fo1r the2 g3ood 4of th5e pe6ople"
// ""  -->  ""

const order = (words: string): string => {
    if (words.length === 0) {
        return "";
    } else {
        const orderedArr: string[] = [];
        words.split(" ").forEach((word) => {
            let numStr: number = Number(word.match(/[1-9]/)![0]) - 1;
            orderedArr[numStr] = word;
        });
        return orderedArr.join(" ");
    }
};

//  IF EMPTY STRING: RETURN ""
//  OTHERWISE:
//      CREATE NEW ARRAY FOR ORDERED WORDS
//      SPLIT INTO ARRAY AND FOR EACH WORD:
//          EXTRACT NUMERIC CHARACTER AND CONVERT TO NUMBER - 1 (INDEX)
//          !!! "Non-null assertion operator" (!) !!!
//          SET WORD AS NEW ELEMENT IN ARRAY AT INDEX
//      RETURN ARRAY JOINED INTO STRING

//  !!! REASON FOR SUBSTRACTING 1 FROM NUMBER: !!!
//  Note: Numbers can be from 1 to 9. So 1 will be the first word (not 0).
//  !!! THIS IS TO PREVENT ELEMENT AT INDEX 0 FROM BEING UNDEFINED IN ORDERED ARRAY  !!!

// order("is2 Thi1s T4est 3a");
// order("");

/*
❗️❗️❗️ TS2531: Object is possibly 'null' ❗️❗️❗️
 
https://stackoverflow.com/questions/49431880/ts2531-object-is-possibly-null
 
You should either check for null (using an if) or use a "Non-null assertion operator" (!) if you are sure it is not null:
 
if(nativeElement.files != null) {
    this.photoService.upload(this.vehicleId, nativeElement.files[0])
        .subscribe(x => console.log(x));
}
 
OR
this.photoService.upload(this.vehicleId, nativeElement.files![0])
    .subscribe(x => console.log(x));
Note:
 
The "Non-null assertion operator" will not perform any runtime checks, it just tells the compiler you have special information and you know nativeElement.files will not be null at runtime.
 
If nativeElement.files is null at runtime, it will generate an error. This is not the safe navigation operator of other languages.
*/

//============= OTHER CODEWARS SOLUTIONS: =============

function order2(words: String): String {
    return words
        .split(" ")
        .sort((a, b) => +a.match(/\d/)! - +b.match(/\d/)!)
        .join(" ");
}

function order3(words: String): String {
    return words
        .split(" ")
        .sort((l, r) => +/\d/.exec(l)![0] - +/\d/.exec(r)![0])
        .join(" ");
}

const order4 = (words: string): string => {
    return words
        .split(" ")
        .sort((a, b) => +a.replace(/\D/g, "") - +b.replace(/\D/g, ""))
        .join(" ");
};

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  TAKE A TEN MINUTE WALK
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// You live in the city of Cartesia where all roads are laid out in a perfect grid. You arrived ten minutes too early to an appointment, so you decided to take the opportunity to go for a short walk. The city provides its citizens with a Walk Generating App on their phones -- everytime you press the button it sends you an array of one-letter strings representing directions to walk (eg. ['n', 's', 'w', 'e']). You always walk only a single block for each letter (direction) and you know it takes you one minute to traverse one city block, so create a function that will return true if the walk the app gives you will take you exactly ten minutes (you don't want to be early or late!) and will, of course, return you to your starting point. Return false otherwise.

// Note: you will always receive a valid array containing a random assortment of direction letters ('n', 's', 'e', or 'w' only). It will never give you an empty array (that's not a walk, that's standing still!).

const isValidWalk = (directions: string[]): boolean => {
    interface Counter {
        [key: string]: number;
    }

    const counterObj: Counter = {};

    directions.forEach((dir) => (counterObj[dir] = (counterObj[dir] || 0) + 1));

    // console.log(
    //     directions.length === 10 ? (counterObj.n === counterObj.s) && (counterObj.e === counterObj.w) : false
    // );

    return directions.length === 10
        ? counterObj.n === counterObj.s && counterObj.e === counterObj.w
        : false;
};

//  CREATE COUNTER OBJECT {direction: count, ...}
//  IF TOTAL NUMBER OF DIRECTIONS IS 10
//      RETURN NUMBER OF BOTH OPPOSITE DIRECTION PAIRS (N-S, E-W) "BOOLEAN"
//  IF NUMBER OF DIRECTIONS IS NOT 10
//      RETURN FALSE

isValidWalk(["n", "s", "n", "s", "n", "s", "n", "s", "n", "s"]);
isValidWalk(["w", "e", "w", "e", "w", "e", "w", "e", "w", "e", "w", "e"]);

//============= OTHER CODEWARS SOLUTIONS: =============

function isValidWalk2(walk: string[]) {
    if (walk.length !== 10) return false;
    if (
        walk.filter((e) => e === "n").length !==
        walk.filter((e) => e === "s").length
    )
        return false;
    if (
        walk.filter((e) => e === "e").length !==
        walk.filter((e) => e === "w").length
    )
        return false;
    return true;
}

function isValidWalk3(walk: string[]) {
    if (walk.length !== 10) return false;

    type directionValues = {
        [key: string]: number;
    };

    const directions: directionValues = {
        n: 0,
        s: 0,
        w: 0,
        e: 0,
    };

    walk.forEach((direction: string) => {
        directions[direction]++;
    });

    return directions.n === directions.s && directions.w === directions.e;
}

function isValidWalk4(walk: string[]): boolean {
    if (walk.length !== 10) return false;

    const coordinates = {
        x: 0,
        y: 0,
    };

    for (let i = 0; i < walk.length; i++) {
        switch (walk[i]) {
            case "n":
                coordinates.x++;
                break;
            case "s":
                coordinates.x--;
                break;
            case "e":
                coordinates.y++;
                break;
            case "w":
                coordinates.y--;
                break;
            default:
                break;
        }
    }

    return !coordinates.x && !coordinates.y;
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// !!! NEED TO REFACTOR !!!
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  DUPLICATE ENCODER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// The goal of this exercise is to convert a string to a new string where each character in the new string is "(" if that character appears only once in the original string, or ")" if that character appears more than once in the original string. Ignore capitalization when determining if a character is a duplicate.

// Examples
// "din"      =>  "((("
// "recede"   =>  "()()()"
// "Success"  =>  ")())())"
// "(( @"     =>  "))(("

const duplicateEncode = (word: string): string => {
    // 1️⃣  DOES NOT WORK WITH SPECIAL CHARACTERS:

    // const strArr = word.split("");
    // strArr.forEach((letter, i) => {
    //     let regex = new RegExp(letter, "gi");
    //     console.table(
    //         {
    //             letter: strArr[i],
    //             matches: word.match(regex)?.length
    //         }
    //     );

    //     //❗️❗️❗️ WITHOUT "?" OBJECT IS POSSIBLY NULL ❗️❗️❗️
    //     let counter: number | undefined = word.match(regex)?.length;

    //     if (counter !== undefined) {
    //         if (counter > 1) {
    //             strArr[i] = ")";
    //         } else {
    //             strArr[i] = "(";
    //         }
    //     }
    // })
    // return strArr.join("");

    // 2️⃣  THIS WORKS:
    //  FIND EACH ELEMENT OF ORIGINAL ARRAY IN COPY(ORIGINAL WORD MINUS CURRENT LETTER)
    // IF FOUND, THEN IT IS A DUPLICATE, IF NOT FOUND THEN IT IS SINGLE
    const original = word.split("").map((letter) => letter.toLowerCase());
    let copy = [...original];
    const resultArr: string[] = [];

    for (let i = 0; i < original.length; i++) {
        copy.splice(i, 1);
        if (copy.indexOf(original[i]) < 0) {
            resultArr.push("(");
        } else {
            resultArr.push(")");
        }
        copy = [...original];
    }

    console.log(resultArr.join(""));
    return resultArr.join("");
};

// duplicateEncode("recEde");
// duplicateEncode("(( @");    // "))(("
// ❗️❗️❗️ SyntaxError: Invalid regular expression: /(/: Unterminated group ❗️❗️❗️

// ❗️❗️❗️ https://stackoverflow.com/questions/17885855/use-dynamic-variable-string-as-regex-pattern-in-javascript/17886301 ❗️❗️❗️

// To create the regex from a string, you have to use JavaScript's RegExp object.

// If you also want to match/replace more than one time, then you must add the g (global match) flag. Here's an example:

// var stringToGoIntoTheRegex = "abc";
// var regex = new RegExp("#" + stringToGoIntoTheRegex + "#", "g");
// // at this point, the line above is the same as: var regex = /#abc#/g;

// var input = "Hello this is #abc# some #abc# stuff.";
// var output = input.replace(regex, "!!");
// alert(output); // Hello this is !! some !! stuff.

//============= OTHER CODEWARS SOLUTIONS: =============

function duplicateEncode2(word: string) {
    // ...
    return word
        .toLowerCase()
        .split("")
        .map((a, i, w) => {
            return w.indexOf(a) == w.lastIndexOf(a) ? "(" : ")";
        })
        .join("");
}

function duplicateEncode3(word: string): string {
    word = word.toLowerCase();
    let countObj: { [index: string]: number } = {};
    for (let char of word) {
        let count = countObj[char] || 0;
        countObj[char] = ++count;
    }
    let result = "";
    for (let char of word) {
        result += countObj[char] > 1 ? ")" : "(";
    }
    return result;
}

function duplicateEncode4(word: string) {
    const chars = word.toLowerCase().split("");

    return chars
        .map((char) => (chars.filter((c) => c === char).length > 1 ? ")" : "("))
        .join("");
}

function duplicateEncode5(word: string): string {
    return word
        .split("")
        .map((value) =>
            (word.match(new RegExp(`[${value}]`, "giu")) || []).length > 1
                ? ")"
                : "("
        )
        .join("");
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  COUNTING DUPLICATES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// Write a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string. The input string can be assumed to contain only alphabets (both uppercase and lowercase) and numeric digits.

// Example
// "abcde" -> 0 # no characters repeats more than once
// "aabbcde" -> 2 # 'a' and 'b'
// "aabBcde" -> 2 # 'a' occurs twice and 'b' twice (`b` and `B`)
// "indivisibility" -> 1 # 'i' occurs six times
// "Indivisibilities" -> 2 # 'i' occurs seven times and 's' occurs twice
// "aA11" -> 2 # 'a' and '1'
// "ABBA" -> 2 # 'A' and 'B' each occur twice

const duplicateCount = (text: string): number => {
    interface Counter {
        [key: string]: number;
    }

    const counterObj: Counter = {};

    text.split("")
        .map((letter) => letter.toLowerCase())
        .forEach((num) => (counterObj[num] = (counterObj[num] || 0) + 1));

    const duplicatesArr = Object.entries(counterObj).filter(
        ([key, value]) => value > 1
    );

    // console.log(duplicatesArr.length);
    return duplicatesArr.length;
};

//  STR -> ARR(LETTERS) -> ARR(LOWERCASED LETTERS) -> OBJ{num: count}
//  FILTER OUT OBJ KEYS WITH VALUE GREATER THAN ONE INTO ARRAY
//  RETURN LENGTH OF ARRAY

//

//============= OTHER CODEWARS SOLUTIONS: =============

// import _ from 'lodash';
// export function duplicateCount2(text: string): number {
//     return _(text).countBy(_.toUpper).values().filter(x => x > 1).size();
// }

function duplicateCount3(text: string): number {
    const values = text.toLowerCase();
    const distinctValues = [...new Set(values)];
    const count = (s: string) => values.split(s).length - 1 > 1;
    return distinctValues.filter((value) => count(value)).length;
}

function duplicateCount4(text: string): number {
    let array = text.toLowerCase().split("");
    return [...new Set(array.filter((e, i) => array.indexOf(e) !== i))].length;
}

function duplicateCount5(text: string): number {
    return new Set(text.toLowerCase().match(/(.)(?=.*\1)/gi) || []).size;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIND THE PARITY OUTLIER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// You are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer N. Write a method that takes the array as an argument and returns this "outlier" N.

// Examples
// [2, 4, 0, 100, 4, 11, 2602, 36]
// Should return: 11 (the only odd number)

// [160, 3, 1719, 19, 11, 13, -21]
// Should return: 160 (the only even number)

// CHECK IF ELEMENT'S ABSOLUT VALUE IS ODD OR EVEN, GROUP THEM IN ARRAYS
// RETURN FIRST ELEMENT OF ARRAY WITH ONE ELEMENT

const findOutlier = (ints: number[]): number => {
    const odds = ints.filter((num) => Math.abs(num) % 2 === 1);
    const evens = ints.filter((num) => Math.abs(num) % 2 === 0);
    // console.log(odds.length > 1 ? evens[0] : odds[0])
    return odds.length > 1 ? evens[0] : odds[0];
};

// findOutlier([2, 4, 0, 100, 4, 11, 2602, 36]);   // 11
// findOutlier([160, 3, 1719, 19, 11, 13, -21]);   // 160
// findOutlier([17417968, -12150916, -135668362, -45067422, 65586444, -104088786, 74395984, 198980314, -91660877, -52541784, -49718652, -189685108, -120327066, 178679078, -31538954, 112116518, -186162190, 29923430, 180062518, 878198, -185634066, -188868404, -111266602, -123331452, -184028074, -24771054, -4052, 98231950, -91193344, -154129192, -134529020, 195427700, 187599832, -11229586, -165510592, -19725720, 180071600, -161055558, 109276994, -88809438, -149769730, -89421390, 27663208, 132490658, 118790172, -23745850, 27711836, -4950342, 32063374, 655394]);   // -91660877

//============= OTHER CODEWARS SOLUTIONS: =============

export function findOutlier2(integers: number[]): number {
    if (integers.slice(0, 3).filter((i) => i % 2 !== 0).length > 1) {
        return integers.find((v) => v % 2 === 0) || 0;
    } else {
        return integers.find((v) => v % 2 !== 0) || 0;
    }
}

export function findOutlier3(integers: number[]): number {
    const odds = integers.filter((v) => v % 2);
    const evens = integers.filter((v) => !(v % 2));

    return odds.length === 1 ? odds[0] : evens[0];
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  BIT COUNTING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

const countBits = (num: number): number => {
    const bitArr = num.toString(2).match(/1/g);
    // console.log(bitArr === null ? 0 : bitArr.length);
    return bitArr === null ? 0 : bitArr.length;
};

// countBits(0);
// countBits(1234);

//============= OTHER CODEWARS SOLUTIONS: =============

export function countBits2(n: number): number {
    return n.toString(2).replace(/0/g, "").length;
}

export function countBits3(n: number) {
    return n
        .toString(2)
        .split("")
        .filter((c) => c === "1").length;
}

export function countBits4(n: number) {
    return n.toString(2).split("").map(Number).filter(Boolean).length;
}

export function countBits5(n: number) {
    return n.toString(2).split("1").length - 1;
}

export function countBits6(n: number) {
    return n.toString(2).replace(/0/gi, "").length;
}

export function countBits7(n: number) {
    return n.toString(2).match(/1/g)?.length || 0;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  WHO LIKES IT?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

const likes = (names: string[]): string => {
    switch (names.length) {
        case 0:
            return "no one likes this";
        case 1:
            return `${names[0]} likes this`;
        case 2:
            return `${names[0]} and ${names[1]} like this`;
        case 3:
            return `${names[0]}, ${names[1]} and ${names[2]} like this`;
        default:
            return `${names[0]}, ${names[1]} and ${names.length - 2
                } others like this`;
    }
};

//  MAKE 4+ NAMES DEFAULT

//============= OTHER CODEWARS SOLUTIONS: =============

// export const likes = (names: string[]): string => {
//     switch (names.length) {
//         case 0: return 'no one likes this';
//         case 1: return `${names[0]} likes this`;
//         case 2: return `${names[0]} and ${names[1]} like this`;
//         case 3: return `${names[0]}, ${names[1]} and ${names[2]} like this`;
//         default: return `${names[0]}, ${names[1]} and ${names.length - 2} others like this`;
//     }
// };

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ARRAY.DIFF
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.

// It should remove all values from list a, which are present in list b keeping their order.

// array_diff({1, 2}, 2, {1}, 1, *z) == {2} (z == 1)
// If a value is present in b, all of its occurrences must be removed from the other:

// array_diff({1, 2, 2, 2, 3}, 5, {2}, 1, *z) == {1, 3} (z == 2)

// RETURN ELEMENTS OF a THAT ARE NOT PRESENT IN b
const arrayDiff = (a: number[], b: number[]): number[] => {
    return a.filter((num) => b.indexOf(num) < 0);
};

arrayDiff([3, 4, 3], [3]);

//============= OTHER CODEWARS SOLUTIONS: =============

// export function arrayDiff(a: number[], b: number[]): number[] {
//     return a.filter(e => !b.includes(e));
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SUM OF DIGITS / DIGITAL ROOT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// Digital root is the recursive sum of all the digits in a number.

// Given n, take the sum of the digits of n. If that value has more than one digit, continue reducing in this way until a single-digit number is produced. The input will be a non-negative integer.

const digitalRoot = (num: number): number => {
    const digitArr = num
        .toString()
        .split("")
        .map((el) => Number(el));

    const sum = digitArr.reduce((a, b) => a + b);
    // console.log(num > 9 ? digitalRoot(sum) : num);
    return num > 9 ? digitalRoot(sum) : num;
};

//  NUM -> STR -> ARR(STR) -> ARR(NUM)
//  GET SUM OF DIGITS
//  RETURN digitalRoot(SUM) OR NUM
digitalRoot(493193); // 6

//============= OTHER CODEWARS SOLUTIONS: =============

// export function digitalRoot(n: number): number {
//     return (n - 1) % 9 + 1;
// }

// export const digitalRoot = (n:number):number => {
//     return n>9?digitalRoot([...(n.toString())].reduce((a,c)=>a+Number(c),0)):n;
// };

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  STOP SPINNING MY WORDS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// mop / forEach
//  STR -> ARR(STR) -> IF LENGTH >= 5{SPLIT.REV.JOIN} -> STR
const spinWords = (words: string): string => {
    const arr = words.split(" ");
    arr.map((word, i) => {
        if (word.length >= 5) {
            arr[i] = arr[i].split("").reverse().join("");
        }
    });
    console.log(arr.join(" "));
    return arr.join(" ");
};

// spinWords("Hey fellow warriors");

//============= OTHER CODEWARS SOLUTIONS: =============

function spinWords2(words: string): string {
    return words.replace(/[a-z]{5,}/gi, (s) => s.split("").reverse().join(""));
}

// const spinWords = (words: string): string => words.split(' ')
//                                                         .map(m => m.length >= 5
//                                                              ? m.split('').reverse().join('')
//                                                              : m)
//                                                         .join(' ')

// function spinWords(words: string): string {
//     return words.split(" ").map(word => word.length >= 5 ? [...word].reverse().join("") : word).join(" ")
// }

// function spinWords(words: string): string {
//     return words.split(" ").map(word => word.length >= 5 ? [...word].reverse().join("") : word).join(" ")
// }

// static spinWords(words: string) {
//     const array = words.split(" ");
//     const spin = array.map((word) => {
//       return word.length < 5 ? word : word.split("").reverse().join("");
//     });
//     return spin.join(" ");
// }

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// ❗️❗️❗️  INCLUDE THIS IN PROJECTS/TYPESCRIPT ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIND INT THAT APPEARS ODD NUMBER OF TIMES IN ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: https://www.reddit.com/r/typescript/comments/hm8jbv/how_to_define_an_interface_for_objects_with/fx4szci/
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// ❗️❗️❗️ DEFINE INTERFACE FOR WHAT'S BEING RETURNED ❗️❗️❗️
// TO AVOID ERROR: Element implicitly has 'any' type because expression of type 'number' can't be used to index type '{}'

// ❗️❗️❗️ LOOK INTO THIS: ❗️❗️❗️

// A type like { [key: string]: number } is just bad and should not be used ever.

// Consider an example: const test: { [key: string]: number } = { a: 1 }; test.b // TS will think it’s of type number, while in fact it’s undefined.

// A type declared like that literally says: „for each key of string type there is a number value”. Which simply is not the case. Just don’t do it. It’s as bad as using any.

// If you need to use an object as a key-value mapper, do it well and either define the keys statically, or make the type of value a union with undefined.

// 1️⃣    WITH filter()

const findOdd = (arr: number[]): number => {
    interface NumCounter {
        [key: string]: number;
    }

    const counter: NumCounter = {};

    arr.forEach((num) => (counter[num] = (counter[num] || 0) + 1));

    const oddTimesArr = Object.entries(counter).filter(
        ([key, value]) => value % 2 > 0
    );

    // console.log(Number(oddTimesArr[0][0]));
    return Number(oddTimesArr[0][0]);
};

// 2️⃣    WITH forEach()

const findOdd2 = (arr: number[]): number => {
    interface NumCounter {
        [key: string]: number;
    }

    const counter: NumCounter = {};

    arr.forEach((num) => (counter[num] = (counter[num] || 0) + 1));

    let solution: any; // INITIALIZE ❗️❗️❗️

    Object.entries(counter).forEach(([key, value]) => {
        // value % 2 > 0 && console.log("key: ", Number(key));
        if (value % 2 > 0) solution = Number(key) as number; // TYPE ASSERTION ❗️❗️❗️
    });

    return solution;
};

// const findOdd = (arr: number[]): number => {

//     // LOOK INTO THIS, SEE ABOVE:
//     interface NumCounter {
//         [key: string]: number;
//     }

//     const counter: NumCounter = {};

//     arr.forEach(num => counter[num] = (counter[num] || 0) + 1);

//     // console.log(counter);

//     // !!! tsconfig.json COMPILER OPTIONS: "target": "es2018" (es2017 OR LATER) FOR Object.entries TO WORK!!!
//     Object.entries(counter).forEach(([key, value]) => console.log(`${key}: ${value}`));

//     Object.entries(counter).forEach(([key, value]) => {
//         value % 2 > 0 && console.log("key: ", Number(key));
//     });

//     const testArr = Object.entries(counter).filter(([key, value]) => value % 2 > 0);
//     console.log(testArr);
//     console.log(Number(testArr[0][0]));

//     return Number(testArr[0][0]);
// };

findOdd([1, 2, 2, 1, 2]);
findOdd2([1, 2, 2, 1, 2]);

//❗️❗️❗️============= OTHER CODEWARS SOLUTIONS: =============❗️❗️❗️

// https://warrenniu.medium.com/find-the-unique-number-in-an-array-using-the-xor-operator-54d35aa9e8d0
const findOdd3 = (xs: number[]): number => {
    return xs.reduce((a, b) => a ^ b);
};

// Bit operators work on 32 bits numbers. Any numeric operand in the operation is converted into a 32 bit number. The result is converted back to a JavaScript number.

// Operator	Description	Example	Same as	Result	Decimal
// &	AND	x = 5 & 1	0101 & 0001	0001	 1
// |	OR	x = 5 | 1	0101 | 0001	0101	 5
// ~	NOT	x = ~ 5	 ~0101	1010	 10
// ^	XOR	x = 5 ^ 1	0101 ^ 0001	0100	 4
// <<	Left shift	x = 5 << 1	0101 << 1	1010	 10
// >>	Right shift	x = 5 >> 1	0101 >> 1	0010	  2

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TypeError: Reduce of empty array with no initial value
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  MULTIPLES OF 3 OR 5
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

// Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in. Additionally, if the number is negative, return 0 (for languages that do have them).

// Note: If the number is a multiple of both 3 and 5, only count it once.

// DIVS ARRAY MUST HAVE AN INITIAL VALUE
const solution = (num: number): number => {
    const divs = [0];
    for (let i = 1; i < num; i++)
        if (i % 3 === 0 || i % 5 === 0) {
            divs.push(i);
        }
    console.log(num >= 0 ? divs.reduce((a, b) => a + b) : 0);
    return num >= 0 ? divs.reduce((a, b) => a + b) : 0;
};

// solution(10);
// solution(-1);
// solution(0);

//============= OTHER CODEWARS SOLUTIONS: =============

// export class Challenge {
//     static solution(n: number) {
//       let x = 0;
//       for (let i = 0;i < n; ++i)
//         if (i % 3 == 0 || i % 5 == 0)
//           x += i
//       return x;
//     }
// }
