// ❗️❗️❗️ ✅  ❓❓❓
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// 🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: HOW MUCH?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
I always thought that my old friend John was rather richer than he looked, but I never knew exactly how much money he actually had. One day (as I was plying him with questions) he said:

"Imagine I have between m and n Zloty..." (or did he say Quetzal? I can't remember!)
"If I were to buy 9 cars costing c each, I'd only have 1 Zloty (or was it Meticals?) left."
"And if I were to buy 7 boats at b each, I'd only have 2 Ringglets (or was it Zloty?) left."
Could you tell me in each possible case:

how much money f he could possibly have ?
the cost c of a car?
the cost b of a boat?
So, I will have a better idea about his fortune. Note that if m-n is big enough, you might have a lot of possible answers.

Each answer should be given as ["M: f", "B: b", "C: c"] and all the answers as [ ["M: f", "B: b", "C: c"], ... ]. "M" stands for money, "B" for boats, "C" for cars.

Note: m, n, f, b, c are positive integers, where 0 <= m <= n or m >= n >= 0. m and n are inclusive.

Examples:
howmuch(1, 100)      => [["M: 37", "B: 5", "C: 4"], ["M: 100", "B: 14", "C: 11"]]
howmuch(1000, 1100)  => [["M: 1045", "B: 149", "C: 116"]]
howmuch(10000, 9950) => [["M: 9991", "B: 1427", "C: 1110"]]
howmuch(0, 200)      => [["M: 37", "B: 5", "C: 4"], ["M: 100", "B: 14", "C: 11"], ["M: 163", "B: 23", "C: 18"]]
Explanation of the results for howmuch(1, 100):

In the first answer his possible fortune is 37:
so he can buy 7 boats each worth 5: 37 - 7 * 5 = 2
or he can buy 9 cars worth 4 each: 37 - 9 * 4 = 1
The second possible answer is 100:
he can buy 7 boats each worth 14: 100 - 7 * 14 = 2
or he can buy 9 cars worth 11: 100 - 9 * 11 = 1
Note
See "Sample Tests" to know the format of the return.


*/
// class G001 {
//     public static howmuch(m: number, n: number): string[][] {
//         // your code
//     }
// }
/*
 testing(1, 100, [["M: 37", "B: 5", "C: 4"], ["M: 100", "B: 14", "C: 11"]]);
        testing(1000, 1100, [["M: 1045", "B: 149", "C: 116"]]);
        testing(10000, 9950, [["M: 9991", "B: 1427", "C: 1110"]]);
*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: GRABSCRAB
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Pirates have notorious difficulty with enunciating. They tend to blur all the letters together and scream at people.

At long last, we need a way to unscramble what these pirates are saying.

Write a function that will accept a jumble of letters as well as a dictionary, and output a list of words that the pirate might have meant.

For example:

grabscrab( "ortsp", ["sport", "parrot", "ports", "matey"] )
Should return ["sport", "ports"].

Return matches in the same order as in the dictionary. Return an empty array if there are no matches.

Good luck!


*/
function grabscrab(anagram: string, dictionary: string[]): string[] {
    return ["hello"];
}
/*
assert.deepEqual(grabscrab("trisf", ["first"]), ["first"], "Should have found 'first'");
    assert.deepEqual(grabscrab("oob", ["bob", "baobab"]), [], "Should not have found anything");
    assert.deepEqual(grabscrab("ainstuomn", ["mountains", "hills", "mesa"]), ["mountains"], "Should have found 'mountains'");
    assert.deepEqual(grabscrab("oolp", ["donkey", "pool", "horse", "loop"]), ["pool", "loop"], "Should have found 'pool' and 'loop'");
    assert.deepEqual(grabscrab("ortsp", ["sport", "parrot", "ports", "matey"]), ["sport", "ports"], "Should have found 'sport' and 'ports'");
    assert.deepEqual(grabscrab("ourf", ["one","two","three"]), [], "Should not have found anything");
*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: MOVES IN SQARED STRINGS - (II)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You are given a string of n lines, each substring being n characters long: For example:

s = "abcd\nefgh\nijkl\nmnop"

We will study some transformations of this square of strings.

Clock rotation 180 degrees: rot
rot(s) => "ponm\nlkji\nhgfe\ndcba"
selfie_and_rot(s) (or selfieAndRot or selfie-and-rot) It is initial string + string obtained by clock rotation 180 degrees with dots interspersed in order (hopefully) to better show the rotation when printed.
s = "abcd\nefgh\nijkl\nmnop" --> 
"abcd....\nefgh....\nijkl....\nmnop....\n....ponm\n....lkji\n....hgfe\n....dcba"
or printed:
|rotation        |selfie_and_rot
|abcd --> ponm   |abcd --> abcd....
|efgh     lkji   |efgh     efgh....
|ijkl     hgfe   |ijkl     ijkl....   
|mnop     dcba   |mnop     mnop....
                           ....ponm
                           ....lkji
                           ....hgfe
                           ....dcba
Notice that the number of dots is the common length of "abcd", "efgh", "ijkl", "mnop".

Task:
Write these two functions rotand selfie_and_rot
and

high-order function oper(fct, s) where

fct is the function of one variable f to apply to the string s (fct will be one of rot, selfie_and_rot)

Examples:
s = "abcd\nefgh\nijkl\nmnop"
oper(rot, s) => "ponm\nlkji\nhgfe\ndcba"
oper(selfie_and_rot, s) => "abcd....\nefgh....\nijkl....\nmnop....\n....ponm\n....lkji\n....hgfe\n....dcba"
Notes:
The form of the parameter fct in oper changes according to the language. You can see each form according to the language in "Your test cases".
It could be easier to take these katas from number (I) to number (IV)
Forthcoming katas will study other tranformations.

Bash Note:
The input strings are separated by , instead of \n. The ouput strings should be separated by \r instead of \n. See "Sample Tests".
*/

/*
 assert.strictEqual(
      oper(rot, "fijuoo\nCqYVct\nDrPmMJ\nerfpBA\nkWjFUG\nCVUfyL"),
      "LyfUVC\nGUFjWk\nABpfre\nJMmPrD\ntcVYqC\nooujif"
    );
    assert.strictEqual(
      oper(rot, "rkKv\ncofM\nzXkh\nflCB"),
      "BClf\nhkXz\nMfoc\nvKkr"
    );
  });

  it("Basic tests selfieAndRot", function() {        
    assert.strictEqual(
      oper(selfieAndRot, "xZBV\njsbS\nJcpN\nfVnP"),
      "xZBV....\njsbS....\nJcpN....\nfVnP....\n....PnVf\n....NpcJ\n....Sbsj\n....VBZx"
    );
    assert.strictEqual(
      oper(selfieAndRot, "uLcq\nJkuL\nYirX\nnwMB"),
      "uLcq....\nJkuL....\nYirX....\nnwMB....\n....BMwn\n....XriY\n....LukJ\n....qcLu"
    );
*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: BALL UPWARDS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You throw a ball vertically upwards with an initial speed v (in km per hour). The height h of the ball at each time t is given by h = v*t - 0.5*g*t*t where g is Earth's gravity (g ~ 9.81 m/s**2). A device is recording at every tenth of second the height of the ball. For example with v = 15 km/h the device gets something of the following form: (0, 0.0), (1, 0.367...), (2, 0.637...), (3, 0.808...), (4, 0.881..) ... where the first number is the time in tenth of second and the second number the height in meter.

Task
Write a function max_ball with parameter v (in km per hour) that returns the time in tenth of second of the maximum height recorded by the device.

Examples:
max_ball(15) should return 4

max_ball(25) should return 7

Notes
Remember to convert the velocity from km/h to m/s or from m/s in km/h when necessary.
The maximum height recorded by the device is not necessarily the maximum height reached by the ball.
*/

function maxBall(v0: number): number {
    return 1;
}
/*
assert.strictEqual(maxBall(37), 10);
    assert.strictEqual(maxBall(45), 13);
    assert.strictEqual(maxBall(99), 28);
    assert.strictEqual(maxBall(85), 24);
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: PRIZE DRAW
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
To participate in a prize draw each one gives his/her firstname.

Each letter of a firstname has a value which is its rank in the English alphabet. A and a have rank 1, B and b rank 2 and so on.

The length of the firstname is added to the sum of these ranks hence a number som.

An array of random weights is linked to the firstnames and each som is multiplied by its corresponding weight to get what they call a winning number.

Example:
names: "COLIN,AMANDBA,AMANDAB,CAROL,PauL,JOSEPH"
weights: [1, 4, 4, 5, 2, 1]

PauL -> som = length of firstname + 16 + 1 + 21 + 12 = 4 + 50 -> 54
The *weight* associated with PauL is 2 so PauL's *winning number* is 54 * 2 = 108.
Now one can sort the firstnames in decreasing order of the winning numbers. When two people have the same winning number sort them alphabetically by their firstnames.

Task:
parameters: st a string of firstnames, we an array of weights, n a rank

return: the firstname of the participant whose rank is n (ranks are numbered from 1)

Example:
names: "COLIN,AMANDBA,AMANDAB,CAROL,PauL,JOSEPH"
weights: [1, 4, 4, 5, 2, 1]
n: 4

The function should return: "PauL"
Notes:
The weight array is at least as long as the number of names, it may be longer.

If st is empty return "No participants".

If n is greater than the number of participants then return "Not enough participants".

See Examples Test Cases for more examples.
*/
// class G964 {

//     public static rank(st, we, n) {
//         // your code
//     }
// }
/*
testing("Addison,Jayden,Sofia,Michael,Andrew,Lily,Benjamin", [4, 2, 1, 4, 3, 1, 2], 4, "Benjamin");
        testing("Elijah,Chloe,Elizabeth,Matthew,Natalie,Jayden", [1, 3, 5, 5, 3, 6], 2, "Matthew");
        testing("Aubrey,Olivai,Abigail,Chloe,Andrew,Elizabeth", [3, 1, 4, 4, 3, 2], 4, "Abigail");
        testing("Lagon,Lily", [1, 5], 2, "Lagon");
*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: STRING TRANSFORMER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a string, return a new string that has transformed based on the input:

Change case of every character, ie. lower case to upper case, upper case to lower case.
Reverse the order of words from the input.
Note: You will have to handle multiple spaces, and leading/trailing spaces.

For example:

"Example Input" ==> "iNPUT eXAMPLE"
You may assume the input only contain English alphabet and spaces.


*/
function stringTransformer(str: string) {
    // Your code here
}

/*
describe("Fixed tests", function() {
  it("Testing for 'Example Input'", () => assert.strictEqual(stringTransformer('Example Input'), 'iNPUT eXAMPLE'));
  it("Testing for ''", () => assert.strictEqual(stringTransformer(''), ''));
  it("Testing for 'To be OR not to be That is the Question'", () => assert.strictEqual(stringTransformer('To be OR not to be That is the Question'), 'qUESTION THE IS tHAT BE TO NOT or BE tO'));
  it("Testing for 'You Know When  THAT  Hotline Bling'", () => assert.strictEqual(stringTransformer('You Know When  THAT  Hotline Bling'), 'bLING hOTLINE  that  wHEN kNOW yOU'));
  it("Testing for ' A b C d E f G '", () => assert.strictEqual(stringTransformer(' A b C d E f G '), ' g F e D c B a '));
});
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: COORDINATES VALIDATOR
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You need to create a function that will validate if given parameters are valid geographical coordinates.

Valid coordinates look like the following: "23.32353342, -32.543534534". The return value should be either true or false.

Latitude (which is first float) can be between 0 and 90, positive or negative. Longitude (which is second float) can be between 0 and 180, positive or negative.

Coordinates can only contain digits, or one of the following symbols (including space after comma) __ -, . __

There should be no space between the minus "-" sign and the digit after it.

Here are some valid coordinates:

-23, 25
24.53525235, 23.45235
04, -23.234235
43.91343345, 143
4, -3
And some invalid ones:

23.234, - 23.4234
2342.43536, 34.324236
N23.43345, E32.6457
99.234, 12.324
6.325624, 43.34345.345
0, 1,2
0.342q0832, 1.2324
*/
function isValidCoordinates(coordinates: string): boolean {
    return true; // do your thing!
}

/*
describe("solution", function(){
    it("exampleTests", function(){
      var ValidCoordinates = [
      "-23, 25",
      "4, -3",
      "24.53525235, 23.45235",
      "04, -23.234235",
      "43.91343345, 143"
    ];
    for(var i=0;i<ValidCoordinates.length;i++) {
      assert.equal(solution.isValidCoordinates(ValidCoordinates[i]), true, ValidCoordinates[i] + " validation failed.");
    }
  
    var InvalidCoordinates = [
      "23.234, - 23.4234",
      "2342.43536, 34.324236",
      "N23.43345, E32.6457",
      "99.234, 12.324",
      "6.325624, 43.34345.345",
      "0, 1,2",
      "0.342q0832, 1.2324",
      "23.245, 1e1"
    ];
    for(var i=0;i<ValidCoordinates.length;i++) {
      assert.equal(solution.isValidCoordinates(InvalidCoordinates[i]), false, InvalidCoordinates[i] + " validation failed.");
    }
    });
  });

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: SALESMAN TRAVEL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A traveling salesman has to visit clients. He got each client's address e.g. "432 Main Long Road St. Louisville OH 43071" as a list.

The basic zipcode format usually consists of two capital letters followed by a white space and five digits. The list of clients to visit was given as a string of all addresses, each separated from the others by a comma, e.g. :

"123 Main Street St. Louisville OH 43071,432 Main Long Road St. Louisville OH 43071,786 High Street Pollocksville NY 56432".

To ease his travel he wants to group the list by zipcode.

Task
The function travel will take two parameters r (addresses' list of all clients' as a string) and zipcode and returns a string in the following format:

zipcode:street and town,street and town,.../house number,house number,...

The street numbers must be in the same order as the streets where they belong.

If a given zipcode doesn't exist in the list of clients' addresses return "zipcode:/"

Examples
r = "123 Main Street St. Louisville OH 43071,432 Main Long Road St. Louisville OH 43071,786 High Street Pollocksville NY 56432"

travel(r, "OH 43071") --> "OH 43071:Main Street St. Louisville,Main Long Road St. Louisville/123,432"

travel(r, "NY 56432") --> "NY 56432:High Street Pollocksville/786"

travel(r, "NY 5643") --> "NY 5643:/"
Note for Elixir:
In Elixir the empty addresses' input is an empty list, not an empty string.

Note:
You can see a few addresses and zipcodes in the test cases.
*/
// class G9645 {
//     public static travel = (r, zipcode) => {
//         // your code
//     };
// }

const ad =
    "123 Main Street St. Louisville OH 43071,432 Main Long Road St. Louisville OH 43071,786 High Street Pollocksville NY 56432," +
    "54 Holy Grail Street Niagara Town ZP 32908,3200 Main Rd. Bern AE 56210,1 Gordon St. Atlanta RE 13000," +
    "10 Pussy Cat Rd. Chicago EX 34342,10 Gordon St. Atlanta RE 13000,58 Gordon Road Atlanta RE 13000," +
    "22 Tokyo Av. Tedmondville SW 43098,674 Paris bd. Abbeville AA 45521,10 Surta Alley Goodtown GG 30654," +
    "45 Holy Grail Al. Niagara Town ZP 32908,320 Main Al. Bern AE 56210,14 Gordon Park Atlanta RE 13000," +
    "100 Pussy Cat Rd. Chicago EX 34342,2 Gordon St. Atlanta RE 13000,5 Gordon Road Atlanta RE 13000," +
    "2200 Tokyo Av. Tedmondville SW 43098,67 Paris St. Abbeville AA 45521,11 Surta Avenue Goodtown GG 30654," +
    "45 Holy Grail Al. Niagara Town ZP 32918,320 Main Al. Bern AE 56215,14 Gordon Park Atlanta RE 13200," +
    "100 Pussy Cat Rd. Chicago EX 34345,2 Gordon St. Atlanta RE 13222,5 Gordon Road Atlanta RE 13001," +
    "2200 Tokyo Av. Tedmondville SW 43198,67 Paris St. Abbeville AA 45522,11 Surta Avenue Goodville GG 30655," +
    "2222 Tokyo Av. Tedmondville SW 43198,670 Paris St. Abbeville AA 45522,114 Surta Avenue Goodville GG 30655," +
    "2 Holy Grail Street Niagara Town ZP 32908,3 Main Rd. Bern AE 56210,77 Gordon St. Atlanta RE 13000";

// testing(
//     ad,
//     "AA 45522",
//     "AA 45522:Paris St. Abbeville,Paris St. Abbeville/67,670"
// );
// testing(
//     ad,
//     "EX 34342",
//     "EX 34342:Pussy Cat Rd. Chicago,Pussy Cat Rd. Chicago/10,100"
// );
// testing(ad, "EX 34345", "EX 34345:Pussy Cat Rd. Chicago/100");
// testing(
//     ad,
//     "AA 45521",
//     "AA 45521:Paris bd. Abbeville,Paris St. Abbeville/674,67"
// );
// testing(ad, "AE 56215", "AE 56215:Main Al. Bern/320");

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: SORT THE INNER CONTENT IN DESCENDING ORDER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You have to sort the inner content of every word of a string in descending order.

The inner content is the content of a word without first and the last char.

Some examples:

"sort the inner content in descending order"  -->  "srot the inner ctonnet in dsnnieedcg oredr"
"wait for me"        -->  "wiat for me"
"this kata is easy"  -->  "tihs ktaa is esay"
Words are made up of lowercase letters.

The string will never be null and will never be empty. In C/C++ the string is always nul-terminated.
*/
function sortTheInnerContent(words: string): string {
    return words;
}

// assert.equal(solution.sortTheInnerContent("sort the inner content in descending order"), "srot the inner ctonnet in dsnnieedcg oredr");
//     assert.equal(solution.sortTheInnerContent("wait for me"), "wiat for me");
//     assert.equal(solution.sortTheInnerContent("this kata is easy"), "tihs ktaa is esay");

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: PRIMORIAL OF A NUMBER - PRODUCT OF PRIMES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Definition (Primorial Of a Number)
Is similar to factorial of a number, In primorial, not all the natural numbers get multiplied, only prime numbers are multiplied to calculate the primorial of a number. It's denoted with P# and it is the product of the first n prime numbers.

Task
Given a number N , calculate its primorial.!alt!alt
Notes
Only positive numbers will be passed (N > 0) .
Input >> Output Examples:
1- numPrimorial (3) ==> return (30)
Explanation:
Since the passed number is (3) ,Then the primorial should obtained by multiplying 2 * 3 * 5 = 30 .

Mathematically written as , P3# = 30 .
2- numPrimorial (5) ==> return (2310)
Explanation:
Since the passed number is (5) ,Then the primorial should obtained by multiplying 2 * 3 * 5 * 7 * 11 = 2310 .

Mathematically written as , P5# = 2310 .
3- numPrimorial (6) ==> return (30030)
Explanation:
Since the passed number is (6) ,Then the primorial should obtained by multiplying 2 * 3 * 5 * 7 * 11 * 13 = 30030 .

Mathematically written as , P6# = 30030 .

*/
const numPrimorial = (num: number) => {
    let primesArr: number[] = [];

    const isPrime = (num: number) => {
        for (let i = 2; i <= Math.sqrt(num); i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    };

    let i: number = 2;

    // GENERATE/PUSH PRIMES UNTIL num IS REACHED
    while (primesArr.length < num) {
        let prime = 0;
        if (isPrime(i)) {
            prime = i;
            primesArr.push(prime);
        }
        if (primesArr.length === num) {
            break;
        }
        i += 1;
    }

    // GET PRODUCT OF PRIMES
    const solution: number = primesArr.reduce((acc, curr) => acc * curr);

    return solution;
};

// it("Testing for 3", () => assert.strictEqual(numPrimorial(3), 30));
//   it("Testing for 4", () => assert.strictEqual(numPrimorial(4), 210));
//   it("Testing for 5", () => assert.strictEqual(numPrimorial(5), 2310));
//   it("Testing for 8", () => assert.strictEqual(numPrimorial(8), 9699690));
//   it("Testing for 9", () => assert.strictEqual(numPrimorial(9), 223092870));

// console.log(numPrimorial(4));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❓❓❓
const primes = [
    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
    73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
    157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
    239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,
    331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,
    421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,
    509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,
    613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,
    709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,
    821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,
    919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013,
    1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091,
    1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181,
    1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277,
    1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361,
    1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451,
    1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531,
    1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609,
    1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699,
    1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789,
    1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889,
    1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997,
    1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083,
    2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161,
    2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273,
    2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357,
    2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441,
    2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551,
    2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663,
    2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729,
    2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819,
    2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917,
    2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023,
    3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137,
    3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251,
    3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331,
    3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449,
    3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533,
    3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617,
    3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709,
    3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821,
    3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917,
    3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013,
    4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111,
    4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219,
    4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297,
    4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423,
    4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519,
    4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639,
    4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729,
    4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831,
    4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951,
    4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023,
    5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147,
    5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261,
    5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387,
    5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471,
    5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563,
    5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659,
    5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779,
    5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857,
    5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981,
    5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089,
    6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199,
    6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287,
    6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367,
    6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491,
    6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607,
    6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709,
    6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827,
    6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917,
    6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013,
    7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129,
    7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243,
    7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369,
    7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499,
    7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577,
    7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681,
    7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789,
    7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901,
    7907, 7919,
];

export function numPrimorial2(n: number) {
    return primes.slice(0, n).reduce((acc, v) => acc * v);
}

// ============================================================

const numPrimorial3 = (n: number): number => {
    const isPrime = (m: number): boolean => {
        for (let i = 2; i < m / 2 + 1; i++) {
            if (m % i === 0) {
                return false;
            }
        }
        return true;
    };

    let t = 0,
        op = 1,
        c = 1;
    while (true) {
        c++;
        if (isPrime(c)) {
            op *= c;
            t++;
            if (t === n) {
                break;
            }
        }
    }
    return op;
};

function numPrimorial4(n: number) {
    const primes = [];
    let i = 2;
    while (primes.length < n) {
        let j = 2;
        let prime = true;
        while (prime && j < i) {
            if (i % j === 0) {
                prime = false;
            }
            j++;
        }
        if (prime) {
            primes.push(i);
        }
        i++;
    }
    return primes.reduce((acc, cur) => acc * cur, 1);
}

function numPrimorial5(n: number) {
    let count = 0;
    let sol = 1;
    for (let i = 2; count < n; i++) {
        let isPrime = true;
        for (let j = 2; j <= ~~Math.sqrt(i); j++)
            if (i % j == 0) {
                isPrime = false;
                break;
            }
        if (isPrime) {
            count++;
            sol *= i;
        }
    }
    return sol;
}
// !!! THIS IS SIMILAR TO 5KYU GAPS IN PRIMES !!!
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: STEPS IN PRIMES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: PRIMES, ❗️❗️❗️ FUNCTION TYPE ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The prime numbers are not regularly spaced. For example from 2 to 3 the step is 1. From 3 to 5 the step is 2. From 7 to 11 it is 4. Between 2 and 50 we have the following pairs of 2-steps primes:

3, 5 - 5, 7, - 11, 13, - 17, 19, - 29, 31, - 41, 43

We will write a function step with parameters:

g (integer >= 2) which indicates the step we are looking for,

m (integer >= 2) which gives the start of the search (m inclusive),

n (integer >= m) which gives the end of the search (n inclusive)

In the example above step(2, 2, 50) will return [3, 5] which is the first pair between 2 and 50 with a 2-steps.

So this function should return the first pair of the two prime numbers spaced with a step of g between the limits m, n if these g-steps prime numbers exist otherwise nil or null or None or Nothing or [] or "0, 0" or {0, 0} or 0 0 or "" (depending on the language).

Examples:
step(2, 5, 7) --> [5, 7] or (5, 7) or {5, 7} or "5 7"

step(2, 5, 5) --> nil or ... or [] in Ocaml or {0, 0} in C++

step(4, 130, 200) --> [163, 167] or (163, 167) or {163, 167}

See more examples for your language in "TESTS"

Remarks:
([193, 197] is also such a 4-steps primes between 130 and 200 but it's not the first pair).

step(6, 100, 110) --> [101, 107] though there is a prime between 101 and 107 which is 103; the pair 101-103 is a 2-step.

Notes:
The idea of "step" is close to that of "gap" but it is not exactly the same. For those interested they can have a look at http://mathworld.wolfram.com/PrimeGaps.html.

A "gap" is more restrictive: there must be no primes in between (101-107 is a "step" but not a "gap". Next kata will be about "gaps":-).

For Go: nil slice is expected when there are no step between m and n. Example: step(2,4900,4919) --> nil
*/

class G9647 {
    public static step = (
        step: number,
        min: number,
        max: number
    ): number[] | null => {
        let solution: number[] = [];
        let primesArr: number[] = [];

        // GET ALL PRIMES WITHIN RANGE (MIN - MAX)

        // ISPRIME() FROM PREVIOUS CODEWARS EXAMPLE
        const isPrime = (num: number) => {
            for (let i = 2; i <= Math.sqrt(num); i++) {
                if (num % i === 0) {
                    return false;
                }
            }
            return true;
        };

        // FIND PRIMES RANGING FROM 2 TO HALF OF NUM [ 101, 103, 107, 109 ]
        for (let i = min; i <= max; i++) {
            let prime = 0;
            if (isPrime(i)) {
                prime = i;
                primesArr.push(prime);
            }
        }

        // [ 101, 103, 107, 109 ]
        // console.log("primesArr", primesArr);

        // LOOP OVER PRIMES ARRAY AND CHECK IF SUCH STEP EXISTS BETWEEN ELEMENTS
        for (let i = 0; i < primesArr.length; i += 1) {
            console.log(primesArr[i]);
            for (let j = i + 1; j < primesArr.length; j += 1) {
                // console.log("difference", primesArr[j] - primesArr[i]);
                const diff: number = primesArr[j] - primesArr[i];
                if (diff === step) {
                    solution = [primesArr[i], primesArr[j]];
                    return solution;
                }
            }
        }

        // RETURN NULL IF NO SUCH STEP EXISTS
        return null;
    };
}

/*

❗️❗️❗️ ALL DIFFERENCES ❗️❗️❗️

primesArr [ 101, 103, 107, 109 ]
101
difference 2
difference 6
103
difference 4
difference 6
107
difference 2
109
[ 103, 109 ]

❗️❗️❗️ WE ONLY NEED THE FIRST ONE SO WE CAN RETURN AFTER 101- 6 IS FOUND ❗️❗️❗️
primesArr [ 101, 103, 107, 109 ]
101
difference 2
difference 6
[ 101, 107 ]

*/

// testing(solution.G964.step(2,100,110), [101, 103]);
//         testing(solution.G964.step(4,100,110), [103, 107]);
//         testing(solution.G964.step(6,100,110), [101, 107]);
//         testing(solution.G964.step(8,300,400), [359, 367]);
//         testing(solution.G964.step(10,300,400), [307, 317]);

// [101, 103]
// console.log(G9647.step(2, 100, 110));
// [103, 107]
// console.log(G9647.step(4, 100, 110));
// [101, 107]
// console.log(G9647.step(6, 100, 110));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// class G96472 {
//     private static prime = (n) => {
//         if (n == 2) {
//             return true;
//         } else if (n < 2 || n % 2 == 0) {
//             return false;
//         } else {
//             for (var i = 3; i <= Math.sqrt(n); i += 2) {
//                 if (n % i == 0) return false;
//             }
//             return true;
//         }
//     };

//     public static step = (g, m, n) => {
//         var res = [];
//         var i = m;
//         while (i <= n - g) {
//             if (G96472.prime(i) && G96472.prime(i + g)) {
//                 res.push(i);
//                 res.push(i + g);
//                 return res;
//             }
//             i++;
//         }
//         return null;
//     };
// }

class G96473 {
    public static step(
        g: number,
        start: number,
        end: number
    ): [number, number] | null {
        for (let n = start; n <= end - g; n++) {
            if (this.isPrime(n) && this.isPrime(n + g)) return [n, n + g];
        }
        return null;
    }

    private static isPrime(n: number): boolean {
        if (n === 2) return true;
        if (n % 2 === 0 || n < 2) return false;

        for (let i = 3; i <= Math.trunc(Math.sqrt(n)); i += 2) {
            if (n % i === 0) return false;
        }

        return true;
    }
}

// ==============================================================

// ❗️❗️❗️ FUNCTION TYPE ❗️❗️❗️

type Step = (step: number, start: number, end: number) => number[];
type GeneratePrimeNumber = (endNumber: number) => Boolean[];

// class G96474 {
//   static generatePrimeNumber: GeneratePrimeNumber = (endNumber) => {
//     let arr: Boolean[] = new Array<Boolean>(endNumber).fill(true);
//     for (let i = 2; i**2 <= endNumber; i++) {
//       if (arr[i] === true) {
//         for (let j = i**2, n = 1; j <= endNumber; j = i**2 + n*i, n++) {
//           arr[j] = false;
//         }
//       }
//     }

//     return arr;
//   }

//   public static step: Step = (step, start, end)  => {
//     const primeNumberArr = G96474.generatePrimeNumber(end);
//     for (let i = start; i <= end; i++) {
//       if (primeNumberArr[i] === true && primeNumberArr[i + step] === true) {
//         return [i, i + step];
//       }
//     }

//     return null;
//   }
// }

// Time: 3309ms Passed: 4Failed: 1Errors: 1Exit Code: 1
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: RAINFALL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
dataand data1 are two strings with rainfall records of a few cities for months from January to December. The records of towns are separated by \n. The name of each town is followed by :.

data and towns can be seen in "Your Test Cases:".

Task:
function: mean(town, strng) should return the average of rainfall for the city town and the strng data or data1 (In R and Julia this function is called avg).
function: variance(town, strng) should return the variance of rainfall for the city town and the strng data or data1.
Examples:
mean("London", data), 51.19(9999999999996) 
variance("London", data), 57.42(833333333374)
Notes:
if functions mean or variance have as parameter town a city which has no records return -1 or -1.0 (depending on the language)

Don't truncate or round: the tests will pass if abs(your_result - test_result) <= 1e-2 or abs((your_result - test_result) / test_result) <= 1e-6 depending on the language.

Shell tests only variance

A ref: http://www.mathsisfun.com/data/standard-deviation.html

data and data1 (can be named d0 and d1 depending on the language; see "Sample Tests:") are adapted from: http://www.worldclimate.com

❗️❗️❗️ VARIANCE ❗️❗️❗️
https://www.scribbr.com/statistics/variance/

Steps for calculating the variance
The variance is usually calculated automatically by whichever software you use for your statistical analysis. But you can also calculate it by hand to better understand how the formula works.

There are five main steps for finding the variance by hand. We’ll use a small data set of 6 scores to walk through the steps.

Data set
46	69	32	60	52	41
Step 1: Find the mean
To find the mean, add up all the scores, then divide them by the number of scores.

Mean (\bar{x})
\bar{x} = (46 + 69 + 32 + 60 + 52 + 41) \div 6 = 50
Step 2: Find each score’s deviation from the mean
Subtract the mean from each score to get the deviations from the mean.

Since x̅ = 50, take away 50 from each score.

Score	Deviation from the mean
46	46 – 50 = -4
69	69 – 50 = 19
32	32 – 50 = -18
60	60 – 50 = 10
52	52 – 50 = 2
41	41 – 50 = -9
Step 3: Square each deviation from the mean
Multiply each deviation from the mean by itself. This will result in positive numbers.

Squared deviations from the mean
(-4)2 = 4 × 4 = 16
192 = 19 × 19 = 361
(-18)2 = -18 × -18 = 324
102 = 10 × 10 = 100
22 = 2 × 2 = 4
(-9)2 = -9 × -9 = 81
Step 4: Find the sum of squares
Add up all of the squared deviations. This is called the sum of squares.

Sum of squares
16 + 361 + 324 + 100 + 4 + 81 = 886
Step 5: Divide the sum of squares by n – 1 or N
Divide the sum of the squares by n – 1 (for a sample) or N (for a population).

Since we’re working with a sample, we’ll use  n – 1, where n = 6.

Variance
 886 \div (6 – 1) = 886 \div 5 = 177.2


*/

// ❗️❗️❗️ CODEWARS ERROR: 'this' cannot be referenced in a static property initializer. (2334) ❗️❗️❗️
class G9646 {
    public static getFigures = (town: string, dataStr: string): string[] => {
        // SPLIT DATA INTO ARRAYS FOR EACH TOWN
        const townsArr: string[] = dataStr.split("\n");
        console.log(townsArr);
        // GET TARGET TOWN AND ITS MONTHLY READINGS
        // ['London:Jan 48.0,Feb 38.9,Mar 39.9,Apr 42.2,May 47.3,Jun 52.1,Jul 59.5,Aug 57.2,Sep 55.4,Oct 62.0,Nov 59.0,Dec 52.9']
        const townRec: string[] = townsArr.filter(
            (townData) =>
                // ❗️❗️❗️ STARTSWITH NOT WORKING IN CODEWARS ❗️❗️❗️
                townData.startsWith(town)
            // townData.indexOf(town) > -1
        );
        console.log(townRec);
        // EXTRACT ALL NUMERIC FIGURES
        // ['48.0', '38.9','39.9', '42.2','47.3', '52.1','59.5', '57.2','55.4', '62.0','59.0', '52.9']
        const monthRec: string[] = townRec[0].match(/\d{0,}\.\d{0,}/g)!;
        // console.log(monthRec);

        return monthRec;
    };

    public static mean = (town: string, str: string) => {
        // ['48.0', '38.9','39.9', '42.2','47.3', '52.1','59.5', '57.2','55.4', '62.0','59.0', '52.9']
        // ==> 51.199999999999996
        const solution: number =
            G9646.getFigures(town, str)
                .map((figure) => Number(figure))
                .reduce((acc, curr) => acc + curr) /
            G9646.getFigures(town, str).length;

        // console.log(solution);
        // 51.199999999999996
        return solution;
    };
    public static variance = (town: string, str: string) => {
        // 1. FIND MEAN:
        const average: number = this.mean(town, str);
        console.log(average);

        // GET ALL NUMERIC FIGURES
        const solution: number =
            this.getFigures(town, str)
                .map((figure) => Number(figure))
                // 2. FIND EACH EL'S DEVIATION FROM MEAN
                .map((num) => num - average)
                // 3. SQUARE EACH EL
                .map((dev) => Math.pow(dev, 2))
                // 4. GET SUM OF SQUARES
                .reduce((acc, curr) => acc + curr) /
            // 5 DIVIDE SUM OF SQUARES BY n (NUMBER OF ELEMENTS)
            this.getFigures(town, str).length;

        // console.log(solution);

        return solution;
    };
}

/*
 class G964 {

   public static getFigures = (town: string, dataStr: string): string[] => {
     
        console.log("input-----------------------", town, dataStr, "-----------------------end");
     
        // SPLIT DATA INTO ARRAYS FOR EACH TOWN
        const townsArr: string[] = dataStr.split("\n");
        console.log(townsArr);
        // GET TARGET TOWN AND ITS MONTHLY READINGS
        // ['London:Jan 48.0,Feb 38.9,Mar 39.9,Apr 42.2,May 47.3,Jun 52.1,Jul 59.5,Aug 57.2,Sep 55.4,Oct 62.0,Nov 59.0,Dec 52.9']
        const townRec: string[] = townsArr.filter((townData) =>
//             townData.startsWith(town)
            townData.indexOf(town) > -1                              
        );
     
        if (townRec.length === 0) {
          console.log("------------empty array-------------");
        }
     
//         console.log(townRec);
        // EXTRACT ALL NUMERIC FIGURES
        // ['48.0', '38.9','39.9', '42.2','47.3', '52.1','59.5', '57.2','55.4', '62.0','59.0', '52.9']
        const monthRec: string[] = townRec[0].match(/\d{0,}\.\d{0,}/g)!;
        // console.log(monthRec);

        return monthRec;
    };

    public static mean = (town: string, str: string) => {
      
//         if (G964.getFigures(town, str).length === 0) {
//           return -1;
//         }
      
        // ['48.0', '38.9','39.9', '42.2','47.3', '52.1','59.5', '57.2','55.4', '62.0','59.0', '52.9']
        // ==> 51.199999999999996
        const solution: number =
            G964.getFigures(town, str)
                .map((figure) => Number(figure))
                .reduce((acc, curr) => acc + curr) /
            G964.getFigures(town, str).length;

        // console.log(solution);
        // 51.199999999999996
        return solution;
    };
    public static variance = (town: string, str: string) => {
      
//         if (G964.getFigures(town, str).length === 0) {
//           return -1;
//         }
      
        // 1. FIND MEAN:
        const average: number = G964.mean(town, str);
//         console.log(average);

        // GET ALL NUMERIC FIGURES
        const solution: number =
            G964.getFigures(town, str)
                .map((figure) => Number(figure))
                // 2. FIND EACH EL'S DEVIATION FROM MEAN
                .map((num) => num - average)
                // 3. SQUARE EACH EL
                .map((dev) => Math.pow(dev, 2))
                // 4. GET SUM OF SQUARES
                .reduce((acc, curr) => acc + curr) /
            // 5. DIVIDE SUM OF SQUARES BY n (NUMBER OF ELEMENTS)
            G964.getFigures(town, str).length;

        // console.log(solution);

        return solution;
    };
}
*/

const data =
    "Rome:Jan 81.2,Feb 63.2,Mar 70.3,Apr 55.7,May 53.0,Jun 36.4,Jul 17.5,Aug 27.5,Sep 60.9,Oct 117.7,Nov 111.0,Dec 97.9" +
    "\n" +
    "London:Jan 48.0,Feb 38.9,Mar 39.9,Apr 42.2,May 47.3,Jun 52.1,Jul 59.5,Aug 57.2,Sep 55.4,Oct 62.0,Nov 59.0,Dec 52.9" +
    "\n" +
    "Paris:Jan 182.3,Feb 120.6,Mar 158.1,Apr 204.9,May 323.1,Jun 300.5,Jul 236.8,Aug 192.9,Sep 66.3,Oct 63.3,Nov 83.2,Dec 154.7" +
    "\n" +
    "NY:Jan 108.7,Feb 101.8,Mar 131.9,Apr 93.5,May 98.8,Jun 93.6,Jul 102.2,Aug 131.8,Sep 92.0,Oct 82.3,Nov 107.8,Dec 94.2" +
    "\n" +
    "Vancouver:Jan 145.7,Feb 121.4,Mar 102.3,Apr 69.2,May 55.8,Jun 47.1,Jul 31.3,Aug 37.0,Sep 59.6,Oct 116.3,Nov 154.6,Dec 171.5" +
    "\n" +
    "Sydney:Jan 103.4,Feb 111.0,Mar 131.3,Apr 129.7,May 123.0,Jun 129.2,Jul 102.8,Aug 80.3,Sep 69.3,Oct 82.6,Nov 81.4,Dec 78.2" +
    "\n" +
    "Bangkok:Jan 10.6,Feb 28.2,Mar 30.7,Apr 71.8,May 189.4,Jun 151.7,Jul 158.2,Aug 187.0,Sep 319.9,Oct 230.8,Nov 57.3,Dec 9.4" +
    "\n" +
    "Tokyo:Jan 49.9,Feb 71.5,Mar 106.4,Apr 129.2,May 144.0,Jun 176.0,Jul 135.6,Aug 148.5,Sep 216.4,Oct 194.1,Nov 95.6,Dec 54.4" +
    "\n" +
    "Beijing:Jan 3.9,Feb 4.7,Mar 8.2,Apr 18.4,May 33.0,Jun 78.1,Jul 224.3,Aug 170.0,Sep 58.4,Oct 18.0,Nov 9.3,Dec 2.7" +
    "\n" +
    "Lima:Jan 1.2,Feb 0.9,Mar 0.7,Apr 0.4,May 0.6,Jun 1.8,Jul 4.4,Aug 3.1,Sep 3.3,Oct 1.7,Nov 0.5,Dec 0.7";
const data1 =
    "Rome:Jan 90.2,Feb 73.2,Mar 80.3,Apr 55.7,May 53.0,Jun 36.4,Jul 17.5,Aug 27.5,Sep 60.9,Oct 147.7,Nov 121.0,Dec 97.9" +
    "\n" +
    "London:Jan 58.0,Feb 38.9,Mar 49.9,Apr 42.2,May 67.3,Jun 52.1,Jul 59.5,Aug 77.2,Sep 55.4,Oct 62.0,Nov 69.0,Dec 52.9" +
    "\n" +
    "Paris:Jan 182.3,Feb 120.6,Mar 188.1,Apr 204.9,May 323.1,Jun 350.5,Jul 336.8,Aug 192.9,Sep 66.3,Oct 63.3,Nov 83.2,Dec 154.7" +
    "\n" +
    "NY:Jan 128.7,Feb 121.8,Mar 151.9,Apr 93.5,May 98.8,Jun 93.6,Jul 142.2,Aug 131.8,Sep 92.0,Oct 82.3,Nov 107.8,Dec 94.2" +
    "\n" +
    "Vancouver:Jan 155.7,Feb 121.4,Mar 132.3,Apr 69.2,May 85.8,Jun 47.1,Jul 31.3,Aug 37.0,Sep 69.6,Oct 116.3,Nov 154.6,Dec 171.5" +
    "\n" +
    "Sydney:Jan 123.4,Feb 111.0,Mar 151.3,Apr 129.7,May 123.0,Jun 159.2,Jul 102.8,Aug 90.3,Sep 69.3,Oct 82.6,Nov 81.4,Dec 78.2" +
    "\n" +
    "Bangkok:Jan 20.6,Feb 28.2,Mar 40.7,Apr 81.8,May 189.4,Jun 151.7,Jul 198.2,Aug 197.0,Sep 319.9,Oct 230.8,Nov 57.3,Dec 9.4" +
    "\n" +
    "Tokyo:Jan 59.9,Feb 81.5,Mar 106.4,Apr 139.2,May 144.0,Jun 186.0,Jul 155.6,Aug 148.5,Sep 216.4,Oct 194.1,Nov 95.6,Dec 54.4" +
    "\n" +
    "Beijing:Jan 13.9,Feb 14.7,Mar 18.2,Apr 18.4,May 43.0,Jun 88.1,Jul 224.3,Aug 170.0,Sep 58.4,Oct 38.0,Nov 19.3,Dec 2.7" +
    "\n" +
    "Lima:Jan 11.2,Feb 10.9,Mar 10.7,Apr 10.4,May 10.6,Jun 11.8,Jul 14.4,Aug 13.1,Sep 23.3,Oct 1.7,Nov 0.5,Dec 10.7";

// 51.199999999999996
// console.log(G9646.mean("London", data));
// 57.42833333333374
// console.log(G9646.variance("London", data));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: BACKWARDS READ PRIMES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ ISPRIME() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Backwards Read Primes are primes that when read backwards in base 10 (from right to left) are a different prime. (This rules out primes which are palindromes.)

Examples:
13 17 31 37 71 73 are Backwards Read Primes
13 is such because it's prime and read from right to left writes 31 which is prime too. Same for the others.

Task
Find all Backwards Read Primes between two positive given numbers (both inclusive), the second one always being greater than or equal to the first one. The resulting array or the resulting string will be ordered following the natural order of the prime numbers.

Examples (in general form):
backwardsPrime(2, 100) => [13, 17, 31, 37, 71, 73, 79, 97] backwardsPrime(9900, 10000) => [9923, 9931, 9941, 9967] backwardsPrime(501, 599) => []

See "Sample Tests" for your language.

Notes
Forth Return only the first backwards-read prime between start and end or 0 if you don't find any
Ruby Don't use Ruby Prime class, it's disabled.
*/

// 1️⃣
const backwardsPrime = (min: number, max: number): number[] => {
    let primesArr: number[] = [];

    // GET ALL PRIMES WITHIN RANGE (MIN - MAX)

    // DETERMINE WHETER NUM IS PRIME

    const isPrime = (num: number) => {
        if (num === 1 || num === 2) return true;
        for (let i = 2; i < num; i++) {
            // console.table({num: num, divider: i});
            if (num % i === 0) return false;
        }
        return true;
    };

    //   FIND PRIMES
    for (let i = min; i <= max; i++) {
        let prime = 0;
        if (isPrime(i)) {
            prime = i;
            // console.log("prime found: ", prime);
            primesArr.push(prime);
        }
    }
    // [7001, 7013, 7019,7027, 7039, 7043,7057, 7069, 7079]
    console.log("PRIMES:", primesArr);

    // REVERSE FOUND PRIMES
    // 1007 3107 9107 7207 9307 3407 7507 9607 9707

    const solution: number[] = primesArr.filter((prime) => {
        const revPrime: number = Number(
            prime.toString().split("").reverse().join("")
        );
        return isPrime(revPrime) && revPrime !== prime;
    });

    // console.log("   TEST:", solution2);
    // [ 7207, 3407, 7507 ]
    return solution;
};

// 2️⃣  https://www.tutorialspoint.com/prime-numbers-in-a-range-javascript

const backwardsPrime2 = (min: number, max: number): number[] => {
    let primesArr: number[] = [];

    // GET ALL PRIMES WITHIN RANGE (MIN - MAX)

    // DETERMINE WHETER NUM IS PRIME
    const isPrime = (num: number) => {
        let count = 2;
        while (count < num / 2 + 1) {
            if (num % count !== 0) {
                count++;
                continue;
            }
            return false;
        }
        return true;
    };

    const primeBetween = (a: number, b: number) => {
        // let count = 0;
        for (let i = Math.min(a, b); i <= Math.max(a, b); i++) {
            if (isPrime(i)) {
                //   count++;
                primesArr.push(i);
            }
        }
        // return count;
    };

    //   FIND PRIMES
    primeBetween(min, max);

    // [7001, 7013, 7019,7027, 7039, 7043,7057, 7069, 7079]
    console.log("PRIMES:", primesArr);

    // REVERSE FOUND PRIMES
    // 1007 3107 9107 7207 9307 3407 7507 9607 9707

    const solution: number[] = primesArr.filter((prime) => {
        const revPrime: number = Number(
            prime.toString().split("").reverse().join("")
        );
        return isPrime(revPrime) && revPrime !== prime;
    });

    // console.log("   TEST:", solution2);
    // [ 7207, 3407, 7507 ]
    return solution;
};

// 3️⃣ https://www.programiz.com/javascript/examples/prime-number-intervals
const backwardsPrime3 = (min: number, max: number): number[] => {
    let primesArr: number[] = [];

    function isPrime(num: number) {
        for (var i = 2; i < num; i++) if (num % i === 0) return false;
        return num > 1;
    }

    // GET ALL PRIMES WITHIN RANGE (MIN - MAX)

    // looping from lowerNumber to higherNumber
    for (let i = min; i <= max; i++) {
        let flag = 0;

        // looping through 2 to user input number
        for (let j = 2; j < i; j++) {
            if (i % j == 0) {
                flag = 1;
                break;
            }
        }

        // if number greater than 1 and not divisible by other numbers
        if (i > 1 && flag == 0) {
            // console.log(i);
            primesArr.push(i);
        }
    }
    // [7001, 7013, 7019,7027, 7039, 7043,7057, 7069, 7079]
    console.log("PRIMES:", primesArr);

    // REVERSE FOUND PRIMES
    // 1007 3107 9107 7207 9307 3407 7507 9607 9707

    const solution: number[] = primesArr.filter((prime) => {
        const revPrime: number = Number(
            prime.toString().split("").reverse().join("")
        );
        return isPrime(revPrime) && revPrime !== prime;
    });

    // console.log("   TEST:", solution2);
    // [ 7207, 3407, 7507 ]
    return solution;
};

// 4️⃣ ✅  ❗️❗️❗️ ISPRIME(): https://gist.github.com/sandrabosk/17319bb427dc4e457595d6670a455f57 ❗️❗️❗️
const backwardsPrime4 = (min: number, max: number): number[] => {
    let primesArr: number[] = [];

    // GET ALL PRIMES WITHIN RANGE (MIN - MAX)

    // ❗️❗️❗️ DETERMINE WHETER NUM IS PRIME ❗️❗️❗️
    const isPrime = (num: number) => {
        for (let i = 2; i <= Math.sqrt(num); i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    };

    //   FIND PRIMES [7001, 7013, 7019,7027, 7039, 7043,7057, 7069, 7079]
    for (let i = min; i <= max; i++) {
        let prime = 0;
        if (isPrime(i)) {
            prime = i;
            primesArr.push(prime);
        }
    }

    // FILTER OUT PRIMES THAT EQUAL TO THEIR REVERSED VERSIONS AND NOT PALINDROMES
    // 1007 3107 9107 7207 9307 3407 7507 9607 9707
    const solution: number[] = primesArr.filter((prime) => {
        const revPrime: number = Number(
            prime.toString().split("").reverse().join("")
        );
        return isPrime(revPrime) && revPrime !== prime;
    });

    // [ 7207, 3407, 7507 ]
    return solution;
};
// [7027, 7043, 7057]
// console.log(backwardsPrime(7000, 7100));
//  TO EQUAL [ 70001, 70009, 70061, 70079, 70121, 70141, 70163,        70241 ]
// console.log(backwardsPrime4(70000, 70245));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
function backwardsPrime5(start: number, stop: number): number[] {
    const prime = [];
    for (let i = start < 10 ? 11 : start; i <= stop; i++) {
        if (isPrime(i)) {
            if (isPrime(Number(i.toString().split("").reverse().join("")))) {
                if (!isPalindrome(String(i))) {
                    prime.push(i);
                }
            }
        }
    }

    return prime;
}

export const isPrime = (num: number): boolean => {
    for (let i = 2, s = Math.sqrt(num); i <= s; i++)
        if (num % i === 0) return false;
    return num > 1;
};

export function isPalindrome(str: string): boolean {
    return str == str.split("").reverse().join("");
}

// ===========================================================

function isPrime2(num: number): boolean {
    for (let i = 2; i * i <= num; i++) {
        if (num % i === 0) return false;
    }
    return true;
}
export function backwardsPrime7(start: number, stop: number): number[] {
    const result: number[] = [];
    for (let num = start; num <= stop; num++) {
        if (!isPrime2(num)) continue;
        const backward = parseInt(num.toString().split("").reverse().join(""));
        if (backward !== num && isPrime2(backward)) result.push(num);
    }
    return result;
}
// ===========================================================

function isPrime3(n: number): boolean {
    for (var x = 2; x <= Math.sqrt(n); x++) {
        if (n % x === 0) {
            return false;
        }
    }

    return n > 1;
}

function reverseNumber(n: number): number {
    return Number(String(n).split("").reverse().join(""));
}

export function backwardsPrime8(start: number, stop: number): number[] {
    var output: number[] = [];

    for (let n = start; n <= stop; n++) {
        let m: number = reverseNumber(n);

        if (m != n && isPrime3(n) && isPrime3(m)) {
            output.push(n);
        }
    }

    return output;
}
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: CHARACTER WITH LONGEST CONSECUTIVE REPETITION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: REGEX, MATCH()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: https://stackoverflow.com/questions/1660694/regular-expression-to-match-any-character-being-repeated-more-than-10-times
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
For a given string s find the character c (or C) with longest consecutive repetition and return:

[c, l]: [string, number]
where l (or L) is the length of the repetition. If there are two or more characters with the same l return the first in order of appearance.

For empty string return:

["", 0]
In JavaScript: If you use Array.sort in your solution, you might experience issues with the random tests as Array.sort is not stable in the Node.js version used by CodeWars. This is not a kata issue.

Happy coding! :)
*/
const longestRepetition = (str: string): [string, number] => {
    if (!str) return ["", 0];

    // const re = /([a-z])\1{0,}/g;
    const re = /(.)\1{0,}/g;
    // [ 'bbb', 'aaa', 'aaaa' ]
    const matchesArr: string[] = str.match(re)!;
    console.log(matchesArr);
    // [ 'aaaa', 'bbb', 'aaa' ]
    const descArr: string[] = matchesArr.sort((a, b) => b.length - a.length);
    console.log(descArr);
    // a 4 - FIRST CHAR OF LONGEST ELEMENT AND ITS LENGTH
    console.log(descArr[0][0], descArr[0].length);

    const solution: [string, number] = [descArr[0][0], descArr[0].length];

    return solution;
};

// ❗️❗️❗️ MATCH REPEATING CHARACTERS: /(.)\1{1,}/
// ❗️❗️❗️ MATCH REPEATING LETTERS, MORE THAN 1: ([a-z])\1{1,}  THIS DOES NOT MATCH "a", "b" IN "ab"
// ❗️❗️❗️ MATCH ALL CONSECUTIVE LETTERS (SINGLE TO INFINITY), MORE THAN 0: ([a-z])\1{0,} ❗️❗️❗️ THIS MATCHES "a", "b" IN "ab" ❗️❗️❗️
// ❗️❗️❗️ WORKS FOR ALL CHARACTERS /(.)\1{0,}/g ❗️❗️❗️

//   assert.deepStrictEqual(longestRepetition('aaaabb'), ['a', 4])
// assert.deepStrictEqual(longestRepetition('bbbaaabaaaa'), ['a', 4])
//   assert.deepStrictEqual(longestRepetition('cbdeuuu900'), ['u', 3])
//   assert.deepStrictEqual(longestRepetition('abbbbb'), ['b', 5])
//   assert.deepStrictEqual(longestRepetition('aabb'), ['a', 2])
//   assert.deepStrictEqual(longestRepetition('ba'), ['b', 1])
//   assert.deepStrictEqual(longestRepetition(''), ['', 0])

// console.log(longestRepetition('ba'));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function longestRepetition2(text: string): [string, number] {
    const output: [string, number] = ["", 0];
    text.match(/(.)\1*/g)?.forEach((match) => {
        if (match?.length > output[1]) {
            output[0] = match.charAt(0);
            output[1] = match.length;
        }
    });
    return output;
}

function longestRepetition3(text: string): [string, number] {
    let longest = { char: "", len: 0 };
    let current = { ...longest };

    text.split("").forEach((character) => {
        if (character === current.char) {
            current.len += 1;
        } else {
            current.char = character;
            current.len = 1;
        }

        if (current.len > longest.len) {
            longest.char = current.char;
            longest.len = current.len;
        }
    });

    return [longest.char, longest.len];
}

function longestRepetition4(text: string): [string, number] {
    let currentChar: string = "";
    let currentCount: number = 0;
    let maxChar: string = "";
    let maxCount: number = 0;

    for (let i = 0; i <= text.length; i++) {
        let char: string = text[i];

        if (char === currentChar) {
            currentCount++;
        } else {
            if (currentCount > maxCount) {
                maxCount = currentCount;
                maxChar = currentChar;
            }

            currentChar = char;
            currentCount = 1;
        }
    }

    return [maxChar, maxCount];
}

function longestRepetition5(text: string): [string, number] {
    let longest: { char: string; repeat: number } = { char: "", repeat: 0 };
    let attempt: { char: string; repeat: number } = { char: "", repeat: 0 };

    text.split("").forEach((alpha: string) => {
        if (alpha === attempt.char) attempt.repeat += 1;
        else attempt = { char: alpha, repeat: 1 };

        if (attempt.repeat > longest.repeat) {
            longest.repeat = attempt.repeat;
            longest.char = attempt.char;
        }
    });

    return [longest.char, longest.repeat];
}

function longestRepetition6(text: string): [string, number] {
    // Implement me! :)

    const match = text.match(/(\w)\1*/gm);
    if (match) {
        const res = match.sort((a, b) => b.length - a.length)[0];
        return [res[0], res.length];
    }

    return ["", 0];
}

function longestRepetition7(text: string): [string, number] {
    return text
        .split("")
        .reduce((acc: [string, number][], curr) => {
            const last = acc[acc.length - 1];
            if (!!last && last[0] === curr) {
                last[1] += 1;
            } else {
                acc.push([curr, 1]);
            }
            return acc;
        }, [])
        .reduce((acc, curr) => (curr[1] > acc[1] ? curr : acc), ["", 0]);
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: DECIPHER THIS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: REPLACE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You are given a secret message you need to decipher. Here are the things you need to know to decipher it:

For each word:

the second and the last letter is switched (e.g. Hello becomes Holle)
the first letter is replaced by its character code (e.g. H becomes 72)
Note: there are no special characters used, only letters and spaces

Examples

decipherThis('72olle 103doo 100ya'); // 'Hello good day'
decipherThis('82yade 115te 103o'); // 'Ready set go'

*/
const decipherThis = (str: string): string => {
    const wordsArr: string[] = str.split(" ");

    // FIND CHAR CODE AND REPLACE WITH ITS CHAR
    wordsArr.forEach((word, idx) => {
        // EXTRACT CODE
        let charCode: number = Number(word.match(/\d+/g));
        // FIND CORRESPONDING CHAR
        const char: string = String.fromCharCode(charCode);
        // REPLACE
        wordsArr[idx] = word.replace(/\d+/g, char);
    });

    // SWAP 2ND FOR LAST
    wordsArr.forEach((word, idx) => {
        if (word.length > 2) {
            const second: string = word[1];
            const last: string = word[word.length - 1];
            const lettersArr: string[] = word.split("");
            lettersArr[1] = last;
            lettersArr[lettersArr.length - 1] = second;
            wordsArr[idx] = lettersArr.join("");
        }
    });
    // JOIN INTO STRING
    const solution: string = wordsArr.join(" ");

    return solution;
};

/*
[
  '72eva',  '97',
  '103o',   '97t',
  '116sih', '97dn',
  '115ee',  '104wo',
  '121uo',  '100o'
]
72
H
72eva
97
a
97
103
g
103o
97
a
97t
116
t
116sih
97
a
97dn
115
s
115ee
104
h
104wo
121
y
121uo
100
d
100o
[
  'Heva', 'a',    'go',
  'at',   'tsih', 'adn',
  'see',  'hwo',  'yuo',
  'do'
]
[ 'H', 'e', 'v', 'a' ]
[ 't', 's', 'i', 'h' ]
[ 'a', 'd', 'n' ]
[ 's', 'e', 'e' ]
[ 'h', 'w', 'o' ]
[ 'y', 'u', 'o' ]
[
  'Have', 'a',    'go',
  'at',   'this', 'and',
  'see',  'how',  'you',
  'do'
]
Have a go at this and see how you do
*/

// Test.assertEquals(decipherThis('72eva 97 103o 97t 116sih 97dn 115ee 104wo 121uo 100o'), 'Have a go at this and see how you do');

// 'Have a go at this and see how you do'
// console.log(
//     decipherThis("72eva 97 103o 97t 116sih 97dn 115ee 104wo 121uo 100o")
// );
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
function decipherThis2(str: string): string {
    return str
        .split(" ")
        .map((word) => {
            const asciiCode = parseInt(word);
            const asciiCodeDigits = asciiCode.toString().length;
            const newWord =
                String.fromCharCode(asciiCode) + word.substr(asciiCodeDigits);

            if (newWord.length <= 2) {
                return newWord;
            } else {
                return (
                    newWord[0] +
                    newWord[newWord.length - 1] +
                    newWord.substring(2, newWord.length - 1) +
                    newWord[1]
                );
            }
        })
        .join(" ");
}

function decipherThis3(str: string): string {
    return str
        .replace(/(\d+)/g, (code) => String.fromCharCode(+code))
        .replace(/\b(\w)(\w?)(\w*)(\w)/g, "$1$4$3$2");
}

function decipherThis4(str: string): string {
    return str
        .split(" ")
        .map((word) =>
            word.replace(/^[0-9]{0,}/, (e) => String.fromCharCode(+e))
        )
        .map((word) =>
            word.length <= 2
                ? word
                : word[0] +
                  word[word.length - 1] +
                  word.slice(2, word.length - 1) +
                  word[1]
        )
        .join(" ");
}

function decipherThis5(str: string): string {
    return str
        .split(" ")
        .map((word) =>
            word.replace(
                /(^\d{2,3})([a-z]?)([a-z]*?)([a-z]?$)/,
                (match, p1, p2, p3, p4) =>
                    `${String.fromCharCode(p1)}${p4}${p3}${p2}`
            )
        )
        .join(" ");
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: LENGTH OF MISSING ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You get an array of arrays.
If you sort the arrays by their length, you will see, that their length-values are consecutive.
But one array is missing!


You have to write a method, that return the length of the missing array.

Example:
[[1, 2], [4, 5, 1, 1], [1], [5, 6, 7, 8, 9]] --> 3

If the array of arrays is null/nil or empty, the method should return 0.

When an array in the array is null or empty, the method should return 0 too!
There will always be a missing element and its length will be always between the given arrays.

*/
const getLengthOfMissingArray = (arrayOfArrays: any[][]): number => {
    if (arrayOfArrays.length === 0) return 0;

    let solution: number = 0;

    // SORT ASCENDING BY LENGTH OF ARRAYS
    // [ [ 1 ], [ 1, 2 ], [ 4, 5, 1, 1 ], [ 5, 6, 7, 8, 9 ] ]
    const ascLenArr: any[][] = arrayOfArrays.sort(
        (a, b) => a.length - b.length
    );

    // COMPARE CURRENT LENGTH TO NEXT
    for (let i = 0; i < ascLenArr.length; i += 1) {
        if (ascLenArr[i].length === 0) return 0;
        let currLen: number = ascLenArr[i].length;
        if (currLen + 1 !== ascLenArr[i + 1].length) {
            solution = currLen + 1;
            break;
        }
    }

    return solution;
};

// assert.equal(solution.getLengthOfMissingArray([ [ 1, 2 ], [ 4, 5, 1, 1 ], [ 1 ], [ 5, 6, 7, 8, 9 ]] ), 3);
//     assert.equal(solution.getLengthOfMissingArray([ [ 5, 2, 9 ], [ 4, 5, 1, 1 ], [ 1 ], [ 5, 6, 7, 8, 9 ]] ), 2);
//     assert.equal(solution.getLengthOfMissingArray([ [ null ], [ null, null, null ] ] ), 2);
//     assert.equal(solution.getLengthOfMissingArray([ [ 'a', 'a', 'a' ], [ 'a', 'a' ], [ 'a', 'a', 'a', 'a' ], [ 'a' ], [ 'a', 'a', 'a', 'a', 'a', 'a' ]] ), 5);

//     assert.equal(solution.getLengthOfMissingArray([ ]), 0);

// 3
// console.log(
// getLengthOfMissingArray([[1, 2], [4, 5, 1, 1], [1], [5, 6, 7, 8, 9]])
// );
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
function getLengthOfMissingArray2(arrayOfArrays: any[]): number {
    const sortedLengthArray = arrayOfArrays
        .map((array) => array.length)
        .sort((a, b) => a - b);
    if (sortedLengthArray[0] === 0) return 0;
    return (
        --sortedLengthArray.filter(
            (a, index, array) => a - array[index - 1] !== 1
        )[1] || 0
    );
}

// function getLengthOfMissingArray3(arrayOfArrays: any[]): number {
//     if (
//         !arrayOfArrays ||
//         !arrayOfArrays.length ||
//         arrayOfArrays.some((x) => x === null) ||
//         arrayOfArrays.some((x) => !x.length)
//     )
//         return 0;
//     let arr: number[] = arrayOfArrays
//         .map((x) => x.length)
//         .sort((a, b) => a - b);
//     return arr.slice(1).find((x, i) => x - arr[i] != 1) - 1;
// }

// function getLengthOfMissingArray4(arrayOfArrays: any[][]): number {
//     if (arrayOfArrays.length <= 1) return 0;

//     const sortedLengths = arrayOfArrays
//       .map((arr) => arr.length)
//       .sort((a, b) => a - b);

//     if (sortedLengths[0] === 0) return 0;
//     return sortedLengths.find((len, i) => sortedLengths[i + 1] - len !== 1) + 1;
//   }

function getLengthOfMissingArray5(arrayOfArrays: any[]) {
    if (arrayOfArrays === null || arrayOfArrays.length === 0) return 0;
    for (let i = 0; i < arrayOfArrays.length; i++) {
        if (arrayOfArrays[i] === null || arrayOfArrays[i].length === 0)
            return 0;
    }
    arrayOfArrays = arrayOfArrays.sort(function (x, y) {
        return x.length > y.length ? 1 : -1;
    });
    for (let i = 1; i < arrayOfArrays.length; i++) {
        if (arrayOfArrays[i].length != arrayOfArrays[i - 1].length + 1)
            return arrayOfArrays[i - 1].length + 1;
    }
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: MAZE RUNNER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ SWITCH WITH IF ELSE ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Introduction
Welcome Adventurer. Your aim is to navigate the maze and reach the finish point without touching any walls. Doing so will kill you instantly!
Task
You will be given a 2D array of the maze and an array of directions. Your task is to follow the directions given. If you reach the end point before all your moves have gone, you should return Finish. If you hit any walls or go outside the maze border, you should return Dead. If you find yourself still in the maze after using all the moves, you should return Lost.
The Maze array will look like

maze = [[1,1,1,1,1,1,1],
        [1,0,0,0,0,0,3],
        [1,0,1,0,1,0,1],
        [0,0,1,0,0,0,1],
        [1,0,1,0,1,0,1],
        [1,0,0,0,0,0,1],
        [1,2,1,0,1,0,1]]
..with the following key

      0 = Safe place to walk
      1 = Wall
      2 = Start Point
      3 = Finish Point
  directions = "NNNNNEEEEE" == "Finish" // (directions passed as a string)
Rules
1. The Maze array will always be square i.e. N x N but its size and content will alter from test to test.

2. The start and finish positions will change for the final tests.

3. The directions array will always be in upper case and will be in the format of N = North, E = East, W = West and S = South.

4. If you reach the end point before all your moves have gone, you should return Finish.

5. If you hit any walls or go outside the maze border, you should return Dead.

6. If you find yourself still in the maze after using all the moves, you should return Lost.
*/
const mazeRunner = (maze: number[][], dirs: string[]): string => {
    // LOCATE START POINT
    let row: number = 0;
    let col: number = 0;

    for (let i = 0; i < maze.length; i += 1) {
        if (maze[i].includes(2)) {
            row = i;
            col = maze[i].indexOf(2);
            break;
        }
    }
    let curr: number = maze[row][col];
    // console.log("col:", col, "row:", row, "CURRENT:", curr);

    // TRACK PATH
    for (let i = 0; i < dirs.length; i += 1) {
        // for (let i = 0; i < 1; i += 1) {
        if (dirs[i] === "N") {
            row -= 1;
            if (row < 0) return "Dead";
            curr = maze[row][col];
            if (curr === 3) {
                return "Finish";
            } else if (curr === 1) {
                return "Dead";
            }
        }

        if (dirs[i] === "S") {
            row += 1;
            if (row > maze.length - 1) return "Dead";
            curr = maze[row][col];
            if (curr === 3) {
                return "Finish";
            } else if (curr === 1) {
                return "Dead";
            }
        }

        if (dirs[i] === "W") {
            col -= 1;
            if (col < 0) return "Dead";
            curr = maze[row][col];
            if (curr === 3) {
                return "Finish";
            } else if (curr === 1) {
                return "Dead";
            }
        }

        if (dirs[i] === "E") {
            col += 1;
            if (col > maze[row].length - 1) return "Dead";
            curr = maze[row][col];
            if (curr === 3) {
                return "Finish";
            } else if (curr === 1) {
                return "Dead";
            }
        }
    }
    // console.log("col:", col, "row:", row, "CURRENT:", curr);

    return "Lost";
};

let maze = [
    [1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 3],
    [1, 0, 1, 0, 1, 0, 1],
    [0, 0, 1, 0, 0, 0, 1],
    [1, 0, 1, 0, 1, 0, 1],
    [1, 0, 0, 0, 0, 0, 1],
    [1, 2, 1, 0, 1, 0, 1],
];

// assert.equal(mazeRunner(maze,["N","N","N","N","N","E","E","E","E","E"]), "Finish", "Expected Finish");
// assert.equal(mazeRunner(maze,["N","N","N","N","N","E","E","S","S","E","E","N","N","E"]), "Finish", "Expected Finish");
// assert.equal(mazeRunner(maze,["N","N","N","N","N","E","E","E","E","E","W","W"]), "Finish", "Expected Finish");

// assert.equal(mazeRunner(maze,["N","N","N","W","W"]), "Dead", "Expected Dead");
// assert.equal(mazeRunner(maze,["N","N","N","N","N","E","E","S","S","S","S","S","S"]), "Dead", "Expected Dead");

// assert.equal(mazeRunner(maze,["N","E","E","E","E"]), "Lost", "Expected Lost");

// console.log(mazeRunner(maze, ["N", "N", "N", "N", "N", "E", "E", "E", "E", "E"]));
// console.log(mazeRunner(maze, ["N", "N", "N", "N", "N", "E", "E", "E", "E"]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// Argument of type '{ x: number; y: number; } | undefined' is not assignable to parameter of type 'ICoordinates'.
//   Type 'undefined' is not assignable to type 'ICoordinates'.ts(2345)
/*
enum RoomType { Safe = 0, Wall = 1, Start = 2, Finish = 3 }
type Direction = "N" | "E" | "S" | "W";
type Result = "Finish" | "Dead" | "Lost";
type Maze = RoomType[][];
interface ICoordinates { x: number; y: number; }

const getStartingCoordinates = (maze: Maze) => {
    for (let y = 0; y < maze.length; y++) {
        const row = maze[y];

        for (let x = 0; x < row.length; x++) {
            if (row[x] === RoomType.Start) {
                return { x, y };
            }
        }
    }
};

const coordinateModifiers: { [K in Direction]: (coordinates: ICoordinates) => ICoordinates } = {
    E: ({ x, y }) => ({ x: x + 1, y }),
    N: ({ x, y }) => ({ x, y: y - 1 }),
    S: ({ x, y }) => ({ x, y: y + 1 }),
    W: ({ x, y }) => ({ x: x - 1, y }),
};

const mazeRunner2 = (maze: Maze, directions: Direction[]): Result => {
    let coordinates = getStartingCoordinates(maze);

    for (const direction of directions) {
        const { x, y } = coordinateModifiers[direction](coordinates);

        if (maze[y] === undefined) { return "Dead"; }

        const room = maze[y][x];
        if (room === undefined || room === RoomType.Wall) { return "Dead"; }
        if (room === RoomType.Finish) { return "Finish"; }

        coordinates = { x, y };
    }

    return "Lost";
};
*/

function mazeRunner3(maze: number[][], directions: string[]): string {
    let y = maze.findIndex((r) => r.includes(2));
    let x = maze[y].indexOf(2);

    for (const d of directions) {
        if (d === "N") y -= 1;
        if (d === "S") y += 1;
        if (d === "W") x -= 1;
        if (d === "E") x += 1;

        if (
            x < 0 ||
            y < 0 ||
            x >= maze[0].length ||
            y >= maze.length ||
            maze[y][x] === 1
        ) {
            return "Dead";
        }
        if (maze[y][x] === 3) {
            return "Finish";
        }
    }

    return "Lost";
}

// ❗️❗️❗️ SWITCH WITH IF ELSE ❗️❗️❗️
function mazeRunner4(maze: number[][], directions: string[]): string {
    var y = 0,
        x = 0;
    var maxY = maze.length,
        maxX = maze[0].length;

    for (let i = 0; i < maxY; i++)
        for (let j = 0; j < maxX; j++)
            if (maze[i][j] === 2) {
                y = i;
                x = j;
            }

    for (let direc of directions) {
        switch (direc) {
            case "N":
                if (y - 1 < 0) return "Dead";
                else y--;
                break;

            case "S":
                if (y + 1 >= maxY) return "Dead";
                else y++;
                break;

            case "W":
                if (x - 1 < 0) return "Dead";
                else x--;
                break;

            case "E":
                if (x + 1 >= maxX) return "Dead";
                else x++;
                break;

            default:
                return "Lost";
        }

        if (maze[y][x] === 1) return "Dead";
        else if (maze[y][x] === 3) return "Finish";
    }

    return "Lost";
}

function mazeRunner5(maze: number[][], directions: string[]): string {
    let runner: number[][] = [[]];
    for (let i = 0; i < maze.length; i++)
        for (let j = 0; j < maze[0].length; j++)
            if (maze[i][j] == 2) runner = [[i], [j]];
    let [[x], [y]] = runner;
    for (let i of directions) {
        if (i === "N") x--;
        if (i === "S") x++;
        if (i === "W") y--;
        if (i === "E") y++;
        if (
            maze[x] === undefined ||
            maze[x][y] === undefined ||
            maze[x][y] === 1
        )
            return "Dead";
        if (maze[x][y] === 3) return "Finish";
    }
    return "Lost";
}

function mazeRunner6(maze: number[][], directions: string[]): string {
    let [row, column] = getStartingPoint(maze);
    const [NORTH, SOUTH, WEST, EAST] = ["N", "S", "W", "E"];
    const [WALL, FINISH] = [1, 3];
    for (let direction of directions) {
        if (direction == NORTH) row -= 1;
        if (direction == SOUTH) row += 1;
        if (direction == WEST) column -= 1;
        if (direction == EAST) column += 1;

        if (
            maze[row] === undefined ||
            maze[row][column] === undefined ||
            maze[row][column] === WALL
        )
            return "Dead";
        if (maze[row][column] === FINISH) return "Finish";
    }
    return "Lost";
}

const getStartingPoint = (maze: number[][]): [number, number] => {
    for (let i in maze) {
        for (let j in maze[i]) {
            if (maze[i][j] === 2) return [Number(i), Number(j)];
        }
    }
    return [-1, -1];
};
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ REFACTOR WITH OBJECT METHODS ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: STATISCTICS FOR AN ATHLETIC ASSOCIATION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: NEW DATE,
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You are the "computer expert" of a local Athletic Association (C.A.A.). Many teams of runners come to compete. Each time you get a string of all race results of every team who has run. For example here is a string showing the individual results of a team of 5 runners:

"01|15|59, 1|47|6, 01|17|20, 1|32|34, 2|3|17"

Each part of the string is of the form: h|m|s where h, m, s (h for hour, m for minutes, s for seconds) are positive or null integer (represented as strings) with one or two digits. Substrings in the input string are separated by , or ,.

To compare the results of the teams you are asked for giving three statistics; range, average and median.

Range : difference between the lowest and highest values. In {4, 6, 9, 3, 7} the lowest value is 3, and the highest is 9, so the range is 9 − 3 = 6.

Mean or Average : To calculate mean, add together all of the numbers in a set and then divide the sum by the total count of numbers.

Median : In statistics, the median is the number separating the higher half of a data sample from the lower half. The median of a finite list of numbers can be found by arranging all the observations from lowest value to highest value and picking the middle one (e.g., the median of {3, 3, 5, 9, 11} is 5) when there is an odd number of observations. If there is an even number of observations, then there is no single middle value; the median is then defined to be the mean of the two middle values (the median of {3, 5, 6, 9} is (5 + 6) / 2 = 5.5).

Your task is to return a string giving these 3 values. For the example given above, the string result will be

"Range: 00|47|18 Average: 01|35|15 Median: 01|32|34"

of the form: "Range: hh|mm|ss Average: hh|mm|ss Median: hh|mm|ss"`

where hh, mm, ss are integers (represented by strings) with each 2 digits.

Remarks:
if a result in seconds is ab.xy... it will be given truncated as ab.
if the given string is "" you will return ""
*/
class G9644 {
    public static stat = (str: string): string => {
        if (str.length === 0) return "";

        console.log("   ------input:", str, ":end of input-----");

        // [ '01|15|59', ' 1|47|16', ' 01|17|20', ' 1|32|34', ' 2|17|17' ]
        const resultStrArr: string[] = str.split(",");
        console.log("RESULT STR ARR", resultStrArr);

        // [[ '01', '15', '59' ],[ ' 1', '47', '16' ],[ ' 01', '17', '20' ],[ ' 1', '32', '34' ],[ ' 2', '17', '17' ]]
        const numResArr: string[][] = resultStrArr.map((result) =>
            result.split("|")
        );
        console.log("NUM RES ARR:", numResArr);

        const convToSec = (hmsArr: string[]): number => {
            // [ 1, 15, 59 ]...
            const numArr: number[] = hmsArr.map((strVal) => Number(strVal));
            console.log(numArr);
            const numSeconds: number =
                numArr[0] * 3600 + numArr[1] * 60 + numArr[2];
            console.log(numSeconds);
            return numSeconds;
        };
        // console.log(convToSec(["01", "15", "59"]));

        const convToHMS = (numSeconds: number) => {
            let hours: number = 0,
                mins: number = 0,
                secs: number = 0;
            if (numSeconds / 3600 >= 1) {
                hours += Math.trunc(numSeconds / 3600);
                numSeconds = numSeconds % 3600;
            }
            if (numSeconds / 60 >= 1) {
                mins += Math.trunc(numSeconds / 60);
                numSeconds = numSeconds % 60;
            }
            secs = numSeconds;
            console.log(hours, mins, secs);
            return [hours, mins, secs];
        };

        // [ 4559, 6436, 4640, 5554, 8237 ]
        const secondsArr: number[] = numResArr.map((arr) => convToSec(arr));
        console.log("SECONDS ARR", secondsArr);

        // 1️⃣ CALC RANGE:

        // 4559 AND 7397
        const lowest: number = Math.min(...secondsArr);
        const highest: number = Math.max(...secondsArr);
        console.log(lowest, highest);

        // 2838
        const secRange: number = highest - lowest;
        console.log(secRange);

        // [ 0, 47, 18 ]
        const rangeHMS = convToHMS(secRange);
        console.log(rangeHMS);

        // 2️⃣ CALC AVARAGE:

        // 5885.2 => 5885 (??? MAYBE USE Math.round() ???)
        const aveSeconds: number = Math.trunc(
            secondsArr.reduce((acc, curr) => acc + curr) / secondsArr.length
        );
        console.log(aveSeconds);

        // [ 1, 35, 15 ]
        const aveHMS = convToHMS(aveSeconds);
        console.log(aveHMS);

        // 3️⃣  CALC MEDIAN:

        // [ 4559, 4640, 5554, 6426, 7397 ]
        const ascSecArr: number[] = secondsArr.sort((a, b) => a - b);
        console.log(ascSecArr);

        const getMedian = (numArr: number[]): number => {
            console.log("   numArr length:", numArr.length);
            console.log("   numArr length & 1:", numArr.length & 1);
            return numArr.length & 1
                ? numArr[(numArr.length - 1) / 2]
                : Math.trunc(
                      (numArr[numArr.length / 2] +
                          numArr[numArr.length / 2 - 1]) /
                          2
                  );
        };

        // 5554
        const medSeconds: number = getMedian(ascSecArr);
        console.log("   MEDIAN SECONDS:", medSeconds);

        // [ 1, 32, 34 ]
        const medHMS = convToHMS(medSeconds);
        console.log("   MEDIAN HMS:", medHMS);

        const format = (arr: number[]) => {
            return arr
                .map((num) => {
                    if (num < 10) {
                        //                         return num.toString().padStart(2, "0");
                        return `0${num.toString()}`;
                    }
                    return num.toString();
                })
                .join("|");
        };

        // console.log("format test:", format(rangeHMS));
        // console.log(`Range: ${rangeHMS} Average: ${aveHMS} Median: ${medHMS}`);

        // Range: 00|47|18 Average: 01|35|15 Median: 01|32|34
        const solution: string = `Range: ${format(rangeHMS)} Average: ${format(
            aveHMS
        )} Median: ${format(medHMS)}`;
        console.log(solution);

        return solution;
    };
}

// ("01|15|59, 1|47|16, 01|17|20, 1|32|34, 2|17|17",
//             "Range: 01|01|18 Average: 01|38|05 Median: 01|32|34");
//         dotest("02|15|59, 2|47|16, 02|17|20, 2|32|34, 2|17|17, 2|22|00, 2|31|41",
//             "Range: 00|31|17 Average: 02|26|18 Median: 02|22|00");
//         dotest("02|15|59, 2|47|16, 02|17|20, 2|32|34, 2|32|34, 2|17|17",
//             "Range: 00|31|17 Average: 02|27|10 Median: 02|24|57");

// LOOK INT MEDIAN
//  'Range: 00|31|17 Average: 02|27|10 Median: ❗️❗️❗️ 02|32|34' ❗️❗️❗️ === 9154
// TO EQUAL:
//  'Range: 00|31|17 Average: 02|27|10 Median: ❗️❗️❗️ 02|24|57' ❗️❗️❗️ === 8697

console
    .log
    // G9644.stat("02|15|59, 2|47|16, 02|17|20, 2|32|34, 2|32|34, 2|17|17")
    ();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// class G96441 {
//     public static stat = (strg) => {
//         let result = "";
//         if (strg === "") return result;

//         //Convertion input to array of seconds
//         const secsArray = strg
//             .split(", ")
//             .map((t) => t.split("|"))
//             .map((x) => x.reduce((acc, time) => 60 * acc + +time, 0))
//             .sort((a, b) => a - b);
//         const middle = Math.floor(secsArray.length / 2);

//         //Calculating required results
//         const range = Math.max(...secsArray) - Math.min(...secsArray);
//         const mean = Math.floor(
//             secsArray.reduce((a, b) => a + b) / secsArray.length
//         );
//         const median = Math.floor(
//             secsArray.length % 2 === 0
//                 ? (secsArray[middle - 1] + secsArray[middle]) / 2
//                 : secsArray[middle]
//         );

//         //Printing output
//         result += `Range: ${new Date(range * 1000)
//             .toISOString()
//             .substr(11, 8)
//             .replace(/:/g, "|")}`;
//         result += ` Average: ${new Date(mean * 1000)
//             .toISOString()
//             .substr(11, 8)
//             .replace(/:/g, "|")}`;
//         result += ` Median: ${new Date(median * 1000)
//             .toISOString()
//             .substr(11, 8)
//             .replace(/:/g, "|")}`;

//         return result;
//     };
// }

// class G964 {

//     private static time2snd = (s) => {
//         var arr = s.split('|').map(function (x) { return ~~x } );
//         var snd = 3600 * arr[0] + 60 * arr[1] + arr[2];
//         return snd;
//     }

//     private static pad = (num, size) => {
//         var s = num + "";
//         while (s.length < size) s = "0" + s;
//         return s;
//     }

//     private static snd2time = (m) => {
//         var n = ~~m;
//         var h = Math.floor(m / 3600);
//         var re = m % 3600;
//         var mn = Math.floor(re / 60);
//         var s = re % 60;
//         return G964.pad(h, 2) + "|" + G964.pad(mn, 2) + "|" + G964.pad(s, 2)
//     }

//     public static stat = (strg) => {
//         if (strg === "")
//             return "";
//         var r = strg.split(',').map(function(x) { return G964.time2snd(x) } ).sort(function(a, b) { return a-b } );
//         var lg = r.length;
//         var avg = ~~(r.reduce(function(s, x) { return (s + x) } ) / lg);
//         var rge = ~~(r[lg - 1] -  r[0]);
//         var md = ~~((r[ ~~((lg - 1) / 2) ] + r[ ~~(lg / 2) ]) / 2);
//         return "Range: " + G964.snd2time(rge) + " Average: " + G964.snd2time(avg) + " Median: " + G964.snd2time(md);
//     }
// }

// class G96441 {
//     public static timeDivider = '|';
//     public static statDivider = ', ';

//     public static stat = (strg) => {
//       if(!strg.length) return '';

//       const arr = strg.split(G964.statDivider);
//       const numArr = arr.map(G964.stringToSeconds);

//       const range = G964.getRange(numArr);
//       const average = G964.getAverage(numArr);
//       const median = G964.getMedian(numArr);

//       return `Range: ${G964.secondsToString(range)} Average: ${G964.secondsToString(average)} Median: ${G964.secondsToString(median)}`
//     }

//     public static getRange = (arr: number[]): number => {
//       const max = Math.max(...arr);
//       const min = Math.min(...arr);

//       return max - min;
//     }

//     public static getAverage = (arr: number[]): number => {
//       return arr.reduce((sum, el) => sum + el, 0) / arr.length;
//     }

//     public static getMedian = (arr: number[]): number => {
//       const arrCopy = [...arr];
//       const sortedArr = arrCopy.sort( (a, b) => a - b );
//       const mid = Math.ceil(sortedArr.length / 2);

//       return sortedArr.length % 2 == 0 ? (sortedArr[mid] + sortedArr[mid - 1]) / 2 : sortedArr[mid - 1];
//     }

//     public static stringToSeconds = (str: string): number => {
//       const arr = str.split(G964.timeDivider);
//       return (Number(arr[0]) * 3600) + (Number(arr[1]) * 60) + (Number(arr[2]));
//     }

//     public static secondsToString = (num: number) => {
//       let time = num
//       const hours = Math.floor(time/3600);
//       time = time - hours * 3600;
//       const minutes = Math.floor(time/60);
//       time = time - minutes * 60;
//       const seconds = Math.floor(time);

//       return [
//         G964.convertToStringWithZero(hours),
//         G964.convertToStringWithZero(minutes),
//         G964.convertToStringWithZero(seconds)
//       ].join(G964.timeDivider);
//     }

//     public static convertToStringWithZero = (num: number): string => {
//       return num < 10 ? '0' + num : '' + num;
//     }
//   }

// class G96441 {

//     public static stat = (strg) => {
//       if (!strg) return strg;
//       const times = strg.split(', ').map(t => {
//         const [ hours, minutes, seconds ] = t.split('|').map(n => +n);
//         return (hours * 3600) + (minutes * 60) + (seconds);
//       }).sort((a, b) => a - b);
//       const range = times[times.length-1] - times[0];
//       const mean = times.reduce((total, t) => total + t, 0) / times.length;
//       const middle = Math.floor(times.length / 2);
//       const median = times.length % 2 !== 0 ? times[middle] : ((times[middle-1] + times[middle]) / 2);
//       const pad = (num) => ('0' + Math.floor(num)).substr(-2);
//       const formatTime = (time) => {
//         const minutes = time % 3600;
//         return `${pad(time / 3600)}|${pad(minutes / 60)}|${pad(minutes % 60)}`;
//       };
//       return `Range: ${formatTime(range)} Average: ${formatTime(mean)} Median: ${formatTime(median)}`;
//     }
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: BUYING A CAR
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Let us begin with an example:

A man has a rather old car being worth $2000. He saw a secondhand car being worth $8000. He wants to keep his old car until he can buy the secondhand one.

He thinks he can save $1000 each month but the prices of his old car and of the new one decrease of 1.5 percent per month. Furthermore this percent of loss increases of 0.5 percent at the end of every two months. Our man finds it difficult to make all these calculations.

Can you help him?

How many months will it take him to save up enough money to buy the car he wants, and how much money will he have left over?

Parameters and return of function:

parameter (positive int or float, guaranteed) start_price_old (Old car price)
parameter (positive int or float, guaranteed) start_price_new (New car price)
parameter (positive int or float, guaranteed) saving_per_month 
parameter (positive float or int, guaranteed) percent_loss_by_month

nbMonths(2000, 8000, 1000, 1.5) should return [6, 766] or (6, 766)
Detail of the above example:
end month 1: percent_loss 1.5 available -4910.0
end month 2: percent_loss 2.0 available -3791.7999...
end month 3: percent_loss 2.0 available -2675.964
end month 4: percent_loss 2.5 available -1534.06489...
end month 5: percent_loss 2.5 available -395.71327...
end month 6: percent_loss 3.0 available 766.158120825...
return [6, 766] or (6, 766)
where 6 is the number of months at the end of which he can buy the new car and 766 is the nearest integer to 766.158... (rounding 766.158 gives 766).

Note:

Selling, buying and saving are normally done at end of month. Calculations are processed at the end of each considered month but if, by chance from the start, the value of the old car is bigger than the value of the new one or equal there is no saving to be made, no need to wait so he can at the beginning of the month buy the new car:

nbMonths(12000, 8000, 1000, 1.5) should return [0, 4000]
nbMonths(8000, 8000, 1000, 1.5) should return [0, 0]
We don't take care of a deposit of savings in a bank:-)
*/
const nbMonths = (
    priceOld: number,
    priceNew: number,
    savePerM: number,
    lossPCM: number
): number[] => {
    // CURRENT DEBTH AFTER SELLING OLD AND BUYING NEW
    let balance: number = priceOld - priceNew;
    console.log("initial balance:", balance);
    // ACCUMULATE MONTHLY SAVINGS HERE
    let savings: number = 0;
    // KEEP TRACK OF MONTHS
    let monthCount: number = 0;

    // WHILE IN DEBTH
    while (balance + savings <= 0) {
        console.log("   loss pc month:", lossPCM);
        // APPLY CURRENT LOSS PERCENTAGE TO BALANCE
        balance *= (100 - lossPCM) / 100;
        console.log("       balance:", balance);

        // ACCUMULATE SAVINGS
        savings += savePerM;
        console.log("savings accumulator:", savings);

        // INCREMENT MONTHS
        monthCount += 1;
        console.log("                  months count:", monthCount);

        // INCREASE LOSS PERCENTAGE BY 0.5 EVERY 2 MONTHS STARTING AT MOMTH 1
        if (monthCount % 2 !== 0) lossPCM += 0.5;

        console.log("change left:", Math.round(savings + balance));
    }
    // CALCULATE MONEY LEFT AFTER MAKING PURCHASE
    const change: number = Math.round(savings + balance);

    return [monthCount, change];
};

// [6, 766]
// console.log(nbMonths(2000, 8000, 1000, 1.5));
// [0, 4000]
// console.log(nbMonths((12000, 8000, 1000, 1.5));
// console.log();
// console.log();
// console.log();

/*
console.log(nbMonths(2000, 8000, 1000, 1.5));

initial balance: -6000
   loss pc month: 1.5
       balance: -5910
savings accumulator: 1000
                  months count: 1
change left: -4910
   loss pc month: 2
       balance: -5791.8
savings accumulator: 2000
                  months count: 2
change left: -3792
   loss pc month: 2
       balance: -5675.964
savings accumulator: 3000
                  months count: 3
change left: -2676
   loss pc month: 2.5
       balance: -5534.064899999999
savings accumulator: 4000
                  months count: 4
change left: -1534
   loss pc month: 2.5
       balance: -5395.713277499999
savings accumulator: 5000
                  months count: 5
change left: -396
   loss pc month: 3
       balance: -5233.841879174999
savings accumulator: 6000
                  months count: 6
change left: 766
[ 6, 766 ]
*/

//============= OTHER CODEWARS SOLUTIONS: =============

function nbMonths2(
    startPriceOld: number,
    startPriceNew: number,
    savingperMonth: number,
    percentLossByMonth: number
): number[] {
    var months = 0,
        moneySaved = 0;
    while (startPriceNew > startPriceOld + moneySaved) {
        moneySaved += savingperMonth;
        startPriceOld -= startPriceOld * (percentLossByMonth / 100);
        startPriceNew -= startPriceNew * (percentLossByMonth / 100);
        months++;
        if (months % 2 == 1) {
            percentLossByMonth += 0.5;
        }
    }
    return [months, Math.round(startPriceOld + moneySaved - startPriceNew)];
}

function nbMonths3(
    startPriceOld: number,
    startPriceNew: number,
    savingperMonth: number,
    percentLossByMonth: number
): number[] {
    let monthCount: number = 0;

    let oldCarPrice: number = startPriceOld;
    let newCarPrice: number = startPriceNew;

    let savingMoneyAmount: number = oldCarPrice - newCarPrice;

    while (Math.round(savingMoneyAmount) < 0) {
        monthCount++;

        oldCarPrice =
            oldCarPrice *
            ((100 - (Math.floor(monthCount / 2) * 0.5 + percentLossByMonth)) /
                100);
        newCarPrice =
            newCarPrice *
            ((100 - (Math.floor(monthCount / 2) * 0.5 + percentLossByMonth)) /
                100);

        savingMoneyAmount =
            oldCarPrice - newCarPrice + savingperMonth * monthCount;
    }

    return [monthCount, Math.round(savingMoneyAmount)];
}

function nbMonths4(
    startPriceOld: number,
    startPriceNew: number,
    savingperMonth: number,
    percentLossByMonth: number
): number[] {
    let months = 0;
    let balance = 0;
    let percent = percentLossByMonth;

    while (balance + startPriceOld < startPriceNew) {
        balance += savingperMonth;
        months += 1;

        if (months % 2 === 0) {
            percent += 0.5;
        }

        startPriceOld *= 1 - percent / 100;
        startPriceNew *= 1 - percent / 100;
    }

    return [months, Math.round(balance + startPriceOld - startPriceNew)];
}

function nbMonths5(
    startPriceOld: number,
    startPriceNew: number,
    savingperMonth: number,
    percentLossByMonth: number
): number[] {
    let gap: number = startPriceOld - startPriceNew,
        gapPrice: number = gap,
        rate: number = 1.0,
        month: number = 0;
    while (gapPrice < 0) {
        month += 1;
        if (month % 2 == 0) {
            percentLossByMonth += 0.5;
        }
        rate *= 1 - percentLossByMonth / 100;
        gapPrice = gap * rate + month * savingperMonth;
    }
    return [month, Math.round(gapPrice)];
}

// function nbMonths6(
//     startPriceOld: number,
//     startPriceNew: number,
//     savingperMonth: number,
//     percentLossByMonth: number,
//     monthsPassed: number = 0
// ): number[] {
//     const result = startPriceOld + savingperMonth * monthsPassed - startPriceNew;

//     if (result > 0) return [monthsPassed, Math.round(result)];

//     const newPercentLossByMonth = (monthsPassed % 2 === 1) ? percentLossByMonth + 0.5 : percentLossByMonth,
//         newPriceOld = startPriceOld * (1 - newPercentLossByMonth / 100),
//         newPriceNew = startPriceNew * (1 - newPercentLossByMonth / 100);

//     return nbMonths(newPriceOld, newPriceNew, savingperMonth, newPercentLossByMonth, monthsPassed + 1)
// }

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// INCLUDE FROMCHARCODE IN EXAMPLES !!!
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: ESOLANG INTERPRETERS #1 -
// Introduction to Esolangs and My First Interpreter (MiniStringFuck)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ TYPE KEYOF ❗️❗️❗️ STRING.FROMCHARCODE ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
For the rest of this Kata, I would recommend considering "fuck" to be non-profane.

Esolang Interpreters #1 - Introduction to Esolangs and My First Interpreter (MiniStringFuck)
About this Kata Series
"Esolang Interpreters" is a Kata Series that originally began as three separate, independent esolang interpreter Kata authored by @donaldsebleung which all shared a similar format and were all somewhat inter-related. Under the influence of a fellow Codewarrior, these three high-level inter-related Kata gradually evolved into what is known today as the "Esolang Interpreters" series.

This series is a high-level Kata Series designed to challenge the minds of bright and daring programmers by implementing interpreters for various esoteric programming languages/Esolangs, mainly Brainfuck derivatives but not limited to them, given a certain specification for a certain Esolang. Perhaps the only exception to this rule is the very first Kata in this Series which is intended as an introduction/taster to the world of esoteric programming languages and writing interpreters for them.

What is an esoteric programming language?
An esoteric programming language, otherwise known as an Esolang, is an informal computer programming language that is generally not designed for serious practical use. There are a few main aims/themes among the vast majority of such languages:

Achieve Turing-completeness in as few commands (instructions) as possible. There are currently a number of implemented Esolangs that have been proven to be Turing-complete, Brainfuck being the most popular of them all, comprised of no more than 8 distinct commands. Despite having only 8 commands, it has been objectively proven to be Turing-complete. However, Brainfuck is not the Turing-complete programming language with the fewest commands. Boolfuck, a derivative of Brainfuck which operates on bits (0s and 1s) and contains 7 commands only, has also been proven to be Turing-complete through reduction from Brainfuck. Another less-known Esolang called Etre contains as few as 3 commands yet has been proven to be Turing-complete through the translation of a Minsky Machine to Etre.
To be as hard to program in as possible. The famous Brainfuck Esolang is well known as a Turing tarpit - that is, a Turing-complete programming language where it is very hard to write a useful program in reality. However, Brainfuck is most definitely not the hardest Esolang to program in. For example, its close cousin, Boolfuck, which operates on bits (mentioned above) is even harder to program in. There have also been a small number of implemented Esolangs which are so difficult to program in that no one has ever successfully written a single program in it from scratch - the only programs generated from these languages came from computers!
As a joke. Many Esolangs out there have been invented solely as a joke. Examples include Ook! and Bitxtreme.
Although there is no clear-cut definition as to when a programming language is esoteric (or not), Esolangs can generally be identified by the following features/traits:

Minimalistic - having as few instructions as possible
Plays with new concepts - for example, Befunge, another very popular Esolang, is interpreted in two dimensions as opposed to the usual linear way of interpreting code
Themed - this is a trait of many joke Esolangs. For example, some may be fashioned like Shakespearean plays and others like cooking recipes
Not clearly documented - Many Esolangs out there have not been described in great detail with perhaps only a few code examples on the entire Internet. Some Esolangs have not even been implemented yet!
Contain incomplete specs - New Esolangs are being invented every day. Some Esolangs on the Internet are still a work-in-progress and their commands and behaviour have not been finalised yet.
Nevertheless, Esolangs are generally fun to program in, experiment with and write interpreters for. A great deal can be learned about certain concepts and theories in Computer Science just by studying and programming in a well-designed Esolang such as Brainfuck or Befunge.

Next off, I will introduce you to a simple, minimalistic Esolang called MiniStringFuck.

The Language
MiniStringFuck is a derivative of the famous Brainfuck which contains a memory cell as its only form of data storage as opposed to a memory tape of 30,000 cells in Brainfuck. The memory cell in MiniStringFuck initially starts at 0. MiniStringFuck contains only 2 commands as opposed to 8:

+ - Increment the memory cell. If it reaches 256, wrap to 0.
. - Output the value of the memory cell as a character with code point equal to the value
For example, here is a MiniStringFuck program that outputs the string "Hello, World!":

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++.+++++++..+++.+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++++++++++++++++++++++++++++.++++++++++++++++++++++++.+++.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
And here is another program that prints the uppercase English alphabet:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.+.
Any characters in a MiniStringFuck program other than + or . are simply non-command characters (no-ops, i.e. do nothing) and therefore can serve as comments in the program.

The Task
Time to write your first Esolang interpreter :D

Your task is to implement a MiniStringFuck interpreter myFirstInterpreter()/my_first_interpreter()/Interpreter()/interpret() MyFirstInterpreter() (depending on your language) which accepts exactly 1 required argument code/$code/strng which is the MiniStringFuck program to be executed. The output of the program should then be returned by your interpreter as a string.

Since this is the first time you are about to write an interpreter for an Esolang, here are a few quick tips:

If you are afraid that your interpreter will be confused by non-command characters appearing in the MiniStringFuck program, you can try to remove all non-command characters from the code input before letting your interpreter interpret it
The memory cell in MiniStringFuck only ever contains a single integer value - think of how it can be modelled in your interpreter
If you are stuck as to how to interpret the string as a program, try thinking of strings as an array of characters. Try looping through the "program" like you would an array
Writing an interpreter for an Esolang can sometimes be quite confusing! It never hurts to add a few comments in your interpreter as you implement it to remind yourself of what is happening within the interpreter at every stage
NOTE: If you would not like to name your interpreter as myFirstInterpreter()/my_first_interpreter(), you can optionally rename it to either miniStringFuck()/mini_string_fuck() or interpreter() instead - the test cases will handle the rest for you. Not available in Java, Go, Swift, TypeScript, Haskell, Elixir, C++, C#, Rust, R, Erlang, F#, COBOL and NASM; irrelevant to Brainfuck solvers ;)

Good luck :D
*/

const myFirstInterpreter = (code: string): string => {
    // // GET SUBSTRINGS
    // const subStrArr: string[] = code.match(/\+{1,}/g)!;
    // // 12
    // console.log(subStrArr.length);
    // const sumArr: number[] = subStrArr.map((sub) => sub.length);
    // // [72,  29,  7, 3, 189,244,  55, 24, 3, 250,248, 189]
    // console.log(sumArr);

    let cellStatus: number = 0;
    const commandArr: string[] = code.split("");
    // let solutionArr: string[] = [];
    let solution: string = "";

    for (let i = 0; i < commandArr.length; i += 1) {
        let currCommand: string = commandArr[i];

        if (currCommand === "+") {
            // ❗️❗️❗️ INCREMENT FIRST ❗️❗️❗️
            cellStatus += 1;
            if (cellStatus === 256) {
                cellStatus = 0;
            }
            // ❗️❗️❗️ NOT HERE ❗️❗️❗️
            // cellStatus += 1;
        }
        if (currCommand === ".") {
            // ❗️❗️❗️ STRING.FROMCHARCODE ❗️❗️❗️
            console.log(String.fromCharCode(cellStatus));
            // solutionArr.push(String.fromCharCode(cellStatus));
            solution += String.fromCharCode(cellStatus);
        }
    }

    // console.log(solutionArr);
    console.log(solution);
    return solution;
};

// ❗️❗️❗️ STRING.FROMCHARCODE ❗️❗️❗️
const arr = [89, 79, 85, 32, 68, 73, 68, 32, 73, 84, 33];
// YOU DID IT!
// console.log(String.fromCharCode(...arr));

// 'Hello, World!'
// console.log(myFirstInterpreter('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++.+++++++..+++.+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++++++++++++++++++++++++++++.++++++++++++++++++++++++.+++.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.'));

// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function myFirstInterpreter2(code: string): string {
    var c = 0,
        out = "";
    for (var i of code) {
        if (i === "+") c = (c + 1) % 256;
        if (i === ".") out += String.fromCharCode(c);
    }
    return out;
}

// ====================================================
type InterpreterState = {
    value: number;
    output: string;
};

type Commands = {
    ".": ".";
    "+": "+";
};

// ❗️❗️❗️ TYPE KEYOF ❗️❗️❗️
type Command = keyof Commands;

const COMMANDS: Commands = {
    "+": "+",
    ".": ".",
};

export const myFirstInterpreter3 = (code: string): string => {
    const DEFAULT_STATE: InterpreterState = {
        value: 0,
        output: "",
    };

    const add = (state: InterpreterState): InterpreterState => {
        const value = (state.value + 1) % 256;
        return { ...state, value };
    };

    const print = (state: InterpreterState): InterpreterState => {
        const output = state.output + String.fromCharCode(state.value);
        return { ...state, output };
    };

    const interprete = (char: string, state: InterpreterState) => {
        switch (char as Command) {
            case COMMANDS["+"]:
                return add(state);

            case COMMANDS["."]:
                return print(state);

            default:
                return state;
        }
    };

    const result = code.split("").reduce((acc, curr) => {
        return interprete(curr, acc);
    }, DEFAULT_STATE);

    return result.output;
};
//   ===============================================================
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: PYRAMID ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ARRAY.FROM, FILL, NEW ARRAY,
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function that when given a number >= 0, returns an Array of ascending length subarrays.

pyramid(0) => [ ]
pyramid(1) => [ [1] ]
pyramid(2) => [ [1], [1, 1] ]
pyramid(3) => [ [1], [1, 1], [1, 1, 1] ]
Note: the subarrays should be filled with 1s
*/
const pyramid = (num: number): number[][] => {
    let solutionArr: number[][] = [];

    for (let i = 0; i < num; i += 1) {
        // "i", "ii", "iii"
        let rowStr: string = "1".repeat(i + 1);
        // [ 1 ], [ 1, 1 ], [ 1, 1, 1 ]...
        let rowArr: number[] = rowStr.split("").map((str) => Number(str));
        // console.log(rowStr, rowArr);
        solutionArr.push(rowArr);
    }

    // [ [ 1 ], [ 1, 1 ], [ 1, 1, 1 ] ]
    return solutionArr;
};

// [[1], [1, 1], [1, 1, 1]]
// console.log(pyramid(0));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function pyramid2(n: number) {
    const ret = [];
    for (let i = 0; i < n; i++) {
        ret.push(Array(i + 1).fill(1));
    }
    return ret;
}

function pyramid3(n: number) {
    const result: Array<Array<1>> = [];

    while (n > 0) {
        result.unshift(new Array(n).fill(1));
        n--;
    }
    return result;
}

function pyramid4(n: number): number[][] {
    // your code here
    if (n === 0) {
        return [];
    }
    const newArr = new Array(n).fill(1);

    return [...pyramid(n - 1), newArr];
}

function pyramid5(n: number) {
    const p: number[][] = [];
    for (let i = 1; i <= n; i++) {
        p.push(new Array(i).fill(1));
    }
    return p;
}

function pyramid6(n: number): number[][] {
    return Array.from(new Array(n).keys()).map((x) => new Array(x + 1).fill(1));
}

function pyramid7(n: number) {
    return Array.from({ length: n }, (_, i) => Array(i + 1).fill(1));
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: DASHATIZE IT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a variable n,

If n is an integer, Return a string with dash'-'marks before and after each odd integer, but do not begin or end the string with a dash mark. If n is negative, then the negative sign should be removed.

If n is not an integer, return an empty value.

Ex:

dashatize(274) -> '2-7-4'
dashatize(6815) -> '68-1-5'
*/
const dashatize = (num: number): string => {
    // IF NUM IS NEGATIVE, GET RID OF "-"
    if (num < 0) num = Math.abs(num);
    // IF NUM IS ONE DIGIT, DONT CHANGE IT
    if (num < 10) return num.toString();

    // [ '5', '3', '1', '1' ]
    const numStrArr: string[] = num.toString().split("");

    // [ '5-', '-3-', '-1-', '-1' ]
    for (let i = 0; i < numStrArr.length; i += 1) {
        let current: string = numStrArr[i];
        // IF CURRENT IS ODD
        if (Number(current) & 1) {
            // TRIM "-" AT BEGINNING OF SOLUTION
            if (i === 0) numStrArr[i] = `${current}-`;
            // TRIM  "-" AT THE END OF SOLUTION
            else if (i === numStrArr.length - 1) numStrArr[i] = `-${current}`;
            // WRAP CURRENT IN "-"S
            else numStrArr[i] = `-${current}-`;
        }
    }

    // MAKE IT STR: "5--3--1--1"
    const dashStr: string = numStrArr.join("");
    // REPLACE "--" WITH "-"
    const solution: string = dashStr.replace(/-{2,}/g, "-");
    return solution;
};

// "Should return 2-7-4"
// console.log(dashatize(12743));
// "Should return 5-3-1-1"
// console.log(dashatize(5311));
// console.log(dashatize(-1));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const dashatize2 = (num: number) => {
    return num
        .toString()
        .replace(/([13579])/g, "-$1-")
        .replace(/\-+/g, "-")
        .replace(/^\-/, "")
        .replace(/\-$/, "");
};

const dashatize3 = (num: number) => {
    return num
        .toString()
        .replace("-", "")
        .split(/([13579])/)
        .filter((s) => s !== "")
        .join("-");
};

const dashatize4 = (num: number) => {
    return String(Math.abs(num))
        .split(/([13579])/)
        .filter((s) => s !== "")
        .join("-");
};
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: STREET FIGHTER2 - CHARACTER SELECTION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Short Intro

Some of you might remember spending afternoons playing Street Fighter 2 in some Arcade back in the 90s or emulating it nowadays with the numerous emulators for retro consoles.

Can you solve this kata? Suuure-You-Can!

UPDATE: a new kata's harder version is available here.

The Kata

You'll have to simulate the video game's character selection screen behaviour, more specifically the selection grid. Such screen looks like this:

Screen:

screen

Selection Grid Layout in text:

| Ryu  | E.Honda | Blanka  | Guile   | Balrog | Vega    |
| Ken  | Chun Li | Zangief | Dhalsim | Sagat  | M.Bison |
Input

the list of game characters in a 2x6 grid;
the initial position of the selection cursor (top-left is (0,0));
a list of moves of the selection cursor (which are up, down, left, right);
Output

the list of characters who have been hovered by the selection cursor after all the moves (ordered and with repetition, all the ones after a move, whether successful or not, see tests);
Rules

Selection cursor is circular horizontally but not vertically!

As you might remember from the game, the selection cursor rotates horizontally but not vertically; that means that if I'm in the leftmost and I try to go left again I'll get to the rightmost (examples: from Ryu to Vega, from Ken to M.Bison) and vice versa from rightmost to leftmost.

Instead, if I try to go further up from the upmost or further down from the downmost, I'll just stay where I am located (examples: you can't go lower than lowest row: Ken, Chun Li, Zangief, Dhalsim, Sagat and M.Bison in the above image; you can't go upper than highest row: Ryu, E.Honda, Blanka, Guile, Balrog and Vega in the above image).

Test

For this easy version the fighters grid layout and the initial position will always be the same in all tests, only the list of moves change.

Notice: changing some of the input data might not help you.

Examples

fighters = [
  ["Ryu", "E.Honda", "Blanka", "Guile", "Balrog", "Vega"],
  ["Ken", "Chun Li", "Zangief", "Dhalsim", "Sagat", "M.Bison"]
]
initial_position = (0,0)
moves = ['up', 'left', 'right', 'left', 'left']
then I should get:

['Ryu', 'Vega', 'Ryu', 'Vega', 'Balrog']
as the characters I've been hovering with the selection cursor during my moves. Notice: Ryu is the first just because it "fails" the first up See test cases for more examples.

fighters = [
  ["Ryu", "E.Honda", "Blanka", "Guile", "Balrog", "Vega"],
  ["Ken", "Chun Li", "Zangief", "Dhalsim", "Sagat", "M.Bison"]
]
initial_position = (0,0)
moves = ['right', 'down', 'left', 'left', 'left', 'left', 'right']
Result:

['E.Honda', 'Chun Li', 'Ken', 'M.Bison', 'Sagat', 'Dhalsim', 'Sagat']
*/
const streetFighterSelection = (
    fighters: Array<string[]>,
    position: number[],
    moves: string[]
): string[] => {
    let solution: string[] = [];
    let y: number = position[1],
        x: number = position[0];

    let currName: string = fighters[y][x];

    moves.forEach((dir) => {
        if (dir === "up") {
            if (y === 1) {
                y = 0;
                currName = fighters[y][x];
                solution.push(currName);
            } else {
                solution.push(currName);
            }
        }

        if (dir === "down") {
            if (y === 0) {
                y = 1;
                currName = fighters[y][x];
                solution.push(currName);
            } else {
                solution.push(currName);
            }
        }

        if (dir === "left") {
            if (x === 0) {
                x = 5;
                currName = fighters[y][x];
                solution.push(currName);
            } else {
                x -= 1;
                currName = fighters[y][x];
                solution.push(currName);
            }
        }

        if (dir === "right") {
            if (x === 5) {
                x = 0;
                currName = fighters[y][x];
                solution.push(currName);
            } else {
                x += 1;
                currName = fighters[y][x];
                solution.push(currName);
            }
        }
    });

    return solution;
};

let fighters = [
    ["Ryu", "E.Honda", "Blanka", "Guile", "Balrog", "Vega"],
    ["Ken", "Chun Li", "Zangief", "Dhalsim", "Sagat", "M.Bison"],
];
// let moves = ['up', 'left', 'right', 'left', 'left'];

// ['Ryu', 'Vega', 'M.Bison', 'Ken', 'Ryu', 'Vega', 'M.Bison', 'Ken']);
let moves = ["up", "left", "down", "right", "up", "left", "down", "right"];
// ['Ryu', 'Vega', 'Ryu', 'Vega', 'Balrog']
// console.log(streetFighterSelection(fighters, [0, 0], moves));
// console.log(streetFighterSelection(fighters, [0, 1], moves));
// console.log(streetFighterSelection(fighters, [0, 0], moves));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function streetFighterSelection2(
    fighters: Array<string[]>,
    position: number[],
    moves: string[]
): string[] {
    const returnArr: string[] = [];
    const pos = position;

    moves.map((move) => {
        switch (move) {
            case "up":
                pos[0] = 0;
                break;
            case "down":
                pos[0] = 1;
                break;
            case "right":
                pos[1] = pos[1] === fighters[0].length - 1 ? 0 : ++pos[1];
                break;
            case "left":
                pos[1] =
                    pos[1] === 0 ? (pos[1] = fighters[0].length - 1) : --pos[1];
                break;
        }
        returnArr.push(fighters[pos[0]][pos[1]]);
    });
    return returnArr;
}

function streetFighterSelection3(
    fighters: Array<string[]>,
    position: number[],
    moves: string[]
) {
    let characters = new Array<string>();

    for (let move of moves) {
        switch (move) {
            case "left":
                position[0] = position[0] === 0 ? 5 : position[0] - 1;
                break;
            case "right":
                position[0] = position[0] === 5 ? 0 : position[0] + 1;
                break;
            case "up":
                position[1] = 0;
                break;
            case "down":
                position[1] = 1;
                break;
        }

        characters.push(fighters[position[1]][position[0]]);
    }

    return characters;
}

function streetFighterSelection4(
    fighters: Array<string[]>,
    position: number[],
    moves: string[]
) {
    let x: number = position[0];
    let y: number = position[1];
    let arr: string[] = [];
    const mod = 6;
    const stepL = (a: number) => {
        let sum = a - 1;
        if (sum < 0) sum += mod;
        return sum;
    };
    const stepR = (a: number) => {
        let sum = a + 1;
        if (sum >= mod) sum -= mod;
        return sum;
    };
    for (let i = 0; i < moves.length; i++) {
        switch (moves[i]) {
            case "up":
                y = 0;
                break;
            case "down":
                y = 1;
                break;
            case "left":
                x = stepL(x);
                break;
            case "right":
                x = stepR(x);
                break;
        }
        arr.push(fighters[y][x]);
    }
    return arr;
}

// function streetFighterSelection5(xs: Array<string[]>, p: number[], moves: string[]) {
//     const n = xs[0].length;
//     const vx = { "up": [-1, 0], "down": [1, 0], "left": [0, -1], "right": [0, 1] };
//     const move = v => { p[0] = Math.min(Math.max(p[0] + v[0], 0), 1); p[1] = (((p[1] + v[1]) % n) + n) % n; }
//     return moves.reduce((his, m) => (move(vx[m]), his.push(xs[p[0]][p[1]]), his), []);
// }

function streetFighterSelection6(
    fighters: string[][],
    position: number[],
    moves: string[]
): string[] {
    let s: string[] = [];
    let [x, y] = position;
    for (let c of moves) {
        switch (c) {
            case "up":
                x = Math.max(x - 1, 0);
                break;
            case "down":
                x = Math.min(x + 1, 1);
                break;
            case "left":
                y = (y + 5) % 6;
                break;
            case "right":
                y = (y + 1) % 6;
                break;
        }
        s.push(fighters[x][y]);
    }
    return s;
}

// function streetFighterSelection7(fighters: Array<string[]>, position: number[], moves: string[]) {
//     function goLeft(current: number[]): number[] {
//         if (current[1] == 0) return [current[0], fighters[current[0]].length - 1];
//         return [current[0], current[1] - 1];
//     }

//     function goRight(current: number[]): number[] {
//         if (current[1] == fighters[current[0]].length - 1) return [current[0], 0];
//         return [current[0], current[1] + 1];
//     }

//     function goDown(current: number[]): number[] {
//         if (current[0] == fighters.length - 1) return current;
//         return [current[0] + 1, current[1]];
//     }

//     function goUp(current: number[]): number[] {
//         if (current[0] == 0) return current;
//         return [current[0] - 1, current[1]];
//     }

//     let selectedFighters: string[] = [];
//     let current = [...position]

//     for (let i = 0; i < moves.length; i += 1) {
//         let operation;
//         switch (moves[i]) {
//             case 'up': operation = goUp; break;
//             case 'down': operation = goDown; break;
//             case 'left': operation = goLeft; break;
//             case 'right': operation = goRight; break;
//         }

//         current = operation(current);
//         selectedFighters.push(fighters[current[0]][current[1]])
//     }

//     return selectedFighters
// }

// ================================

enum Moves {
    right = "right",
    left = "left",
    up = "up",
    down = "down",
}
export function streetFighterSelection8(
    fighters: Array<string[]>,
    position: number[],
    moves: string[]
) {
    var chosenFighters: string[] = [];
    var horizontalPosition = position[1];
    var verticalPosition = position[0];
    function setHorisontalPosition() {
        var fightersLength = fighters[verticalPosition].length - 1;
        if (horizontalPosition < 0) {
            horizontalPosition = fightersLength;
        } else if (horizontalPosition > fightersLength) {
            horizontalPosition = 0;
        }
    }

    function setVerticalPosition() {
        var fightersLength = fighters.length - 1;
        if (verticalPosition < 0) {
            verticalPosition = 0;
        } else if (verticalPosition > fightersLength) {
            verticalPosition = fightersLength;
        }
    }

    for (var i = 0; i < moves.length; i++) {
        if (moves[i] === Moves.right) {
            horizontalPosition++;
            setHorisontalPosition();
        } else if (moves[i] === Moves.left) {
            horizontalPosition--;
            setHorisontalPosition();
        } else if (moves[i] === Moves.up) {
            verticalPosition--;
            setVerticalPosition();
        } else if (moves[i] === Moves.down) {
            verticalPosition++;
            setVerticalPosition();
        }
        console.log(moves, fighters[verticalPosition][horizontalPosition]);
        chosenFighters.push(fighters[verticalPosition][horizontalPosition]);
    }
    return chosenFighters;
}
//   =======================

const MAX_X = 5;
const MAX_Y = 1;

export function streetFighterSelection9(
    fighters: Array<string[]>,
    position: number[],
    moves: string[]
) {
    let [x, y] = position;

    return moves.map((dir) => {
        switch (dir) {
            case "up":
                y = y > 0 ? y - 1 : y;
                break;
            case "down":
                y = y < MAX_Y ? y + 1 : y;
                break;
            case "left":
                x = x === 0 ? MAX_X : x - 1;
                break;
            case "right":
                x = x === MAX_X ? 0 : x + 1;
                break;
        }
        return fighters[y][x];
    });
}

function streetFighterSelection10(
    fighters: Array<string[]>,
    position: number[],
    moves: string[]
) {
    let hoveredCharacters = [];
    let currentPosition = position;
    for (let move of moves) {
        if (move == "up") {
            if (currentPosition[0] == 0) {
                hoveredCharacters.push(
                    fighters[currentPosition[0]][currentPosition[1]]
                );
            } else {
                currentPosition[0]--;
                hoveredCharacters.push(
                    fighters[currentPosition[0]][currentPosition[1]]
                );
            }
        }

        if (move == "down") {
            if (currentPosition[0] == 1) {
                hoveredCharacters.push(
                    fighters[currentPosition[0]][currentPosition[1]]
                );
            } else {
                currentPosition[0]++;
                hoveredCharacters.push(
                    fighters[currentPosition[0]][currentPosition[1]]
                );
            }
        }

        if (move == "left") {
            if (currentPosition[1] == 0) {
                currentPosition[1] = 5;
                hoveredCharacters.push(
                    fighters[currentPosition[0]][currentPosition[1]]
                );
            } else {
                currentPosition[1]--;
                hoveredCharacters.push(
                    fighters[currentPosition[0]][currentPosition[1]]
                );
            }
        }

        if (move == "right") {
            if (currentPosition[1] == 5) {
                currentPosition[1] = 0;
                hoveredCharacters.push(
                    fighters[currentPosition[0]][currentPosition[1]]
                );
            } else {
                currentPosition[1]++;
                hoveredCharacters.push(
                    fighters[currentPosition[0]][currentPosition[1]]
                );
            }
        }
    }

    return hoveredCharacters;
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
//  ❗️❗️❗️ LOOK INTO THIS: STRING.FROMCHARCODE() ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: PLAYING WITH PASSPHRASES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: SHIFT EACH LETTER BY A GIVEN NUM, ❗️❗️❗️ STRING.FROMCHARCODE() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Everyone knows passphrases. One can choose passphrases from poems, songs, movies names and so on but frequently they can be guessed due to common cultural references. You can get your passphrases stronger by different means. One is the following:

choose a text in capital letters including or not digits and non alphabetic characters,

shift each letter by a given number but the transformed letter must be a letter (circular shift),
replace each digit by its complement to 9,
keep such as non alphabetic and non digit characters,
downcase each letter in odd position, upcase each letter in even position (the first character is in position 0),
reverse the whole result.
Example:
your text: "BORN IN 2015!", shift 1

1 + 2 + 3 -> "CPSO JO 7984!"

4 "CpSo jO 7984!"

5 "!4897 Oj oSpC"

With longer passphrases it's better to have a small and easy program. Would you write it?
*/
const playPass = (str: string, shift: number): string => {
    const alphabet = "abcdefghijklmnopqrstuvwxyz";

    // ['i', ' ', 'l', 'o','v', 'e', ' ', 'y','o', 'u', '!', '!','!']
    const strArr: string[] = str.toLowerCase().split("");

    // ['j', ' ', 'm', 'p','w', 'f', ' ', 'z','p', 'v', '!', '!','!']
    const shiftArr: string[] = strArr.map((char, i) => {
        // CALCULATE TARGET IDX, IF IT IS LONGER THAN ARRAY LENGTH,
        // DIVIDE IT BY LENGTH AND GET REMAINDER AS IDX
        let targetIdx = alphabet.indexOf(char) + shift;
        if (targetIdx > alphabet.length - 1)
            targetIdx = targetIdx % alphabet.length;
        // IF CHAR IS A LETTER, REPLACE WITH LETTER AT TARGET IDX (A,B,C), 2 => (C, D, E)
        if (/[a-z]/.test(char)) return alphabet[targetIdx];
        // IF CHAR IS NUMERIC, REPLACE IT WITH ITS COMPLIMENT TO 9
        if (/[0-9]/.test(char)) return (9 - Number(char)).toString();

        // IF CHAR IS NOT A LETTER/DIGIT, THEN LEAVE IT AS IT IS
        return char;
    });

    // MAKE CHARS AT EVEN INDECES UPPERCASE, REVERSE ARRAY AND JOIN INTO STR
    const solution: string = shiftArr
        .map((char, i) => {
            if ((i & 1) === 0) return char.toUpperCase();
            return char;
        })
        .reverse()
        .join("");

    return solution;
};
// }"!!!vPz fWpM J"
// console.log(playPass("I LOVE YOU!!!", 1));
// console.log(playPass("xyz123", 2));
// "!!!uOy eVoL I"
// console.log(playPass("I LOVE YOU!!!", 0));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ STRING.FROMCHARCODE() ❗️❗️❗️
function playPass2(s: string, n: number): string {
    return s
        .toUpperCase()
        .split("")
        .map((v, i, a) => {
            if (/[0-9]/.test(v)) return Math.abs(Number(v) - 9);
            if (/[A-Z]/.test(v)) {
                let x = String.fromCharCode(
                    ((v.charCodeAt(0) + n - 65) % 26) + 65
                );
                return i % 2 == 1 ? x.toLowerCase() : x;
            }
            return v;
        })
        .reverse()
        .join("");
}

class G9641 {
    private static alphabet = "abcdefghijklmnopqrstuvwxyz";
    private static digits = "0123456789";

    private static isLetter(v: string) {
        return G9641.alphabet.indexOf(v) !== -1;
    }

    private static isDigit(v: string) {
        return G9641.digits.indexOf(v) !== -1;
    }

    public static playPass3(s: string = "", n: number = 0): string {
        if (!s) {
            return "";
        }
        return s
            .toLowerCase()
            .split("")
            .map((v, i) => {
                if (G9641.isLetter(v)) {
                    let letter =
                        G9641.alphabet[(G9641.alphabet.indexOf(v) + n) % 26];
                    return i % 2 ? letter.toLowerCase() : letter.toUpperCase();
                } else if (G9641.isDigit(v)) {
                    return 9 - Number(v);
                }
                return v;
            })
            .reverse()
            .join("");
    }
}

function playPass4(
    s: string,
    n: number,
    a: string = "abcdefghijklmnopqrstuvwxyz"
): string {
    return s
        .replace(/\d/g, (d) => "" + (9 - +d))
        .replace(
            /[a-z]/gi,
            (l) => a[(a.indexOf(l.toLowerCase()) + n) % a.length]
        )
        .split("")
        .map((e, i) => (i % 2 == 1 ? e : e.toUpperCase()))
        .reverse()
        .join("");
}

// ❗️❗️❗️ STRING.FROMCHARCODE() ❗️❗️❗️
class G9642 {
    public static playPass(s: string, n: number): string {
        let result = s.replace(/[A-Z]/g, (match) => {
            const code = match.charCodeAt(0);
            return String.fromCharCode(((code - 65 + n) % 26) + 65);
        });

        result = result.replace(/\d/g, (match) => {
            return Math.abs(Number(match) - 9).toString();
        });

        const split = result.split("");

        for (let i = 0; i < split.length; i++) {
            if (i % 2 === 0) {
                split[i] = split[i].toUpperCase();
            } else {
                split[i] = split[i].toLowerCase();
            }
        }
        return split.reverse().join("");
    }
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: FOLD AN ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: RECURSION,
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
In this kata you have to write a method that folds a given array of integers by the middle x-times.
 
An example says more than thousand words:
 
Fold 1-times:
[1,2,3,4,5] -> [6,6,3]
 
A little visualization (NOT for the algorithm but for the idea of folding):
 
 Step 1         Step 2        Step 3       Step 4       Step5
                     5/           5|         5\          
                    4/            4|          4\      
1 2 3 4 5      1 2 3/         1 2 3|       1 2 3\       6 6 3
----*----      ----*          ----*        ----*        ----*
 
 
Fold 2-times:
[1,2,3,4,5] -> [9,6]
As you see, if the count of numbers is odd, the middle number will stay. Otherwise the fold-point is between the middle-numbers, so all numbers would be added in a way.
 
The array will always contain numbers and will never be null. The parameter runs will always be a positive integer greater than 0 and says how many runs of folding your method has to do.
 
If an array with one element is folded, it stays as the same array.
 
The input array should not be modified!
*/
const foldArray = (numArr: number[], numFolds: number): number[] => {
    // TRACK NUMBER OF FOLDS REMAINING
    let numFoldsLeft: number = numFolds;
    // THIS IS THE STATE OF OUR numArr AFTER EACH FOLD
    let currentArray: number[] = [];

    // IF ODD LENGTH:
    if (numArr.length & 1) {
        // GRAB FIRST HALF, SECOND HALF(REVERSED) AND MIDDLE OF ARRAY
        let leadSub: number[] = numArr.slice(0, (numArr.length - 1) / 2);
        let trailSub: number[] = numArr
            .slice(Math.ceil(numArr.length / 2))
            .reverse();
        let middleEl: number = numArr[(numArr.length - 1) / 2];
        // SUM CURRENT PAIR AND PUSH INTO CURRENT ARR
        leadSub.forEach((num, idx) => {
            currentArray.push(num + trailSub[idx]);
        });
        // CONCAT MIDDLE ELEMENT TO CURREN ARRAY
        currentArray.push(middleEl);
        // DECREMENT NUMBER OF FOLDS BY ONE (OUTSIDE OF LOOP !!!)
        numFoldsLeft -= 1;
    } else {
        // EVEN LENGTH:
        for (let i = 0; i < numArr.length / 2; i += 1) {
            // CALC CURRENT SUM BY ADDING (FIRST AND N), (SECOND AND N-1), (THIRD AND N-2)...
            let currSum: number = numArr[i] + numArr[numArr.length - 1 - i];
            // PUSH INTO CURRENT ARRAY
            currentArray.push(currSum);
        }
        // DECREMENT NUMBER OF REMAINING FOLDS BY ONE (OUTSIDE OF LOOP !!!)
        numFoldsLeft -= 1;
    }

    // RECURSION: IF numFoldsLeft > 0 FUNCION TO CALL ITSELF WITH CURRENT ARGUMENTS,
    // OTHERWISE RETURN CURRENT ARRAY
    return numFoldsLeft ? foldArray(currentArray, numFoldsLeft) : currentArray;
};

//  [ 6, 6, 3 ]
// console.log(foldArray([1, 2, 3, 4, 5], 1));
//  [9, 6]
// console.log(foldArray([1, 2, 3, 4, 5], 2));
// [15]
// console.log(foldArray([1, 2, 3, 4, 5], 3));
// [ 14, 75, 0 ]
// console.log(foldArray([-9, 9, -8, 8, 66, 23], 1));
// [427]
// console.log(foldArray([1, 2, 3, 4, 5, 99, 88, 78, 74, 73], 5));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

//  ERROR: Object is possibly 'undefined'.ts(2532) AT array.pop(), ADDED "!"
function foldArray2(array: number[], runs: number): number[] {
    const arr2 = [...array];
    while (runs > 0) {
        arr2.map((val, i, arr) =>
            i + 1 === arr.length ? val : (arr[i] = val + arr.pop()!)
        );
        runs--;
    }
    return arr2;
}

function foldArray3(array: number[], runs: number): number[] {
    var len = array.length,
        arr = array.slice(); //copy array
    if (runs == 0) return arr;
    for (var i = 0; i < Math.floor(len / 2); i++) {
        arr[i] += arr[len - i - 1];
    }
    return foldArray(arr.slice(0, Math.ceil(len / 2)), runs - 1);
}

function foldArray4(array: number[], runs: number): number[] {
    let resultArray = array.slice();
    for (var i = 0; i < runs; ++i) {
        let runArray = resultArray.slice(0, Math.ceil(resultArray.length / 2));
        for (var j = resultArray.length - 1; j >= resultArray.length / 2; --j) {
            runArray[resultArray.length - 1 - j] += resultArray[j];
        }
        resultArray = runArray;
    }
    return resultArray;
}

function foldArray5(array: number[], runs: number): number[] {
    while (runs > 0) {
        let n = ~~(array.length / 2);
        array = Array.from(
            { length: n },
            (_, i) => array[i] + array[array.length - 1 - i]
        ).concat(...(array.length % 2 ? [array[n]] : []));
        runs--;
    }
    return array;
}

// =========================================================
function foldArray6(array: number[], runs: number): number[] {
    let foldedArray = array;
    for (let i = 0; i < runs; i++) {
        // Folding the array 'runs' times
        foldedArray = singleFold(foldedArray);
    }

    return foldedArray;
}

function singleFold(array: number[]) {
    const middle = Math.ceil(array.length / 2); // The middle of the array

    // Reversing the array and splitting it into the middle. Also adding
    // a trailing zero in case the array hasn't a pair length
    const reversed = array.slice(middle, array.length).reverse().concat(0);
    // Splitted but non reversed array
    const normal = array.slice(0, middle);

    // Number addition iteration
    return normal.map((num, i) => num + reversed[i]);
}
// =========================================================

function foldArray7(array: number[], runs: number): number[] {
    if (runs === 0) return array;

    const hasCenterPoint = array.length % 2 === 1;

    const foldLength = Math.floor(array.length / 2);

    const newArr = [];

    for (let i = 0; i < foldLength; i++) {
        newArr[i] = array[array.length - 1 - i] + array[i];
    }

    if (hasCenterPoint) newArr.push(array[foldLength]);

    return foldArray(newArr, --runs);
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: CONSONANT VALUE - GET MAX SUM OF CONSUNANT SUBSTRINGS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ SPLIT, MAP, REDUCE, MATH.MAX ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a lowercase string that has alphabetic characters only and no spaces, return the highest value of consonant substrings. Consonants are any letters of the alphabet except "aeiou".
 
We shall assign the following values: a = 1, b = 2, c = 3, .... z = 26.
 
For example, for the word "zodiacs", let's cross out the vowels. We get: "z o d ia cs"
 
-- The consonant substrings are: "z", "d" and "cs" and the values are z = 26, d = 4 and cs = 3 + 19 = 22. The highest is 26.
solve("zodiacs") = 26
 
For the word "strength", solve("strength") = 57
-- The consonant substrings are: "str" and "ngth" with values "str" = 19 + 20 + 18 = 57 and "ngth" = 14 + 7 + 20 + 8 = 49. The highest is 57.
For C: do not mutate input.
*/

// 1️⃣
const solve = (str: string): number => {
    // RETUTRN 0 IF NO CONSONANTS ARE IN STRING
    if (!/[bcdfghjklmnpqrstvwxyz]/g.test(str)) return 0;

    const alphabet = "abcdefghijklmnopqrstuvwxyz";

    // [ 'chr', 'schtsch', 'v' ] =>
    // [ [ 'c', 'h', 'r' ], ['s', 'c', 'h', 't', 's', 'c','h'],[ 'v' ]]
    const matchSubs: string[][] = str
        .match(/[^aeiou]+/g)!
        .map((sub) => sub.split(""));

    // [ [ 3, 8, 18 ], [ 19, 3, 8, 20, 19, 3, 8 ], [ 22 ] ]
    const valueSubs: number[][] = matchSubs.map((subArr) => {
        return subArr.map((char) => alphabet.indexOf(char) + 1);
    });

    let allSums: number[] = [];
    // GET SUM OF EACH SUBARRAY
    valueSubs.forEach((sub) => {
        let currSum = sub.reduce((acc, curr) => acc + curr);
        allSums.push(currSum);
    });

    // all sums => [ 29, 80, 22 ]
    const solution: number = Math.max(...allSums);
    // 80
    return solution;
};

// 2️⃣ SHORTER:
const solve6 = (str: string): number => {
    // RETUTRN 0 IF NO CONSONANTS ARE IN STRING
    if (!/[bcdfghjklmnpqrstvwxyz]/g.test(str)) return 0;

    const alphabet = "abcdefghijklmnopqrstuvwxyz";

    const valueSubs: number[][] = str
        .match(/[^aeiou]+/g)!
        .map((sub) => sub.split(""))
        .map((subArr) => {
            return subArr.map((char) => alphabet.indexOf(char) + 1);
        });

    let allSums: number[] = [];
    // GET SUM OF EACH SUBARRAY
    valueSubs.forEach((sub) => {
        let currSum = sub.reduce((acc, curr) => acc + curr);
        allSums.push(currSum);
    });

    // all sums => [ 29, 80, 22 ]
    const solution: number = Math.max(...allSums);
    // 80
    return solution;
};

// 80
// console.log(solve("chruschtschov"));
// console.log(solve("eaiouuua"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ SPLIT, MAP, REDUCE, MATH.MAX ❗️❗️❗️
function solve2(s: string) {
    // your code here
    return Math.max(
        ...s
            .split(/[aeiou]/)
            .map((x) => [...x].reduce((a, b) => a + b.charCodeAt(0) - 96, 0))
    );
}

// console.log(solve2("chruschtschov"));

function solve3(s: string) {
    let highest = 0;
    let sum = 0;

    for (let i = 0; i < s.length; i++) {
        if ("aeiou".includes(s[i])) {
            sum = 0;
            continue;
        }

        sum += s.charCodeAt(i) - 96;

        if (highest < sum) {
            highest = sum;
        }
    }

    return highest;
}

function solve4(s: string) {
    let res = 0;
    const arr = s.split(/a|e|i|o|u/);
    arr.forEach((subs) => {
        let sum = 0;
        for (let i = 0; i < subs.length; i++) {
            sum += subs.charCodeAt(i) - 96;
        }
        if (sum > res) res = sum;
    });
    return res;
}

function solve5(s: string): number {
    return Math.max(
        ...s
            .replace(/[aeiou]+/g, " ")
            .split(" ")
            .map((e) =>
                e
                    .split("")
                    .reduce(
                        (prev, current) => prev + current.charCodeAt(0) - 96,
                        0
                    )
            )
    );
}
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// ❗️❗️❗️ Execution Timed Out (12000 ms) ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: TORTOISE RACING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Two tortoises named A and B must run a race. A starts with an average speed of 720 feet per hour. Young B knows she runs faster than A, and furthermore has not finished her cabbage.
 
When she starts, at last, she can see that A has a 70 feet lead but B's speed is 850 feet per hour. How long will it take B to catch A?
 
More generally: given two speeds v1 (A's speed, integer > 0) and v2 (B's speed, integer > 0) and a lead g (integer > 0) how long will it take B to catch A?
 
The result will be an array [hour, min, sec] which is the time needed in hours, minutes and seconds (round down to the nearest second) or a string in some languages.
 
If v1 >= v2 then return nil, nothing, null, None or {-1, -1, -1} for C++, C, Go, Nim, Pascal, COBOL, [-1, -1, -1] for Perl,[] for Kotlin or "-1 -1 -1".
 
Examples:
(form of the result depends on the language)
 
race(720, 850, 70) => [0, 32, 18] or "0 32 18"
race(80, 91, 37)   => [3, 21, 49] or "3 21 49"
Note:
See other examples in "Your test cases".
 
In Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use dynamically allocated character strings.
 
** Hints for people who don't know how to convert to hours, minutes, seconds:
 
Tortoises don't care about fractions of seconds
Think of calculation by hand using only integers (in your code use or simulate integer division)
or Google: "convert decimal time to hours minutes seconds"
*/

const race = (v1: number, v2: number, lead: number): number[] => {
    const convert = (seconds: number): [number, number, number] => {
        let hour: number = 0,
            min: number = 0,
            sec: number = 0;

        // ❗️❗️❗️ TOO SLOW, TOO MANY OPERATIONS, USE DIISION AS BELOW ❗️❗️❗️
        // while (seconds >= 3600) {
        //     seconds -= 3600;
        //     hour += 1;
        // }
        // while (seconds >= 60) {
        //     seconds -= 60;
        //     min += 1;
        // }
        // while (seconds > 0) {
        //     seconds -= 1;
        //     sec += 1;
        // }

        if (seconds >= 3600) {
            hour += Math.floor(seconds / 3600);
            seconds = seconds % 3600;
            // console.log("seconds - 3600", seconds);
        }
        if (seconds >= 60) {
            min += Math.floor(seconds / 60);
            seconds = seconds % 60;
            // console.log("seconds - 60", seconds);
        }

        sec += seconds;

        return [hour, min, sec];
    };

    const feetPerSec1: number = v1 / 3600,
        feetPerSec2 = v2 / 3600;

    // const feetPerSec1: number = Math.floor(v1 / 3600)
    //       ,feetPerSec2 = Math.floor(v2 / 3600);
    // console.log(feetPerSec1, feetPerSec2);

    let numSeconds: number = 0;
    let dist1: number = lead;
    let dist2: number = 0;
    // let numHours: number = 0;

    while (dist2 < dist1) {
        dist1 += feetPerSec1;
        dist2 += feetPerSec2;
        numSeconds += 1;

        // dist1 += v1;
        // dist2 += v2;
        // numHours += 1;
    }

    // console.log(numSeconds);
    // console.log(numHours - 1);

    // ❗️❗️❗️ -1 ❗️❗️❗️
    const solution: number[] = convert(numSeconds - 1);

    return solution;

    // return [1];
};

// [3, 21, 49]
// console.log(race(80, 91, 37));
// [2, 0, 0]
// console.log(race(80, 100, 40));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: MULTIPLICATION TABLE/MATRIX
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task, is to create NxN multiplication table, of size provided in parameter.
 
for example, when given size is 3:
 
1 2 3
2 4 6
3 6 9
for given example, the return value should be: [[1,2,3],[2,4,6],[3,6,9]]
*/

const multiplicationTable = (size: number): number[][] => {
    let solution: number[][] = [];

    let firstRow: number[] = [];

    // [ 1, 2, 3 ]
    for (let i = 1; i <= size; i += 1) {
        firstRow.push(i);
    }
    console.log(firstRow);
    for (let i = 1; i <= firstRow.length; i += 1) {
        // [ 1, 2, 3 ] => [ 2, 4, 6 ] , [ 3, 6, 9 ]
        let nthRow: number[] = firstRow.map((num) => {
            return num * i;
        });
        solution.push(nthRow);
    }

    return solution;
};

// [1]
// console.log(multiplicationTable(1));
// [[1, 2], [2, 4]]
// console.log(multiplicationTable(2));
// [[1, 2, 3], [2, 4, 6], [3, 6, 9]]
// console.log(multiplicationTable(3));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const multiplicationTable2 = (size: number): number[][] => {
    const result = [];
    for (let i = 1; i <= size; i++) {
        const resultSubArr = [];
        for (let j = 1; j <= size; j++) {
            resultSubArr.push(i * j);
        }
        result.push(resultSubArr);
    }
    return result;
};

function multiplicationTable3(size: number): number[][] {
    return [...Array(size)].map((_, i) =>
        [...Array(size)].map((_, j) => (i + 1) * (j + 1))
    );
}

function multiplicationTable4(size: number): number[][] {
    let table: number[][] = [];

    for (let i = 1; size >= i; i++) {
        let row: number[] = [];
        for (let j = 1; size >= j; j++) {
            row.push(i * j);
        }
        table.push(row);
    }

    return table;
}

function multiplicationTable5(size: number): number[][] {
    return new Array(size)
        .fill(null)
        .map((_, i) =>
            new Array(size).fill(null).map((_, j) => (i + 1) * (j + 1))
        );
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: BACKSPACE IN STRING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: REGEX NEGATED SET // ❗️❗️❗️ RECURSION REPLACE ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Assume "#" is like a backspace in string. This means that string "a#bc#d" actually is "bd"
  
Your task is to process a string with "#" symbols.  
 
Examples
"abc#d##c"      ==>  "ac"
"abc##d######"  ==>  ""
"#######"       ==>  ""
""              ==>  ""
*/

const cleanString = (str: string): string => {
    let charsArr: string[] = [];

    for (let char of str) {
        // WITH REGEX:
        // if (/[^#]/.test(char)) charsArr.push(char);
        // if (/#/.test(char) && charsArr.length > 0) charsArr.pop();
        if (char !== "#") charsArr.push(char);
        if (char === "#" && charsArr.length) charsArr.pop();
    }
    const solution: string = charsArr.join("");
    return solution;
};

// "ac"
// console.log(cleanString('abc#d##c'));
// ""
// console.log(cleanString('abc####d##c#'));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ RECURSION REPLACE ❗️❗️❗️
function cleanString6(s: string): string {
    const re = /(^|[^#])#/;
    return re.test(s) ? cleanString(s.replace(re, "")) : s;
}

function cleanString2(s: string) {
    return Array.from(s).reduce(
        (a, b) => (b == "#" ? a.slice(0, -1) : a.concat(b)),
        ""
    );
}

function cleanString3(s: string): string {
    let stack = [];
    for (const c of s) {
        if (c === "#") {
            stack.pop();
        } else {
            stack.push(c);
        }
    }
    return stack.join("");
}

const cleanString4 = (s: string) =>
    Array.from(s).reduce(
        (acc, char) =>
            char === "#" ? acc.substring(0, acc.length - 1) : acc + char,
        ""
    );

function cleanString8(s: string): string {
    while (s.indexOf("#") != -1) {
        while (s[0] == "#") {
            s = s.substring(1);
        }

        s = s.replace(/[^#]#/g, "");
    }

    return s;
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: ENCRYPT THIS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ REPLACE() MULTIPLE / SWAP ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Encrypt this!
 
You want to create secret messages which can be deciphered by the Decipher this! kata. Here are the conditions:
 
Your message is a string containing space separated words.
You need to encrypt each word in the message using the following rules:
The first letter must be converted to its ASCII code.
The second letter must be switched with the last letter
Keepin' it simple: There are no special characters in the input.
Examples:
encryptThis "Hello" == "72olle"
encryptThis "good" == "103doo"
encryptThis "hello world" == "104olle 119drlo"
*/

const encryptThis = (str: string): string => {
    if (str.length === 0) return "";
    // [ [ 'A' ],[ 'w', 'i', 's', 'e' ]... ]
    const wordsArr: string[][] = str.split(" ").map((word) => word.split(""));
    wordsArr.forEach((lettersArr) => {
        //[ 'A' ],[ 'w', 'i', 's', 'e' ]... => "A", "w"... => 65 => "65"
        lettersArr[0] = lettersArr[0].charCodeAt(0).toString();
        if (lettersArr.length > 2) {
            // GRAB THE CHARACTERS THAT NEED SWAPPING
            let secondChar: string = lettersArr[1];
            let lastChar: string = lettersArr[lettersArr.length - 1];
            // SWAP
            lettersArr[1] = lastChar;
            lettersArr[lettersArr.length - 1] = secondChar;
        }
    });

    // [[ '65' ],[ '119', 'e', 's', 'i' ]...] => [65, 119esi...]
    // => "65 119esi 111dl 111lw 108dvei 105n 97n 111ka"
    const solution: string = wordsArr
        .map((array: string[]) => array.join(""))
        .join(" ");

    return solution;
};

//   ""
// console.log(encryptThis(""));
// "65"
// console.log((encryptThis("A"));
// "65 119esi 111dl 111lw 108dvei 105n 97n 111ka"
// console.log(encryptThis("A wise old owl lived in an oak"));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

let encryptThis2 = (str: string): string => {
    if (!str) return "";
    return str
        .split(" ")
        .map((word) => {
            let first = word[0];
            let second = word.length > 1 ? word[1] : "";
            let middle = word.slice(2, -1);
            let last = word.length > 2 ? word[word.length - 1] : "";
            return first.charCodeAt(0) + last + middle + second;
        })
        .join(" ");
};

// ❗️❗️❗️ REPLACE() MULTIPLE / SWAP ❗️❗️❗️
const encryptThis3 = (str: string): string =>
    str
        .split(" ")
        .map((word) =>
            word
                .replace(/(^\w)(\w)(\w*)(\w$)/, `$1$4$3$2`)
                .replace(/^\w/, (letter) => letter.charCodeAt(0).toFixed(0))
        )
        .join(" ");

// ❗️❗️❗️ REPLACE() MULTIPLE / SWAP ❗️❗️❗️
const encryptThis4 = (str: string): string => {
    return str.replace(
        /\b(\S)(\S?)(\S*?)(\S?)\b/g,
        (_, a, b, c, d) => `${a.charCodeAt(0)}${d}${c}${b}`
    );
};

const encryptThis5 = (str: string): string => {
    return str
        .split(" ")
        .map((word) => {
            if (word === "") return "";
            if (word.length === 1) return word.charCodeAt(0).toString();
            if (word.length === 2)
                return (word[0].charCodeAt(0) + word[1]).toString();

            return (
                word[0].charCodeAt(0) +
                word[word.length - 1] +
                word.substring(2, word.length - 1) +
                word[1]
            );
        })
        .join(" ");
};

// ❗️❗️❗️ REPLACE() MULTIPLE / SWAP ❗️❗️❗️
const encryptThis6 = (str: string): string => {
    return str
        .split(" ")
        .map((word) =>
            word.replace(
                /(^\w)(\w?)(\w*?)(\w?$)/,
                (match, p1, p2, p3, p4) => `${p1.charCodeAt(0)}${p4}${p3}${p2}`
            )
        )
        .join(" ");
};

const encryptThis7 = (str: string): string => {
    return str
        .split(" ")
        .map((w) => {
            switch (w.length) {
                case 0:
                    return "";
                case 1:
                    return w.charCodeAt(0);
                case 2:
                    return w.charCodeAt(0) + w.charAt(1);
                default:
                    return (
                        w.charCodeAt(0) +
                        w.charAt(w.length - 1) +
                        w.slice(2, w.length - 1) +
                        w.charAt(1)
                    );
            }
        })
        .join(" ");
};
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: MEETING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: SORT NESTED ARRAY, TYPE, CLASS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
John has invited some friends. His list is:
 
s = "Fred:Corwill;Wilfred:Corwill;Barney:Tornbull;Betty:Tornbull;Bjon:Tornbull;Raphael:Corwill;Alfred:Corwill";
Could you make a program that
 
makes this string uppercase
gives it sorted in alphabetical order by last name.
When the last names are the same, sort them by first name. Last name and first name of a guest come in the result between parentheses separated by a comma.
 
So the result of function meeting(s) will be:
 
"(CORWILL, ALFRED)(CORWILL, FRED)(CORWILL, RAPHAEL)(CORWILL, WILFRED)(TORNBULL, BARNEY)(TORNBULL, BETTY)(TORNBULL, BJON)"
It can happen that in two distinct families with the same family name two people have the same first name too.
 
 
*/

const meeting = (str: string): string => {
    // EXTRACT NAMES INTO ARRAY / MAKE UPPERCASE: 'ALEXIS:WAHL'...
    const namesArr: string[] = str.toUpperCase().split(";");
    let solution: string = "";
    // SPLIT FULL NAMES: [ 'ALEXIS', 'WAHL' ]...
    // REVERSE NAME ORDER: [ 'WAHL', 'ALEXIS' ]...
    const revNamesArr: string[][] = namesArr
        .map((fullName) => fullName.split(":"))
        .map((fullName) => fullName.reverse());
    // SORT ALPHABETICALLY: [ 'ARNO', 'ANN' ], [ 'BELL', 'JOHN' ]...
    const sortedTest: string[][] = revNamesArr.sort();
    // FORMAT AND CONCAT: (ARNO, ANN)(BELL, JOHN)...
    sortedTest.forEach((fullName) => {
        solution += `(${fullName.join(", ")})`;
    });

    return solution;
};

// "(ARNO, ANN)(BELL, JOHN)(CORNWELL, ALEX)(DORNY, ABBA)(KERN, LEWIS)(KORN, ALEX)(META, GRACE)(SCHWARZ, VICTORIA)(STAN, MADISON)(STAN, MEGAN)(WAHL, ALEXIS)");
// console.log(meeting("Alexis:Wahl;John:Bell;Victoria:Schwarz;Abba:Dorny;Grace:Meta;Ann:Arno;Madison:STAN;Alex:Cornwell;Lewis:Kern;Megan:Stan;Alex:Korn"));
// "(CORWILL, ALFRED)(CORWILL, FRED)(CORWILL, RAPHAEL)(CORWILL, WILFRED)(TORNBULL, BARNEY)(TORNBULL, BETTY)(TORNBULL, BJON)"
// console.log(meeting("Fred:Corwill;Wilfred:Corwill;Barney:Tornbull;Betty:Tornbull;Bjon:Tornbull;Raphael:Corwill;Alfred:Corwill"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function meeting2(s: string): string {
    return s
        .toUpperCase()
        .split(";")
        .map((n) => "(" + n.split(":").reverse().join(", ") + ")")
        .sort()
        .join("");
}

// ====================================================

type Attendee = {
    firstName: string;
    lastName: string;
};

const toUpper = (str: string) => str.toUpperCase();
const stringSorter = (a: string, b: string) => {
    if (a < b) {
        return -1;
    }
    if (a > b) {
        return 1;
    }
    return 0;
};
const attendeeToString = ({ lastName, firstName }: Attendee) =>
    `(${toUpper(lastName)}, ${toUpper(firstName)})`;

function meeting3(s: string): string {
    const attendees: Attendee[] = s.split(";").map((attendee) => {
        const [firstName, lastName] = attendee.split(":");
        return {
            firstName: toUpper(firstName),
            lastName: toUpper(lastName),
        };
    });

    const sortedAttendees = attendees.sort((a, b) => {
        if (a.lastName === b.lastName) {
            return stringSorter(a.firstName, b.firstName);
        } else {
            return stringSorter(a.lastName, b.lastName);
        }
    });

    return sortedAttendees.map((x) => attendeeToString(x)).join("");
}

// ====================================================

function meeting4(s: string): string {
    return s
        .split(";")
        .map((x) =>
            x
                .split(":")
                .map((x) => x.toUpperCase())
                .reverse()
                .join(", ")
        )
        .sort()
        .map((x) => `(${x})`)
        .join("");
}

// ====================================================

/**
 * * Wrapper for grouped objects
 */
type Group<T> = {
    key: string;
    value: Array<T>;
};

/**
 * * Friend class which contains an information about the meeting user
 */
class Friend {
    private readonly firstName: string;
    private readonly lastName: string;

    constructor(name: string) {
        const [firstName, lastName] = name.split(":");

        this.firstName = firstName.toUpperCase();
        this.lastName = lastName.toUpperCase();
    }

    get getFirstName() {
        return this.firstName;
    }

    get getLastName() {
        return this.lastName;
    }

    get getFullName() {
        return `(${this.getLastName}, ${this.getFirstName})`;
    }
}

/**
 * * Group for the meeting friend
 */
type FriendGroup = Group<Friend>;

/**
 * * Grouped friends
 */
class FriendGrouped {
    constructor(private readonly groups: Array<FriendGroup>) {}

    /**
     * * Sort array of groups by key value by alphabet
     */
    public sortGroupByKey() {
        this.groups.sort((lhs, rhs) => lhs.key.localeCompare(rhs.key));
    }

    /**
     * * Sort array of friends by firstName
     */
    public sortFriendsByFirstName() {
        this.groups.forEach((group) =>
            group.value.sort((lhs, rhs) =>
                lhs.getFirstName.localeCompare(rhs.getFirstName)
            )
        );
    }

    /**
     * * Transform groups to readable string
     */
    public toString() {
        let str = "";

        for (const group of this.groups) {
            str += group.value.map((friend) => friend.getFullName).join("");
        }

        return str;
    }
}

/**
 * * Helper to work with friends
 */
class FriendsHelper {
    /**
     * * Transform input to friends array
     */
    public static parse(input: string): Array<Friend> {
        return input.split(";").map((name) => new Friend(name));
    }

    /**
     * * Group by lastName and return an grouped list
     */
    public static createGroupedFriends(friends: Array<Friend>): FriendGrouped {
        let list: Array<FriendGroup> = [];

        friends.forEach((friend) => {
            let group = list.find((group) => group.key === friend.getLastName);

            if (!group) {
                group = {
                    key: friend.getLastName,
                    value: [],
                };

                list.push(group);
            }

            group.value.push(friend);
        });

        return new FriendGrouped(list);
    }
}

function meeting5(s: string): string {
    const friends = FriendsHelper.parse(s);
    const groupedFriends = FriendsHelper.createGroupedFriends(friends);
    groupedFriends.sortGroupByKey();
    groupedFriends.sortFriendsByFirstName();

    return groupedFriends.toString();
}
// ====================================================

class Attendee2 {
    static FromInputString(str: string) {
        const [firstName, lastName] = str.split(":");
        return new Attendee2(firstName, lastName);
    }

    constructor(private _first: string, private _last: string) {}

    public get first() {
        return this._first.toUpperCase();
    }
    public get last() {
        return this._last.toUpperCase();
    }

    public toString() {
        return `(${this.last}, ${this.first})`;
    }
}

const stringSorter2 = (a: string, b: string) => {
    if (a < b) {
        return -1;
    }
    if (a > b) {
        return 1;
    }
    return 0;
};

function meeting6(s: string): string {
    const attendees: Attendee2[] = s
        .split(";")
        .map((str) => Attendee2.FromInputString(str));

    const sortedAttendees = attendees.sort((a, b) => {
        if (a.last === b.last) {
            return stringSorter(a.first, b.first);
        } else {
            return stringSorter(a.last, b.last);
        }
    });

    return sortedAttendees.join("");
}

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: RULE OF DIVISIBILITY BY 13
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
From Wikipedia:
 
"A divisibility rule is a shorthand way of determining whether a given integer is divisible by a fixed divisor without performing the division, usually by examining its digits."
 
When you divide the successive powers of 10 by 13 you get the following remainders of the integer divisions:
 
1, 10, 9, 12, 3, 4 because:
 
10 ^ 0 ->  1 (mod 13)
10 ^ 1 -> 10 (mod 13)
10 ^ 2 ->  9 (mod 13)
10 ^ 3 -> 12 (mod 13)
10 ^ 4 ->  3 (mod 13)
10 ^ 5 ->  4 (mod 13)
(For "mod" you can see: https://en.wikipedia.org/wiki/Modulo_operation)
 
Then the whole pattern repeats. Hence the following method:
 
Multiply
 
the right most digit of the number with the left most number in the sequence shown above,
the second right most digit with the second left most digit of the number in the sequence.
The cycle goes on and you sum all these products. Repeat this process until the sequence of sums is stationary.
 
Example:
What is the remainder when 1234567 is divided by 13?
 
7      6     5      4     3     2     1  (digits of 1234567 from the right)
×      ×     ×      ×     ×     ×     ×  (multiplication)
1     10     9     12     3     4     1  (the repeating sequence)
Therefore following the method we get:
 
7×1 + 6×10 + 5×9 + 4×12 + 3×3 + 2×4 + 1×1 = 178
 
We repeat the process with the number 178:
 
8x1 + 7x10 + 1x9 = 87
 
and again with 87:
 
7x1 + 8x10 = 87
 
From now on the sequence is stationary (we always get 87) and the remainder of 1234567 by 13 is the same as the remainder of 87 by 13 ( i.e 9).
 
Task:
Call thirt the function which processes this sequence of operations on an integer n (>=0). thirt will return the stationary number.
 
thirt(1234567) calculates 178, then 87, then 87 and returns 87.
 
thirt(321) calculates 48, 48 and returns 48
*/

function thirt(n: number): number {
    return 1;
}

//  79
// console.log((thirt(8529));
// 31
// console.log(thirt(85299258));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: SUMS OF PARTS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ REVERSE() - MUTATES ORIGINAL ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Let us consider this example (array written in general format):
 
ls = [0, 1, 3, 6, 10]
 
Its following parts:
 
ls = [0, 1, 3, 6, 10]
ls = [1, 3, 6, 10]
ls = [3, 6, 10]
ls = [6, 10]
ls = [10]
ls = []
The corresponding sums are (put together in a list): [20, 20, 19, 16, 10, 0]
 
The function parts_sums (or its variants in other languages) will take as parameter a list ls and return a list of the sums of its parts as defined above.
 
Other Examples:
ls = [1, 2, 3, 4, 5, 6] 
parts_sums(ls) -> [21, 20, 18, 15, 11, 6, 0]
 
ls = [744125, 935, 407, 454, 430, 90, 144, 6710213, 889, 810, 2579358]
parts_sums(ls) -> [10037855, 9293730, 9292795, 9292388, 9291934, 9291504, 9291414, 9291270, 2581057, 2580168, 2579358, 0]
 
Notes
Take a look at performance: some lists have thousands of elements.
*/

const partsSums = (numArr: number[]): number[] => {
    numArr.reverse(); // ❗️❗️❗️ REVERSE() - MUTATES ORIGINAL ❗️❗️❗️
    let solution: number[] = [];
    let accum: number = 0;

    numArr.forEach((num) => {
        accum += num;
        solution.push(accum);
    });

    solution.reverse().push(0); //❗️❗️❗️ REVERSE() - MUTATES ORIGINAL ❗️❗️❗️
    return solution;
};

// [20, 20, 19, 16, 10, 0]
// console.log(partsSums([0, 1, 3, 6, 10]));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
function partsSums2(ls: number[]): number[] {
    let total = ls.reduce((acc, cur) => acc + cur, 0);
    return [...[total], ...ls.map((num) => (total -= num))];
}

function partsSums3(ls: number[]): number[] {
    let summArr = [0];
    for (let i = ls.length - 1; i >= 0; i--) {
        summArr.push(summArr[summArr.length - 1] + ls[i]);
    }
    return summArr.reverse();
}

function partsSums4(ls: number[]): number[] {
    let length = ls.length;
    let total = ls.reduce((prev, curr) => prev + curr, 0);
    ls.unshift(0);
    return ls.map((val, i) => (total -= val));
}

function partsSums5(values: number[]): number[] {
    let knownTotal = values.reduce((ac, n) => ac + n, 0);
    return values.reduce(
        (output, value) => {
            output.push((knownTotal -= value));
            return output;
        },
        [knownTotal]
    );
}

function partsSums6(ls: number[]): number[] {
    return ls
        .reverse()
        .reduce(
            (acc, n, i) => {
                const a = acc[i];
                acc.push(n + a);
                return acc;
            },
            [0]
        )
        .reverse();
}
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: MAKE THE DEADFISH SWIM
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: SWITCH(), FOR(OF)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a simple parser that will parse and run Deadfish.
 
Deadfish has 4 commands, each 1 character long:
 
i increments the value (initially 0)
d decrements the value
s squares the value
o outputs the value into the return array
Invalid characters should be ignored.
 
parse("iiisdoso") => [8, 64]
*/

/** return the output array and ignore all non-op characters */
const parse = (str: string): number[] => {
    let solution: number[] = [];
    let currVal: number = 0;
    str.split("").forEach((instr) => {
        // if (instr === "i") {
        //     currVal++;
        // } else if (instr === "d") {
        //     currVal--;
        // } else if (instr === "s") {
        //     currVal *= currVal;
        // } else if (instr === "o") {
        //     solution.push(currVal);
        // }

        switch (instr) {
            case "i":
                currVal++;
                break;
            case "d":
                currVal--;
                break;
            case "s":
                currVal *= currVal;
                break;
            case "o":
                solution.push(currVal);
        }
    });
    return solution;
};

// [8, 64]
// console.log(parse("iiisdoso"));
// [8, 64]
// console.log(parse("iiisxxxdoso"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function parse2(data: string): number[] {
    var result: number[] = [];
    var current = 0;

    data.split("").map((c) => {
        switch (c) {
            case "i":
                current++;
                break;
            case "d":
                current--;
                break;
            case "s":
                current = current ** 2;
                break;
            case "o":
                result.push(current);
                break;
        }
    });

    return result;
}

function parse3(data: string): number[] {
    let v = 0,
        result = [];
    for (let d of data.split("")) {
        switch (d) {
            case "i":
                v++;
                break;
            case "d":
                v--;
                break;
            case "s":
                v *= v;
                break;
            case "o":
                result.push(v);
        }
    }
    return result;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: HELP THE BOOKSELLER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ REGEX MATCH ONE OR MORE DIGITS TO EXTRACT NUMBER FROM STRING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A bookseller has lots of books classified in 26 categories labeled A, B, ... Z. Each book has a code c of 3, 4, 5 or more characters. The 1st character of a code is a capital letter which defines the book category.
 
In the bookseller's stocklist each code c is followed by a space and by a positive integer n (int n >= 0) which indicates the quantity of books of this code in stock.
 
For example an extract of a stocklist could be:
 
L = {"ABART 20", "CDXEF 50", "BKWRK 25", "BTSQZ 89", "DRTYM 60"}.
or
L = ["ABART 20", "CDXEF 50", "BKWRK 25", "BTSQZ 89", "DRTYM 60"] or ....
You will be given a stocklist (e.g. : L) and a list of categories in capital letters e.g :
 
M = {"A", "B", "C", "W"} 
or
M = ["A", "B", "C", "W"] or ...
and your task is to find all the books of L with codes belonging to each category of M and to sum their quantity according to each category.
 
For the lists L and M of example you have to return the string (in Haskell/Clojure/Racket a list of pairs):
 
(A : 20) - (B : 114) - (C : 50) - (W : 0)
where A, B, C, W are the categories, 20 is the sum of the unique book of category A, 114 the sum corresponding to "BKWRK" and "BTSQZ", 50 corresponding to "CDXEF" and 0 to category 'W' since there are no code beginning with W.
 
If L or M are empty return string is "" (Clojure and Racket should return an empty array/list instead).
 
Note:
In the result codes and their values are in the same order as in M.
*/

class G964C {
    public static stockList = (
        artList: string[],
        catList: string[]
    ): string => {
        let solutionArr: string[] = [];
        // COUNT TOTAL NUMBER OF BOOKS IN STOCK
        let totalCounter: number = 0;
        // LOOP OVER CATLIST AND FIND EACH CATEGORY IN ARTLIST
        catList.forEach((cat) => {
            // ❗️❗️❗️ TRY DOING IT WITH DYNAMIC REGEX ❗️❗️❗️
            // let regex = new RegExp(`/^${cat}/`);
            let counter: number = 0;
            artList.forEach((art) => {
                // if (regex.test(art)) {
                //     console.log(art);
                // }
                // CHECK IF FIRST CHARACTER OF art MATCHES cat ("B" IN "BKWR 250")
                if (art[0] === cat) {
                    // ❗️❗️❗️ EXTRACT NUMBER (ONE OR MORE NUMERIC DIGITS: "BTSQ 890" => [890], GET ONLY ELEMENT AT IDX 0)
                    let stock: number = Number(art.match(/\d+/g)![0]);
                    // INCREMENT COUNTER WITH CURRENT STOCK
                    counter += stock;
                }
            });
            // ADD FORMATTED PAIR TO solutionArr (B : 1290)
            solutionArr.push(`(${cat} : ${counter})`);
            // UPDATE TOTALCOUNTER
            totalCounter += counter;
        });

        // FORMAT SOLUTION [(A : 0), (B : 1290)...] => (A : 0) - (B : 1290) - (C : 515) - (D : 600)
        const solution: string = solutionArr.join(" - ");

        // RETURN EMPTY STRING IF ALL CATEGORIES ARE EMPTY, OTHERWISE SOLUTION
        return totalCounter ? solution : "";
    };
}

var b, c;
b = ["BBAR 150", "CDXE 515", "BKWR 250", "BTSQ 890", "DRTY 600"];
c = ["A", "B", "C", "D"];

// "(A : 0) - (B : 1290) - (C : 515) - (D : 600)"
// console.log(G964C.stockList(b, c));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// class G964C2 {

//     public static stockList = (listOfArt, listOfCat) => {
//         if( !listOfArt.length || !listOfCat.length ) return "";
//         var count = listOfArt.reduce(function(cat, art) {
//             cat[art[0]] = ~~cat[art[0]]+ +art.split(" ")[1];
//             return cat
//         },{});
//         return listOfCat.map(function(cat){ return "(" +cat +" : " + (count[cat] || 0) + ")"; }).join(" - ");
//     }
// }

// Variable 'bookList' implicitly has type 'any[]' in some locations where its type cannot be determined.ts(7034)
// class G964C3 {
//     public static stockList = (listOfArt: string[], listOfCat: string[]) => {
//       if (listOfArt.length === 0) return "";

//       const books: { [k: string]: number } = {};
//       listOfCat.forEach((category) => (books[category] = 0));

//       listOfArt.forEach((i) => {
//         let [category, quantity] = i.split(" ");
//         books[category[0]] += Number(quantity);
//       });

//       let bookList = [];
//       listOfCat.forEach((category) =>
//         bookList.push(`(${category} : ${books[category]})`)
//       );

//       return bookList.join(" - ");
//     };
//   }
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: REVERSE OR ROTATE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: FLAT()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The input is a string str of digits. Cut the string into chunks (a chunk here is a substring of the initial string) of size sz (ignore the last chunk if its size is less than sz).
 
If a chunk represents an integer such as the sum of the cubes of its digits is divisible by 2, reverse that chunk; otherwise rotate it to the left by one position. Put together these modified chunks and return the result as a string.
 
If
 
sz is <= 0 or if str is empty return ""
sz is greater (>) than the length of str it is impossible to take a chunk of size sz hence return "".
Examples:
revrot("123456987654", 6) --> "234561876549"
revrot("123456987653", 6) --> "234561356789"
revrot("66443875", 4) --> "44668753"
revrot("66443875", 8) --> "64438756"
revrot("664438769", 8) --> "67834466"
revrot("123456779", 8) --> "23456771"
revrot("", 8) --> ""
revrot("123456779", 0) --> "" 
revrot("563000655734469485", 4) --> "0365065073456944"
Example of a string rotated to the left by one position:
s = "123456" gives "234561".
*/

// "563000655734469485" LENGTH: 22
// "0365065073456944"   LENGTH: CHUNK(4) * 5 = 20

class G964B {
    public static revrot = (str: string, chunkSize: number): string => {
        if (chunkSize <= 0 || str.length === 0) return "";

        let numArr: number[] = str.split("").map((el) => parseInt(el));
        console.log(numArr);
        // ❓❓❓ WILL NOT ACCEPT type: number , type: any IS OK ❓❓❓
        //  let chunksArr: any = [];
        let chunksArr = [];
        // LOOP ONLY RUNS LENGTH / CHUNKSIZE TIMES
        for (let i = 0; i < str.length; i += chunkSize) {
            // ONLY GET CHUNKS WITH MINIMUM LENGTH OF chunkSize
            if (numArr.length >= chunkSize) {
                chunksArr.push(numArr.slice(0, chunkSize));
            }
            // DELETE FIRST chunkSize ELEMENTS
            numArr.splice(0, chunkSize);
        }

        // [ [ 5, 6, 3, 0 ], [ 0, 0, 6, 5 ], [ 5, 7, 3, 4 ], [ 4, 6, 9, 4 ] ]
        // console.log("before: ", chunksArr);

        // CHECK IF CHUNKS MEETS CONDITION
        chunksArr.forEach((chunk: number[]) => {
            // sum of the cubes of its digits is divisible by 2 ???
            let condition = Number.isInteger(
                chunk.map((num) => Math.pow(num, 3)).reduce((a, b) => a + b) / 2
            );
            if (condition) {
                // REVERSE [ 5, 6, 3, 0 ] => [ 0, 3, 6, 5 ]
                chunk = chunk.reverse();
            } else {
                // ROTATE [ 0, 0, 6, 5 ] => [ 0, 6, 5, 0 ]
                let firstDigit = chunk[0];
                chunk.splice(0, 1);
                chunk.push(firstDigit);
            }
        });

        // [ [ 0, 3, 6, 5 ], [ 0, 6, 5, 0 ], [ 7, 3, 4, 5 ], [ 6, 9, 4, 4 ] ]
        // console.log("after: ", chunksArr);

        // FLATTEN ARRAY AND JOIN INTO STRING
        const solution: string = chunksArr
            // ❗️❗️❗️ HAVE TO USE reduce() ON CODEWARS ❗️❗️❗️
            // .reduce((acc, val) => acc.concat(val), [])
            .flat()
            .join(""); // 0365065073456944

        return solution;
    };
}

/*
❗️❗️❗️ Property 'flat' does not exist on type 'any[]'. (2339) ❗️❗️❗️
 
You should add es2019 or es2019.array to your --lib setting for TypeScript to recognize array.flat() and flatMap().
 
Example:
 
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "es2019"
    ]
  }
}
 
To flat single level array:
 
arr.reduce((acc, val) => acc.concat(val), []);
 
To flat multi level array
 
function flatDeep(arr, d = 1) {
   return d > 0 ? arr.reduce((acc, val) => acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), []) : arr.slice();
};
*/

// "5630 0065 5734 4694 85" ==>
// "0365 0650 7345 6944"
// console.log(G964B.revrot("563000655734469485", 4));
// console.log(G964B.revrot("565635", 0));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

/*
class G964B3 {
    public static revrot(str: string, sz: number) {
        if (sz <= 0 || str == "" || sz > str.length) return "";
        let chunk = str.slice(0, sz).split('');
        const divisibleBy2 = chunk.reduce((a, b) => { return a + Math.pow(parseInt(b), 3) }, 0) % 2 == 0;
        divisibleBy2 ? chunk = chunk.reverse() : chunk.push(chunk.shift());
        return chunk.join('') + G964.revrot(str.slice(sz, str.length), sz);
    }
}
 
 
class G964B4 {
    public static revrot(str, sz) {
        if (sz <= 0 || str === '' || sz > str.length) return '';
        const chunks: string[] = str.match(new RegExp(`.{${sz}}`, 'g'));
        const test = (chunk: string) => chunk.split('').reduce((a: number, b: string) => a + Number(b)**3, 0) % 2 === 0 ? true : false;
        const reverse = (chunk: string) => chunk.split('').reverse().join('');
        const rotate = (chunk: string) => chunk.slice(1) + chunk[0];
        return chunks.map((chunk: string) => test(chunk) ? reverse(chunk) : rotate(chunk)).join('');
    }
}
 
 
 
class G964B5 {
    public static revrot(str, sz) {
        if(this.isInvalidInput(str, sz)) { return '' }
 
        const chunks: string[] = this.getChunks(str, sz);
        const newChunks = chunks.map(chunk => this.formatChunk(chunk, sz));
        
        return newChunks.join('');
        
    }
    
    private static isInvalidInput(str, sz) {
      return !str || !sz || str.length < sz;
    }
    
    private static getChunks(str: string, sz: number): string[] {
      return str.match(new RegExp('.{1,' + sz + '}', 'g'));
    }
    
    private static formatChunk(chunk: string, sz: number): string {
      if(chunk.length < sz) { 
        chunk = '';
        return '';
      }
      const splitChunk = chunk.split('');
      const shouldReverse = this.shouldReverseChunk(splitChunk);
      return shouldReverse ? this.reverseChunk(splitChunk) : this.rotateChunk(splitChunk);
    }
    
    private static shouldReverseChunk(splitChunk: string[]): boolean {
      const total = splitChunk.reduce((accumulator, currentValue) => accumulator + (+currentValue * +currentValue), 0);
      return +total % 2 === 0;
    }
    
    private static reverseChunk(splitChunk: string[]): string {
      return splitChunk.reverse().join('');
    }
    
    private static rotateChunk(splitChunk: string[]): string {
      const firstItem = splitChunk.shift();
      splitChunk.push(firstItem);
      return splitChunk.join('');
    }
}
 
 
 
class G964B6 {
    public static revrot(str, sz) {
        if (str === "" || sz === 0 || str.length < sz) {
            return "";
        }
 
        const processSlice = (s: string): string => {
            let chunks = [...s];
            const div2 = chunks.map((d) => Math.pow(parseInt(d), 3)).reduce((a, b) => a + b, 0) % 2 === 0;
            if (div2) {
                chunks.reverse();
            } else {
                chunks = [...chunks.slice(1), chunks[0]];
            }
            return chunks.join("");
          };
 
        return processSlice(str.slice(0, sz)) + G964B6.revrot(str.slice(sz), sz);
    }
}
 
*/

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  RECTANGLE INTO SQUARES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The drawing below gives an idea of how to cut a given "true" rectangle into squares ("true" rectangle meaning that the two dimensions are different).
 
alternative text
 
Can you translate this drawing into an algorithm?
 
You will be given two dimensions
 
a positive integer length
a positive integer width
You will return a collection or a string (depending on the language; Shell bash, PowerShell, Pascal and Fortran return a string) with the size of each of the squares.
 
Examples in general form:
(depending on the language)
 
  sqInRect(5, 3) should return [3, 2, 1, 1]
  sqInRect(3, 5) should return [3, 2, 1, 1]
  
  You can see examples for your language in **"SAMPLE TESTS".**
Notes:
lng == wdth as a starting case would be an entirely different problem and the drawing is planned to be interpreted with lng != wdth. (See kata, Square into Squares. Protect trees! http://www.codewars.com/kata/54eb33e5bc1a25440d000891 for this problem).
 
When the initial parameters are so that lng == wdth, the solution [lng] would be the most obvious but not in the spirit of this kata so, in that case, return None/nil/null/Nothing or return {} with C++, Array() with Scala, [] with Perl, Raku.
 
In that case the returned structure of C will have its sz component equal to 0.
 
Return the string "nil" with Bash, PowerShell, Pascal and Fortran.
*/

class G966 {
    public static sqInRect(length: number, width: number): number[] | null {
        if (length === width) return null;

        let solution: number[] = [];
        let descSides = [length, width].sort((a, b) => b - a);
        // console.log("descSides: ", descSides);

        while (descSides[0] > 0 && descSides[1] > 0) {
            //  COUNT HOW MANY SQUARES IT CONTAINS
            let numberOfSq: number = Math.floor(descSides[0] / descSides[1]);
            // console.log("squares found: ", numberOfSq);

            //  PUSH SQUARE INTO SOLUTION numberOfSq TIMES
            for (let i = 1; i <= numberOfSq; i++) {
                solution.push(descSides[1]);
            }
            // console.log("SOLUTION: ", solution);

            //  CALC NEW SMALLER SIDE (LONG / SHORT)
            let newSide: number = descSides[0] % descSides[1];
            // console.log("new side: ", newSide);

            // UPDATE ARRAY, SHORT(ARR[1]) IS NOW EQUAL TO NEWSIZE AND LONG IS PREVIOUS SHORT
            descSides[0] = newSide;
            descSides.sort((a, b) => b - a);
            // console.log("descSides: ", descSides);
        }

        return solution;
    }
}

/*
 
sides:  [ 5, 3 ]
descSides:  [ 5, 3 ]
squares found:  1
SOLUTION:  [ 3 ]
new side:  2
descSides:  [ 3, 2 ]
 
sides:  [ 3, 2 ]
descSides:  [ 3, 2 ]
squares found:  1
SOLUTION:  [ 2 ]
new side:  1
descSides:  [ 2, 1 ]
 
sides:  [ 2, 1 ]
descSides:  [ 2, 1 ]
squares found:  2
SOLUTION:  [ 1, 1 ]
new side:  0
descSides:  [ 1, 0 ]
 
sides:  [ 1, 0 ]
descSides:  [ 1, 0 ]
squares found:  Infinity
 
*/

// console.log(G964.sqInRect(5, 5));
// [ 3, 2, 1, 1 ]
// console.log(G966.sqInRect(5, 3));
// [ 14, 6, 6, 2, 2, 2 ]
// console.log(G966.sqInRect(20, 14));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G966a {
    public static sqInRect(l: number, w: number): number[] | null {
        if (l == w) return null;
        var sqs = [],
            tmp;
        while (l) {
            tmp = Math.min(w, l);
            l = Math.max(w, l);
            w = tmp;
            sqs.push(w);
            l -= w;
        }
        return sqs;
    }
}

class G966a1 {
    static sqInRect(l: number, w: number): number[] | null {
        if (l === w) return null;
        if (w > l) [l, w] = [w, l];
        return [w].concat(G966a1.sqInRect(l - w, w) || w);
    }
}

class G966a2 {
    public static sqInRect(l: number, w: number): number[] | null {
        let remainingSize: number = l * w;
        let shorterSide: number;
        const insideSqSides: Array<number> = [];

        if (l == w) {
            return null;
        }

        while (remainingSize > 0) {
            shorterSide = Math.min(l, w);
            remainingSize -= Math.pow(shorterSide, 2);

            l = shorterSide;
            w = remainingSize / l;

            insideSqSides.push(shorterSide);
        }

        return insideSqSides;
    }
}

// class G966a3 {
//     private static sq(l: number, w: number): number[] | null{
//       [l, w] = l > w ? [l, w] : [w, l];
//       return l === w ? [w] : [w, ...G966a3.sq(l - w, w)]
//     }
//     public static sqInRect(l: number, w: number): number[] {
//         // your code
//         return l === w ? null : G966a3.sq(l, w);
//     }
// }

// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  CAMEL CASE METHOD
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: CAPITALIZE FIRST LETTER, REPLACE(), MAP()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write simple .camelCase method (camel_case function in PHP, CamelCase in C# or camelCase in Java) for strings. All words must have their first letter capitalized without spaces.
 
For instance:
 
camelCase("hello case"); // => "HelloCase"
camelCase("camel case word"); // => "CamelCaseWord"
 
*/
const camelCase = (str: string): string => {
    /*
    return str
        ? str
            .trim()
            .split(" ")
            .map((word) => word.replace(word[0], word[0].toUpperCase()))
            .join("")
        : "";  
    */

    return str
        ? str
              .trim()
              .split(" ")
              .map((word) =>
                  word
                      //   ❗️❗️❗️ DON'T NEED TO LOWERCASE, PRESERVE ORIGINAL FORMAT ❗️❗️❗️
                      //   .toLowerCase()
                      .replace(word[0], word[0].toUpperCase())
              )
              .join("")
        : "";

    // return "hello";
};

// ""
// console.log(camelCase(""));
// "TestCase"
// console.log(camelCase(" test case"));
// console.log(camelCase("camel case method"));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const camelCase2 = (str: string): string =>
    str
        .split(" ")
        .map((s) => (s ? s[0].toUpperCase() + s.slice(1) : ""))
        .join("");

function camelCase3(str: string): string {
    return str
        .replace(/\b\w/g, (str) => str.toUpperCase())
        .split(" ")
        .join("");
}

function camelCase4(str: string): string {
    return str
        .split(" ")
        .reduce(
            (acc, cur) => acc + cur.charAt(0).toUpperCase() + cur.slice(1),
            ""
        );
}

function camelCase5(str: string): string {
    return str
        .split(" ")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join("");
}

const camelCase6 = (str: string): string =>
    str
        .split(" ")
        .map((s) => s.replace(s.charAt(0), s.charAt(0).toUpperCase()))
        .join("");

function camelCase7(str: string): string {
    return str
        ? str
              .trim()
              .split(" ")
              .map((word) => word[0].toUpperCase() + word.substring(1))
              .join("")
        : "";
}

const camelCase8 = (str: string): string =>
    str
        .split(" ")
        .map((x) => x[0]?.toUpperCase().concat(x.slice(1)))
        .join("");

const camelCase9 = (str: string): string =>
    str
        .split(" ")
        .map((word) =>
            word.length ? word[0].toUpperCase() + word.slice(1) : ""
        )
        .join("");

// function camelCase(str: string): string {
//   return str
//          .split(' ')
//          .map(item =>  item.replace(/^./, item.charAt(0).toUpperCase()))
//          .join('');

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ REFACTOR AND COMMENT ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ROMAN NUMERALS DECODER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Create a function that takes a Roman numeral as its argument and returns its value as a numeric decimal integer. You don't need to validate the form of the Roman numeral.
 
Modern Roman numerals are written by expressing each decimal digit of the number to be encoded separately, starting with the leftmost digit and skipping any 0s. So 1990 is rendered "MCMXC" (1000 = M, 900 = CM, 90 = XC) and 2008 is rendered "MMVIII" (2000 = MM, 8 = VIII). The Roman numeral for 1666, "MDCLXVI", uses each letter in descending order.
 
Example:
 
solution('XXI'); // should return 21
Help:
 
Symbol    Value
I          1
V          5
X          10
L          50
C          100
D          500
M          1,000
Courtesy of rosettacode.org
*/

// interface Counter {
//     [key: string]: number;
// }

// const counterObj: Counter = {};

const solution0 = (roman: string): number => {
    // VALUES OBJ
    const romanValues = {
        I: 1,
        II: 2,
        III: 3,
        IV: 4,
        V: 5,
        VI: 6,
        VII: 7,
        VIII: 8,
        IX: 9,
        X: 10,
        XX: 20,
        XXX: 30,
        XL: 40,
        L: 50,
        XC: 90,
        C: 100,
        CC: 200,
        CCC: 300,
        CD: 400,
        D: 500,
        CM: 900,
        M: 1000,
        MM: 2000,
        MMM: 3000,
    };

    let result: number = 0;

    // FILTER OUT COMBINATIONS
    if (roman.indexOf("CM") > -1) {
        result += romanValues.CM;
        roman = roman.replace("CM", "");
    }
    if (roman.indexOf("CD") > -1) {
        result += romanValues.CD;
        roman = roman.replace("CD", "");
    }
    if (roman.indexOf("D") > -1) {
        result += romanValues.D;
        roman = roman.replace("D", "");
    }
    if (roman.indexOf("XC") > -1) {
        result += romanValues.XC;
        roman = roman.replace("XC", "");
    }
    if (roman.indexOf("XL") > -1) {
        result += romanValues.XL;
        roman = roman.replace("XL", "");
    }
    if (roman.indexOf("L") > -1) {
        result += romanValues.L;
        roman = roman.replace("L", "");
    }
    if (roman.indexOf("IX") > -1) {
        result += romanValues.IX;
        roman = roman.replace("IX", "");
    }
    if (roman.indexOf("IV") > -1) {
        result += romanValues.IV;
        roman = roman.replace("IV", "");
    }
    if (roman.indexOf("V") > -1) {
        result += romanValues.V;
        roman = roman.replace("V", "");
    }

    // COUNT SINGLES AND MULTIPLY BY VALUE. ERROR WITHOUT "!"
    if (roman.match(/M/g)) result += romanValues.M * roman.match(/M/g)!.length;
    if (roman.match(/C/g)) result += romanValues.C * roman.match(/C/g)!.length;
    if (roman.match(/X/g)) result += romanValues.X * roman.match(/X/g)!.length;
    if (roman.match(/I/g)) result += romanValues.I * roman.match(/I/g)!.length;

    return result;
};

function solution1(roman: string): number {
    var valRoman = {
        1: "I",
        4: "IV",
        5: "V",
        9: "IX",
        10: "X",
        40: "XL",
        50: "L",
        90: "XC",
        100: "C",
        400: "CD",
        500: "D",
        900: "CM",
        1000: "M",
    };

    // console.log(valRoman[40]);

    var romanVal = {
        I: 1,
        IV: 4,
        V: 4,
        IX: 9,
        x: 10,
        XL: 40,
        L: 50,
        XC: 90,
        C: 100,
        CD: 400,
        D: 500,
        CM: 900,
        M: 1000,
    };

    // console.log(romanVal.IV);

    const romanStrVal = {
        I: 1,
        II: 2,
        III: 3,
        IV: 4,
        V: 5,
        VI: 6,
        VII: 7,
        VIII: 8,
        IX: 9,
        X: 10,
        XX: 20,
        XXX: 30,
        XL: 40,
        L: 50,
        XC: 90,
        C: 100,
        CC: 200,
        CCC: 300,
        CD: 400,
        D: 500,
        CM: 900,
        M: 1000,
        MM: 2000,
        MMM: 3000,
    };

    // console.log(romanStrVal.XL);
    // console.log(romanStrVal[XL])  ERROR

    let result: number = 0;
    console.log(roman);

    if (roman.indexOf("CM") > -1) {
        result += romanStrVal.CM;
        roman = roman.replace("CM", "");
    }

    // if (roman.indexOf("MMM") > -1) {
    //     result += romanStrVal.MMM;
    //     roman = roman.replace("MMM", "")
    // }
    // if (roman.indexOf("MM") > -1) {
    //     result += romanStrVal.MM;
    //     roman = roman.replace("MM", "")
    // }
    // if (roman.indexOf("M") > -1) {
    //     result += romanStrVal.M;
    //     roman = roman.replace("M", "")
    // }

    if (roman.indexOf("CD") > -1) {
        result += romanStrVal.CD;
        roman = roman.replace("CD", "");
    }
    if (roman.indexOf("D") > -1) {
        result += romanStrVal.D;
        roman = roman.replace("D", "");
    }

    // if (roman.indexOf("CCC") > -1) {
    //     result += romanStrVal.CCC;
    //     roman = roman.replace("CCC", "");
    // }
    // if (roman.indexOf("CC") > -1) {
    //     result += romanStrVal.CC;
    //     roman = roman.replace("CC", "");
    // }
    // if (roman.indexOf("C") > -1) {
    //     result += romanStrVal.C;
    //     roman = roman.replace("C", "");
    // }

    if (roman.indexOf("XC") > -1) {
        result += romanStrVal.XC;
        roman = roman.replace("XC", "");
    }

    if (roman.indexOf("XL") > -1) {
        result += romanStrVal.XL;
        roman = roman.replace("XL", "");
    }
    if (roman.indexOf("L") > -1) {
        result += romanStrVal.L;
        roman = roman.replace("L", "");
    }

    if (roman.indexOf("IX") > -1) {
        result += romanStrVal.IX;
        roman = roman.replace("IX", "");
    }
    // if (roman.indexOf("XXX") > -1) {
    //     result += romanStrVal.XXX;
    //     roman = roman.replace("XXX", "");
    // }
    // if (roman.indexOf("XX") > -1) {
    //     result += romanStrVal.XX;
    //     roman = roman.replace("XX", "");
    // }
    // if (roman.indexOf("X") > -1) {
    //     result += romanStrVal.X;
    //     roman = roman.replace("X", "");
    // }

    if (roman.indexOf("IV") > -1) {
        result += romanStrVal.IV;
        roman = roman.replace("IV", "");
    }
    if (roman.indexOf("V") > -1) {
        result += romanStrVal.V;
        roman = roman.replace("V", "");
    }
    // if (roman.indexOf("III") > -1) {
    //     result += romanStrVal.III;
    //     roman = roman.replace("III", "");
    // }
    // if (roman.indexOf("II") > -1) {
    //     result += romanStrVal.II;
    //     roman = roman.replace("II", "");
    // }
    // if (roman.indexOf("I") > -1) {
    //     result += romanStrVal.I;
    //     roman = roman.replace("I", "");
    // }

    // roman = roman.replace(/CM|CD|D|XC|XL|L|IX|IV|V/g, "");

    const Ms: number | undefined = roman.match(/M/g)?.length;
    if (Ms) result += romanStrVal.M * Ms;
    // result += romanStrVal.M * Ms;
    // console.log("1000: ", Ms);

    const Cs: number | undefined = roman.match(/C/g)?.length;
    if (Cs) result += romanStrVal.C * Cs;
    // console.log("100: ", Cs);

    const Xs: number | undefined = roman.match(/X/g)?.length;
    if (Xs) result += romanStrVal.X * Xs;
    // console.log("10: ", Xs);

    const Is: number | undefined = roman.match(/I/g)?.length;
    if (Is) result += romanStrVal.I * Is;
    // console.log("1: ", Is);

    // console.log(result);
    console.log("roman: ", roman);

    return result;
}

// console.log(solution1("MDCCCXXIXII"));
// console.log(solution1("MDCLXVI"));
// console.log(solution1('MMCM'));
// console.log(solution('IV');
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

const values: Record<string, number> = {
    I: 1,
    V: 5,
    X: 10,
    L: 50,
    C: 100,
    D: 500,
    M: 1000,
};

export function solution5(roman: string): number {
    let value = 0;
    for (let i = 0; i < roman.length; i++) {
        const current = values[roman[i]];
        const next = values[roman[i + 1]] || 0;
        if (current < next) {
            value -= current;
        } else {
            value += current;
        }
    }
    return value;
}

function solution8(roman: string): number {
    const symbols: any = {
        I: 1,
        V: 5,
        X: 10,
        L: 50,
        C: 100,
        D: 500,
        M: 1000,
    };
    return roman
        .split("")
        .map((e) => symbols[e])
        .reduce((p, c) => (p < c ? c - p : c + p));
}

//   function solution9(roman: string): number {
//     const table = {
//       M : 1000,
//       D: 500,
//       C: 100,
//       L: 50,
//       X: 10,
//       V: 5,
//       I: 1
//     }

//     return roman.split('').reduceRight((prev, cur, i, arr) => {
//       return table[arr[i+1]] > table[cur] ? prev - table[cur] : prev + table[cur];
//     }, 0);
//   }

// function solution10(roman: string): number {
//     let splitString : string[] = roman.split("");
//     let num : number = 0;
//     let previous: string;
//     for(var i = 0; i < splitString.length; i++)
//     {
//       if( splitString[i] == "I")
//       {
//         num += 1;
//       }
//       else if( splitString[i] == "V" && previous != "I")
//       {
//         num += 5;
//       }
//       else if( splitString[i] == "V" && previous == "I")
//       {
//         num += 3;
//       }
//       else if( splitString[i] == "X")
//       {
//         num += 10;
//       }
//       else if( splitString[i] == "L" && previous != "X")
//       {
//         num += 50;
//       }
//       else if( splitString[i] == "L" && previous == "X")
//       {
//         num += 30;
//       }
//       else if( splitString[i] == "C" && previous != "X")
//       {
//         num += 100;
//       }
//       else if( splitString[i] == "C" && previous == "X")
//       {
//         num += 80;
//       }
//       else if( splitString[i] == "D" && previous != "C")
//       {
//         num += 500;
//       }
//       else if( splitString[i] == "D" && previous == "C")
//       {
//         num += 300;
//       }
//       else if( splitString[i] == "M" && previous != "C")
//       {
//         num += 1000;
//       }
//       else if( splitString[i] == "M" && previous == "I")
//       {
//         num += 800;
//       }
//       previous = splitString[i];
//     }
//     return num;
//   }

function solution11(roman: string): number {
    const symbols: any = {
        I: 1,
        V: 5,
        X: 10,
        L: 50,
        C: 100,
        D: 500,
        M: 1000,
    };

    return roman
        .split("")
        .map((r: string, i: number, arr: string[]) =>
            r === "I" && ["V", "X"].includes(arr[i + 1]) ? -1 : symbols[r]
        )
        .reduce((a: number, b: number) => a + b);
}

function solution12(roman: string): number {
    // complete the solution by transforming the
    // string roman numeral into an integer
    const map = new Map([
        ["I", 1],
        ["IV", 4],
        ["V", 5],
        ["IX", 9],
        ["X", 10],
        ["XL", 40],
        ["L", 50],
        ["XC", 90],
        ["C", 100],
        ["CD", 400],
        ["D", 500],
        ["CM", 900],
        ["M", 1000],
    ]);
    let result = 0;

    for (let i = 0; i < roman.length; i++) {
        const twoSymbols = map.get(roman[i] + roman[i + 1]);
        const oneSymbol = map.get(roman[i]);
        if (twoSymbols) {
            i += 1;
        }
        result += twoSymbols || oneSymbol || 0;
    }

    return result;
}

//   function solution13(roman: string): number {
//     var dict = {M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1};
//    var result = 0;
//    while (roman.length > 0) {
//      for (var e in dict) {
//        if (roman.substring(0, 2) == e) {
//          result += dict[e];
//          roman = roman.substr(2);
//        } else if (roman.substring(0, 1) == e) {
//          result += dict[e];
//          roman = roman.substr(1);
//        }
//      }
//    }
//    return result;
//  }

function solution13(roman: string): number {
    const values: Record<string, number> = {
        I: 1,
        V: 5,
        X: 10,
        L: 50,
        C: 100,
        D: 500,
        M: 1000,
        CM: 900,
        CD: 400,
        XC: 90,
        XL: 40,
        IX: 9,
        IV: 4,
    };
    return roman
        .replace(/CM|CD|XC|XL|IX|IV|M|D|C|L|X|V|I/g, (r) => `,${values[r]},`)
        .split(/,+/)
        .reduce((sum: number, n: string) => sum + Number(n), 0);
}

function solution14(roman: string): number {
    const initial = 0;
    const numbers: number[] = roman.split("").map((letter) => {
        switch (letter) {
            case "I":
                return 1;
            case "V":
                return 5;
            case "X":
                return 10;
            case "L":
                return 50;
            case "C":
                return 100;
            case "D":
                return 500;
            case "M":
                return 1000;
            default:
                return 0;
        }
    });
    const result = numbers.reduce(function (
        valorAnterior,
        valorActual,
        indice
    ) {
        if (
            indice + 1 === numbers.length ||
            valorActual >= numbers[indice + 1]
        ) {
            return valorAnterior + valorActual;
        } else {
            return valorAnterior - valorActual;
        }
    },
    initial);
    return result;
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ REFACTOR THIS ❗️❗️❗️ AND COMMENT ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ROMAN NUMERALS ENCODER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: REPEAT(), MODULO
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Create a function taking a positive integer as its parameter and returning a string containing the Roman Numeral representation of that integer.
 
Modern Roman numerals are written by expressing each digit separately starting with the left most digit and skipping any digit with a value of zero. In Roman numerals 1990 is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC. 2008 is written as 2000=MM, 8=VIII; or MMVIII. 1666 uses each Roman symbol in descending order: MDCLXVI.
 
Example:
 
solution(1000); // should return 'M'
Help:
 
Symbol    Value
I          1
V          5
X          10
L          50
C          100
D          500
M          1,000
Remember that there can't be more than 3 identical symbols in a row.
*/

const solution2 = (num: number): string => {
    let roman: string = "";

    // console.table({ num: num, roman: roman });

    if (num >= 1000) {
        // GET INT NUMBER OF 1000s
        const v1000: number = (num / 1000) | 0;
        console.log("1000: " + v1000);
        // GET REMAINDER AFTER TAKING AWAY 1000s
        num = num % 1000;
        // REPEAT "M" V1000 TIMES
        roman += "M".repeat(v1000);
        // console.table({ num: num, roman: roman });
    }

    if (num >= 900) {
        num = num % 900;
        roman += "CM";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 500) {
        num = num % 500;
        roman += "D";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 400) {
        num = num % 400;
        roman += "CD";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 100) {
        const v100: number = (num / 100) | 0;
        console.log("100: " + v100);
        num = num % 100;
        roman += "C".repeat(v100);
        // console.table({ num: num, roman: roman });
    }

    if (num >= 90) {
        num = num % 90;
        roman += "XC";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 50) {
        num = num % 50;
        roman += "L";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 40) {
        num = num % 40;
        roman += "XL";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 10) {
        const v10: number = (num / 10) | 0;
        console.log("10: " + v10);
        num = num % 10;
        roman += "X".repeat(v10);
        // console.table({ num: num, roman: roman });
    }

    if (num >= 9) {
        num = num % 9;
        roman += "IX";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 5) {
        num = num % 5;
        roman += "V";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 4) {
        num = num % 4;
        roman += "IV";
        // console.table({ num: num, roman: roman });
    }

    if (num >= 1) {
        const v1: number = (num / 1) | 0;
        // console.log("1: " + v1);
        num = num % 1;
        roman += "I".repeat(v1);
        // console.table({ num: num, roman: roman });
    }

    return num > 3999 ? "invalid input" : roman;
};

/*
3999
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│   num   │  3999  │
│  roman  │   ''   │
└─────────┴────────┘
1000: 3
┌─────────┬────────┐
│ (index) │ Values │
├─────────┼────────┤
│   num   │  999   │
│  roman  │ 'MMM'  │
└─────────┴────────┘
900: 1
┌─────────┬─────────┐
│ (index) │ Values  │
├─────────┼─────────┤
│   num   │   99    │
│  roman  │ 'MMMCM' │
└─────────┴─────────┘
90: 1
┌─────────┬───────────┐
│ (index) │  Values   │
├─────────┼───────────┤
│   num   │     9     │
│  roman  │ 'MMMCMXC' │
└─────────┴───────────┘
9: 1
┌─────────┬─────────────┐
│ (index) │   Values    │
├─────────┼─────────────┤
│   num   │      0      │
│  roman  │ 'MMMCMXCIX' │
└─────────┴─────────────┘
MMMCMXCIX
*/

// console.log(solution2(3999));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ERROR:
// Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ M: number; CM: number; D: number; CD: number; C: number; XC: number; L: number; XL: number; X: number; IX: number; V: number; IV: number; I: number; } '.
//   No index signature with a parameter of type 'string' was found on type '{ M: number; CM: number; D: number; CD: number; C: number; XC: number; L: number; XL: number; X: number; IX: number; V: number; IV: number; I: number; }'.ts(7053)

// function solution3(number: number): string {
//     const ROMAN = {
//         M: 1000,
//         CM: 900,
//         D: 500,
//         CD: 400,
//         C: 100,
//         XC: 90,
//         L: 50,
//         XL: 40,
//         X: 10,
//         IX: 9,
//         V: 5,
//         IV: 4,
//         I: 1,
//     };

//     let result = "";
//     for (let k in ROMAN) {
//         result += k.repeat(Math.floor(number / ROMAN[k]));
//         number = number % ROMAN[k];
//     }

//     return result;
// }

function solution4(number: number): string {
    const nums: Array<number> = [
        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1,
    ];
    const romans: Array<string> = [
        "M",
        "CM",
        "D",
        "CD",
        "C",
        "XC",
        "L",
        "XL",
        "X",
        "IX",
        "V",
        "IV",
        "I",
    ];
    let result: string = "";

    for (let i: number = 0; i < nums.length; i++) {
        while (number >= nums[i]) {
            number -= nums[i];
            result += romans[i];
        }
    }

    return result;
}

// ERROR:
// Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ M: number; CM: number; D: number; CD: number; C: number; XC: number; L: number; XL: number; X: number; IX: number; V: number; IV: number; I: number; } '.
//   No index signature with a parameter of type 'string' was found on type '{ M: number; CM: number; D: number; CD: number; C: number; XC: number; L: number; XL: number; X: number; IX: number; V: number; IV: number; I: number; }'.ts(7053)

// function solution5(number: number): string {
//     let table = {
//         "1": "I",
//         "2": "II",
//         "3": "III",
//         "4": "IV",
//         "5": "V",
//         "6": "VI",
//         "7": "VII",
//         "8": "VIII",
//         "9": "IX",
//         "10": "X",
//         "20": "XX",
//         "30": "XXX",
//         "40": "XL",
//         "50": "L",
//         "60": "LX",
//         "70": "LXX",
//         "80": "LXXX",
//         "90": "XC",
//         "100": "C",
//         "200": "CC",
//         "300": "CCC",
//         "400": "CD",
//         "500": "D",
//         "600": "DC",
//         "700": "DCC",
//         "800": "DCCC",
//         "900": "CM",
//         "1000": "M",
//         "2000": "MM",
//         "3000": "MMM",
//     };
//     let output = "";
//     let str = number.toString();

//     for (let i = str.length - 1, zeros = ""; i >= 0; i--, zeros += "0") {
//         let current = str.charAt(i);
//         if (current !== "0") output = table[current + zeros] + output;
//     }

//     return output;
// }

function solution6(n: number): string {
    let thousands: string[] = ["", "M", "MM", "MMM"];
    let hundreds: string[] = [
        "",
        "C",
        "CC",
        "CCC",
        "CD",
        "D",
        "DC",
        "DCC",
        "DCCC",
        "CM",
    ];
    let tens: string[] = [
        "",
        "X",
        "XX",
        "XXX",
        "XL",
        "L",
        "LX",
        "LXX",
        "LXXX",
        "XC",
    ];
    let ones: string[] = [
        "",
        "I",
        "II",
        "III",
        "IV",
        "V",
        "VI",
        "VII",
        "VIII",
        "IX",
    ];

    let res: string = "";
    res += thousands[Math.floor(n / 1000)];
    res += hundreds[Math.floor(n / 100) % 10];
    res += tens[Math.floor(n / 10) % 10];
    res += ones[n % 10];
    return res;
}

function solution7(number: number): string {
    let returnString = "";
    const table = [
        { key: "M", value: 1000 },
        { key: "CM", value: 900 },
        { key: "D", value: 500 },
        { key: "CD", value: 400 },
        { key: "C", value: 100 },
        { key: "XC", value: 90 },
        { key: "L", value: 50 },
        { key: "XL", value: 40 },
        { key: "X", value: 10 },
        { key: "IX", value: 9 },
        { key: "V", value: 5 },
        { key: "IV", value: 4 },
        { key: "I", value: 1 },
    ];
    while (true) {
        const v = table.filter((v) => v.value <= number)[0];
        if (v == null) {
            break;
        }
        if (v !== null) {
            if (v.value <= number) {
                returnString += v.key;
                number = number - v.value;
            }
        }
    }
    return returnString;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  MEXICAN WAVE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Introduction
The wave (known as the Mexican wave in the English-speaking world outside North America) is an example of metachronal rhythm achieved in a packed stadium when successive groups of spectators briefly stand, yell, and raise their arms. Immediately upon stretching to full height, the spectator returns to the usual seated position.
 
The result is a wave of standing spectators that travels through the crowd, even though individual spectators never move away from their seats. In many large arenas the crowd is seated in a contiguous circuit all the way around the sport field, and so the wave is able to travel continuously around the arena; in discontiguous seating arrangements, the wave can instead reflect back and forth through the crowd. When the gap in seating is narrow, the wave can sometimes pass through it. Usually only one wave crest will be present at any given time in an arena, although simultaneous, counter-rotating waves have been produced. (Source Wikipedia)
Task
In this simple Kata your task is to create a function that turns a string into a Mexican Wave. You will be passed a string and you must return that string in an array where an uppercase letter is a person standing up. 
Rules
 1.  The input string will always be lower case but maybe empty.
 
 2.  If the character in the string is whitespace then pass over it as if it was an empty seat
Example
wave("hello") => []string{"Hello", "hEllo", "heLlo", "helLo", "hellO"}
*/

// ❗️❗️❗️ BOTH WORK ❗️❗️❗️
// function wave(str: string): Array<string> {
const wave = (str: string): string[] => {
    const strArr: string[] = str.split("");
    // console.log(strArr);
    let solution: string[] = [];

    strArr.forEach((letter, idx) => {
        let currentWaveArr: string[] = [...strArr];
        // console.table({ letter: letter, index: idx, strAtIdx: noSpaceStr[idx], upperCased: noSpaceStr[idx].toUpperCase() });
        if (letter !== " ") {
            currentWaveArr[idx] = currentWaveArr[idx].toUpperCase();
            // console.log(currentWave);
            solution.push(currentWaveArr.join(""));
        }
    });

    return solution;
};

//  SPLIT str INTO ARRAY
//  INITIALIZE solution AS EMPTY ARR
//  LOOP OVER strArr
//      CURRENT WORD(WAVE) IS A COPY OF strArr
//      IF CURRENT ELEMENT IS NOT A SPACE:
//          CONVERT currentWaveArr[idx] TO UPPERCASE
//          AND PUSH IT AS A STRING INTO solution
//  RETURN SOLUTION

/*
[
    'Two words',
    'tWo words',
    'twO words',
    'two Words',
    'two wOrds',
    'two woRds',
    'two worDs',
    'two wordS'
  ]
  */

// console.log(wave("hello"));
// console.log(wave("two words"));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// function wave2(str: string): Array<string> {
//     return str.split("").reduce((wave, char, index) => {
//         if (char === " ") {
//             return wave;
//         }
//         wave.push(
//             str.slice(0, index) + char.toUpperCase() + str.slice(index + 1)
//         );
//         return wave;
//     }, [])
// }

function wave3(str: string): Array<string> {
    const result = [];
    for (let i = 0; i < str.length; i++) {
        if (str.charAt(i) === " ") {
            continue;
        }
        result.push(
            str.substring(0, i) +
                str.charAt(i).toUpperCase() +
                str.substring(i + 1)
        );
    }
    return result;
}

// function wave4(str: string): Array<string> {
//     return [...str].reduce((acc, s, i) => {
//         if (s !== ' ') {
//             acc.push(str.slice(0, i) + s.toUpperCase() + str.slice(i + 1));
//         }
//         return acc;
//     }, []);
// }

function wave5(str: string): Array<string> {
    let arr = [];
    for (let i = 0; i < str.length; i++) {
        let k = str.split("");
        k[i] = k[i].toUpperCase();
        if (str != k.join("")) {
            arr.push(k.join(""));
        }
    }
    return arr;
}

// function wave6(str: string): Array<string> {
//     return str.split('').reduce((result, item, index) => {
//         (item != ' ') && result.push(str.substr(0, index) + item.toUpperCase() + str.substr(index + 1));
//         return result;
//     }, []);
// }

function wave7(str: string): Array<string> {
    let finalArray: string[] = [];
    for (let i = 0; i < str.length; i++) {
        if (str[i] === " ") continue;
        let letters = str.split("");
        letters[i] = str[i].toUpperCase();
        finalArray.push(letters.join(""));
    }
    return finalArray;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  BOUNCING BALLS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A child is playing with a ball on the nth floor of a tall building. The height of this floor, h, is known.
 
He drops the ball out of the window. The ball bounces (for example), to two-thirds of its height (a bounce of 0.66).
 
His mother looks out of a window 1.5 meters from the ground.
 
How many times will the mother see the ball pass in front of her window (including when it's falling and bouncing?
 
Three conditions must be met for a valid experiment:
Float parameter "h" in meters must be greater than 0
Float parameter "bounce" must be greater than 0 and less than 1
Float parameter "window" must be less than h.
If all three conditions above are fulfilled, return a positive integer, otherwise return -1.
 
Note:
The ball can only be seen if the height of the rebounding ball is strictly greater than the window parameter.
 
Examples:
- h = 3, bounce = 0.66, window = 1.5, result is 3
 
- h = 3, bounce = 1, window = 1.5, result is -1 
 
(Condition 2) not fulfilled).
*/

const bouncingBall = (
    dropHeight: number,
    bounceRate: number,
    viewHeight: number
): number => {
    if (
        dropHeight <= 0 ||
        bounceRate <= 0 ||
        bounceRate >= 1 ||
        viewHeight <= 0 ||
        viewHeight >= dropHeight
    ) {
        return -1;
    }

    let actualBounce: number = dropHeight * bounceRate;
    let counter: number = 1;

    while (actualBounce > viewHeight) {
        actualBounce = actualBounce * bounceRate;
        counter += 2;
    }

    return counter;
};

//  3
// console.log(bouncingBall(3.0, 0.66, 1.5));
// 15
// console.log(bouncingBall(30.0, 0.66, 1.5));
// 21
// console.log(bouncingBall(30, 0.75, 1.5));
// 3
// console.log(bouncingBall(30, 0.4, 10));
// -1
// console.log(bouncingBall(3, 0.5, 4))

//============= OTHER CODEWARS SOLUTIONS: =============

function bouncingBall2(h: number, bounce: number, window: number): number {
    if (h <= 0 || bounce <= 0 || bounce >= 1 || window >= h) {
        return -1;
    }

    return 2 * Math.ceil(Math.log(window / h) / Math.log(bounce)) - 1;
}

function bouncingBall3(h: number, bounce: number, window: number): number {
    if (h <= 0 || bounce <= 0 || bounce >= 1 || window >= h) {
        return -1;
    }

    return 2 + bouncingBall3(h * bounce, bounce, window);
}

// ❗️❗️❗️ INCLUDE THIS IN CODEWARS EXAMPLES ❗️❗️❗️ (FIND(FUNCTION))
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  WHICH ARE IN
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  FIND(FUNCTION), FILTER()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given two arrays of strings a1 and a2 return a sorted array r in lexicographical order of the strings of a1 which are substrings of strings of a2.
 
Example 1:
a1 = ["arp", "live", "strong"]
 
a2 = ["lively", "alive", "harp", "sharp", "armstrong"]
 
returns ["arp", "live", "strong"]
 
Example 2:
a1 = ["tarp", "mice", "bull"]
 
a2 = ["lively", "alive", "harp", "sharp", "armstrong"]
 
returns []
 
Notes:
Arrays are written in "general" notation. See "Your Test Cases" for examples in your language.
In Shell bash a1 and a2 are strings. The return is a string where words are separated by commas.
Beware: r must be without duplicates.
*/

class G964a {
    public static inArray(a1: string[], a2: string[]): string[] {
        let solution: string[] = [];

        a1.forEach((subStr) => {
            const findSubStr = (word: string): boolean =>
                word.indexOf(subStr) >= 0;
            // ❗️❗️❗️ UNDEFINED NOT NEEDED IN CODEWARS ❗️❗️❗️
            let firstMatch: string | undefined = a2.find(findSubStr);
            if (firstMatch) solution.push(subStr);
        });

        return solution.sort();

        /*
                let solution: string[] = [];
        
                a1.forEach((sub) => {
        
                    const findSubStr = (word: string): boolean => {
                        return word.indexOf(sub) >= 0;
                    }
        
                    let firstMatch: string | undefined = a2.find(findSubStr);
        
                    if (firstMatch !== undefined) {
                        solution.push(sub);
                    }
        
                })
        
                return solution.sort();
        */
    }
}

//  INITIALIZE solution AS EMPTY ARRAY
//  LOOP THROUGH a1
//      findSubStr RETURNS true IF WORD HAS subStr IN IT
//      FIND firstMatch IN a2 (find() RETURNS FIRST ELEMENT THAT PASSES TEST IN findSubStr)
//      IF THERE'S A MATCH, PUSH subStr INTO solution
//  RETURN solution SORTED ALPHABETICALLY

// var a2 = ["lively", "alive", "harp", "sharp", "armstrong"];
// var a1 = ["arp", "live", "strong"];
// a1 = ["xyz", "live", "strong"];
// a1 = ["live", "strong", "arp"];
// a1 = ["hello", "goodbye"];

// console.log(G964a.inArray(a1, a2));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ FILTER() ❗️❗️❗️
class G964a2 {
    public static inArray(a1: string[], a2: string[]): string[] {
        return a1.filter((a) => a2.some((b) => b.includes(a))).sort();
    }
}

class G964a3 {
    public static inArray(a1: string[], a2: string[]): string[] {
        return a1.filter((x) => a2.join().indexOf(x) > -1).sort();
    }
}

class G964a4 {
    public static inArray(a1: string[], a2: string[]): string[] {
        const source = a2.join("#");
        return a1.filter((item) => source.indexOf(item) !== -1).sort();
    }
}

class G964a5 {
    public static inArray(a1: string[], a2: string[]): string[] {
        return a1.sort().filter((s) => a2.find((s2) => s2.includes(s)));
    }
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ARE THEY THE SAME?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  ❗️❗️❗️ SPREAD(NULL) ❗️❗️❗️ ERROR: Type 'number[] | null' must have a '[Symbol.iterator]()' method that returns an iterator.ts(2488)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given two arrays a and b write a function comp(a, b) (orcompSame(a, b)) that checks whether the two arrays have the "same" elements, with the same multiplicities (the multiplicity of a member is the number of times it appears). "Same" means, here, that the elements in b are the elements in a squared, regardless of the order.
 
Examples
Valid arrays
a = [121, 144, 19, 161, 19, 144, 19, 11]  
b = [121, 14641, 20736, 361, 25921, 361, 20736, 361]
comp(a, b) returns true because in b 121 is the square of 11, 14641 is the square of 121, 20736 the square of 144, 361 the square of 19, 25921 the square of 161, and so on. It gets obvious if we write b's elements in terms of squares:
 
a = [121, 144, 19, 161, 19, 144, 19, 11] 
b = [11*11, 121*121, 144*144, 19*19, 161*161, 19*19, 144*144, 19*19]
Invalid arrays
If, for example, we change the first number to something else, comp is not returning true anymore:
 
a = [121, 144, 19, 161, 19, 144, 19, 11]  
b = [132, 14641, 20736, 361, 25921, 361, 20736, 361]
comp(a,b) returns false because in b 132 is not the square of any number of a.
 
a = [121, 144, 19, 161, 19, 144, 19, 11]  
b = [121, 14641, 20736, 36100, 25921, 361, 20736, 361]
comp(a,b) returns false because in b 36100 is not the square of any number of a.
 
Remarks
a or b might be [] or {} (all languages except R, Shell).
a or b might be nil or null or None or nothing (except in C++, COBOL, Crystal, D, Dart, Elixir, Fortran, F#, Haskell, Nim, OCaml, Pascal, Perl, PowerShell, Prolog, PureScript, R, Racket, Rust, Shell, Swift).
If a or b are nil (or null or None, depending on the language), the problem doesn't make sense so return false.
 
Note for C
The two arrays have the same size (> 0) given as parameter in fun
*/

// 1️⃣
const comp = (a1: number[] | null, a2: number[] | null): boolean => {
    // ❗️❗️❗️ CHECK FOR NULL FIRST ❗️❗️❗️
    return a1 === null || a2 === null
        ? false
        : String([...a1].sort((a, b) => a - b).map((el) => Math.pow(el, 2))) ===
              String([...a2].sort((a, b) => a - b));
};

// 2️⃣
const comp2 = (a1: number[] | null, a2: number[] | null): boolean => {
    // ❗️❗️❗️ CHECK FOR NULL FIRST ❗️❗️❗️
    if (a1 === null || a2 === null) return false;

    const ascending1: number[] = [...a1].sort((a, b) => a - b);
    const ascending1Squared: number[] = ascending1.map((el) => Math.pow(el, 2));
    const ascending2: number[] = [...a2].sort((a, b) => a - b);

    return String(ascending1Squared) === String(ascending2);
};

//  RETURN FALSE IF EMPTY ARRAY
//  OTHERWISE, SORT BOTH ARRAYS NUMERICALLY ASCENDING, SQUARE ELEMENTS IN a1
//  CONVERT BOTH TO STRING AND COMPARE

/* ❗️❗️❗️ SPREAD NULL:
I think you cannot spread null, you should check on whether your argument is null either:
 
before it gets into this function, and then you can change the type to string
 
do it in the function, before you spread the argument
❗️❗️❗️ 
*/

// TRUE
// var a1: number[] = [121, 144, 19, 161, 19, 144, 19, 11];
// var a2: number[] = [11 * 11, 121 * 121, 144 * 144, 19 * 19, 161 * 161, 19 * 19, 144 * 144, 19 * 19];

// FALSE
var b1 = [121, 144, 19, 161, 19, 144, 19, 11];
var b2 = [
    11 * 21,
    121 * 121,
    144 * 144,
    19 * 19,
    161 * 161,
    19 * 19,
    144 * 144,
    19 * 19,
];

// console.log(comp(a1, a2));
// console.log(comp(b1, b2));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function comp3(a1: number[] | null, a2: number[] | null): boolean {
    if (!(a1 && a2) || a1.length !== a2.length) return false;
    return (
        a1
            .map((x) => x * x)
            .sort()
            .toString() === a2.sort().toString()
    );
}

function comp4(a1: number[] | null, a2: number[] | null): boolean {
    return (
        !!a1 &&
        !!a2 &&
        a1
            .map((x) => x * x)
            .sort()
            .join() == a2.sort().join()
    );
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  CONSECUTIVE STRINGS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  NESTED FOR(), ❗️❗️❗️ SORT(), REDUCE() ❗️❗️❗️
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You are given an array(list) strarr of strings and an integer k. Your task is to return the first longest string consisting of k consecutive strings taken in the array.
 
Examples:
strarr = ["tree", "foling", "trashy", "blue", "abcdef", "uvwxyz"], k = 2
 
Concatenate the consecutive strings of strarr by 2, we get:
 
treefoling   (length 10)  concatenation of strarr[0] and strarr[1]
folingtrashy ("      12)  concatenation of strarr[1] and strarr[2]
trashyblue   ("      10)  concatenation of strarr[2] and strarr[3]
blueabcdef   ("      10)  concatenation of strarr[3] and strarr[4]
abcdefuvwxyz ("      12)  concatenation of strarr[4] and strarr[5]
 
Two strings are the longest: "folingtrashy" and "abcdefuvwxyz".
The first that came is "folingtrashy" so 
longest_consec(strarr, 2) should return "folingtrashy".
 
In the same way:
longest_consec(["zone", "abigail", "theta", "form", "libe", "zas", "theta", "abigail"], 2) --> "abigailtheta"
*/

const longestConsec = (strArr: string[], numWords: number): string => {
    if (strArr.length === 0 || numWords < 1 || numWords > strArr.length) {
        return "";
    }

    let concatArr: string[] = [];

    for (let i = 0; i < strArr.length - numWords + 1; i++) {
        let concatWord: string = "";

        for (let j = 0; j < numWords; j++) {
            let nextWord = strArr[i + j];
            concatWord += nextWord;
        }

        concatArr.push(concatWord);
    }

    // ❗️❗️❗️  concatArrCopy.sort WILL MUTATE ORIGINAL ARRAY SO HAVE TO COPY IT ❗️❗️❗️
    const concatArrCopy = [...concatArr];
    const sortedArr = concatArrCopy.sort((a, b) => b.length - a.length);
    const longest = sortedArr[0].length;
    let solution = "";

    for (let i = 0; i < concatArr.length; i++) {
        if (concatArr[i].length === longest) {
            solution = concatArr[i];
            break;
        }
    }

    return solution;
};

/*
  RETURN EMPTY STRING IF n = 0 or k > n or k <= 0
  PUSH ALL CONCATENATED STRINGS INTO concatArr (OUTER LOOP WILL STOP AT LAST IDX - numWords)
  MAKE A COPY OF concatArr
  SORT concatArrCopy BY LENGTH OF ELEMENTS (DESCENDING, LONGEST TO SHORTEST)
  GET LENGTH OF LONGEST (FIRST) ELEMENT - longest
  LOOP THROUGH ORIGINAL concatArr AND FIND FIRST STRING THAT HAS THE LENGTH OF longest
  RETURN IT AS SOLUTION
*/

/*
❗️❗️❗️
You need to copy the array before you sort it. One way with es6:
 
const sorted = [...arr].sort();
The spread-syntax as array literal (copied from mdn):
 
var arr = [1, 2, 3];
var arr2 = [...arr]; // like arr.slice()
❗️❗️❗️
*/

// "abigailtheta"
// console.log(longestConsec(["zone", "abigail", "theta", "form", "libe", "zas"], 2));
// "ixoyx3452zzzzzzzzzzzz"
// console.log(longestConsec(["it", "wkppv", "ixoyx", "3452", "zzzzzzzzzzzz"], 3));
// "oocccffuucccjjjkkkjyyyeehh"
// console.log(longestConsec(["ejjjjmmtthh", "zxxuueeg", "aanlljrrrxx", "dqqqaaabbb", "oocccffuucccjjjkkkjyyyeehh"], 1));
// console.log(longestConsec(["ac", "c", "aaa", "aaa", "hg", "abc", "def", "sd", "abc", "abc"], 2));
// console.log(longestConsec([], 2));

//============= OTHER CODEWARS SOLUTIONS: =============

function longestConsec2(strarr: string[], k: number): string {
    if (strarr.length === 0 || k > strarr.length || k <= 0) return "";
    // ❗️❗️❗️ REDUCE() ❗️❗️❗️
    return strarr
        .map((currentValue, index, array) =>
            array.slice(index, index + k).join("")
        )
        .reduce((acc, cur) => (cur.length > acc.length ? cur : acc));
}

function longestConsec3(strarr: string[], k: number): string {
    if (!(strarr && strarr.length) || k <= 0 || strarr.length < k) {
        return "";
    }
    // ❗️❗️❗️ REDUCE() ❗️❗️❗️
    return strarr.reduce((acc, cur, i, arr) => {
        let concatinated = arr.slice(i, i + k).join("");
        return acc.length < concatinated.length ? concatinated : acc;
    }, "");
}

function longestConsec4(strarr: string[], k: number): string {
    let max = "";
    const n = strarr.length;

    for (let i = 0; i <= n - k && k > 0 && k <= n; i++) {
        const newStr = strarr.slice(i, i + k).join("");
        max = max.length >= newStr.length ? max : newStr;
    }
    return max;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  BUILD PILE OF CUBES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: WHILE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Your task is to construct a building which will be a pile of n cubes. The cube at the bottom will have a volume of n^3, the cube above will have volume of (n-1)^3 and so on until the top which will have a volume of 1^3.
 
You are given the total volume m of the building. Being given m can you find the number n of cubes you will have to build?
 
The parameter of the function findNb (find_nb, find-nb, findNb, ...) will be an integer m and you have to return the integer n such as n^3 + (n-1)^3 + ... + 1^3 = m if such a n exists or -1 if there is no such n.
 
Examples:
findNb(1071225) --> 45
 
findNb(91716553919377) --> -1
*/

const findNb = (num: number): number => {
    let total: number = num;
    let base: number = 1;

    while (total > 0) {
        total -= Math.pow(base, 3);
        base++;
    }

    return total < 0 ? -1 : base - 1;
};

//  SET total TO BE INPUT NUMBER num
//  START OFF base(ACTS AS A COUNTER) AT 1
//  WHILE total IS GREATER THAN 0
//      DECREMENT BY base(COUNTER) CUBED
//      INCREMENT base BY 1
// CHECK IF TOTAL HAS GONE BELOW 0
//      IF SO, RETURN -1
//      OTHERWISE RETURN base - 1

// console.log(findNb(100));
// 2022
// console.log(findNb(4183059834009));
// -1
// console.log(findNb(24723578342962))

//============= OTHER CODEWARS SOLUTIONS: =============

function findNb2(m: number): number {
    var n = 0;
    while (m > 0) m -= Math.pow(++n, 3);
    return m ? -1 : n;
}

function findNb3(m: number): number {
    let sum = 0;
    let i = 1;

    for (; sum < m; i++) {
        sum += Math.pow(i, 3);
    }

    return sum === m ? i - 1 : -1;
}

function findNb4(m: number): number {
    let n = 1;
    while (m > 0) {
        m = m - n ** 3;
        if (m === 0) return n;
        n++;
    }
    return -1;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PLAYING WITH DIGITS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Some numbers have funny properties. For example:
 
89 --> 8¹ + 9² = 89 * 1
 
695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2
 
46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
 
Given a positive integer n written as abcd... (a, b, c, d... being digits) and a positive integer p
 
we want to find a positive integer k, if it exists, such as the sum of the digits of n taken to the successive powers of p is equal to k * n.
In other words:
 
Is there an integer k such as : (a ^ p + b ^ (p+1) + c ^(p+2) + d ^ (p+3) + ...) = n * k
 
If it is the case we will return k, if not return -1.
 
Note: n and p will always be given as strictly positive integers.
 
dig_pow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1
dig_pow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k
dig_pow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2
dig_pow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51
*/

class G964 {
    public static digPow = (num: number, pow: number): number => {
        const digitArr = String(num).split("").map(Number);

        let sum = 0;

        // for (let i = 0; i < digitArr.length; i++) {
        //     sum += Math.pow(digitArr[i], i + pow);
        // }

        digitArr.forEach((digit, idx) => {
            sum += Math.pow(digit, idx + pow);
        });

        console.log("sum: " + sum);

        return sum % num === 0 ? sum / num : -1;
    };
}

//  CONVERT num TO ARRAY OF NUMBER DIGITS
//  INITIALIZE sum WITH VALUE OF 0
//  LOOP THROUGH digitArr
//      RAISE EACH DIGIT TO ITS SUCCESSIVE POWERS OF pow (INCREMENT POW BY idx)
//  CHECK IF sum CAN BE DIVIDED BY num
//      IF SO, RETURN INTEGER sum / num AS SOLUTION
//      OTHERWISE RETURN -1

// console.log(G964.digPow(89, 1));
// console.log(G964.digPow(695, 2));
// console.log(G964.digPow(46288, 3));
// console.log(G964.digPow(92, 1));

//============= OTHER CODEWARS SOLUTIONS: =============

/*
 
class G964 {
 
    public static digPow = (n, p) => {
        var x = n.toString().split("").reduce((s, d, i) => s + Math.pow(d, p + i), 0)
        return x % n ? -1 : x / n;
    }
 
}
 
 
 
class G964 {
 
    public static digPow = (n, p) => {
        var x = n.toString().split("").reduce((s, d, i) => s + Math.pow(d, p + i), 0)
        return x % n ? -1 : x / n;
    }
}
 
 
 
class G964 {
 
    public static digPow = (n: number, p: number) => {
        const sum = ('' + n).split('').reduce((sum, digit, i) => sum += Math.pow(+digit, p + i), 0);
        const k = sum / n;
        return Number.isInteger(k) ? k : -1;
    }
}
 
*/

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  VALID BRACES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: REGEXP, WHILE(), REPLACE()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function that takes a string of braces, and determines if the order of the braces is valid. It should return true if the string is valid, and false if it's invalid.
 
This Kata is similar to the Valid Parentheses Kata, but introduces new characters: brackets [], and curly braces {}. Thanks to @arnedag for the idea!
 
All input strings will be nonempty, and will only consist of parentheses, brackets and curly braces: ()[]{}.
 
What is considered Valid?
A string of braces is considered valid if all braces are matched with the correct brace.
 
Examples
"(){}[]"   =>  True
"([{}])"   =>  True
"(}"       =>  False
"[(])"     =>  False
"[({})](]" =>  False
*/

// /\(\)|\[\]|\{\}/g

const validBraces = (braces: string): boolean => {
    if (braces.length % 2 > 0) return false;

    const bracePair = /\(\)|\[\]|\{\}/;

    let str: string = braces;

    while (bracePair.test(str)) {
        str = str.replace(bracePair, "");
    }

    console.log("str: " + str);

    return str.length === 0;
};

//  RETURN FALSE IF UNVALID INPUT LENGTH
//  SAVE MATCHING PAIRS TO VAR bracePair
//  COPY braces TO str
//  WHILE MATCH IS FOUND (ANY OF THE THREE)
//      REMOVE PAIR FROM str
//  IF str CAN BE REDUCED TO EMPTY STRING, RETURN true, OTHERWISE false

// console.log(validBraces("()[]{}"));
// console.log(validBraces("({[{}]})"));
// console.log(validBraces("[(])"));
// console.log(validBraces("[(])"));

//============= OTHER CODEWARS SOLUTIONS: =============

function validBraces2(braces: string): boolean {
    if (braces.length % 2 !== 0) return false;
    let count = braces.length;
    braces = braces.replace("()", "");
    braces = braces.replace("[]", "");
    braces = braces.replace("{}", "");
    if (braces.length === 0) return true;
    if (braces.length === count) return false;
    return validBraces(braces);
}

function validBraces3(braces: string): boolean {
    let tempBraces = braces;
    for (let i = 0; i <= braces.length / 2; i++) {
        tempBraces = tempBraces.replace(/(\(\))|(\[\])|(\{\})/g, "");
    }
    return !tempBraces;
}

function validBrace4(braces: string): boolean {
    [...braces].forEach(
        () =>
            (braces = braces
                .replace("()", "")
                .replace("{}", "")
                .replace("[]", ""))
    );
    return !braces;
}

const validBraces5 = (braces: string): boolean => {
    const s = braces.replace(/\(\)|\[\]|\{\}/g, "");
    if (s.length === 0) return true;
    else if (s === braces) return false;
    else return validBraces(s);
};

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: OBJECT.ENTRIES()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a string of words, you need to find the highest scoring word.
 
Each letter of a word scores points according to its position in the alphabet: a = 1, b = 2, c = 3 etc.
 
You need to return the highest scoring word as a string.
 
If two words score the same, return the word that appears earliest in the original string.
 
All letters will be lowercase and all inputs will be valid.
*/

const high = (str: string): string => {
    const alphabet = [
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
    ];
    //  CALCULATE SCORE FOR WORD
    const getScore = (str: string): number => {
        let score: number = 0;
        str.split("").forEach((char) => {
            score += alphabet.indexOf(char) + 1;
        });
        return score;
    };

    interface Counter {
        [key: string]: number;
    }

    const counterObj: Counter = {};
    //  CREATE COUNTER OBJ { word: score, word: score ... }
    str.split(" ").forEach((word) => {
        counterObj[word] = getScore(word);
    });
    //  SORT OBJECT ENTRIES BY THEIR SECOND ELEMENT (INDEX 1 / VALUE)
    //  RETURN INDEX 0 OF ELEMENT AT INDEX 0
    //  [[ 'volcano', 82 ], [ 'climbing', 69 ], [ 'what', 52 ]... ]
    console.log(Object.entries(counterObj).sort((a, b) => b[1] - a[1])[0][0]);
    return Object.entries(counterObj).sort((a, b) => b[1] - a[1])[0][0];
};

// high('what time are we climbing up the volcano');

//============= OTHER CODEWARS SOLUTIONS: =============

const VALUE_OFFSET = 96;
const calcValue = (word: string): number => {
    return word
        .split("")
        .reduce((sum, char) => sum + char.charCodeAt(0) - VALUE_OFFSET, 0);
};
const high2 = (str: string): string => {
    return str
        .split(" ")
        .reduce((max, word) => (calcValue(word) > calcValue(max) ? word : max));
};

const alphabet = "abcdefghijklmnopqrstuvwxyz";
const getLetterScore = (str: string): number => alphabet.indexOf(str) + 1;
const getWordScore = (str: string): number =>
    str
        .split("")
        .map(getLetterScore)
        .reduce((acc, n) => acc + n, 0);

const high3 = (str: string): string =>
    str
        .split(" ")
        .reduce((acc, value) =>
            getWordScore(value) > getWordScore(acc) ? value : acc
        );

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  BUILD TOWER - MULTIPLE VARIABLES IN FOR LOOP
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Build Tower
Build Tower by the following given argument:
number of floors (integer and always greater than 0).
 
Tower block is represented as *
 
towerBuilder(3)
 
[
  '  *  ', 
  ' *** ', 
  '*****'
]
*/

const towerBuilder = (nFloors: number): string[] => {
    const absoluteWidth = nFloors + (nFloors - 1);
    const building: string[] = [];

    for (let floors = 1, blocks = 1; floors <= nFloors; floors++, blocks += 2) {
        let floorStr: string = "";
        // console.table({floors: floors, blocks: blocks});
        let leadTrailSpaces = (absoluteWidth - blocks) / 2;

        floorStr =
            " ".repeat(leadTrailSpaces) +
            "*".repeat(blocks) +
            " ".repeat(leadTrailSpaces);

        // console.log(floorStr);

        building.push(floorStr);
    }

    console.log(building);

    return building;
};

/*
 
 CALCULATE ABSOLUTE WIDTH OF PYRAMID (WIDTH OF BASE)
 INITAILIZE ARRAY FOR BUILDING (SOLUTION)
 
 LOOP OVER FLOORS WHILE KEEPING TRACK OF NUMBER OF BLOCKS IN EACH ITERATION
    EMPTY STRING FOR EACH FLOOR STRING
    CALCULATE LEADING/TRAILING SPACES
    
    BUILD COMPLETE FLOOR: LEADING SPACES + BLOCKS + TRAILING SPACES
    
    PUSH NEW FLOOR INTO BUILDING ARRAY
    
  RETURN BUILDING
 
  [
  '           *           ',
  '          ***          ',
  '         *****         ',
  '        *******        ',
  '       *********       ',
  '      ***********      ',
  '     *************     ',
  '    ***************    ',
  '   *****************   ',
  '  *******************  ',
  ' ********************* ',
  '***********************'
]
  
*/

// towerBuilder(1);
// towerBuilder(12);

//============= OTHER CODEWARS SOLUTIONS: =============

const towerBuilder2 = (nFloors: number): string[] => {
    return Array.from(
        { length: nFloors },
        (_, i) =>
            `${" ".repeat(nFloors - i - 1)}${"*".repeat(2 * i + 1)}${" ".repeat(
                nFloors - i - 1
            )}`
    );
};

const towerBuilder3 = (nFloors: number): string[] => {
    return Array.from({ length: nFloors }, (_, index) => {
        const spaces = " ".repeat(nFloors - 1 - index);
        return `${spaces}${"*".repeat(index * 2 + 1)}${spaces}`;
    });
};

const towerBuilder4 = (n: number): string[] => {
    const result: string[] = [];
    for (let i = 1; i <= n; i++) {
        result.push(
            " ".repeat(n - i) + "*".repeat(i * 2 - 1) + " ".repeat(n - i)
        );
    }
    return result;
};

const towerBuilder5 = (n: number): string[] => {
    return new Array(n).fill("").map((_, i) => {
        let spaces = " ".repeat(n - i - 1);
        return spaces + "*".repeat(2 * i + 1) + spaces;
    });
};

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIND MISSING LETTER IN ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a method that takes an array of consecutive (increasing) letters as input and that returns the missing letter in the array.
 
You will always get an valid array. And it will be always exactly one letter be missing. The length of the array will always be at least 2.
The array will always contain letters in only one case.
 
Example:
 
['a','b','c','d','f'] -> 'e' ['O','Q','R','S'] -> 'P'
 
["a","b","c","d","f"] -> "e"
["O","Q","R","S"] -> "P"
(Use the English alphabet with 26 letters!)
*/

const findMissingLetter = (arr: string[]): string => {
    let solution: string = "";
    const alphabet = [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
    ];
    const startIdx = alphabet.indexOf(arr[0]);

    for (let i = 1; i < arr.length; i++) {
        if (alphabet[startIdx + i] !== arr[i]) {
            solution = alphabet[startIdx + i];
            break;
        }
    }

    return solution;
};

//  startIdx: THIS IS WHERE LOOP STARTS COMPARING TWO PARALLEL ARRAYS
//  IF CURRENT ALPHABET ELEMENT !== CURRENT INPUT ARRAY ELEMENT
//      SAVE CURRENT ALPHABET ELEMENT AS SOLUTION AND BREAK LOOP
//  RETURN SOLUTION

findMissingLetter(["a", "b", "c", "d", "f"]);
findMissingLetter(["O", "Q", "R", "S"]);

//============= OTHER CODEWARS SOLUTIONS: =============

// !!! Function lacks ending return statement and return type does not include 'undefined'.ts(2366) !!!
// function findMissingLetter2(array:string[]):string
// {
//     for(let i = 0; i < array.length; i++) {
//         if(array[i].charCodeAt(0) + 1 != array[i+1].charCodeAt(0))
//             return String.fromCharCode(array[i].charCodeAt(0) + 1);
//     }
// }

function findMissingLetter3(array: string[]): string {
    const isUpper = array[0] == array[0].toUpperCase();

    let expectedLetter = "";
    for (const letter of array) {
        if (expectedLetter != "" && letter != expectedLetter)
            return expectedLetter;

        expectedLetter = String.fromCharCode(letter.charCodeAt(0) + 1);
    }

    throw "Nothing missing";
}

function findMissingLetter4(letters: string[]): string {
    const first = letters.shift()!.charCodeAt(0) + 1;
    const offset = letters.findIndex((l, i) => l.charCodeAt(0) !== i + first);
    return String.fromCharCode(first + offset);
}

function findMissingLetter5(array: string[]) {
    const alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    return alphabet
        .substr(alphabet.indexOf(array[0]))
        .split("")
        .find((curr, idx) => curr != array[idx]);
}

// !!! Type 'undefined' is not assignable to type 'string'.ts(2322) !!!
// function findMissingLetter6(array:string[]):string
// {
//    let ret;
//     array.map(item => item.charCodeAt(0))
//         .reduce((prev, cur, curIndex) =>
//         {
//             if (cur - prev > 1) {
//                 ret = String.fromCharCode(cur-1)
//             }
//             return cur
//         })

//     return ret
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  UNUQUE NUMBER IN ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
There is an array with some numbers. All numbers are equal except for one. Try to find it!
 
findUniq([ 1, 1, 1, 2, 1, 1 ]) === 2
findUniq([ 0, 0, 0.55, 0, 0 ]) === 0.55
It’s guaranteed that array contains at least 3 numbers.
 
The tests contain some very huge arrays, so think about performance.
*/

// 1️⃣  LOOP THROUGH ALL ELEMENTS:

// const findUniq = (arr: number[]): number => {

//     let solution: number = 0;

//     for (let i = 0; i < arr.length; i++) {

//         if (i < arr.length - 2) {
//             if (arr[i] !== arr[i + 1] && arr[i] !== arr[i + 2]) {
//                 console.log("odd one found: " + arr[i]);
//                 solution = arr[i];
//                 break;
//             }
//         } else if (i === arr.length - 2) {
//             if (arr[i] !== arr[i + 1] && arr[i] !== arr[i - 1]) {
//                 console.log("odd one found: " + arr[i]);
//                 solution = arr[i];
//                 break;
//             }
//         } else if (i === arr.length - 1) {
//             if (arr[i] !== arr[i - 1] && arr[i] !== arr[i - 2]) {
//                 console.log("odd one found: " + arr[i]);
//                 solution = arr[i];
//             }
//         }

//     }

//     console.log("solution: " + solution);
//     return solution;

// }

// 2️⃣  CHECK FIRST AND LAST ELEMENT FIRST
// THEN LOOP THROUGH MIDDLE ELEMENTS
const findUniq = (arr: number[]): number => {
    const arrLength: number = arr.length;

    let solution: number = 0;

    if (arr[0] !== arr[1] && arr[0] !== arr[2]) {
        solution = arr[0];
    }

    if (
        arr[arrLength - 1] !== arr[arrLength - 2] &&
        arr[arrLength - 1] !== arr[arrLength - 3]
    ) {
        solution = arr[arrLength - 1];
    }

    for (let i = 1; i < arrLength - 1; i++) {
        if (arr[i] !== arr[i + 1] && arr[i] !== arr[i - 1]) {
            solution = arr[i];
            break;
        }
    }

    return solution;
};

// findUniq([2, 1, 1, 1, 1, 1]);
// findUniq([1, 2, 1, 1, 1, 1]);
// findUniq([1, 1, 2, 1, 1, 1]);
// findUniq([1, 1, 1, 2, 1, 1]);
// findUniq([1, 1, 1, 1, 2, 1]);
// findUniq([1, 1, 1, 1, 1, 2]);

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️
function findUniq3(arr: Array<number>): number {
    arr = arr.sort();
    return arr[0] == arr[1] ? arr[arr.length - 1] : arr[0];
}
// ❗️❗️❗️

// "!"
function findUniq4(arr: Array<number>): number {
    const x = arr[arr[0] == arr[1] ? 0 : 2];
    return arr.find((y) => y != x)!;
}

// "!"
function findUniq5(arr: Array<number>): number {
    return arr.find((n) => arr.indexOf(n) === arr.lastIndexOf(n))!;
}

// "!"
function findUniq6(arr: Array<number>): number {
    var arr = arr.sort();
    return arr[0] == arr[1] ? arr.pop()! : arr[0];
}

function findUniq7(arr: Array<number>): number {
    return arr.filter((el) => arr.indexOf(el) == arr.lastIndexOf(el))[0];
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  NARCISSISTIC NUMBER - DOES MY NUMBER LOOK BIG IN THIS?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A Narcissistic Number is a positive number which is the sum of its own digits, each raised to the power of the number of digits in a given base. In this Kata, we will restrict ourselves to decimal (base 10).
 
For example, take 153 (3 digits), which is narcisstic:
 
    1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153
and 1652 (4 digits), which isn't:
 
    1^4 + 6^4 + 5^4 + 2^4 = 1 + 1296 + 625 + 16 = 1938
The Challenge:
 
Your code must return true or false (not 'true' and 'false') depending upon whether the given number is a Narcissistic number in base 10. This may be True and False in your language, e.g. PHP.
 
Error checking for text strings or other invalid inputs is not required, only valid positive non-zero integers will be passed into the function.
*/

const narcissistic = (num: number): boolean => {
    const exp: number = num.toString().length;
    const digitArr: number[] = num.toString().split("").map(Number);
    const powerSum: number = digitArr
        .map((base) => Math.pow(base, exp))
        .reduce((a, b) => a + b);
    return powerSum === num;
};

//  GET EXPONENT
//  CONVERT NUM TO ARRAY OF DIGITS(number)
//  CALCULATE SUM OF DIGITS RAISED TO EXP
//  COMPARE NUM AND ITS POWERSUM, RETURN boolean RESULT

narcissistic(7);
narcissistic(153);
narcissistic(1634);
narcissistic(16342);

//============= OTHER CODEWARS SOLUTIONS: =============

function narcissistic2(value: number): boolean {
    const str = String(value);
    let acc = 0;
    str.split("").forEach((x) => (acc += Math.pow(+x, str.length)));
    return acc === value;
}

function narcissistic3(value: number): boolean {
    const digits = String(value).split("");

    return (
        digits.reduce(
            (acc, current) => acc + Math.pow(Number(current), digits.length),
            0
        ) === value
    );
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  IS PANGRAM
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A pangram is a sentence that contains every single letter of the alphabet at least once. For example, the sentence "The quick brown fox jumps over the lazy dog" is a pangram, because it uses the letters A-Z at least once (case is irrelevant).
 
Given a string, detect whether or not it is a pangram. Return True if it is, False if not. Ignore numbers and punctuation.
*/

// 1️⃣ FIRST ATTEMPT:
// const isPangram = (phrase: string): boolean => {

//     if (phrase.length < 26) return false;

//     const alphabet: string[] = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];

//     let solution: boolean = true;

//     for (let i = 0; i < alphabet.length; i++) {
//         if (phrase.toLowerCase().indexOf(alphabet[i]) < 0) {
//             solution = false;
//             break;
//         }
//     }

//     return solution;

// }

/*
RETURN FALSE IF LENGTH IS LESS THAN ALPHABET LENGTH
LOOP OVER ALPHABET AND CHECK IF EACH LETTER(LOWERCASED) IS FOUND IN PHRASE
    IF NOT FOUND, STOP LOOP AND RETURN SOLUTION AS FALSE
*/

// 2️⃣ SECOND ATTEMPT:
const isPangram = (phrase: string): boolean => {
    const lettersArr: string[] = phrase.toLowerCase().match(/[a-z]/g)!;
    const lettersSet = new Set(lettersArr);
    return lettersSet.size === 26;
};
/*
MATCH ALL LETTERS(LOWERCASED) INTO ARRAY
MAKE A SET OUT OF THE ARRAY TO REMOVE DUPLICATES
IF SET SIZE IS 26 RETURN true, OTHERWISE false
*/

// isPangram("The quick brown fox jumps over the lazy dog.");
// isPangram("This is not a pangram.");

//  !!! FILTER ALL LETTERS INTO ARRAY !!!
/* 
let onlyLettersArray = message.split('').filter(char => /[a-zA-Z]/.test(char));
let onlyLettersArray = message.replace(/[^a-z]+/gi, '').split('');
let arr = "Learning is fun!  1233  ashdgahsgdh".match(/[A-Za-z]/g);
8?
 
//============= OTHER CODEWARS SOLUTIONS: =============
 
const isPangram3 = (phrase: string): boolean => new Set(phrase.toLowerCase().match(/[a-z]/g)).size === 26;
 
 
const isPangram4 = (phrase: string): boolean => ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
    .every(l => phrase.toLowerCase().includes(l))
 
 
function isPangram5(phrase: string): boolean {
    let newString: Set<string> = new Set((phrase.replace(/\W|\d/g, '')).toLowerCase());
    if (newString.size == 26) {
        return true;
    } else {
        return false;
    }
}
 
 
// 
 
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIRST N ELEMENTS OF TRIBONACCI SEQUENCE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
 
/*
As the name may already reveal, it works basically like a Fibonacci, but summing the last 3 (instead of 2) numbers of the sequence to generate the next. And, worse part of it, regrettably I won't get to hear non-native Italian speakers trying to pronounce it :(
 
    So, if we are to start our Tribonacci sequence with [1, 1, 1] as a starting input (AKA signature), we have this sequence:
    
    [1, 1 ,1, 3, 5, 9, 17, 31, ...]
    But what if we started with [0, 0, 1] as a signature? As starting with [0, 1] instead of [1, 1] basically shifts the common Fibonacci sequence by once place, you may be tempted to think that we would get the same sequence shifted by 2 places, but that is not the case and we would get:
    
    [0, 0, 1, 1, 2, 4, 7, 13, 24, ...]
    Well, you may have guessed it by now, but to be clear: you need to create a fibonacci function that given a signature array/list, returns the first n elements - signature included of the so seeded sequence.
    
    Signature will always contain 3 numbers; n will always be a non-negative number; if n == 0, then return an empty array (except in C return NULL) and be ready for anything else which is not clearly specified ;)
*/

const tribonacci = (
    [a, b, c]: [number, number, number],
    n: number
): number[] => {
    if (n === 0) return [];
    if (n === 1) return [a];
    if (n === 2) return [a, b];
    if (n === 3) return [a, b, c];

    const triArr = [a, b, c];

    for (let i = 3; i < n; i++) {
        let length = triArr.length;
        triArr.push(
            triArr[length - 1] + triArr[length - 2] + triArr[length - 3]
        );
    }

    return triArr;
};

/*
RETURN [], [a], [a, b] OR [a, b, c] IF n IS 0, 1, 2 OR 3
INITALIZE TRIARR WITH a, b and c
CALCULATE AND PUSH NEXT ELEMENT BY SUMMING LAST 3 ELEMENTS
RETURN TRIARR AS SOLUTION
*/

// tribonacci([1, 1, 1], 10);
// tribonacci([1, 1, 1], 4);
// tribonacci([3, 2, 1], 10);

//============= OTHER CODEWARS SOLUTIONS: =============

function tribonacci2(s: Array<number>, n: number): number[] {
    for (let i = 0; s.length < n; i++) s.push(s[i] + s[i + 1] + s[i + 2]);
    return s.slice(0, n);
}

function tribonacci3([a, b, c]: [number, number, number], n: number): number[] {
    if (n == 0) return [];
    if (n == 1) return [a];
    if (n == 2) return [a, b];
    if (n == 3) return [a, b, c];
    var result: number[] = [a, b, c];
    for (var i = 3; i < n; i++) {
        result[i] = result[i - 1] + result[i - 2] + result[i - 3];
    }
    return result;
}

const tribonacci4 = (
    [a, b, c]: [number, number, number],
    n: number
): number[] => (n < 1 ? [] : [a].concat(tribonacci([b, c, a + b + c], n - 1)));

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIND EVEN INDEX - EQUAL SIDES OF ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// You are going to be given an array of integers. Your job is to take that array and find an index N where the sum of the integers to the left of N is equal to the sum of the integers to the right of N. If there is no index that would make this happen, return -1.

// For example:

// Let's say you are given the array {1,2,3,4,3,2,1}:
// Your function will return the index 3, because at the 3rd position of the array, the sum of left side of the index ({1,2,3}) and the sum of the right side of the index ({3,2,1}) both equal 6.

// Let's look at another one.
// You are given the array {1,100,50,-51,1,1}:
// Your function will return the index 1, because at the 1st position of the array, the sum of left side of the index ({1}) and the sum of the right side of the index ({50,-51,1,1}) both equal 1.

// Last one:
// You are given the array {20,10,-80,10,10,15,35}
// At index 0 the left side is {}
// The right side is {10,-80,10,10,15,35}
// They both are equal to 0 when added. (Empty arrays are equal to 0 in this problem)
// Index 0 is the place where the left side and right side are equal.

// Note: Please remember that in most programming/scripting languages the index of an array starts at 0.

// Input:
// An integer array of length 0 < arr < 1000. The numbers in the array can be any integer positive or negative.

// Output:
// The lowest index N where the side to the left of N is equal to the side to the right of N. If you do not find an index that fits these rules, then you will return -1.

// Note:
// If you are given an array with multiple answers, return the lowest correct index.

const findEvenIndex = (arr: number[]): number => {
    const sum = arr.reduce((a, b) => a + b);
    let counterLeft: number = 0;
    let solution: number = -1;

    //     for (let i = 0; i < arr.length; i++) {

    //         let current = arr[i];
    //         let previous = arr[i - 1];
    //         let sideSum = (sum - current) / 2;

    //         counterLeft += previous ? previous : 0;

    //         if (sideSum === counterLeft) {
    //             solution = i;
    //         }

    //     }

    arr.forEach((current, i) => {
        let previous = arr[i - 1];
        let sideSum = (sum - current) / 2;
        // NO PREVIOUS FOR IDX 0 (ITS undefined) THEREFORE COUNTERLEFT IS 0
        counterLeft += previous ? previous : 0;

        if (sideSum === counterLeft) {
            solution = i;
        }

        console.table({
            current: current,
            sideSum: sideSum,
            counter: counterLeft,
        });
        if (sideSum === counterLeft) {
            console.log("solution found at idx : ", i);
            solution = i;
        }
    });

    return solution;
};

// findEvenIndex([1, 2, 3, 4, 3, 2, 1]);
// findEvenIndex([1,100,50,-51,1,1]);
// findEvenIndex([1,8,1]);
// findEvenIndex([20, 10, 30, 10, 10, 15, 35]);
// findEvenIndex([20, 10, -80, 10, 10, 15, 35]);

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// ❗️❗️❗️  INCLUDE THIS IN PROJECTS/TYPESCRIPT ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  YOUR ORDER PLEASE (REARRANGE WORDS BY NUMBER FOUND IN THEM)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// Your task is to sort a given string. Each word in the string will contain a single number. This number is the position the word should have in the result.

// Note: Numbers can be from 1 to 9. So 1 will be the first word (not 0).

// If the input string is empty, return an empty string. The words in the input String will only contain valid consecutive numbers.

// Examples
// "is2 Thi1s T4est 3a"  -->  "Thi1s is2 3a T4est"
// "4of Fo1r pe6ople g3ood th5e the2"  -->  "Fo1r the2 g3ood 4of th5e pe6ople"
// ""  -->  ""

const order = (words: string): string => {
    if (words.length === 0) {
        return "";
    } else {
        const orderedArr: string[] = [];
        words.split(" ").forEach((word) => {
            let numStr: number = Number(word.match(/[1-9]/)![0]) - 1;
            orderedArr[numStr] = word;
        });
        return orderedArr.join(" ");
    }
};

//  IF EMPTY STRING: RETURN ""
//  OTHERWISE:
//      CREATE NEW ARRAY FOR ORDERED WORDS
//      SPLIT INTO ARRAY AND FOR EACH WORD:
//          EXTRACT NUMERIC CHARACTER AND CONVERT TO NUMBER - 1 (INDEX)
//          !!! "Non-null assertion operator" (!) !!!
//          SET WORD AS NEW ELEMENT IN ARRAY AT INDEX
//      RETURN ARRAY JOINED INTO STRING

//  !!! REASON FOR SUBSTRACTING 1 FROM NUMBER: !!!
//  Note: Numbers can be from 1 to 9. So 1 will be the first word (not 0).
//  !!! THIS IS TO PREVENT ELEMENT AT INDEX 0 FROM BEING UNDEFINED IN ORDERED ARRAY  !!!

// order("is2 Thi1s T4est 3a");
// order("");

/*
❗️❗️❗️ TS2531: Object is possibly 'null' ❗️❗️❗️
 
https://stackoverflow.com/questions/49431880/ts2531-object-is-possibly-null
 
You should either check for null (using an if) or use a "Non-null assertion operator" (!) if you are sure it is not null:
 
if(nativeElement.files != null) {
    this.photoService.upload(this.vehicleId, nativeElement.files[0])
        .subscribe(x => console.log(x));
}
 
OR
this.photoService.upload(this.vehicleId, nativeElement.files![0])
    .subscribe(x => console.log(x));
Note:
 
The "Non-null assertion operator" will not perform any runtime checks, it just tells the compiler you have special information and you know nativeElement.files will not be null at runtime.
 
If nativeElement.files is null at runtime, it will generate an error. This is not the safe navigation operator of other languages.
*/

//============= OTHER CODEWARS SOLUTIONS: =============

function order2(words: String): String {
    return words
        .split(" ")
        .sort((a, b) => +a.match(/\d/)! - +b.match(/\d/)!)
        .join(" ");
}

function order3(words: String): String {
    return words
        .split(" ")
        .sort((l, r) => +/\d/.exec(l)![0] - +/\d/.exec(r)![0])
        .join(" ");
}

const order4 = (words: string): string => {
    return words
        .split(" ")
        .sort((a, b) => +a.replace(/\D/g, "") - +b.replace(/\D/g, ""))
        .join(" ");
};

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  TAKE A TEN MINUTE WALK
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// You live in the city of Cartesia where all roads are laid out in a perfect grid. You arrived ten minutes too early to an appointment, so you decided to take the opportunity to go for a short walk. The city provides its citizens with a Walk Generating App on their phones -- everytime you press the button it sends you an array of one-letter strings representing directions to walk (eg. ['n', 's', 'w', 'e']). You always walk only a single block for each letter (direction) and you know it takes you one minute to traverse one city block, so create a function that will return true if the walk the app gives you will take you exactly ten minutes (you don't want to be early or late!) and will, of course, return you to your starting point. Return false otherwise.

// Note: you will always receive a valid array containing a random assortment of direction letters ('n', 's', 'e', or 'w' only). It will never give you an empty array (that's not a walk, that's standing still!).

const isValidWalk = (directions: string[]): boolean => {
    interface Counter {
        [key: string]: number;
    }

    const counterObj: Counter = {};

    directions.forEach((dir) => (counterObj[dir] = (counterObj[dir] || 0) + 1));

    // console.log(
    //     directions.length === 10 ? (counterObj.n === counterObj.s) && (counterObj.e === counterObj.w) : false
    // );

    return directions.length === 10
        ? counterObj.n === counterObj.s && counterObj.e === counterObj.w
        : false;
};

//  CREATE COUNTER OBJECT {direction: count, ...}
//  IF TOTAL NUMBER OF DIRECTIONS IS 10
//      RETURN NUMBER OF BOTH OPPOSITE DIRECTION PAIRS (N-S, E-W) "BOOLEAN"
//  IF NUMBER OF DIRECTIONS IS NOT 10
//      RETURN FALSE

isValidWalk(["n", "s", "n", "s", "n", "s", "n", "s", "n", "s"]);
isValidWalk(["w", "e", "w", "e", "w", "e", "w", "e", "w", "e", "w", "e"]);

//============= OTHER CODEWARS SOLUTIONS: =============

function isValidWalk2(walk: string[]) {
    if (walk.length !== 10) return false;
    if (
        walk.filter((e) => e === "n").length !==
        walk.filter((e) => e === "s").length
    )
        return false;
    if (
        walk.filter((e) => e === "e").length !==
        walk.filter((e) => e === "w").length
    )
        return false;
    return true;
}

function isValidWalk3(walk: string[]) {
    if (walk.length !== 10) return false;

    type directionValues = {
        [key: string]: number;
    };

    const directions: directionValues = {
        n: 0,
        s: 0,
        w: 0,
        e: 0,
    };

    walk.forEach((direction: string) => {
        directions[direction]++;
    });

    return directions.n === directions.s && directions.w === directions.e;
}

function isValidWalk4(walk: string[]): boolean {
    if (walk.length !== 10) return false;

    const coordinates = {
        x: 0,
        y: 0,
    };

    for (let i = 0; i < walk.length; i++) {
        switch (walk[i]) {
            case "n":
                coordinates.x++;
                break;
            case "s":
                coordinates.x--;
                break;
            case "e":
                coordinates.y++;
                break;
            case "w":
                coordinates.y--;
                break;
            default:
                break;
        }
    }

    return !coordinates.x && !coordinates.y;
}

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// !!! NEED TO REFACTOR !!!
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  DUPLICATE ENCODER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// The goal of this exercise is to convert a string to a new string where each character in the new string is "(" if that character appears only once in the original string, or ")" if that character appears more than once in the original string. Ignore capitalization when determining if a character is a duplicate.

// Examples
// "din"      =>  "((("
// "recede"   =>  "()()()"
// "Success"  =>  ")())())"
// "(( @"     =>  "))(("

const duplicateEncode = (word: string): string => {
    // 1️⃣  DOES NOT WORK WITH SPECIAL CHARACTERS:

    // const strArr = word.split("");
    // strArr.forEach((letter, i) => {
    //     let regex = new RegExp(letter, "gi");
    //     console.table(
    //         {
    //             letter: strArr[i],
    //             matches: word.match(regex)?.length
    //         }
    //     );

    //     //❗️❗️❗️ WITHOUT "?" OBJECT IS POSSIBLY NULL ❗️❗️❗️
    //     let counter: number | undefined = word.match(regex)?.length;

    //     if (counter !== undefined) {
    //         if (counter > 1) {
    //             strArr[i] = ")";
    //         } else {
    //             strArr[i] = "(";
    //         }
    //     }
    // })
    // return strArr.join("");

    // 2️⃣  THIS WORKS:
    //  FIND EACH ELEMENT OF ORIGINAL ARRAY IN COPY(ORIGINAL WORD MINUS CURRENT LETTER)
    // IF FOUND, THEN IT IS A DUPLICATE, IF NOT FOUND THEN IT IS SINGLE
    const original = word.split("").map((letter) => letter.toLowerCase());
    let copy = [...original];
    const resultArr: string[] = [];

    for (let i = 0; i < original.length; i++) {
        copy.splice(i, 1);
        if (copy.indexOf(original[i]) < 0) {
            resultArr.push("(");
        } else {
            resultArr.push(")");
        }
        copy = [...original];
    }

    console.log(resultArr.join(""));
    return resultArr.join("");
};

// duplicateEncode("recEde");
// duplicateEncode("(( @");    // "))(("
// ❗️❗️❗️ SyntaxError: Invalid regular expression: /(/: Unterminated group ❗️❗️❗️

// ❗️❗️❗️ https://stackoverflow.com/questions/17885855/use-dynamic-variable-string-as-regex-pattern-in-javascript/17886301 ❗️❗️❗️

// To create the regex from a string, you have to use JavaScript's RegExp object.

// If you also want to match/replace more than one time, then you must add the g (global match) flag. Here's an example:

// var stringToGoIntoTheRegex = "abc";
// var regex = new RegExp("#" + stringToGoIntoTheRegex + "#", "g");
// // at this point, the line above is the same as: var regex = /#abc#/g;

// var input = "Hello this is #abc# some #abc# stuff.";
// var output = input.replace(regex, "!!");
// alert(output); // Hello this is !! some !! stuff.

//============= OTHER CODEWARS SOLUTIONS: =============

function duplicateEncode2(word: string) {
    // ...
    return word
        .toLowerCase()
        .split("")
        .map((a, i, w) => {
            return w.indexOf(a) == w.lastIndexOf(a) ? "(" : ")";
        })
        .join("");
}

function duplicateEncode3(word: string): string {
    word = word.toLowerCase();
    let countObj: { [index: string]: number } = {};
    for (let char of word) {
        let count = countObj[char] || 0;
        countObj[char] = ++count;
    }
    let result = "";
    for (let char of word) {
        result += countObj[char] > 1 ? ")" : "(";
    }
    return result;
}

function duplicateEncode4(word: string) {
    const chars = word.toLowerCase().split("");

    return chars
        .map((char) => (chars.filter((c) => c === char).length > 1 ? ")" : "("))
        .join("");
}

function duplicateEncode5(word: string): string {
    return word
        .split("")
        .map((value) =>
            (word.match(new RegExp(`[${value}]`, "giu")) || []).length > 1
                ? ")"
                : "("
        )
        .join("");
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  COUNTING DUPLICATES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// Write a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string. The input string can be assumed to contain only alphabets (both uppercase and lowercase) and numeric digits.

// Example
// "abcde" -> 0 # no characters repeats more than once
// "aabbcde" -> 2 # 'a' and 'b'
// "aabBcde" -> 2 # 'a' occurs twice and 'b' twice (`b` and `B`)
// "indivisibility" -> 1 # 'i' occurs six times
// "Indivisibilities" -> 2 # 'i' occurs seven times and 's' occurs twice
// "aA11" -> 2 # 'a' and '1'
// "ABBA" -> 2 # 'A' and 'B' each occur twice

const duplicateCount = (text: string): number => {
    interface Counter {
        [key: string]: number;
    }

    const counterObj: Counter = {};

    text.split("")
        .map((letter) => letter.toLowerCase())
        .forEach((num) => (counterObj[num] = (counterObj[num] || 0) + 1));

    const duplicatesArr = Object.entries(counterObj).filter(
        ([key, value]) => value > 1
    );

    // console.log(duplicatesArr.length);
    return duplicatesArr.length;
};

//  STR -> ARR(LETTERS) -> ARR(LOWERCASED LETTERS) -> OBJ{num: count}
//  FILTER OUT OBJ KEYS WITH VALUE GREATER THAN ONE INTO ARRAY
//  RETURN LENGTH OF ARRAY

//

//============= OTHER CODEWARS SOLUTIONS: =============

// import _ from 'lodash';
// export function duplicateCount2(text: string): number {
//     return _(text).countBy(_.toUpper).values().filter(x => x > 1).size();
// }

function duplicateCount3(text: string): number {
    const values = text.toLowerCase();
    const distinctValues = [...new Set(values)];
    const count = (s: string) => values.split(s).length - 1 > 1;
    return distinctValues.filter((value) => count(value)).length;
}

function duplicateCount4(text: string): number {
    let array = text.toLowerCase().split("");
    return [...new Set(array.filter((e, i) => array.indexOf(e) !== i))].length;
}

function duplicateCount5(text: string): number {
    return new Set(text.toLowerCase().match(/(.)(?=.*\1)/gi) || []).size;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIND THE PARITY OUTLIER
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// You are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer N. Write a method that takes the array as an argument and returns this "outlier" N.

// Examples
// [2, 4, 0, 100, 4, 11, 2602, 36]
// Should return: 11 (the only odd number)

// [160, 3, 1719, 19, 11, 13, -21]
// Should return: 160 (the only even number)

// CHECK IF ELEMENT'S ABSOLUT VALUE IS ODD OR EVEN, GROUP THEM IN ARRAYS
// RETURN FIRST ELEMENT OF ARRAY WITH ONE ELEMENT

const findOutlier = (ints: number[]): number => {
    const odds = ints.filter((num) => Math.abs(num) % 2 === 1);
    const evens = ints.filter((num) => Math.abs(num) % 2 === 0);
    // console.log(odds.length > 1 ? evens[0] : odds[0])
    return odds.length > 1 ? evens[0] : odds[0];
};

// findOutlier([2, 4, 0, 100, 4, 11, 2602, 36]);   // 11
// findOutlier([160, 3, 1719, 19, 11, 13, -21]);   // 160
// findOutlier([17417968, -12150916, -135668362, -45067422, 65586444, -104088786, 74395984, 198980314, -91660877, -52541784, -49718652, -189685108, -120327066, 178679078, -31538954, 112116518, -186162190, 29923430, 180062518, 878198, -185634066, -188868404, -111266602, -123331452, -184028074, -24771054, -4052, 98231950, -91193344, -154129192, -134529020, 195427700, 187599832, -11229586, -165510592, -19725720, 180071600, -161055558, 109276994, -88809438, -149769730, -89421390, 27663208, 132490658, 118790172, -23745850, 27711836, -4950342, 32063374, 655394]);   // -91660877

//============= OTHER CODEWARS SOLUTIONS: =============

export function findOutlier2(integers: number[]): number {
    if (integers.slice(0, 3).filter((i) => i % 2 !== 0).length > 1) {
        return integers.find((v) => v % 2 === 0) || 0;
    } else {
        return integers.find((v) => v % 2 !== 0) || 0;
    }
}

export function findOutlier3(integers: number[]): number {
    const odds = integers.filter((v) => v % 2);
    const evens = integers.filter((v) => !(v % 2));

    return odds.length === 1 ? odds[0] : evens[0];
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  BIT COUNTING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

const countBits = (num: number): number => {
    const bitArr = num.toString(2).match(/1/g);
    // console.log(bitArr === null ? 0 : bitArr.length);
    return bitArr === null ? 0 : bitArr.length;
};

// countBits(0);
// countBits(1234);

//============= OTHER CODEWARS SOLUTIONS: =============

export function countBits2(n: number): number {
    return n.toString(2).replace(/0/g, "").length;
}

export function countBits3(n: number) {
    return n
        .toString(2)
        .split("")
        .filter((c) => c === "1").length;
}

export function countBits4(n: number) {
    return n.toString(2).split("").map(Number).filter(Boolean).length;
}

export function countBits5(n: number) {
    return n.toString(2).split("1").length - 1;
}

export function countBits6(n: number) {
    return n.toString(2).replace(/0/gi, "").length;
}

export function countBits7(n: number) {
    return n.toString(2).match(/1/g)?.length || 0;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  WHO LIKES IT?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

const likes = (names: string[]): string => {
    switch (names.length) {
        case 0:
            return "no one likes this";
        case 1:
            return `${names[0]} likes this`;
        case 2:
            return `${names[0]} and ${names[1]} like this`;
        case 3:
            return `${names[0]}, ${names[1]} and ${names[2]} like this`;
        default:
            return `${names[0]}, ${names[1]} and ${
                names.length - 2
            } others like this`;
    }
};

//  MAKE 4+ NAMES DEFAULT

//============= OTHER CODEWARS SOLUTIONS: =============

// export const likes = (names: string[]): string => {
//     switch (names.length) {
//         case 0: return 'no one likes this';
//         case 1: return `${names[0]} likes this`;
//         case 2: return `${names[0]} and ${names[1]} like this`;
//         case 3: return `${names[0]}, ${names[1]} and ${names[2]} like this`;
//         default: return `${names[0]}, ${names[1]} and ${names.length - 2} others like this`;
//     }
// };

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  ARRAY.DIFF
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.

// It should remove all values from list a, which are present in list b keeping their order.

// array_diff({1, 2}, 2, {1}, 1, *z) == {2} (z == 1)
// If a value is present in b, all of its occurrences must be removed from the other:

// array_diff({1, 2, 2, 2, 3}, 5, {2}, 1, *z) == {1, 3} (z == 2)

// RETURN ELEMENTS OF a THAT ARE NOT PRESENT IN b
const arrayDiff = (a: number[], b: number[]): number[] => {
    return a.filter((num) => b.indexOf(num) < 0);
};

arrayDiff([3, 4, 3], [3]);

//============= OTHER CODEWARS SOLUTIONS: =============

// export function arrayDiff(a: number[], b: number[]): number[] {
//     return a.filter(e => !b.includes(e));
// }

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SUM OF DIGITS / DIGITAL ROOT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// Digital root is the recursive sum of all the digits in a number.

// Given n, take the sum of the digits of n. If that value has more than one digit, continue reducing in this way until a single-digit number is produced. The input will be a non-negative integer.

const digitalRoot = (num: number): number => {
    const digitArr = num
        .toString()
        .split("")
        .map((el) => Number(el));

    const sum = digitArr.reduce((a, b) => a + b);
    // console.log(num > 9 ? digitalRoot(sum) : num);
    return num > 9 ? digitalRoot(sum) : num;
};

//  NUM -> STR -> ARR(STR) -> ARR(NUM)
//  GET SUM OF DIGITS
//  RETURN digitalRoot(SUM) OR NUM
digitalRoot(493193); // 6

//============= OTHER CODEWARS SOLUTIONS: =============

// export function digitalRoot(n: number): number {
//     return (n - 1) % 9 + 1;
// }

// export const digitalRoot = (n:number):number => {
//     return n>9?digitalRoot([...(n.toString())].reduce((a,c)=>a+Number(c),0)):n;
// };

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  STOP SPINNING MY WORDS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// mop / forEach
//  STR -> ARR(STR) -> IF LENGTH >= 5{SPLIT.REV.JOIN} -> STR
const spinWords = (words: string): string => {
    const arr = words.split(" ");
    arr.map((word, i) => {
        if (word.length >= 5) {
            arr[i] = arr[i].split("").reverse().join("");
        }
    });
    console.log(arr.join(" "));
    return arr.join(" ");
};

// spinWords("Hey fellow warriors");

//============= OTHER CODEWARS SOLUTIONS: =============

function spinWords2(words: string): string {
    return words.replace(/[a-z]{5,}/gi, (s) => s.split("").reverse().join(""));
}

// const spinWords = (words: string): string => words.split(' ')
//                                                         .map(m => m.length >= 5
//                                                              ? m.split('').reverse().join('')
//                                                              : m)
//                                                         .join(' ')

// function spinWords(words: string): string {
//     return words.split(" ").map(word => word.length >= 5 ? [...word].reverse().join("") : word).join(" ")
// }

// function spinWords(words: string): string {
//     return words.split(" ").map(word => word.length >= 5 ? [...word].reverse().join("") : word).join(" ")
// }

// static spinWords(words: string) {
//     const array = words.split(" ");
//     const spin = array.map((word) => {
//       return word.length < 5 ? word : word.split("").reverse().join("");
//     });
//     return spin.join(" ");
// }

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// ❗️❗️❗️  INCLUDE THIS IN PROJECTS/TYPESCRIPT ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  FIND INT THAT APPEARS ODD NUMBER OF TIMES IN ARRAY
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: https://www.reddit.com/r/typescript/comments/hm8jbv/how_to_define_an_interface_for_objects_with/fx4szci/
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// ❗️❗️❗️ DEFINE INTERFACE FOR WHAT'S BEING RETURNED ❗️❗️❗️
// TO AVOID ERROR: Element implicitly has 'any' type because expression of type 'number' can't be used to index type '{}'

// ❗️❗️❗️ LOOK INTO THIS: ❗️❗️❗️

// A type like { [key: string]: number } is just bad and should not be used ever.

// Consider an example: const test: { [key: string]: number } = { a: 1 }; test.b // TS will think it’s of type number, while in fact it’s undefined.

// A type declared like that literally says: „for each key of string type there is a number value”. Which simply is not the case. Just don’t do it. It’s as bad as using any.

// If you need to use an object as a key-value mapper, do it well and either define the keys statically, or make the type of value a union with undefined.

// 1️⃣    WITH filter()

const findOdd = (arr: number[]): number => {
    interface NumCounter {
        [key: string]: number;
    }

    const counter: NumCounter = {};

    arr.forEach((num) => (counter[num] = (counter[num] || 0) + 1));

    const oddTimesArr = Object.entries(counter).filter(
        ([key, value]) => value % 2 > 0
    );

    // console.log(Number(oddTimesArr[0][0]));
    return Number(oddTimesArr[0][0]);
};

// 2️⃣    WITH forEach()

const findOdd2 = (arr: number[]): number => {
    interface NumCounter {
        [key: string]: number;
    }

    const counter: NumCounter = {};

    arr.forEach((num) => (counter[num] = (counter[num] || 0) + 1));

    let solution: any; // INITIALIZE ❗️❗️❗️

    Object.entries(counter).forEach(([key, value]) => {
        // value % 2 > 0 && console.log("key: ", Number(key));
        if (value % 2 > 0) solution = Number(key) as number; // TYPE ASSERTION ❗️❗️❗️
    });

    return solution;
};

// const findOdd = (arr: number[]): number => {

//     // LOOK INTO THIS, SEE ABOVE:
//     interface NumCounter {
//         [key: string]: number;
//     }

//     const counter: NumCounter = {};

//     arr.forEach(num => counter[num] = (counter[num] || 0) + 1);

//     // console.log(counter);

//     // !!! tsconfig.json COMPILER OPTIONS: "target": "es2018" (es2017 OR LATER) FOR Object.entries TO WORK!!!
//     Object.entries(counter).forEach(([key, value]) => console.log(`${key}: ${value}`));

//     Object.entries(counter).forEach(([key, value]) => {
//         value % 2 > 0 && console.log("key: ", Number(key));
//     });

//     const testArr = Object.entries(counter).filter(([key, value]) => value % 2 > 0);
//     console.log(testArr);
//     console.log(Number(testArr[0][0]));

//     return Number(testArr[0][0]);
// };

findOdd([1, 2, 2, 1, 2]);
findOdd2([1, 2, 2, 1, 2]);

//❗️❗️❗️============= OTHER CODEWARS SOLUTIONS: =============❗️❗️❗️

// https://warrenniu.medium.com/find-the-unique-number-in-an-array-using-the-xor-operator-54d35aa9e8d0
const findOdd3 = (xs: number[]): number => {
    return xs.reduce((a, b) => a ^ b);
};

// Bit operators work on 32 bits numbers. Any numeric operand in the operation is converted into a 32 bit number. The result is converted back to a JavaScript number.

// Operator	Description	Example	Same as	Result	Decimal
// &	AND	x = 5 & 1	0101 & 0001	0001	 1
// |	OR	x = 5 | 1	0101 | 0001	0101	 5
// ~	NOT	x = ~ 5	 ~0101	1010	 10
// ^	XOR	x = 5 ^ 1	0101 ^ 0001	0100	 4
// <<	Left shift	x = 5 << 1	0101 << 1	1010	 10
// >>	Right shift	x = 5 >> 1	0101 >> 1	0010	  2

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TypeError: Reduce of empty array with no initial value
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  MULTIPLES OF 3 OR 5
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

// Finish the solution so that it returns the sum of all the multiples of 3 or 5 below the number passed in. Additionally, if the number is negative, return 0 (for languages that do have them).

// Note: If the number is a multiple of both 3 and 5, only count it once.

// DIVS ARRAY MUST HAVE AN INITIAL VALUE
const solution = (num: number): number => {
    const divs = [0];
    for (let i = 1; i < num; i++)
        if (i % 3 === 0 || i % 5 === 0) {
            divs.push(i);
        }
    console.log(num >= 0 ? divs.reduce((a, b) => a + b) : 0);
    return num >= 0 ? divs.reduce((a, b) => a + b) : 0;
};

// solution(10);
// solution(-1);
// solution(0);

//============= OTHER CODEWARS SOLUTIONS: =============

// export class Challenge {
//     static solution(n: number) {
//       let x = 0;
//       for (let i = 0;i < n; ++i)
//         if (i % 3 == 0 || i % 5 == 0)
//           x += i
//       return x;
//     }
// }
