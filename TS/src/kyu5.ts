// ❗️❗️❗️ ✅  ❓❓❓
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// 🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦🟦
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/
/*

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// !!! Time: 3745ms Passed: 7Failed: 7 !!!
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: Street Fighter 2 - Character Selection - Part 2
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
As you may see, we now have 16 characters on 3 rows. You might think: let's make an array of 3 arrays! But that's not enough.

Empty space
The first character of the first row (Ryu) is not aligned with the first of the second row (Balrog) but with the second (Ken) and the same goes with the other side; therefore we need to introduce something new, like an offset: the Empty Space.

The empty space, represented as empty string "", will allow us to keep the grid aligned and rectangular, with spaces that won't be selectable. In this case we need 2 empty spaces (3 rows x 6 columns = 18 slots, 18 slots - 16 characters = 2 empty spaces). Like this:

|        | Ryu    | E.Honda  | Blanka  | Guile   |         |
| Balrog | Ken    | Chun Li  | Zangief | Dhalsim | Sagat   |
| Vega   | T.Hawk | Fei Long | Deejay  | Cammy   | M.Bison |
The moves of the selection cursor are the same as before: rotate horizontally but stop vertically. When you find empty spaces (1 or more) you need to skip them if you approach them horizontally and get to the next selectable slot with the next fighter on the left or right; and if you approach them vertically you need to just stop and stay where you are.

Example: if you are on Ryu and move left, you must get to Guile; if you are on Balrog and move up, you must stay on Balrog.

Notice: I might put empty spaces right in the middle and the rectangular grids can be any size, not only 3x6, deal with this too.

What's new
So, let's resume what are the new issues in this harder version of the Kata:

The initial position might be any non-empty slot in the grid (given as input).
The characters grid (also given as input) might have any rectangular layout, not only 3 rows.
The grid might contain empty spaces, both on the borders or right in the middle.
Input
Fighters grid;
Initial position;
List of moves.
The third input parameter is still the list of moves (all valid ones: left, right, up or down).

Output
The output is the same as before: the list of characters that have been hovered by the selection cursor after each move, successful or not.

Hopefully test cases will complete my explanation.
*/

/*
!!! Time: 3745ms Passed: 7Failed: 7 !!!

const superStreetFighterSelection = (
    fighters: string[][],
    position: [number, number],
    moves: string[]
): string[] => {
    console.log(fighters);
    console.log(moves);

    if (!fighters.length) return [];
    if (!position.length) return [];
    if (!moves.length) return [];

    // const vertical: number = position[0];
    // const horizontal: number = position[1];
    let currentPlayer: string = fighters[position[0]][position[1]];
    console.log("current player:", currentPlayer);
    //     let solution: string[] = [currentPlayer];
    let solution: string[] = [];

    let vertical: number = position[0];
    let horizontal: number = position[1];

    for (let i = 0; i < moves.length; i += 1) {
        let currentDir: string = moves[i];
        console.log("current direction:", currentDir);

        // let vertical: number = position[0];
        // let horizontal: number = position[1];

        // UP
        if (currentDir === "up") {
            // FIRST ROW, UNDEFINED ABOVE
            if (vertical < 1) {
                solution.push(currentPlayer);
                console.log("UNDEFINED, STOP!");
                solution.push(fighters[vertical][horizontal]);
                // VALID ROW
            } else {
                // EMPTY ABOVE
                if (fighters[vertical - 1][horizontal] === "") {
                    solution.push(currentPlayer);
                    console.log("EMPTY, STOP!");
                    // VALID ABOVE
                } else {
                    vertical -= 1;
                    solution.push(fighters[vertical][horizontal]);
                }
            }
            // DOWN
        } else if (currentDir === "down") {
            // BOTTOM ROW, UNDEFINED BELOW
            if (vertical === fighters.length - 1) {
                console.log("UNDEFINED, STOP!");
                solution.push(fighters[vertical][horizontal]);
            }
            // VALID ROWS
            else {
                // EMPTY BELOW
                if (fighters[vertical + 1][horizontal] === "") {
                    console.log("EMPTY BELOW, STOP!");
                }
                // VALID BELOW
                else {
                    vertical += 1;
                    solution.push(fighters[vertical][horizontal]);
                }
            }
        }
        // LEFT
        else if (currentDir === "left") {
            // EMPTY TO LEFT
            if (fighters[vertical][horizontal - 1] === "") {
                console.log("EMPTY LEFT, STOP!");
                solution.push(fighters[vertical][horizontal]);
            }
            // ROTATE LEFT
            else {
                // FIRST COLUMN, GO TO LAST INDEX
                if (horizontal === 0) {
                    console.log("UNDEFINED LEFT, ROTATE!");
                    horizontal = fighters[horizontal].length - 1;
                    solution.push(fighters[vertical][horizontal]);
                    // NOT FIRST COLUMN, GO TO PREVIOUS INDEX
                } else {
                    horizontal -= 1;
                    solution.push(fighters[vertical][horizontal]);
                    // continue;
                }
            }
        }
        // RIGHT
        else {
            console.log("RIGHT");
            // EMPTY TO RIGHT
            if (fighters[vertical][horizontal + 1] === "") {
                console.log("EMPTY RIGHT, STOP");
                solution.push(fighters[vertical][horizontal]);
            }
            // ROTATE RIGHT
            else {
                // LAST COLUMN, GO TO FIRST INDEX
                if (horizontal === fighters[vertical].length - 1) {
                    console.log("UNDEFINED RIGHT, ROTATE!");
                    horizontal = 0;
                    solution.push(fighters[vertical][horizontal]);
                }
                // NOT LAST COLUMN, GO TO NEXT INDEX
                else {
                    horizontal += 1;
                    solution.push(fighters[vertical][horizontal]);
                }
            }
        }
    }

    return solution;
};

*/

let fighters = [
    ["", "Ryu", "E.Honda", "Blanka", "Guile", ""],
    ["Balrog", "Ken", "Chun Li", "Zangief", "Dhalsim", "Sagat"],
    ["Vega", "T.Hawk", "Fei Long", "Deejay", "Cammy", "M.Bison"],
];
// let fighters = [
//     ["Vega", "Ryu", "E.Honda", "Blanka", "Guile", ""],
//     ["Balrog", "Ken", "Chun Li", "Zangief", "Dhalsim", "Sagat"],
//     ["", "T.Hawk", "Fei Long", "Deejay", "Cammy", "M.Bison"],
// ];
// let position: [number, number] = [1, 1];
// let position: [number, number] = [2, 0];
// let position: [number, number] = [0, 0];
let position: [number, number] = [0, 2];
// let position: [number, number] = [1, 1];
// let position: [number, number] = [1, 5];

// let moves = ["up"];
// let moves = ["down"];
// let moves = ["left"];
// let moves = ["left", "left", "left", "left", "left", "left", "left", "left"];
let moves = ["left", "left"];

const superStreetFighterSelection = (
    fighters: string[][],
    position: [number, number],
    moves: string[]
): string[] => {
    console.log(fighters);
    console.log(moves);

    if (!fighters.length) return [];
    if (!position.length) return [];
    if (!moves.length) return [];

    // const vertical: number = position[0];
    // const horizontal: number = position[1];
    const currentPlayer: string = fighters[position[0]][position[1]];
    console.log("current player:", currentPlayer);
    //     let solution: string[] = [currentPlayer];
    let solution: string[] = [];

    let row: number = position[0];
    let column: number = position[1];

    for (let i = 0; i < moves.length; i += 1) {
        let currentDir: string = moves[i];
        console.log("current direction:", currentDir);

        // let vertical: number = position[0];
        // let horizontal: number = position[1];

        // UP
        if (currentDir === "up") {
            // FIRST ROW, UNDEFINED ABOVE
            if (row < 1) {
                solution.push(currentPlayer);
                console.log("UNDEFINED, STOP!");
                solution.push(fighters[row][column]);
                // VALID ROW
            } else {
                // EMPTY ABOVE
                if (fighters[row - 1][column] === "") {
                    solution.push(currentPlayer);
                    console.log("EMPTY, STOP!");
                    // VALID ABOVE
                } else {
                    column -= 1;
                    solution.push(fighters[row][column]);
                }
            }
            // DOWN
        } else if (currentDir === "down") {
            // BOTTOM ROW, UNDEFINED BELOW
            if (row === fighters.length - 1) {
                console.log("UNDEFINED, STOP!");
                solution.push(fighters[row][column]);
            }
            // VALID ROWS
            else {
                // EMPTY BELOW
                if (fighters[row + 1][column] === "") {
                    console.log("EMPTY BELOW, STOP!");
                }
                // VALID BELOW
                else {
                    row += 1;
                    solution.push(fighters[row][column]);
                }
            }
        }
        // LEFT
        else if (currentDir === "left") {
            /*
            // EMPTY TO LEFT
            if (fighters[row][column - 1] === "") {
                console.log("EMPTY LEFT, STOP!");
                solution.push(fighters[row][column]);
            }
            // ROTATE LEFT
            else {
                // FIRST COLUMN, GO TO LAST INDEX 
                if (column === 0) {
                    console.log("UNDEFINED LEFT, ROTATE!");
                    column = fighters[column].length - 1;
                    solution.push(fighters[row][vertical]);
                    // NOT FIRST COLUMN, GO TO PREVIOUS INDEX
                } else {
                    horizontal -= 1;
                    solution.push(fighters[row][column]);
                    // continue;
                }
            }
            
            */
            if (fighters[row][column] !== " ") {
                solution.push(currentPlayer);
            }
            // LOOP IN REVERSE UNTIL VALID INDEX IS FOUND
            let index: number = column;
            for (let i = fighters[row].length; i >= 0; i -= 1) {
                if (index > -1) {
                    index -= 1;
                } else {
                    index = fighters[row].length - 1;
                }
                console.log(i, " - ", fighters[row][index]);
                if (fighters[row][index] !== " ") {
                    // solution.push(fighters[row][index]);
                    // row = index;
                }
            }

            // let index: number = column;
            // while (true) {
            //     if (index < 1) {
            //         index = fighters[row].length - 1;
            //     }
            //     index -= 1;
            // }
        }
        // RIGHT
        else {
            console.log("RIGHT");
            // EMPTY TO RIGHT
            if (fighters[row][column + 1] === "") {
                console.log("EMPTY RIGHT, STOP");
                solution.push(fighters[row][column]);
            }
            // ROTATE RIGHT
            else {
                // LAST COLUMN, GO TO FIRST INDEX
                if (column === fighters[row].length - 1) {
                    console.log("UNDEFINED RIGHT, ROTATE!");
                    column = 0;
                    solution.push(fighters[row][column]);
                }
                // NOT LAST COLUMN, GO TO NEXT INDEX
                else {
                    column += 1;
                    solution.push(fighters[row][column]);
                }
            }
        }
    }

    return solution;
};

/*
let fighters = [
    [       "",    "Ryu",  "E.Honda",  "Blanka",   "Guile", ""       ],
    [ "Balrog",    "Ken",  "Chun Li", "Zangief", "Dhalsim", "Sagat"  ],
    [   "Vega", "T.Hawk", "Fei Long",  "Deejay",   "Cammy", "M.Bison"]
];
let opts = ["up","down","right","left"];

describe("Character selection", function(){

  it("should work with no selection cursor moves", function(){
    let moves:string[] =  [];
    let position: [number,number]  = [0,0];
    let solution:string[] = [];
    assert.deepEqual(superStreetFighterSelection(copy(fighters), position, moves),solution);
  });
  



  it("should stop on empty spaces vertically", function(){
    let moves =  ["up"];
    let position: [number,number]  = [1,0];
    let solution = ['Balrog'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters), position, moves),solution);
  });

  it("should stop on empty spaces vertically", function(){
    let moves =  ["up","up","up","up"];
    let position: [number,number]  = [1,0];
    let solution = ['Balrog','Balrog','Balrog','Balrog'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters), position, moves),solution);
  });

  it("should stop vertically", function(){
    let moves =  ["down","down","down","down"];
    let position: [number,number]  = [1,0];
    let solution = ['Vega','Vega','Vega','Vega'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters), position, moves),solution);
  });

  it("should stop on empty spaces vertically", function(){
    let moves =  ["up","up","up","up"];
    let position: [number,number]  = [1,5];
    let solution = ['Sagat','Sagat','Sagat','Sagat'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters), position, moves),solution);
  });

  it("should stop vertically", function(){
    let moves =  ["down","down","down","down"];
    let position: [number,number]  = [1,5];
    let solution = ['M.Bison','M.Bison','M.Bison','M.Bison'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters), position, moves),solution);
  });

  it("should rotate horizontally", function(){
    let moves =  ["left","left","left","left","left","left","left","left"];
    let position: [number,number]  = [0,2];
    let solution = ['Ryu', 'Guile', 'Blanka', 'E.Honda', 'Ryu', 'Guile', 'Blanka', 'E.Honda'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters), position, moves),solution);
  });

  it("should rotate horizontally", function(){
    let moves =  ["left","left","left","left","left","left","left","left"];
    let position: [number,number]  = [1,3];
    let solution = ['Chun Li', 'Ken', 'Balrog', 'Sagat', 'Dhalsim', 'Zangief', 'Chun Li', 'Ken'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters), position, moves),solution);
  });

  it("should rotate horizontally with empty spaces", function(){
    let moves =  ["right","right","right","right","right","right","right","right"];
    let position: [number,number]  = [0,2];
    let solution = ['Blanka', 'Guile', 'Ryu', 'E.Honda', 'Blanka', 'Guile', 'Ryu', 'E.Honda'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters), position, moves),solution);
  });

  it("should rotate on all rows", function(){
    let moves =  ["right","right","right","right","right","right","down","left","left","left","left","left","left","left","left","left","left","left","left","down","right","right","right","right","right","right","right","right","right","right","right","right"];
    let position: [number,number]  = [0,2];
    let solution = ['Blanka', 'Guile', 'Ryu', 'E.Honda', 'Blanka', 'Guile', 'Dhalsim', 'Zangief', 'Chun Li', 'Ken', 'Balrog', 'Sagat', 'Dhalsim', 'Zangief', 'Chun Li', 'Ken', 'Balrog', 'Sagat', 'Dhalsim', 'Cammy', 'M.Bison', 'Vega', 'T.Hawk', 'Fei Long', 'Deejay', 'Cammy', 'M.Bison', 'Vega', 'T.Hawk', 'Fei Long', 'Deejay', 'Cammy'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters), position, moves),solution);
  });

// DO NOT CHANGE THIS VARIABLE!
// LIST WITH HOLES AND DUPLICATES
let fighters3 = [
    [       "",    "Ryu",  "E.Honda",  "Cammy",  "Blanka",   "Guile",        "", "Chun Li" ],
    [ "Balrog",    "Ken",  "Chun Li",       "", "M.Bison", "Zangief", "Dhalsim", "Sagat"  ],
    [   "Vega",       "", "Fei Long", "Balrog",  "Deejay",   "Cammy",        "", "T.Hawk"]
];

  it("should rotate on all rows", function(){
    let moves =  ["right","right","right","right","right","right","down","left","left","left","left","left","left","left","left","left","left","left","left","down","right","right","right","right","right","right","right","right","right","right","right","right"];
    let position: [number,number]  = [0,2];
    let solution = ['Cammy', 'Blanka', 'Guile', 'Chun Li', 'Ryu', 'E.Honda', 'Chun Li', 'Ken', 'Balrog', 'Sagat', 'Dhalsim', 'Zangief', 'M.Bison', 'Chun Li', 'Ken', 'Balrog', 'Sagat', 'Dhalsim', 'Zangief', 'Cammy', 'T.Hawk', 'Vega', 'Fei Long', 'Balrog', 'Deejay', 'Cammy', 'T.Hawk', 'Vega', 'Fei Long', 'Balrog', 'Deejay', 'Cammy'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters3), position, moves),solution);
  });

  it("should work", function(){
    let moves =  ["down","right","right","right","down","left","left","down","right","right","right","up"];
    let position: [number,number]  = [0,3];
    let solution = ['Cammy', 'Blanka', 'Guile', 'Chun Li', 'Sagat', 'Dhalsim', 'Zangief', 'Cammy', 'T.Hawk', 'Vega', 'Fei Long', 'Chun Li'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters3), position, moves),solution);
  });

  // DO NOT CHANGE THIS VARIABLE!
  let fighters4 = [
    [        "",     "Ryu",  "E.Honda",  "Cammy" ],
    [  "Balrog",     "Ken",  "Chun Li",       "" ],
    [    "Vega",        "", "Fei Long", "Balrog",],
      [  "Blanka",   "Guile",         "", "Chun Li"],
      [ "M.Bison", "Zangief",  "Dhalsim", "Sagat"  ],
      [  "Deejay",   "Cammy",         "", "T.Hawk" ]
  ]

  it("should work with longer grid", function(){
    let moves =  ["left","left","down","right","right","right","right","down","left","left","left","left","down","right","right", "down","right","right","right","down","left","left","left","down","left","left","left"];
    let position: [number,number]  = [0,3];
    let solution = ['E.Honda', 'Ryu', 'Ken', 'Chun Li', 'Balrog', 'Ken', 'Chun Li', 'Fei Long', 'Vega', 'Balrog', 'Fei Long', 'Vega', 'Blanka', 'Guile', 'Chun Li', 'Sagat', 'M.Bison', 'Zangief', 'Dhalsim', 'Dhalsim', 'Zangief', 'M.Bison', 'Sagat', 'T.Hawk', 'Cammy', 'Deejay', 'T.Hawk'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters4), position, moves),solution);
  });

  it("should work with odd initial position", function(){
    let moves =  ["left","left","down","right","right","right","right","down","left","left","left","left","up","right","right", "up","right","right","right"];
    let position: [number,number]  = [3,3];
    let solution = ['Guile', 'Blanka', 'M.Bison', 'Zangief', 'Dhalsim', 'Sagat', 'M.Bison', 'Deejay', 'T.Hawk', 'Cammy', 'Deejay', 'T.Hawk', 'Sagat', 'M.Bison', 'Zangief', 'Guile', 'Chun Li', 'Blanka', 'Guile'];
    assert.deepEqual(superStreetFighterSelection(copy(fighters4), position, moves),solution);
  });
*/
console.log(superStreetFighterSelection(fighters, position, moves));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: Closest and Smallest
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Input
a string strng of n positive numbers (n = 0 or n >= 2)
Let us call weight of a number the sum of its digits. For example 99 will have "weight" 18, 100 will have "weight" 1.

Two numbers are "close" if the difference of their weights is small.

Task:
For each number in strng calculate its "weight" and then find two numbers of strng that have:

the smallest difference of weights ie that are the closest
with the smallest weights
and with the smallest indices (or ranks, numbered from 0) in strng
Output:
an array of two arrays, each subarray in the following format:
[number-weight, index in strng of the corresponding number, original corresponding number in strng]

or a pair of two subarrays (Haskell, Clojure, FSharp) or an array of tuples (Elixir, C++)

or a (char*) in C or a string in some other languages mimicking an array of two subarrays or a string

or a matrix in R (2 rows, 3 columns, no columns names)

The two subarrays are sorted in ascending order by their number weights if these weights are different, by their indexes in the string if they have the same weights.

Examples:
Let us call that function closest

strng = "103 123 4444 99 2000"
the weights are 4, 6, 16, 18, 2 (ie 2, 4, 6, 16, 18)

closest should return [[2, 4, 2000], [4, 0, 103]] (or ([2, 4, 2000], [4, 0, 103])
or [{2, 4, 2000}, {4, 0, 103}] or ... depending on the language)
because 2000 and 103 have for weight 2 and 4, their indexes in strng are 4 and 0.
The smallest difference is 2.
4 (for 103) and 6 (for 123) have a difference of 2 too but they are not 
the smallest ones with a difference of 2 between their weights.
....................

strng = "80 71 62 53"
All the weights are 8.
closest should return [[8, 0, 80], [8, 1, 71]]
71 and 62 have also:
- the smallest weights (which is 8 for all)
- the smallest difference of weights (which is 0 for all pairs)
- but not the smallest indices in strng.
....................

strng = "444 2000 445 544"
the weights are 12, 2, 13, 13 (ie 2, 12, 13, 13)

closest should return [[13, 2, 445], [13, 3, 544]] or ([13, 2, 445], [13, 3, 544])
or [{13, 2, 445}, {13, 3, 544}] or ...
444 and 2000 have the smallest weights (12 and 2) but not the smallest difference of weights;
they are not the closest.
Here the smallest difference is 0 and in the result the indexes are in ascending order.
...................

closest("444 2000 445 644 2001 1002") --> [[3, 4, 2001], [3, 5, 1002]] or ([3, 4, 2001], 
[3, 5, 1002]]) or [{3, 4, 2001}, {3, 5, 1002}] or ...
Here the smallest difference is 0 and in the result the indexes are in ascending order.
...................

closest("239382 162 254765 182 485944 468751 49780 108 54")
The weights are: 27, 9, 29, 11, 34, 31, 28, 9, 9.
closest should return  [[9, 1, 162], [9, 7, 108]] or ([9, 1, 162], [9, 7, 108]) 
or [{9, 1, 162}, {9, 7, 108}] or ...
108 and 54 have the smallest difference of weights too, they also have 
the smallest weights but they don't have the smallest ranks in the original string.
..................

closest("54 239382 162 254765 182 485944 468751 49780 108")
closest should return  [[9, 0, 54], [9, 2, 162]] or ([9, 0, 54], [9, 2, 162])
or [{9, 0, 54}, {9, 2, 162}] or ...
Notes :
If n == 0 closest("") should return []

or ([], []) in Haskell, Clojure, FSharp

or [{}, {}] in Elixir or '(() ()) in Racket

or {{0,0,0}, {0,0,0}} in C++

or "[(), ()]" in Go, Nim,

or "{{0,0,0}, {0,0,0}}" in C, NULL in R

or "" in Perl.

See Example tests for the format of the results in your language.
*/

const closest = (str: string): number[][] => {
    // MIGHT NOT BE NECESSARY:
    const numArr: number[] = str.split(" ").map((str) => Number(str));
    console.log("numArr:", numArr);

    // RETURN EMPTY ARRAY IF EMPTY STRING
    if (numArr.length === 1) return [];

    // WEIGHTS:
    const weigthArr: number[] = numArr.map((num) =>
        num
            .toString()
            .split("")
            .map((str) => Number(str))
            .reduce((acc, curr) => acc + curr)
    );
    console.log("weightArr:", weigthArr);

    // ❗️❗️❗️ MAKE COPY OF weigthArr FOR SORTED ARRAY BECAUSE WE NEED ORIGINAL (SORT() WILL MUTATE ORIGINAL) ❗️❗️❗️
    const weightArrCopy: number[] = [...weigthArr];

    // ASCENDING WEIGHTS:
    const ascWeigthArr: number[] = weightArrCopy.sort((a, b) => a - b);
    // console.log("ascWeigthArr:", ascWeigthArr);

    // DIFFERENCES ARRAY:
    const diffArr: number[] = [];
    for (let i = 1; i < ascWeigthArr.length; i += 1) {
        const current: number = ascWeigthArr[i] - ascWeigthArr[i - 1];
        diffArr.push(current);
    }
    // console.log("diffArr:", diffArr);

    // FIND SMALLEST DIFFERENCE WITH SMALLEST INDEX:
    const smallestDiff: number = Math.min(...diffArr);
    // console.log("smallest difference:", smallestDiff);

    // FIND FIRST OCCURENCE OF smallestDiff IN diffArr:
    let smallestIdx: number = 0;
    for (let i = 0; i < diffArr.length; i += 1) {
        if (diffArr[i] === smallestDiff) {
            smallestIdx = i;
            break;
        }
    }
    // console.log("smallestIdx:", smallestIdx);

    // RETRIEVE PAIR WITH SMALLEST INDEX:
    const diffA: number = ascWeigthArr[smallestIdx];
    const diffB: number = ascWeigthArr[smallestIdx + 1];
    // console.log("diffA:", diffA, "diffB:", diffB);

    //
    let idxNumA: number = 0;
    let idxNumB: number = 0;

    // DUPLICATES (HAVE TO FIND ALL MATCHES AND USE THE FIRST TWO - WITH THE SAME INDEX)
    if (diffA === diffB) {
        let sameIndicesArr: number[] = [];
        // console.log("    ----- same weight! -----");
        // console.log("weightArr:", weigthArr);
        for (let i = 0; i < weigthArr.length; i += 1) {
            // console.log(weigthArr[i], diffA);
            if (weigthArr[i] === diffA) {
                // console.log("----- DUPLICATE -----");
                sameIndicesArr.push(i);
            }
        }

        // console.log("sameWeightsArr:", sameIndicesArr);

        idxNumA = sameIndicesArr[0];
        idxNumB = sameIndicesArr[1];
        // NO DUPLICATES (NUMBERS WILL BE NEXT TO EACH OTHER IN ORDERED ARR)
    } else {
        idxNumA = weigthArr.indexOf(diffA);
        idxNumB = weigthArr.indexOf(diffB);
    }

    // GET ACTUAL NUMBERS FROM numArr:
    // console.log("numArr:", numArr);
    const numA: number = numArr[idxNumA];
    const numB: number = numArr[idxNumB];
    // console.log("numA:", numA, "numB", numB);

    const solution: number[][] = [
        [diffA, idxNumA, numA],
        [diffB, idxNumB, numB],
    ];
    // console.log(solution);

    return solution;
};
/*

console.log(closest("239382 162 254765 182 485944 134 468751 62 49780 108 54"));

numArr: [
  239382,    162, 254765,
     182, 485944,    134,
  468751,     62,  49780,
     108,     54
]
weightArr: [
  27,  9, 29, 11, 34,
   8, 31,  8, 28,  9,
   9
]
ascWeigthArr: [
   8,  8,  9,  9,  9,
  11, 27, 28, 29, 31,
  34
]
diffArr: [
   0, 1, 0, 0, 2,
  16, 1, 1, 2, 3
]
smallest difference: 0
smallestIdx: 0
diffA: 8 diffB: 8
    ----- same weight! -----
weightArr: [
  27,  9, 29, 11, 34,
   8, 31,  8, 28,  9,
   9
]
27 8
9 8
29 8
11 8
34 8
8 8
----- DUPLICATE -----
31 8
8 8
----- DUPLICATE -----
28 8
9 8
9 8
sameWeightsArr: [ 5, 7 ]
numArr: [
  239382,    162, 254765,
     182, 485944,    134,
  468751,     62,  49780,
     108,     54
]
numA: 134 numB 62
[ [ 8, 5, 134 ], [ 8, 7, 62 ] ]
[ [ 8, 5, 134 ], [ 8, 7, 62 ] ]
*/
// console.log(closest("103 123 4444 99 2000"));
// expected [ [ 8, 5, 134 ], [ 8, 5, 134 ] ] to deeply equal [ [ 8, 5, 134 ], [ 8, 7, 62 ] ]
// console.log(closest("239382 162 254765 182 485944 134 468751 62 49780 108 54"));
// [[10, 1, 154], [10, 9, 37]]
// console.log(
//     closest("241259 154 155206 194 180502 147 300751 200 406683 37 57")
// );
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
function closest2(code: string): number[][] {
    if (!code) {
        return [];
    }

    const arr = code
        .split(" ")
        .map((e, i) => [[...e].reduce((a, b) => +a + +b, 0), i, +e])
        .sort(([a0, a1], [b0, b1]) => a0 - b0 || a1 - b1);

    let findIndex = 0,
        findDel = arr[1][0] - arr[0][0];

    for (let i = 2; i < arr.length; i++) {
        if (findDel > arr[i][0] - arr[i - 1][0]) {
            findDel = arr[i][0] - arr[i - 1][0];
            findIndex = i - 1;
        }
    }

    return arr.slice(findIndex, findIndex + 2);
}

function closest3(s: string): number[][] {
    if (s === "") return [];

    const splitted = s.split(" ");
    const positions = splitted.map((_, i) => i);
    const values = splitted.map((x) => +x);
    const weights = splitted.map((x) =>
        x.split("").reduce((a, v) => a + +v, 0)
    );
    const ranks = splitted.map((_, i) => i);

    ranks.sort(
        (a, b) => weights[a] - weights[b] || positions[a] - positions[b]
    );

    let delta = Number.MAX_SAFE_INTEGER;
    let best = 0;
    for (let i = 1; i < ranks.length; i++) {
        const d = weights[ranks[i]] - weights[ranks[i - 1]];
        if (d < delta) {
            delta = d;
            best = i - 1;
        }
    }

    const s1 = ranks[best];
    const s2 = ranks[best + 1];

    return [
        [weights[s1], positions[s1], values[s1]],
        [weights[s2], positions[s2], values[s2]],
    ];
}

export const closest4 = (z: string): number[][] =>
    z
        ? z
              .split(" ")
              .map((s, i) => [
                  s
                      .split("")
                      .map((c) => +c)
                      .reduce((w, d) => (w += d)),
                  i,
                  +s,
              ])
              .sort(([a, b], [c, d]) => a - c || b - d)
              .reduce(
                  (d, w, i, [_, ...a]) =>
                      a[i]
                          ? ([...d, [a[i][0] - w[0], i, [w, a[i]]]] as typeof d)
                          : d,
                  [] as [number, number, number[][]][]
              )
              .sort(([a, b], [c, d]) => a - c || b - d)[0][2]
        : [];

function closest5(strng: string): number[][] {
    let numbers = strng.split(" ");
    let sumDigits = numbers.map((s) =>
        s.split("").reduce((acc, d) => {
            acc += parseInt(d);
            return acc;
        }, 0)
    );

    let diff = -1;
    let res: number[][] = [];
    for (let i = 0; i < sumDigits.length - 1; i++) {
        for (let j = i + 1; j < sumDigits.length; j++) {
            const currentDiff = Math.abs(sumDigits[i] - sumDigits[j]);

            if (diff < 0 || currentDiff < diff) {
                diff = currentDiff;
                res = [
                    [sumDigits[i], i, parseInt(numbers[i])],
                    [sumDigits[j], j, parseInt(numbers[j])],
                ];
            } else if (currentDiff == diff) {
                if (sumDigits[i] + sumDigits[j] < res[0][0] + res[1][0]) {
                    diff = currentDiff;
                    res = [
                        [sumDigits[i], i, parseInt(numbers[i])],
                        [sumDigits[j], j, parseInt(numbers[j])],
                    ];
                }
            }
        }
    }

    return res.sort((a, b) => {
        if (a[0] === b[0]) {
            return a[1] - b[1];
        }

        return a[0] - b[0];
    });
}
// ============================================================
class ClosestWeight {
    inputNums: string;
    nestedNums: number[][] = [];
    weights: number[] = [];
    weightsChart: Record<string, number> = {};
    diffsChart: Record<string, number[][]> = {};
    nums: number[] = [];
    closestWeightsIndex: number = 0;
    smallestWeghtDiff = 999999999;
    num1_index = 0;
    num2_index = 1;

    constructor(inputNums: string) {
        this.inputNums = inputNums;
    }

    parseInputs() {
        this.nums = this.inputNums.split(" ").map((d) => parseInt(d));
        console.log("nums", this.nums);
    }

    calcWeights() {
        this.weights = this.nums.map((n) =>
            n
                .toString()
                .split("")
                .reduce((a, b) => a + parseInt(b), 0)
        );
        console.log("weights", this.weights);
    }

    saveClosestAndSmallest(
        weightDiff: number,
        num1_index: number,
        num2_index: number
    ) {
        this.smallestWeghtDiff = weightDiff;
        this.num1_index = num1_index;
        this.num2_index = num2_index;
    }

    findClosestAndSmallest() {
        this.smallestWeghtDiff = Math.abs(this.weights[0] - this.weights[1]);

        for (let i = 0; i < this.nums.length - 1; i++) {
            for (let j = i + 1; j < this.nums.length; j++) {
                let weight_i = this.weights[i];
                let weight_j = this.weights[j];
                let weightdiff = Math.abs(this.weights[i] - this.weights[j]);

                if (weightdiff < this.smallestWeghtDiff) {
                    this.saveClosestAndSmallest(weightdiff, i, j);
                } else if (weightdiff == this.smallestWeghtDiff) {
                    let currentWeight = weight_i + weight_j;
                    let smallestWeight =
                        this.weights[this.num1_index] +
                        this.weights[this.num2_index];
                    if (currentWeight < smallestWeight) {
                        this.saveClosestAndSmallest(weightdiff, i, j);
                    } else if (currentWeight == smallestWeight) {
                        if (i + j < this.num1_index + this.num2_index) {
                            this.saveClosestAndSmallest(weightdiff, i, j);
                        }
                    }
                }
            }
        }
    }

    formatNum(index: number) {
        return [this.weights[index], index, this.nums[index]];
    }

    run() {
        this.parseInputs();
        if (this.nums.length < 2) return [];
        this.calcWeights();
        this.findClosestAndSmallest();
        if (this.weights[this.num1_index] > this.weights[this.num2_index])
            [this.num1_index, this.num2_index] = [
                this.num2_index,
                this.num1_index,
            ];

        return [
            this.formatNum(this.num1_index),
            this.formatNum(this.num2_index),
        ];
    }
}

export function closest6(strng: string): number[][] {
    return new ClosestWeight(strng).run();
}
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: k-Primes
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A natural number is called k-prime if it has exactly k prime factors, counted with multiplicity. For example:

k = 2  -->  4, 6, 9, 10, 14, 15, 21, 22, ...
k = 3  -->  8, 12, 18, 20, 27, 28, 30, ...
k = 5  -->  32, 48, 72, 80, 108, 112, ...
A natural number is thus prime if and only if it is 1-prime.

Task:
Complete the function count_Kprimes (or countKprimes, count-K-primes, kPrimes) which is given parameters k, start, end (or nd) and returns an array (or a list or a string depending on the language - see "Solution" and "Sample Tests") of the k-primes between start (inclusive) and end (inclusive).

Example:
countKprimes(5, 500, 600) --> [500, 520, 552, 567, 588, 592, 594]
Notes:

The first function would have been better named: findKprimes or kPrimes :-)
In C some helper functions are given (see declarations in 'Solution').
For Go: nil slice is expected when there are no k-primes between start and end.
Second Task: puzzle (not for Shell)
Given a positive integer s, find the total number of solutions of the equation a + b + c = s, where a is 1-prime, b is 3-prime, and c is 7-prime.

Call this function puzzle(s).

Examples:
puzzle(138)  -->  1  because [2 + 8 + 128] is the only solution
puzzle(143)  -->  2  because [3 + 12 + 128] and [7 + 8 + 128] are the solutions

*/
export const countKprimes = (
    k: number,
    start: number,
    nd: number
): number[] => {
    // you code
    return [];
};
export const puzzle = (s: number): number => {
    // you code
    return -1;
};
/*
testing(countKprimes(2, 0, 100), [4, 6, 9, 10, 14, 15, 21, 22, 25, 26, 33, 34, 35, 38, 39,  46, 49, 51, 55, 57, 58, 62, 65, 69, 74, 77, 82, 85, 86, 87, 91, 93, 94, 95]);
        testing(countKprimes(3, 0, 100), [8, 12, 18, 20, 27, 28, 30, 42, 44, 45, 50, 52, 63, 66, 68, 70, 75, 76, 78, 92, 98, 99]);
        testing(countKprimes(5, 1000, 1100), [1020, 1026, 1032, 1044, 1050, 1053, 1064, 1072, 1092, 1100]);
        testing(countKprimes(5, 500, 600), [500, 520, 552, 567, 588, 592, 594]);
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: John and Ann sign up for Codewars
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
John and his wife Ann have decided to go to Codewars. On the first day Ann will do one kata and John - he wants to know how it is working - 0 kata.

Let us call a(n) - and j(n) - the number of katas done by Ann - and John - at day n. We have a(0) = 1 and in the same manner j(0) = 0.

They have chosen the following rules:

On day n the number of katas done by Ann should be n minus the number of katas done by John at day t, t being equal to the number of katas done by Ann herself at day n - 1

On day n the number of katas done by John should be n minus the number of katas done by Ann at day t, t being equal to the number of katas done by John himself at day n - 1

Whoops! I think they need to lay out a little clearer exactly what there're getting themselves into!

Could you write:
functions ann(n) and john(n) that return the list of the number of katas Ann/John does on the first n days;
functions sum_ann(n) and sum_john(n) that return the total number of katas done by Ann/John on the first n days
Examples:
john(11)  -->  [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6]
ann(6)    -->  [1, 1, 2, 2, 3, 3]

sum_john(75)  -->  1720
sum_ann(150)  -->  6930
Note:
Keep an eye on performance.
*/
export function john(n: number): number[] {
    return [];
}
export function ann(n: number): number[] {
    return [];
}
export function sumJohn(n: number): number {
    return 0;
}
export function sumAnn(n: number): number {
    return 0;
}
/*
describe("Fixed Tests", function() {
    it("john", function() {
        testJohn(11, [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6]);
    });
});
describe("Fixed Tests", function() {
    it("ann", function() {
        testAnn(6, [1, 1, 2, 2, 3, 3]);
    });
});
describe("Fixed tests",function() {
    it("sumAnn",function() {
        testSumAnn(115, 4070);
})});
describe("Fixed tests",function() {
    it("sumJohn",function() {
        testSumJohn(75, 1720);
})})

*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
//🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: Base64 Encoding
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Extend the String object (JS) or create a function (Python, C#) that converts the value of the String to and from Base64 using the ASCII (UTF-8 for C#) character set.

Example (input -> output):
'this is a string!!' -> 'dGhpcyBpcyBhIHN0cmluZyEh'
You can learn more about Base64 encoding and decoding here.

Note: This kata uses the non-padding version ("=" is not added to the end).


*/
export function toBase64(str: string): string {
    return "hello";
}

export function fromBase64(str: string): string {
    return "hello";
}

/*
 expect(toBase64('this is a string!!')).to.equal('dGhpcyBpcyBhIHN0cmluZyEh');
    expect(fromBase64('dGhpcyBpcyBhIHN0cmluZyEh')).to.equal('this is a string!!');
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
//🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: Buddy Pairs
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Buddy pairs
You know what divisors of a number are. The divisors of a positive integer n are said to be proper when you consider only the divisors other than n itself. In the following description, divisors will mean proper divisors. For example for 100 they are 1, 2, 4, 5, 10, 20, 25, and 50.

Let s(n) be the sum of these proper divisors of n. Call buddy two positive integers such that the sum of the proper divisors of each number is one more than the other number:

(n, m) are a pair of buddy if s(m) = n + 1 and s(n) = m + 1

For example 48 & 75 is such a pair:

Divisors of 48 are: 1, 2, 3, 4, 6, 8, 12, 16, 24 --> sum: 76 = 75 + 1
Divisors of 75 are: 1, 3, 5, 15, 25 --> sum: 49 = 48 + 1
Task
Given two positive integers start and limit, the function buddy(start, limit) should return the first pair (n m) of buddy pairs such that n (positive integer) is between start (inclusive) and limit (inclusive); m can be greater than limit and has to be greater than n

If there is no buddy pair satisfying the conditions, then return "Nothing" or (for Go lang) nil or (for Dart) null; (for Lua, Pascal, Perl, D) [-1, -1]; (for Erlang {-1, -1}).

Examples
(depending on the languages)

buddy(10, 50) returns [48, 75] 
buddy(48, 50) returns [48, 75]
or
buddy(10, 50) returns "(48 75)"
buddy(48, 50) returns "(48 75)"
Notes
for C: The returned string will be free'd.
See more examples in "Sample Tests:" of your language.
*/

/*
// PASSED FIXED TESTS 1 AND 4
const buddy = (start: number, limit: number): number[] => {

    let solution: number[] = [];
    // CALC SUM OF DIVISORS
    for (let i = start; i <= limit; i += 1) {
        console.log("number", i);
        let divisors: number[] = [];
        for (let j = 1; j <= i / 2; j += 1) {
            if (Number.isInteger(i / j)) {
                divisors.push(j);
            }
        }
        // console.log("   divisors", divisors);
        const currenSum: number = divisors.reduce((acc, curr) => acc + curr);
        console.log("       current sum:", currenSum, "\n");

        // START NEW LOOP TO FIND PAIR
        let k = i + 1;
        // let k = currenSum - 1;
        while (true) {
            console.log("           new loop:", k);
            let buddyDivisors: number[] = [];
            for (let l = 1; l <= k / 2; l += 1) {
                if (Number.isInteger(k / l)) {
                    buddyDivisors.push(l);
                }
            }
            // k += 1;

            // console.log(buddyDivisors);
            const buddySum: number = buddyDivisors.reduce(
                (acc, curr) => acc + curr
            );
            console.log("               buddySum:", buddySum);

            // if (k === i + 3) break;

            // if (buddySum === i + 1) {
            if (buddySum === i + 1 && currenSum === k + 1) {
                console.log("Match found:", i, k);
                solution.push(i, k);
                // !!!!!!!!!
                return solution;
                break;
                // !!!!!!!!!
            }

            if (k > 90) break;

            k += 1;
        }
    }

    console.log("SOLUTION:", solution);

    return solution;

};
*/

/*
// !!! TIMEOUT ON FIXED TEST 2 !!!
const buddy = (start: number, limit: number): number[] => {

    let solution: number[] = [];
    // CALC SUM OF DIVISORS
    for (let i = start; i <= limit; i += 1) {
        console.log("number", i);
        let divisorsSum: number = 0;
        for (let j = 1; j <= i / 2; j += 1) {
            if (Number.isInteger(i / j)) {
                divisorsSum += j;
            }
        }

        console.log("       current sum:", divisorsSum, "\n");

        // START NEW LOOP TO FIND PAIR
        let k = divisorsSum < i
            ? i + 1
            : divisorsSum - 1;

        while (true) {
            console.log("           new loop:", k);
            let buddyDivisorsSum = 0;
            for (let l = 1; l <= k / 2; l += 1) {
                if (Number.isInteger(k / l)) {
                    buddyDivisorsSum += l;
                }
            }

            console.log("               buddySum:", buddyDivisorsSum);

            if (buddyDivisorsSum === i + 1 && divisorsSum === k + 1) {
                console.log("Match found:", i, k);
                solution.push(i, k);
                return solution;
            }

            if (k > 90) break;

            k += 1;
        }
    }

    console.log("SOLUTION:", solution);

    return solution;

};
*/

/*
const buddy = (start: number, limit: number): number[] => {
    const divSum = (num: number): number => {
        // Final result of summation of divisors
        let result = 0;

        // find all divisors which divides 'num'
        for (let i = 2; i <= Math.sqrt(num); i++) {
            // if 'i' is divisor of 'num'
            if (num % i == 0) {
                // if both divisors are same then add
                // it only once else add both
                if (i == num / i) result += i;
                else result += i + num / i;
            }
        }

        // Add 1 to the result as 1 is also a divisor
        return result + 1;
    };

    let solution: number[] = [];
    // CALC SUM OF DIVISORS
    for (let i = start; i <= limit; i += 1) {
        console.log("number", i);

        const divisorsSum = divSum(i);

        console.log("       current sum:", divisorsSum, "\n");

        // START NEW LOOP TO FIND PAIR
        let k = divisorsSum < i ? i + 1 : divisorsSum - 1;

        while (true) {
            console.log("           new loop:", k);

            let buddyDivisorsSum = divSum(k);

            console.log("               buddySum:", buddyDivisorsSum);

            if (buddyDivisorsSum === i + 1 && divisorsSum === k + 1) {
                console.log("Match found:", i, k);
                solution.push(i, k);
                // ❗️❗️❗️
                return solution;
            }


            // if (k > 90) break;
            // ❗️❗️❗️
            break;
            // return solution;

            // k += 1;
        }
    }

    console.log("SOLUTION:", solution);

    return solution;
};
*/

// 3️⃣✅ NO SECOND LOOP NEEDED:
const buddy5 = (start: number, limit: number): number[] => {
    const divSum = (num: number): number => {
        // Final result of summation of divisors
        let result = 0;

        // find all divisors which divides 'num'
        for (let i = 2; i <= Math.sqrt(num); i++) {
            // if 'i' is divisor of 'num'
            if (num % i == 0) {
                // if both divisors are same then add
                // it only once else add both
                if (i == num / i) result += i;
                else result += i + num / i;
            }
        }

        // Add 1 to the result as 1 is also a divisor
        return result + 1;
    };

    let solution: number[] = [];
    // CALC SUM OF DIVISORS
    for (let i = start; i <= limit; i += 1) {
        // console.log("number", i);

        const divisorsSum = divSum(i);

        // console.log("       current sum:", divisorsSum, "\n");

        let k = divisorsSum < i ? i + 1 : divisorsSum - 1;

        let buddyDivisorsSum = divSum(k);

        // console.log("               buddySum:", buddyDivisorsSum);

        if (buddyDivisorsSum === i + 1 && divisorsSum === k + 1) {
            console.log("Match found:", i, k);
            solution.push(i, k);
            // ❗️❗️❗️
            return solution;
        }
    }

    // console.log("SOLUTION:", solution);

    return solution;
};
/*
testing(10, 50, [48, 75] );
        testing(1071625, 1103735, [1081184, 1331967] );
        testing(57345, 90061, [62744, 75495] );
        testing(2382, 3679, [] );
*/
// console.log(buddy(10, 50));
// console.log(buddy(48, 50));
// console.log(buddy(2382, 3679));
// console.log(buddy(62744, 62745));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function sumFactor(n: number): number {
    let total: number = 1;
    for (let i: number = 2; i <= Math.sqrt(n) + 1; i++) {
        if (n % i == 0) total += i + n / i;
    }
    return total;
}

export function buddy2(start: number, limit: number): number[] {
    for (let i: number = start; i <= limit; i++) {
        let a: number = sumFactor(i) - 1;
        let b: number = sumFactor(a) - 1;
        if (b == i && i < a) return [i, a];
    }
    return [];
}

// ============================================================
function buddy3(start: number, limit: number): number[] {
    function aux(n: number): number {
        var res = 1,
            i = 2;
        for (; i * i < n; i++) if (n % i === 0) res += i + n / i;
        if (i * i === n) res += i;
        return res;
    }
    for (let k = start; k <= limit; k++) {
        let m = aux(k) - 1;
        if (k === aux(m) - 1 && k < m) return [k, m];
    }
    return [];
}

// ============================================================

const divisors = (n: number): number[] => {
    let divisors: number[] = [];

    for (let i = 1; i <= Math.sqrt(n); i++) {
        if (n % i === 0) {
            if (i === n / i) {
                divisors.push(n);
            } else {
                divisors.push(i);
                divisors.push(n / i);
            }
        }
    }
    return divisors;
};

const properDivisors = (num: number): number[] =>
    divisors(num).filter((n) => n !== num);

const sumOfProperDivisors = (num: number): number =>
    properDivisors(num).reduce((prev, curr) => prev + curr, 0);

export function buddy(start: number, limit: number): number[] {
    for (let n = start; n <= limit; n++) {
        let m = sumOfProperDivisors(n) - 1;

        if (m <= n) continue;
        if (sumOfProperDivisors(m) - 1 === n) {
            return [n, m];
        }
    }
    return [];
}
// ============================================================

const DUMMY: Record<number, number> = {
    48: 75,
    1050: 1925,
    2024: 2295,
    5775: 6128,
    8892: 16587,
    9504: 20735,
    62744: 75495,
    186615: 206504,
    196664: 219975,
    199760: 309135,
    266000: 507759,
    312620: 549219,
    526575: 544784,
    573560: 817479,
    587460: 1057595,
    1000824: 1902215,
    1081184: 1331967,
    1139144: 1159095,
    1173704: 1341495,
    1208504: 1348935,
    1233056: 1524831,
    1236536: 1459143,
    1279950: 2576945,
    1921185: 2226014,
    2036420: 2681019,
    2102750: 2142945,
    2140215: 2421704,
    2171240: 3220119,
    2198504: 3123735,
    2312024: 3010215,
    2580864: 5644415,
    2958500: 3676491,
};
const ARR: number[] = Object.keys(DUMMY).map(Number);

export function buddy4(start: number, limit: number): number[] {
    const v = ARR.find((v) => v >= start) || -1;
    const w = DUMMY[v]!;
    return v != -1 && v <= limit ? [v, w] : [];
}
// ============================================================

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: Phone Directory
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
John keeps a backup of his old personal phone book as a text file. On each line of the file he can find the phone number (formated as +X-abc-def-ghij where X stands for one or two digits), the corresponding name between < and > and the address.
 
Unfortunately everything is mixed, things are not always in the same order; parts of lines are cluttered with non-alpha-numeric characters (except inside phone number and name).
 
Examples of John's phone book lines:
 
"/+1-541-754-3010 156 Alphand_St. <J Steeve>\n"
 
" 133, Green, Rd. <E Kustur> NY-56423 ;+1-541-914-3010!\n"
 
"<Anastasia> +48-421-674-8974 Via Quirinal Roma\n"
 
Could you help John with a program that, given the lines of his phone book and a phone number num returns a string for this number : "Phone => num, Name => name, Address => adress"
 
Examples:
s = "/+1-541-754-3010 156 Alphand_St. <J Steeve>\n 133, Green, Rd. <E Kustur> NY-56423 ;+1-541-914-3010!\n"
 
phone(s, "1-541-754-3010") should return "Phone => 1-541-754-3010, Name => J Steeve, Address => 156 Alphand St."
It can happen that there are many people for a phone number num, then return : "Error => Too many people: num"
 
or it can happen that the number num is not in the phone book, in that case return: "Error => Not found: num"
 
Notes
Codewars stdout doesn't print part of a string when between < and >
 
You can see other examples in the test cases.
 
JavaScript random tests completed by @matt c.
*/

const dr =
    "/+1-541-754-3010 156 Alphand_St. <J Steeve>\n 133, Green, Rd. <E Kustur> NY-56423 ;+1-541-914-3010\n" +
    "+1-541-984-3012 <P Reed> /PO Box 530; Pollocksville, NC-28573\n :+1-321-512-2222 <Paul Dive> Sequoia Alley PQ-67209\n" +
    "+1-741-984-3090 <Peter Reedgrave> _Chicago\n :+1-921-333-2222 <Anna Stevens> Haramburu_Street AA-67209\n" +
    "+1-111-544-8973 <Peter Pan> LA\n +1-921-512-2222 <Wilfrid Stevens> Wild Street AA-67209\n" +
    "<Peter Gone> LA ?+1-121-544-8974 \n <R Steell> Quora Street AB-47209 +1-481-512-2222\n" +
    "<Arthur Clarke> San Antonio $+1-121-504-8974 TT-45120\n <Ray Chandler> Teliman Pk. !+1-681-512-2222! AB-47209,\n" +
    "<Sophia Loren> +1-421-674-8974 Bern TP-46017\n <Peter O'Brien> High Street +1-908-512-2222; CC-47209\n" +
    "<Anastasia> +48-421-674-8974 Via Quirinal Roma\n <P Salinger> Main Street, +1-098-512-2222, Denver\n" +
    "<C Powel> *+19-421-674-8974 Chateau des Fosses Strasbourg F-68000\n <Bernard Deltheil> +1-498-512-2222; Mount Av.  Eldorado\n" +
    "+1-099-500-8000 <Peter Crush> Labrador Bd.\n +1-931-512-4855 <William Saurin> Bison Street CQ-23071\n" +
    "<P Salinge> Main Street, +1-098-512-2222, Denve\n" +
    "/+5-541-754-3010 156 Alphandria_Street. <Jr Part>\n 1333, Green, Road <F Fulgur> NW-46423 ;+6-541-914-3010!\n" +
    "+5-541-984-3012 <Peter Reeves> /PO Box 5300; Albertville, SC-28573\n :+5-321-512-2222 <Paulo Divino> Boulder Alley ZQ-87209\n" +
    "+3-741-984-3090 <F Flanaghan> _Chicago Av.\n :+3-921-333-2222 <Roland Scorsini> Bellevue_Street DA-67209\n" +
    "+8-111-544-8973 <Laurence Pantow> SA\n +8-921-512-2222 <Raymond Stevenson> Joly Street EE-67209\n" +
    "<John Freeland> Mantow ?+2-121-544-8974 \n <Robert Mitch> Eleonore Street QB-87209 +2-481-512-2222?\n" +
    "<Arthur Paternos> San Antonio $+7-121-504-8974 TT-45121\n <Ray Charles> Stevenson Pk. !+7-681-512-2222! CB-47209,\n" +
    "<JP Gorce> +9-421-674-8974 New-Bern TP-16017\n <P McDon> Revolution Street +2-908-512-2222; PP-47209\n" +
    "<Elizabeth Corber> +8-421-674-8974 Via Papa Roma\n <C Saborn> Main Street, +15-098-512-2222, Boulder\n" +
    "<Colin Marshall> *+9-421-674-8974 Edinburgh UK\n <Bernard Povit> +3-498-512-2222; Hill Av.  Cameron\n" +
    "+12-099-500-8000 <Pete Highman> Ontario Bd.\n +8-931-512-4855 <W Mount> Oxford Street CQ-23071\n" +
    "<Donald Drinkaw> Moon Street, +3-098-512-2222, Peterville\n";
// + "<Anastasia> +48-421-674-8974 Via Quirinal Roma\n <P Salinger> Main Street, +1-098-512-2222, Denver\n";

// const num = "1-541-754-3010,1-541-914-3010,1-541-984-3012,1-321-512-2222,1-741-984-3090,"
// + "1-921-333-2222,1-111-544-8973,1-921-512-2222,1-121-544-8974,1-481-512-2222,"
// + "1-121-504-8974,1-681-512-2222,1-421-674-8974,1-908-512-2222,48-421-674-8974,1-098-512-2222,"
// + "19-421-674-8974,1-498-512-2222,1-099-500-8000,1-931-512-4855,5-555-555-5555,"
// + "5-541-754-3010,6-541-914-3010,5-541-984-3012,5-321-512-2222,3-741-984-3090,"
// + "3-921-333-2222,8-111-544-8973,8-921-512-2222,2-121-544-8974,2-481-512-2222,"
// + "7-121-504-8974,7-681-512-2222,9-421-674-8974,2-908-512-2222,8-421-674-8974,"
// + "15-098-512-2222,9-421-674-8974,3-498-512-2222,12-099-500-8000,8-931-512-4855,"
// + "3-098-512-2222";

// 1️⃣
const phone = (str: string, num: string): string => {
    const dataArr: string[] = str.split("\n");
    // console.log(dataArr);

    // FILTER OUT ENTRIES THAT INCLUDE INPUT PHONE NUMBER
    const entryMatches: string[] = dataArr.filter(
        (entry) => entry.indexOf(num) > -1
    );
    console.log("entry matches:", entryMatches);

    // if (entryMatches.length === 0) return "Error => Not found: " + num;
    if (entryMatches.length === 0) return `Error => Not found: ${num}`;
    // if (entryMatches.length > 1) return "Error => Too many people: " + num;
    if (entryMatches.length > 1) return `Error => Too many people: ${num}`;

    // LOOP NOT NEEDED AS WE ONLY HANDLE SINGLE ENTRY
    // entryMatches.forEach((match) => {
    //     const phoneNum: string[] = match.match(phoneFormat)!;
    //     console.log("number:", phoneNum[0]);
    // })

    // GET PHONE NUMBER
    // const phoneNum: string[] = entryMatches[0].match(phoneFormat)!;
    // MATCH "48-421-674-8974" / "1-421-674-8974" PHONE NUMBER FORMAT

    // THIS IS WITHOUT "+"
    const phoneFormat = new RegExp(/\d{1,2}-\d{3}-\d{3}-\d{4}/g);
    // ICLUDING LEADING "+"
    // const phoneFormat = new RegExp(/\+\d{1,2}-\d{3}-\d{3}-\d{4}/g);
    const phoneNum: string = entryMatches[0].match(phoneFormat)![0];
    console.log("   number:", phoneNum);

    // GET NAME (MATCH ALL CHARACTERS BETWEEN TWO STRINGS <MATCH>)

    // INCLUDING LEADING "<" AND TRAILING ">"
    // const nameFormat = new RegExp(/<.*?>/g);
    // NAME WITHOUT < >
    const nameFormat = new RegExp(/(?<=<).*?(?=>)/g);
    const name: string = entryMatches[0].match(nameFormat)![0];
    console.log("   name:", name);

    let address: string = entryMatches[0]
        // DELETE NAME
        .replace(/<.*?>/g, "")
        // DELETE PHONE NUMBER
        .replace(/\+\d{1,2}-\d{3}-\d{3}-\d{4}/g, "")
        .replace(/_/g, " ")
        .replace(/\//g, "")
        .replace(/[^a-zA-Z0-9 \- \.]/g, "")
        .replace(/\s{2,}/g, " ")
        .trim();

    console.log(`Phone => ${phoneNum}, Name => ${name}, Address => ${address}`);

    const solution: string = `Phone => ${phoneNum}, Name => ${name}, Address => ${address}`;

    return solution;
};

// 2️⃣
const phone2 = (str: string, num: string): string => {
    const dataArr: string[] = str.split("\n");
    const entryMatches: string[] = dataArr.filter(
        (entry) => entry.indexOf(num) > -1
    );

    if (entryMatches.length === 0) return `Error => Not found: ${num}`;
    if (entryMatches.length > 1) return `Error => Too many people: ${num}`;

    const phoneFormat = new RegExp(/\d{1,2}-\d{3}-\d{3}-\d{4}/g);
    const phoneNum: string = entryMatches[0].match(phoneFormat)![0];

    const nameFormat = new RegExp(/(?<=<).*?(?=>)/g);
    const name: string = entryMatches[0].match(nameFormat)![0];

    let address: string = entryMatches[0]
        .replace(nameFormat, "")
        .replace(phoneFormat, "")
        .replace(/_/g, " ")
        .replace(/\//g, "")
        .replace(/[^a-zA-Z0-9 \- \.]/g, "")
        .replace(/\s{2,}/g, " ")
        .trim();

    const solution: string = `Phone => ${phoneNum}, Name => ${name}, Address => ${address}`;

    return solution;
};
/*
expected 'Phone => 19-421-674-8974, Name => C Powel, Address => * Chateau des Fosses Strasbourg F-68000' to equal 'Phone => 19-421-674-8974, Name => C Powel, Address => Chateau des Fosses Strasbourg F-68000'
 
expected 'Phone => 1-098-512-2222, Name => Roland Scorsini, Address => PO Box 5300 Albertville SC-28573 ' to equal 'Phone => 1-098-512-2222, Name => Roland Scorsini, Address => PO Box 5300 Albertville SC-28573'
 
entry matches: [ '/+1-541-754-3010 156 Alphand_St. <J Steeve>' ]
   number: 1-541-754-3010
   name: J Steeve
   address: 156 Alphand St
Phone => 1-541-754-3010, Name => J Steeve, Address => 156 Alphand St
expected 'Phone => 1-541-754-3010, Name => J Steeve, Address => 156 Alphand St' to equal 'Phone => 1-541-754-3010, Name => J Steeve, Address => 156 Alphand St.'
 
 
entry matches: [ ' <Anastasia Via>  156 Alphandria Street.  +8-421-674-8974 ?' ]
   number: 8-421-674-8974
   name: Anastasia Via
   address: 156 Alphandria Street
Phone => 8-421-674-8974, Name => Anastasia Via, Address => 156 Alphandria Street
expected 'Phone => 8-421-674-8974, Name => Anastasia Via, Address => 156 Alphandria Street' to equal 'Phone => 8-421-674-8974, Name => Anastasia Via, Address => 156 Alphandria Street.'
// ============================================
console.log(phone(dr, "1-541-754-3010 156"));
 
entry matches: [ '/+1-541-754-3010 156 Alphand_St. <J Steeve>' ]
   number: 1-541-754-3010
   name: J Steeve
   address: / 156 Alphand_St.  18
   address: / 156 Alphand St.  18
   address:  156 Alphand St.  17
Phone => 1-541-754-3010, Name => J Steeve, Address =>  156 Alphand St. 
Phone => 1-541-754-3010, Name => J Steeve, Address =>  156 Alphand St. 
 
*/

// console.log(phone(dr, "1-541-754-3010 156"));

//============= OTHER CODEWARS SOLUTIONS: =============

// class G964phone {
//     public static phone = (strng: string, num: string): string => {
//       const phoneBook: string[] = strng.split('\n')

//       const searchResults = phoneBook.filter(el => el.indexOf(num) > -1)

//       if (!searchResults.length) return `Error => Not found: ${num}`
//       if (searchResults.length > 1) return `Error => Too many people: ${num}`

//       const currentContact = searchResults[0]

//       const name = /\<(.*?)\>/.exec(currentContact)[0].trim()

//       const address = currentContact
//         .replace(name, '')
//         .replace(num, '')
//         .replace(/[+*;/?$,:]/g, '')
//         .replace(/\s\s+/g, ' ')
//         .replace(/_/g, ' ')
//         .trim()

//       return `Phone => ${num}, Name => ${name.replace(/[+*\/-<>]/g, '')}, Address => ${address}`
//     }
//   }

// ===========================================================

const getName = (phoneData: string) => {
    return phoneData.match("<(.*?)>") ?? ["", ""];
};

const getPhoneNumber = (phoneData: string) => {
    return (
        phoneData.match(
            /(\+?( |-|\.)?\d{1,2}( |-|\.)?)?(\(?\d{3}\)?|\d{3})( |-|\.)?(\d{3}( |-|\.)?\d{4})/g
        )?.[0] ?? ""
    );
};

const cleanupAddress = (address: string) => {
    return [...address]
        .join("")
        .replace(/[`~!@#$%^&*()|+\=?;:'",<>\{\}\[\]\\\/]/g, "")
        .replace(/_/g, " ")
        .replace(/\s+/g, " ")
        .trim();
};

export const phone3 = (strng: string, num: string): string => {
    const matchingResults = strng.split(/\n/g).filter((a) => a.includes(num));

    if (matchingResults.length === 0) {
        return `Error => Not found: ${num}`;
    }

    if (matchingResults.length > 1) {
        return `Error => Too many people: ${num}`;
    }

    const phoneData = matchingResults[0];

    const [nameWithTags, name] = getName(phoneData);
    const phoneNumber = getPhoneNumber(phoneData);
    const address = [...phoneData]
        .join("")
        .replace(nameWithTags, "")
        .replace(phoneNumber, "")
        .trim();

    const cleanedUpAddress = cleanupAddress(address);

    return `Phone => ${num}, Name => ${name}, Address => ${cleanedUpAddress}`;
};

// ===========================================================

const phone4 = (strng: string, num: string): string => {
    const re = new RegExp(`(?:\\n|\/)((?:.(?!\\n))*\\\+${num}.*?)\\n`, "gmi");

    let s = strng.match(re);

    if (!s) {
        return `Error => Not found: ${num}`;
    }

    if (s.length > 1) {
        return `Error => Too many people: ${num}`;
    }

    let str = s[0].replace("\n", "").trim();

    const nameReg = str.match(/<(.*)>/gim);

    let name = nameReg ? nameReg[0] : "";

    str = str
        .replace(name, "")
        .replace(`+${num}`, "")
        .replace(/[*|;|\/|\?|\$|,|\:]/g, "")
        .replace(/\s\s+/g, " ")
        .replace("_", " ");

    name = name.replace(/[<|>]/g, "");

    return `Phone => ${num}, Name => ${name.trim()}, Address => ${str.trim()}`;
};

// ===========================================================

// function searchPhoneIndexInText(text: string, phoneNumber: string) {
//     const searchValue = `+${phoneNumber}`;

//     const firstIndex = text.indexOf(searchValue);
//     if (firstIndex === -1) {
//       throw new Error(`Error => Not found: ${phoneNumber}`);
//     }

//     const lastIndex = text.lastIndexOf(searchValue);
//     if (firstIndex !== lastIndex) {
//       throw new Error(`Error => Too many people: ${phoneNumber}`);
//     }

//     return firstIndex;
//   }

//   function extractLineFromPosition(text: string, position: number) {
//     const LF = "\n"; // Qu'est ce qu'on ferait pas pour éviter un magic number ...
//     const lineStart = text.slice(0, position).lastIndexOf(LF) + LF.length;
//     const lineEnd = text.indexOf(LF, lineStart + LF.length);
//     return text.slice(lineStart, lineEnd).trim();
//   }

//   function extractNameFromLine(line: string) {
//     const LEFT_DELIMITER = "<";
//     const RIGHT_DELIMITER = ">";
//     const start = line.indexOf(LEFT_DELIMITER) + LEFT_DELIMITER.length;
//     const end = line.lastIndexOf(RIGHT_DELIMITER);
//     return {
//       extractedValue: line.slice(start, end), // le nom sans les "< >"
//       rest: (
//         line.slice(0, start - LEFT_DELIMITER.length) +
//         line.slice(end + RIGHT_DELIMITER.length)
//       ).trim(), // "line" dont on a enlevé toute l'information concernant le nom du contact, y compris les "< >"
//     };
//   }

//   function extractPhoneFromLine(line: string, phoneNumber: string) {
//     const start = searchPhoneIndexInText(line, phoneNumber);
//     const end = start + phoneNumber.length + 1;
//     return {
//       extractedValue: phoneNumber,
//       rest: (line.slice(0, start) + line.slice(end)).trim(), // "line" dont on a enlevé toute l'information concernant le numéro de téléphone du contact
//     };
//   }

//   function sanitizeAddress(address: string) {
//     // On pourrait faire un truc plus smart, mais je considère qu'ici, on est juste en "best effort".
//     // disclaimer, le phonebook de John est en Anglais, alors on va pas inventer des problèmes, c'est juste un kata ...
//     return address
//       .replace(/[_]/g, " ")
//       .replace(/[^a-zA-Z0-9.\- ]/g, "") // remplacement de tous les caracteres autres que alphanum, espace, tiret et point par "rien"
//       .replace(/  +/g, ' ').trim()
//   }

//   export const phone5 = (
//     plaintext: string,
//     phoneNumber: string
//   ) => {
//     try {
//       const phoneNumberIndex = searchPhoneIndexInText(plaintext, phoneNumber);

//       const extractedLine = extractLineFromPosition(plaintext, phoneNumberIndex);

//       const name = extractNameFromLine(extractedLine);
//       const phone = extractPhoneFromLine(name.rest, phoneNumber);
//       const address = sanitizeAddress(phone.rest);

//       return `Phone => ${phone.extractedValue}, Name => ${name.extractedValue}, Address => ${address}`;
//     } catch (error) {
//       return error.message;
//     }
//   };

// ===========================================================

const phone6 = (strng: string, num: string): string => {
    const lines = strng.split("\n");
    const relevantLines = lines.filter((line) => line.includes(num));

    if (relevantLines.length === 0) {
        return `Error => Not found: ${num}`;
    }

    if (relevantLines.length > 1) {
        return `Error => Too many people: ${num}`;
    }

    const line = relevantLines[0];
    const name = line.match(/<([^>]+)>/)![1];
    const address = line
        .replace(num, "")
        .replace(name, "")
        .replace(/[^a-z0-9\.\s\-_]/gi, "")
        .replace(/[\s_]+/g, " ")
        .trim();

    return `Phone => ${num}, Name => ${name}, Address => ${address}`;
};

//🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: First Variation on Caesar Cipher
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The action of a Caesar cipher is to replace each plaintext letter (plaintext letters are from 'a' to 'z' or from 'A' to 'Z') with a different one a fixed number of places up or down the alphabet.
 
This program performs a variation of the Caesar shift. The shift increases by 1 for each character (on each iteration).
 
If the shift is initially 1, the first character of the message to be encoded will be shifted by 1, the second character will be shifted by 2, etc...
 
Coding: Parameters and return of function "movingShift"
param s: a string to be coded
 
param shift: an integer giving the initial shift
 
The function "movingShift" first codes the entire string and then returns an array of strings containing the coded string in 5 parts (five parts because, to avoid more risks, the coded message will be given to five runners, one piece for each runner).
 
If possible the message will be equally divided by message length between the five runners. If this is not possible, parts 1 to 5 will have subsequently non-increasing lengths, such that parts 1 to 4 are at least as long as when evenly divided, but at most 1 longer. If the last part is the empty string this empty string must be shown in the resulting array.
 
For example, if the coded message has a length of 17 the five parts will have lengths of 4, 4, 4, 4, 1. The parts 1, 2, 3, 4 are evenly split and the last part of length 1 is shorter. If the length is 16 the parts will be of lengths 4, 4, 4, 4, 0. Parts 1, 2, 3, 4 are evenly split and the fifth runner will stay at home since his part is the empty string. If the length is 11, equal parts would be of length 2.2, hence parts will be of lengths 3, 3, 3, 2, 0.
 
You will also implement a "demovingShift" function with two parameters
 
Decoding: parameters and return of function "demovingShift"
an array of strings: s (possibly resulting from "movingShift", with 5 strings)
 
an int shift
 
"demovingShift" returns a string.
 
Example:
u = "I should have known that you would have a perfect answer for me!!!"
 
movingShift(u, 1) returns :
 
v = ["J vltasl rlhr ", "zdfog odxr ypw", " atasl rlhr p ", "gwkzzyq zntyhv", " lvz wp!!!"]
 
(quotes added in order to see the strings and the spaces, your program won't write these quotes, see Example Test Cases)
 
and demovingShift(v, 1) returns u. #Ref:
 
Caesar Cipher : http://en.wikipedia.org/wiki/Caesar_cipher
 
 
*/
const movingShift = (s: string, shift: number) => {
    return [];
};

const demovingShift = (arr: string[], shift: number) => {
    return "";
};
/*
it("movingShift, demovingShift", function() {
        var u, sol, v;
        u = "I should have known that you would have a perfect answer for me!!!";
        sol = ["J vltasl rlhr ", "zdfog odxr ypw", " atasl rlhr p ", "gwkzzyq zntyhv", " lvz wp!!!"];
        dotest1(u, 1, sol);
        dotest2(sol, 1, u);
        dotest3(u, 1);
    });
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: Decimal to Factorial and Back
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Coding decimal numbers with factorials is a way of writing out numbers in a base system that depends on factorials, rather than powers of numbers.
 
In this system, the last digit is always 0 and is in base 0!. The digit before that is either 0 or 1 and is in base 1!. The digit before that is either 0, 1, or 2 and is in base 2!, etc. More generally, the nth-to-last digit is always 0, 1, 2, ..., n and is in base n!.
 
Read more about it at: http://en.wikipedia.org/wiki/Factorial_number_system
 
Example
The decimal number 463 is encoded as "341010", because:
 
463 = 3×5! + 4×4! + 1×3! + 0×2! + 1×1! + 0×0!
 
If we are limited to digits 0..9, the biggest number we can encode is 10!-1 (= 3628799). So we extend 0..9 with letters A..Z. With these 36 digits we can now encode numbers up to 36!-1 (= 3.72 × 1041)
 
Task
We will need two functions. The first one will receive a decimal number and return a string with the factorial representation.
 
The second one will receive a string with a factorial representation and produce the decimal representation.
 
Given numbers will always be positive.
*/
class G9640 {
    public static dec2FactString = (nb: number): string => {
        return "hello";
    };
    public static factString2Dec = (str: string): number => {
        return 1;
    };
}
/*
it("Basic tests dec2FactString", function() {
        testing1(2982, "4041000");
    });
    it("Basic tests factString2Dec", function() {
        testing2("341010", 463);
    });
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: Diophantine Equation
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
In mathematics, a Diophantine equation is a polynomial equation, usually with two or more unknowns, such that only the integer solutions are sought or studied.
 
In this kata we want to find all integers x, y (x >= 0, y >= 0) solutions of a diophantine equation of the form:
 
x2 - 4 * y2 = n
(where the unknowns are x and y, and n is a given positive number) in decreasing order of the positive xi.
 
If there is no solution return [] or "[]" or "". (See "RUN SAMPLE TESTS" for examples of returns).
 
Examples:
solEquaStr(90005) --> "[[45003, 22501], [9003, 4499], [981, 467], [309, 37]]"
solEquaStr(90002) --> "[]"
Hint:
x2 - 4 * y2 = (x - 2*y) * (x + 2*y)
 
 
*/
function solequa(n: number): [number, number][] {
    return [[1, 1]];
}
/*
 assert.deepEqual(solequa(5), [[3, 1]]);
    assert.deepEqual(solequa(12), [[4, 1]]);
    assert.deepEqual(solequa(13), [[7, 3]]);
    assert.deepEqual(solequa(16), [[4, 0]]);
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: Find the smallest
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
You have a positive number n consisting of digits. You can do at most one operation: Choosing the index of a digit in the number, remove this digit at that index and insert it back to another or at the same place in the number in order to find the smallest number you can get.
 
Task:
Return an array or a tuple or a string depending on the language (see "Sample Tests") with
 
the smallest number you got
the index i of the digit d you took, i as small as possible
the index j (as small as possible) where you insert this digit d to have the smallest number.
Examples:
smallest(261235) --> [126235, 2, 0] or (126235, 2, 0) or "126235, 2, 0"
126235 is the smallest number gotten by taking 1 at index 2 and putting it at index 0
 
smallest(209917) --> [29917, 0, 1] or ...
 
[29917, 1, 0] could be a solution too but index `i` in [29917, 1, 0] is greater than 
index `i` in [29917, 0, 1].
29917 is the smallest number gotten by taking 2 at index 0 and putting it at index 1 which gave 029917 which is the number 29917.
 
smallest(1000000) --> [1, 0, 6] or ...
Note
Have a look at "Sample Tests" to see the input and output in each language
*/
function smallest(n: number): number[] {
    return [1];
}
/*
assert.deepEqual(smallest(261235), [126235, 2, 0]);
    assert.deepEqual(smallest(209917), [29917, 0, 1]);
    assert.deepEqual(smallest(285365), [238565, 3, 1]);
    assert.deepEqual(smallest(269045), [26945, 3, 0]);
    assert.deepEqual(smallest(296837), [239687, 4, 1]);
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: Going to zero or to infinity?
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Consider the following numbers (where n! is factorial(n)):
 
u1 = (1 / 1!) * (1!)
u2 = (1 / 2!) * (1! + 2!)
u3 = (1 / 3!) * (1! + 2! + 3!)
...
un = (1 / n!) * (1! + 2! + 3! + ... + n!)
Which will win: 1 / n! or (1! + 2! + 3! + ... + n!)?
 
Are these numbers going to 0 because of 1/n! or to infinity due to the sum of factorials or to another number?
 
Task
Calculate (1 / n!) * (1! + 2! + 3! + ... + n!) for a given n, where n is an integer greater or equal to 1.
 
To avoid discussions about rounding, return the result truncated to 6 decimal places, for example:
 
1.0000989217538616 will be truncated to 1.000098
1.2125000000000001 will be truncated to 1.2125
Remark
Keep in mind that factorials grow rather rapidly, and you need to handle large inputs.
 
Hint
You could try to simplify the expression.
*/
function going(n: number): number {
    // your code
    return -1;
}
/*
testing(5, 1.275);
        testing(6, 1.2125);
        testing(7, 1.173214);
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: Find the unique string
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
There is an array of strings. All strings contains similar letters except one. Try to find it!
 
findUniq([ 'Aa', 'aaa', 'aaaaa', 'BbBb', 'Aaaa', 'AaAaAa', 'a' ]) === 'BbBb'
findUniq([ 'abc', 'acb', 'bac', 'foo', 'bca', 'cab', 'cba' ]) === 'foo'
Strings may contain spaces. Spaces are not significant, only non-spaces symbols matters. E.g. string that contains only spaces is like empty string.
 
It’s guaranteed that array contains more than 2 strings.
 
This is the second kata in series:
*/
const findUniq = (arr: string[]): string => {
    let match: string = "";

    let reducedStrArr: string[] = [];

    for (let i = 0; i < arr.length; i += 1) {
        // DELETE SPACES, SORT APLHABETICALLY , !!! TOLOWERCASE HAS TO BE BEFORE SORT AS "M" WILL COME BEFORE "a" !!!
        const current: string = arr[i]
            .replace(/\s/g, "")
            .toLowerCase()
            .split("")
            .sort()
            .join("");

        // console.log("original:", current);

        // FILTER OUT DUPLICATES WITH SET
        const set = new Set(current);
        // console.log("   set:", set);

        // CONVERT SET TO STRING
        const reduced: string = Array.from(current).join("");

        // reduced SIMPLIFIED:
        // const reduced: string = Array.from(new Set(current)).join("");
        // console.log("       reduced:", reduced);

        reducedStrArr.push(reduced);
    }

    // console.log(reducedStrArr);

    // COMPARE EACH STRING TO ITS NEIGHBOUR
    for (let i = 0; i < reducedStrArr.length; i += 1) {
        let current: string = reducedStrArr[i];
        if (i === 0) {
            if (
                current !== reducedStrArr[i + 1] &&
                current !== reducedStrArr[i + 2]
            ) {
                match = current;
                break;
            }
        }
        if (i > 0 && i < reducedStrArr.length - 1) {
            if (
                current !== reducedStrArr[i - 1] &&
                current !== reducedStrArr[i + 1]
            ) {
                match = current;
                break;
            }
        }
        if (i === reducedStrArr.length - 1) {
            if (
                current !== reducedStrArr[i - 1] &&
                current !== reducedStrArr[i - 2]
            ) {
                match = current;
                break;
            }
        }
    }

    const matchIndex: number = reducedStrArr.indexOf(match);
    const solution: string = arr[matchIndex];

    return solution;
};
/*
console.log(findUniq(['Tom Marvolo Riddle', 'I am Lord Voldemort', 'Harry Potter']));
 
 
original: addeillmmooorrtv
   set: Set(10) { 'a', 'd', 'e', 'i', 'l', 'm', 'o', 'r', 't', 'v' }
       reduced: adeilmortv
original: addeillmmooorrtv
   set: Set(10) { 'a', 'd', 'e', 'i', 'l', 'm', 'o', 'r', 't', 'v' }
       reduced: adeilmortv
original: aehoprrrtty
   set: Set(8) { 'a', 'e', 'h', 'o', 'p', 'r', 't', 'y' }
       reduced: aehoprty
[ 'adeilmortv', 'adeilmortv', 'aehoprty' ]
Harry Potter
*/

// console.log(findUniq(['abc', 'acb', 'bac', 'foo', 'bca', 'cab', 'cba']));
// console.log(findUniq(['Aca', 'aaac', 'aaac   aaa', 'BbcBb', 'Acaaa', 'AaAaAac', 'ac']));
// console.log(findUniq(['Tom Marvolo Riddle', 'I am Lord Voldemort', 'Harry Potter']));
// console.log(findUniq(['abc', 'acb', 'bac', 'foo', 'bca', 'cab', 'cba']));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function findUniq2(arr: string[]): string {
    const regx = new RegExp(`[${arr[0]}]`, "ig");
    const resultArray: string[] = arr.map((value: string): string =>
        value.replace(regx, "")
    );
    let trueCheck: boolean = false;

    if (resultArray[1] === "" || resultArray[2] === "") trueCheck = true;

    if (trueCheck) {
        for (let i: number = 1; i < resultArray.length; i++) {
            if (resultArray[i] !== "") return arr[i];
        }
        return "Log"; // it is error it tests!
    } else {
        return arr[0];
    }
}

function findUniq3(arr: string[]): string {
    let newArr = arr.map((a) => [...new Set(a.toLowerCase())].sort().join(""));
    return arr.find(
        (str, i) => newArr.indexOf(newArr[i]) === newArr.lastIndexOf(newArr[i])
    )!;
}

function findUniq4(arr: string[]): string {
    const isEqual = (a: string, b: string) => {
        const aSet = new Set(a.toLowerCase());
        const bSet = new Set(b.toLowerCase());
        if (aSet.size !== bSet.size) return false;
        return [...aSet].every((letter: string) => bSet.has(letter));
    };
    const etalon = isEqual(arr[0], arr[1]) ? arr[0] : arr[2];
    return arr.filter((str) => !isEqual(str, etalon))[0];
}

export const findUniq5 = (arr: string[]) =>
    arr
        .sort()
        .filter((x, _, array) =>
            x.match(new RegExp(`[^${array[1]}]`, `ig`))
        )[0] || `Log`;

function findUniq6(arr: string[]): string {
    function hash(value: string) {
        return Array.from(new Set(value.split("").map((c) => c.toLowerCase())))
            .sort()
            .filter((c) => c !== " ")
            .join("");
    }
    const x = hash(arr[hash(arr[0]) === hash(arr[1]) ? 0 : 2]);
    return arr.find((v) => hash(v) !== x) ?? "";
}

function findUniq7(arr: Array<string>): string {
    const cleaned = arr.map((s) =>
        [...new Set(s.replace(/\s/g, "").toLowerCase().split(""))]
            .sort()
            .join("")
    );
    const notUnique = cleaned[cleaned[0] === cleaned[1] ? 0 : 2];
    const uniqueIndex = cleaned.findIndex((s) => s !== notUnique);
    return arr[uniqueIndex];
}
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: Vector class
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Create a Vector object that supports addition, subtraction, dot products, and norms. So, for example:
 
a = new Vector([1, 2, 3])
b = new Vector([3, 4, 5])
c = new Vector([5, 6, 7, 8])
 
a.add(b)      # should return a new Vector([4, 6, 8])
a.subtract(b) # should return a new Vector([-2, -2, -2])
a.dot(b)      # should return 1*3 + 2*4 + 3*5 = 26
a.norm()      # should return sqrt(1^2 + 2^2 + 3^2) = sqrt(14)
a.add(c)      # throws an error
If you try to add, subtract, or dot two vectors with different lengths, you must throw an error!
 
Also provide:
 
a toString method, so that using the vectors from above, a.toString() === '(1,2,3)' (in Python, this is a __str__ method, so that str(a) == '(1,2,3)')
an equals method, to check that two vectors that have the same components are equal
Note: the test cases will utilize the user-provided equals method.
 
 
*/
class Vector {
    constructor(components: number[]) {
        // Start here...
    }
}

/*
describe("Tests", () => {
it("Simple Equality Test", () => {
  let a = new Vector([1,2]);
  let b = new Vector([3,4]);
  assert.isFalse(a.equals(b));
});
 
it("Simple Add Test", function() {
  let a = new Vector([1, 2, 3]);
  let b = new Vector([3, 4, 5]);
  assert.isTrue(a.add(b).equals(new Vector([4,6, 8])));
})
 
it("Simple Norm Test", function () {
  assert.approximately(new Vector([1,2,3]).norm(), Math.sqrt(14),  0.1);
});
 
it("Simple Subtract Test", function() {
  let a = new Vector([1, 2, 3]);
  let b = new Vector([3, 4, 5]);
  assert.isTrue(a.subtract(b).equals(new Vector([-2,-2,-2])));
});
 
it("Simple Dot Test", function() {
  let a = new Vector([1, 2, 3]);
  let b = new Vector([3, 4, 5]);
  assert.strictEqual(a.dot(b), 26);
})
 
it("Simple ToString Test", function() {
  let a = new Vector([1, 2, 3]);
  assert.strictEqual(a.toString(), "(1,2,3)");
})
});
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: Esolang Interpreters #2 - Custom Smallfuck Interpreter
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Esolang Interpreters #2 - Custom Smallfuck Interpreter
About this Kata Series
"Esolang Interpreters" is a Kata Series that originally began as three separate, independent esolang interpreter Kata authored by @donaldsebleung which all shared a similar format and were all somewhat inter-related. Under the influence of a fellow Codewarrior, these three high-level inter-related Kata gradually evolved into what is known today as the "Esolang Interpreters" series.
 
This series is a high-level Kata Series designed to challenge the minds of bright and daring programmers by implementing interpreters for various esoteric programming languages/Esolangs, mainly Brainfuck derivatives but not limited to them, given a certain specification for a certain Esolang. Perhaps the only exception to this rule is the very first Kata in this Series which is intended as an introduction/taster to the world of esoteric programming languages and writing interpreters for them.
 
The Language
Smallfuck is an esoteric programming language/Esolang invented in 2002 which is a sized-down variant of the famous Brainfuck Esolang. Key differences include:
 
Smallfuck operates only on bits as opposed to bytes
It has a limited data storage which varies from implementation to implementation depending on the size of the tape
It does not define input or output - the "input" is encoded in the initial state of the data storage (tape) and the "output" should be decoded in the final state of the data storage (tape)
Here are a list of commands in Smallfuck:
 
> - Move pointer to the right (by 1 cell)
< - Move pointer to the left (by 1 cell)
* - Flip the bit at the current cell
[ - Jump past matching ] if value at current cell is 0
] - Jump back to matching [ (if value at current cell is nonzero)
As opposed to Brainfuck where a program terminates only when all of the commands in the program have been considered (left to right), Smallfuck terminates when any of the two conditions mentioned below become true:
 
All commands have been considered from left to right
The pointer goes out-of-bounds (i.e. if it moves to the left of the first cell or to the right of the last cell of the tape)
Smallfuck is considered to be Turing-complete if and only if it had a tape of infinite length; however, since the length of the tape is always defined as finite (as the interpreter cannot return a tape of infinite length), its computational class is of bounded-storage machines with bounded input.
 
More information on this Esolang can be found here.
 
The Task
Implement a custom Smallfuck interpreter interpreter() (interpreter in Haskell and F#, Interpreter in C#, custom_small_fuck:interpreter/2 in Erlang) which accepts the following arguments:
 
code - Required. The Smallfuck program to be executed, passed in as a string. May contain non-command characters. Your interpreter should simply ignore any non-command characters.
tape - Required. The initial state of the data storage (tape), passed in as a string. For example, if the string "00101100" is passed in then it should translate to something of this form within your interpreter: [0, 0, 1, 0, 1, 1, 0, 0]. You may assume that all input strings for tape will be non-empty and will only contain "0"s and "1"s.
Your interpreter should return the final state of the data storage (tape) as a string in the same format that it was passed in. For example, if the tape in your interpreter ends up being [1, 1, 1, 1, 1] then return the string "11111".
 
NOTE: The pointer of the interpreter always starts from the first (leftmost) cell of the tape, same as in Brainfuck.
 
Good luck :D
*/
function interpreter(code: string, tape: string): string {
    return "hello";
}

/*
// Flips the leftmost cell of the tape
    assert.equal(interpreter("*", "00101100"), "10101100");
    // Flips the second and third cell of the tape
    assert.equal(interpreter(">*>*", "00101100"), "01001100");
    // Flips all the bits in the tape
    assert.equal(interpreter("*>*>*>*>*>*>*>*", "00101100"), "11010011");
    // Flips all the bits that are initialized to 0
    assert.equal(interpreter("*>*>>*>>>*>*", "00101100"), "11111111");
    // Goes somewhere to the right of the tape and then flips all bits that are initialized to 1, progressing leftwards through the tape
    assert.equal(interpreter(">>>>>*<*<<*", "00101100"), "00000000");
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: FACTORIAL DECOMPOSITION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The aim of the kata is to decompose n! (factorial n) into its prime factors.
 
Examples:
 
n = 12; decomp(12) -> "2^10 * 3^5 * 5^2 * 7 * 11"
since 12! is divisible by 2 ten times, by 3 five times, by 5 two times and by 7 and 11 only once.
 
n = 22; decomp(22) -> "2^19 * 3^9 * 5^4 * 7^3 * 11^2 * 13 * 17 * 19"
 
n = 25; decomp(25) -> 2^22 * 3^10 * 5^6 * 7^3 * 11^2 * 13 * 17 * 19 * 23
Prime numbers should be in increasing order. When the exponent of a prime is 1 don't put the exponent.
 
Notes
 
the function is decomp(n) and should return the decomposition of n! into its prime factors in increasing order of the primes, as a string.
factorial can be a very big number (4000! has 12674 digits, n can go from 300 to 4000).
In Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use dynamically allocated character strings.
 
*/
function decomp(n: number): string {
    return "your code";
}

/*
 assert.equal(decomp(17), "2^15 * 3^6 * 5^3 * 7^2 * 11 * 13 * 17")
        assert.equal(decomp(5), "2^3 * 3 * 5")
        assert.equal(decomp(22), "2^19 * 3^9 * 5^4 * 7^3 * 11^2 * 13 * 17 * 19")
        assert.equal(decomp(14), "2^11 * 3^5 * 5^2 * 7^2 * 11 * 13")
        assert.equal(decomp(25), "2^22 * 3^10 * 5^6 * 7^3 * 11^2 * 13 * 17 * 19 * 23")
        */

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ REFACTOR WITH WHILE OR DETERMINE MAX NUMBER OF ITERATIONS ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: BEERAMID
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Let's pretend your company just hired your friend from college and paid you a referral bonus. Awesome! To celebrate, you're taking your team out to the terrible dive bar next door and using the referral bonus to buy, and build, the largest three-dimensional beer can pyramid you can. And then probably drink those beers, because let's pretend it's Friday too.
 
A beer can pyramid will square the number of cans in each level - 1 can in the top level, 4 in the second, 9 in the next, 16, 25...
 
Complete the beeramid function to return the number of complete levels of a beer can pyramid you can make, given the parameters of:
 
your referral bonus, and
 
the price of a beer can
 
For example:
 
beeramid(1500, 2); // should === 12
beeramid(5000, 3); // should === 16
 
*/
const beeramid = (bonus: number, price: number): number => {
    let totalDrinks: number = Math.trunc(bonus / price);
    // console.log("initial total drinks:", totalDrinks);

    let levelCounter: number = 0;

    // HARD CODED MAX ITERATION:
    // for (let i = 1; i < 100; i += 1) {

    // CALC MAX NUMBER OF ITERATIONS (MATH ABS WILL MAKE NEGATIVE BONUS WORK)
    for (let i = 1; i <= Math.abs(bonus / price); i += 1) {
        // console.log("LEVEL:", i);
        // console.log("   drinks left:", totalDrinks);

        let currSquare: number = Math.pow(i, 2);
        // console.log("   current square:", currSquare);
        if (totalDrinks < currSquare) break;
        levelCounter += 1;
        totalDrinks -= currSquare;
        // console.log("       drinks left:", totalDrinks);
    }

    return levelCounter;
};

/*
console.log(beeramid(29, 1));
 
max iterations: 29
initial total drinks: 29
LEVEL: 1
   drinks left: 29
   current square: 1
       drinks left: 28
LEVEL: 2
   drinks left: 28
   current square: 4
       drinks left: 24
LEVEL: 3
   drinks left: 24
   current square: 9
       drinks left: 15
LEVEL: 4
   drinks left: 15
   current square: 16
3
*/
// console.log(beeramid(21, 1.5));
// console.log(beeramid(22.5, 1.5));

// 5
// console.log(beeramid(454, 5));
// console.log(beeramid(29, 1));
// 6
// console.log(beeramid(455, 5));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

function beeramid2(bonus: number, price: number): number {
    let level: number = 0;
    let n: number = 1;
    let i: number = 1;
    while (n <= Math.floor(bonus / price)) {
        i++;
        n += i ** 2;
        level++;
    }
    return level;
}

function beeramid3(bonus: number, price: number): number {
    let pyramidLevel = 1;
    let remainingBonus = bonus;
    let nextLevelCost = pyramidLevel * pyramidLevel * price;
    while (remainingBonus >= nextLevelCost) {
        remainingBonus -= nextLevelCost;
        pyramidLevel++;
        nextLevelCost = pyramidLevel * pyramidLevel * price;
    }

    return pyramidLevel - 1;
}

// function beeramid4(bonus: number, price: number, level: number = 1): number {
//     const cost = level * level * price;
//     if (bonus < cost) return level - 1;
//     return beeramid(bonus - cost, price, ++level);
// }

//   function beeramid5(bonus: number, price: number, level: number = 1): number {
//     const costOfCurrentBeers = (level ** 2) * price;
//     const remainingMoney = bonus - costOfCurrentBeers;

//     if (remainingMoney < 0) return level - 1;

//     return beeramid(remainingMoney, price, level + 1)
//   }

function beeramid6(bonus: number, price: number): number {
    let maxCan: number = Math.floor(bonus / price);
    let result = 0;

    while (Math.pow(result + 1, 2) <= maxCan) {
        result++;
        maxCan -= Math.pow(result, 2);
    }

    return result;
}

function beeramid7(bonus: number, price: number): number {
    let i: number = 1;

    while (true) {
        const total: number = ((i * (i + 1) * (2 * i + 1)) / 6) * price;

        if (total > bonus) {
            return i - 1;
        }

        i++;
    }
}

function beeramid8(bonus: number, price: number): number {
    const beer = Math.floor(bonus / price);
    let num = 0;
    let lvl = 0;

    while (num < beer) {
        num += lvl ** 2;

        if (num == beer) break;
        if (num > beer) {
            lvl--;
            break;
        }
        lvl++;
    }
    return lvl;
}
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: SNAKES AND LADDERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
ntroduction
Snakes and Ladders is an ancient Indian board game regarded today as a worldwide classic. It is played between two or more players on a gameboard having numbered, gridded squares. A number of "ladders" and "snakes" are pictured on the board, each connecting two specific board squares. (Source Wikipedia)
 
Task
Your task is to make a simple class called SnakesLadders. The test cases will call the method play(die1, die2) independantly of the state of the game or the player turn. The variables die1 and die2 are the die thrown in a turn and are both integers between 1 and 6. The player will move the sum of die1 and die2.
The Board
 
Rules
1.  There are two players and both start off the board on square 0.
 
2.  Player 1 starts and alternates with player 2.
 
3.  You follow the numbers up the board in order 1=>100
 
4.  If the value of both die are the same then that player will have another go.
 
5.  Climb up ladders. The ladders on the game board allow you to move upwards and get ahead faster. If you land exactly on a square that shows an image of the bottom of a ladder, then you may move the player all the way up to the square at the top of the ladder. (even if you roll a double).
 
6.  Slide down snakes. Snakes move you back on the board because you have to slide down them. If you land exactly at the top of a snake, slide move the player all the way to the square at the bottom of the snake or chute. (even if you roll a double).
 
7.  Land exactly on the last square to win. The first person to reach the highest square on the board wins. But there's a twist! If you roll too high, your player "bounces" off the last square and moves back. You can only win by rolling the exact number needed to land on the last square. For example, if you are on square 98 and roll a five, move your game piece to 100 (two moves), then "bounce" back to 99, 98, 97 (three, four then five moves.)
 
8.  If the Player rolled a double and lands on the finish square “100” without any remaining moves then the Player wins the game and does not have to roll again.
Returns
Return Player n Wins!. Where n is winning player that has landed on square 100 without any remainding moves left.
 
Return Game over! if a player has won and another player tries to play.
 
Otherwise return Player n is on square x. Where n is the current player and x is the sqaure they are currently on.
Good luck and enjoy!
*/
class SnakesLadders {
    constructor() {
        // Good luck
    }

    play(die1: number, die2: number): string {
        return "HELLO";
    }
}

/*
assert.equal(game.play(1, 1), "Player 1 is on square 38", "Should return: 'Player 1 is on square 38'");
    assert.equal(game.play(1, 5), "Player 1 is on square 44", "Should return: 'Player 1 is on square 44'");
    assert.equal(game.play(6, 2), "Player 2 is on square 31", "Should return: 'Player 2 is on square 31'");
    assert.equal(game.play(1, 1), "Player 1 is on square 25", "Should return: 'Player 1 is on square 25'");
    */

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: MOLECULE TO ATOMS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
For a given chemical formula represented by a string, count the number of atoms of each element contained in the molecule and return an object (associative array in PHP, Dictionary<string, int> in C#, Map<String,Integer> in Java).
 
For example:
 
var water = 'H2O';
parseMolecule(water); // return {H: 2, O: 1}
 
var magnesiumHydroxide = 'Mg(OH)2';
parseMolecule(magnesiumHydroxide); // return {Mg: 1, O: 2, H: 2}
 
var fremySalt = 'K4[ON(SO3)2]2';
parseMolecule(fremySalt); // return {K: 4, O: 14, N: 2, S: 4}
As you can see, some formulas have brackets in them. The index outside the brackets tells you that you have to multiply count of each atom inside the bracket on this index. For example, in Fe(NO3)2 you have one iron atom, two nitrogen atoms and six oxygen atoms.
 
Note that brackets may be round, square or curly and can also be nested. Index after the braces is optional.
 
 
*/

const parseMolecule = (formula: string) => {
    // MATCH STANDALONE ELELMENT ( ONE UPPERCASE FOLLOWED BY OPTIONAL LOWERCASE)
    const elementMatch = /[A-Z]{1}[a-z]?/g;

    console.log(formula.match(elementMatch));
};

// {H: 2, O: 1}
// console.log(parseMolecule("H2O"));
// {Mg: 1, O: 2, H: 2}
// console.log(parseMolecule("Mg(OH)2"));
// {K: 4, O: 14, N: 2, S: 4}
// console.log(parseMolecule("K4[ON(SO3)2]2"));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

//  ❗️❗️❗️ REFACTOR, SLOW ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// ❗️❗️❗️ Timed Out Passed: 9 Failed: 1+ ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: JOSEPHUS SURVIVOR
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
In this kata you have to correctly return who is the "survivor", ie: the last element of a Josephus permutation.
 
Basically you have to assume that n people are put into a circle and that they are eliminated in steps of k elements, like this:
 
josephus_survivor(7,3) => means 7 people in a circle;
one every 3 is eliminated until one remains
[1,2,3,4,5,6,7] - initial sequence
[1,2,4,5,6,7] => 3 is counted out
[1,2,4,5,7] => 6 is counted out
[1,4,5,7] => 2 is counted out
[1,4,5] => 7 is counted out
[1,4] => 5 is counted out
[4] => 1 counted out, 4 is the last element - the survivor!
The above link about the "base" kata description will give you a more thorough insight about the origin of this kind of permutation, but basically that's all that there is to know to solve this kata.
 
Notes and tips: using the solution to the other kata to check your function may be helpful, but as much larger numbers will be used, using an array/list to compute the number of the survivor may be too slow; you may assume that both n and k will always be >=1.
*/

const josephusSurvivor = (num: number, gap: number): number => {
    // if (num === 1) return num;

    let items: number[] = [];
    for (let i = 1; i <= num; i += 1) {
        items.push(i);
    }
    console.log(items);

    // let targetIdx: number = gap > seqArr.length
    //     ? gap % seqArr.length - 1
    //     : gap - 1;

    // console.log("targetIdx:", targetIdx);

    // INITIALIZE SEQ ARR WITH COPY OF ITEMS
    let solutionArr: number[] = [],
        seqArr: number[] = [...items];
    // CONUNT VALID STEPS (IGNORE DEAD)
    let validSteps: number = 0;

    // LOOP THROUGH SEQ ARR
    for (let i = 0; i < seqArr.length; i += 1) {
        // INCREMENT VALID STEPS IF ELEMENT IS ALIVE
        if (!solutionArr.includes(seqArr[i])) validSteps += 1;
        // IF VALD STEPS === GAP (EVERY NTH), PUSH CURRENT AND RESET VALIDSTEPS
        if (validSteps === gap) {
            solutionArr.push(seqArr[i]);
            validSteps = 0;
        }
        // STOP LOOP IF EVERY ELEMENT HAS BEEN SELECTED
        if (solutionArr.length === items.length) break;
        // IF LOOP REACHES LENGTH OF ITEMS, CONCAT ANOTHER COPY TO EXTEND SEQUENCE
        if (i === seqArr.length - 1) seqArr = seqArr.concat(items);
    }

    return solutionArr[solutionArr.length - 1];

    // return 1;
};

//  4
// console.log(josephusSurvivor(7, 3));
// 10
// ❗️❗️❗️
// console.log(josephusSurvivor(11, 19));
// console.log(josephusSurvivor(7, 8));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ REFACTOR: DELETE CURRENT ITEM TO ELEMINATE SEQ ARR ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: FOSEPHUS PERMUTATION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
This problem takes its name by arguably the most important event in the life of the ancient historian Josephus: according to his tale, he and his 40 soldiers were trapped in a cave by the Romans during a siege.
 
Refusing to surrender to the enemy, they instead opted for mass suicide, with a twist: they formed a circle and proceeded to kill one man every three, until one last man was left (and that it was supposed to kill himself to end the act).
 
Well, Josephus and another man were the last two and, as we now know every detail of the story, you may have correctly guessed that they didn't exactly follow through the original idea.
 
You are now to create a function that returns a Josephus permutation, taking as parameters the initial array/list of items to be permuted as if they were in a circle and counted out every k places until none remained.
 
Tips and notes: it helps to start counting from 1 up to n, instead of the usual range 0..n-1; k will always be >=1.
 
For example, with n=7 and k=3 josephus(7,3) should act this way.
 
[1,2,3,4,5,6,7] - initial sequence
[1,2,4,5,6,7] => 3 is counted out and goes into the result [3]
[1,2,4,5,7] => 6 is counted out and goes into the result [3,6]
[1,4,5,7] => 2 is counted out and goes into the result [3,6,2]
[1,4,5] => 7 is counted out and goes into the result [3,6,2,7]
[1,4] => 5 is counted out and goes into the result [3,6,2,7,5]
[4] => 1 is counted out and goes into the result [3,6,2,7,5,1]
[] => 4 is counted out and goes into the result [3,6,2,7,5,1,4]
So our final result is:
 
josephus([1,2,3,4,5,6,7],3)==[3,6,2,7,5,1,4]
*/

// 2️⃣ SECOND SOLUTION, DYNAMIC SEQ ARR LENGTH !!!
const josephus2 = (items: any[], gap: number): any[] => {
    if (items.length === 1) return items;
    // INITIALIZE SEQ ARR WITH COPY OF ITEMS
    let solutionArr: any[] = [],
        seqArr: any[] = [...items];
    // CONUNT VALID STEPS (IGNORE DEAD)
    let validSteps: number = 0;

    // LOOP THROUGH SEQ ARR
    for (let i = 0; i < seqArr.length; i += 1) {
        // INCREMENT VALID STEPS IF ELEMENT IS ALIVE
        if (!solutionArr.includes(seqArr[i])) validSteps += 1;
        // IF VALD STEPS === GAP (EVERY NTH), PUSH CURRENT AND RESET VALIDSTEPS
        if (validSteps === gap) {
            solutionArr.push(seqArr[i]);
            validSteps = 0;
        }
        // STOP LOOP IF EVERY ELEMENT HAS BEEN SELECTED
        if (solutionArr.length === items.length) break;
        // IF LOOP REACHES LENGTH OF ITEMS, CONCAT ANOTHER COPY TO EXTEND SEQUENCE
        if (i === seqArr.length - 1) seqArr = seqArr.concat(items);
    }

    return solutionArr;
};

//   [3, 6, 2, 7, 5, 1, 4]
// console.log(josephus2([1, 2, 3, 4, 5, 6, 7], 3));
// console.log(josephus2([1, 2, 3, 4, 5, 6, 7], 10));
// console.log(josephus2([4, 5, 7, 1], 3));
// [1,2,3,4,5,6,7,8,9,10]
// console.log(josephus2([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1));
// [2, 4, 6, 8, 10, 3, 7, 1, 9, 5]
// console.log(josephus2([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2));
// ['e', 's', 'W', 'o', 'C', 'd', 'r', 'a']
// console.log(josephus2(["C", "o", "d", "e", "W", "a", "r", "s"], 4));
// []
// console.log(josephus2([], 3));
// [ 5, 1, 3, 4, 2 ]
// console.log(josephus2([1, 2, 3, 4, 5], 5));

// 1️⃣  FIRST SOLUTION, UNUSED CODE, HARD CODED SEQ ARR LENGTH !!!
const josephus3 = (items: any[], gap: number): any[] => {
    if (items.length === 1) return items;
    // NUMBER OF VALID STEPS TO NEXT ITEM
    // const validGap: number = gap <= items.length
    //     ? gap
    //     : gap % items.length;
    // console.log(validGap);

    let solutionArr: any[] = [],
        sequenceArr: any[] = [];

    for (let i = 0; i < items.length * 40; i += 1) {
        sequenceArr = sequenceArr.concat(items);
    }

    let validSteps: number = 0;

    for (let i = 0; i < sequenceArr.length; i += 1) {
        // console.log("CYCLE COUNT: ", i)
        // for (let i = 0; i < 49; i += 1) {
        if (!solutionArr.includes(sequenceArr[i])) {
            validSteps += 1;
        }
        if (validSteps === gap) {
            solutionArr.push(sequenceArr[i]);
            validSteps = 0;
        }
        if (solutionArr.length === items.length) break;
    }
    return solutionArr;
};

//   [3, 6, 2, 7, 5, 1, 4]
// console.log(josephus3([1, 2, 3, 4, 5, 6, 7], 3));
// console.log(josephus3([1, 2, 3, 4, 5, 6, 7], 10));
// console.log(josephus3([4, 5, 7, 1], 3));
// [1,2,3,4,5,6,7,8,9,10]
// console.log(josephus3([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1));
// [2, 4, 6, 8, 10, 3, 7, 1, 9, 5]
// console.log(josephus3([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2));
// ['e', 's', 'W', 'o', 'C', 'd', 'r', 'a']
// console.log(josephus3(["C", "o", "d", "e", "W", "a", "r", "s"], 4));
// []
// console.log(josephus3([], 3));
// [ 5, 1, 3, 4, 2 ]
// console.log(josephus3([1, 2, 3, 4, 5], 5));

//============= OTHER CODEWARS SOLUTIONS: =============

const josephus4 = (items: any[], k: number): any[] => {
    let lst: any[] = [];
    let i: number = (k - 1) % items.length;
    while (items.length) {
        lst.push(items[i]);
        items.splice(i, 1);
        i = (i + k - 1) % items.length;
    }
    return lst;
};

const josephus5 = (items: any[], k: number): any[] => {
    const alive = [...items];
    const dead = [];
    let i = (k - 1) % alive.length;

    while (alive.length) {
        const killed = alive.splice(i, 1);
        dead.push(...killed);
        i = (i + k - 1) % alive.length;
    }

    return dead;
};

function josephus6(items: any[], k: number): any[] {
    const result = [];

    while (items.length > 0) {
        for (let skip = 1; skip < k; skip++) {
            items.push(items.shift());
        }
        result.push(items.shift());
    }

    return result;
}

const josephus7 = (items: any[], k: number): any[] => {
    let result: any[] = [];
    let currentIndex: number = 1;

    while (items.length > 0) {
        currentIndex = currentIndex + k - 1;
        while (currentIndex > items.length) {
            currentIndex = currentIndex - items.length;
        }

        result.push(items[currentIndex - 1]);
        items.splice(currentIndex - 1, 1);
    }
    return result;
};

const josephus8 = (items: any[], k: number): any[] => {
    let res = [];
    let i = (k - 1) % items.length;
    while (items.length) {
        res.push(items[i]);
        items.splice(i, 1);
        i = (i + k - 1) % items.length;
    }
    return res;
};
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES (REPLACE) ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: COMMON DENOMINATORS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: EVERY(), SET(),  ❗️❗️❗️ REPLACE(PERFORM MATH OPERATIONS ON NUMERIC STRINGS)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Common denominators
 
You will have a list of rationals in the form
 
{ {numer_1, denom_1} , ... {numer_n, denom_n} } 
or
[ [numer_1, denom_1] , ... [numer_n, denom_n] ] 
or
[ (numer_1, denom_1) , ... (numer_n, denom_n) ] 
where all numbers are positive ints. You have to produce a result in the form:
 
(N_1, D) ... (N_n, D) 
or
[ [N_1, D] ... [N_n, D] ] 
or
[ (N_1', D) , ... (N_n, D) ] 
or
{{N_1, D} ... {N_n, D}} 
or
"(N_1, D) ... (N_n, D)"
depending on the language (See Example tests) in which D is as small as possible and
 
N_1/D == numer_1/denom_1 ... N_n/D == numer_n,/denom_n.
Example:
convertFracs [(1, 2), (1, 3), (1, 4)] `shouldBe` [(6, 12), (4, 12), (3, 12)]
Note:
Due to the fact that the first translations were written long ago - more than 6 years - these first translations have only irreducible fractions.
 
Newer translations have some reducible fractions. To be on the safe side it is better to do a bit more work by simplifying fractions even if they don't have to be.
*/
const convertFrac = (list: [number, number][]): string => {
    let solution: string = "";
    let denomsArr: number[] = [];
    // FIND COMMON DENOMINATOR
    list.forEach((frac) => {
        denomsArr.push(frac[1]);
    });
    // console.log("denomsArr: ", denomsArr);
    // denomsArr:  [ 2, 5, 4, 9, 10 ]

    let commDenom: number = 0;
    let i = Math.max(...denomsArr);
    while (true) {
        if (denomsArr.every((denom) => i % denom === 0)) {
            commDenom = i;
            break;
        }
        i++;
    }
    // console.log("common denom: ", commDenom);
    // common denom:  180

    // SET FOR ALL UNIQUE COMPONENTS (FURTHER REDUCTION OF FRACTIONS)
    const uniqueComps = new Set<number>();

    list.forEach((frac) => {
        // (90,180) AND SO ON...
        solution += `(${frac[0] * (commDenom / frac[1])},${commDenom})`;
        uniqueComps.add(frac[0] * (commDenom / frac[1]));
    });
    // console.log(uniqueComps);
    // Set(5) { 90, 144, 135, 120, 126 }

    // SIMPLIFY FRACTIONS IF POSSIBLE (FIND COMMON DIVIDER FOR ALL COMPONENTS)
    let simplifiedSolution: string = "";
    // ADD COMMON DENOMINATOR TO SET
    uniqueComps.add(commDenom);
    // MAKE ARRAY FROM SET FOR ARRAY METHOD EVERY
    const allCompsArr: number[] = Array.from(uniqueComps);
    // console.log("allCompsArr: ", allCompsArr);
    // allCompsArr:  [ 90, 144, 135, 120, 126, 180 ]
    for (let i = 2; i <= commDenom / 2; i++) {
        if (allCompsArr.every((comp) => comp % i === 0)) {
            // ❗️❗️❗️ REPLACE EVERY NUMBER IN STRING WITH ITSELF DIVIDED BY i (COMMON DIVIDER)
            simplifiedSolution = solution.replace(/\d+/g, (num: string) =>
                (Number(num) / i).toString()
            );
        }
    }

    // console.log("simplifiedSolution: ", simplifiedSolution);
    // simplifiedSolution:  (30,60)(48,60)(45,60)(40,60)(42,60)

    // IF SIMPLIFIED SOLUTION EXIST, RETURN IT, OTHERWISE RETURN SOLUTION
    return simplifiedSolution ? simplifiedSolution : solution;
};

// "(6,12)(4,12)(3,12)"
// console.log(convertFrac([[1, 2], [1, 3], [1, 4]]));
// ============================================================
// ❗️❗️❗️ SOLUTION:
// '(90,180)(144,180)(135,180)(120,180)(126,180)'
//  ❗️❗️❗️ SIMPLIFIED SOLUTION:
// '(30,60) (48,60)  (45,60)  (40,60)  (42,60)'
// console.log(convertFrac([[1, 2], [4, 5], [3, 4], [6, 9], [7, 10]]));
// ============================================================

// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
const convertFrac2 = (lst: [number, number][]): string => {
    const gcd = (a: number, b: number): number => (b ? gcd(b, a % b) : a);
    const lcm = (a: number, b: number): number => (a * b) / gcd(a, b);
    const cd = lst.reduce((a, [_, d]) => lcm(d, a), 1);
    const lcd = lst.reduce((d, [a, c]) => gcd(d, (a * cd) / c), cd);
    return lst.map(([n, d]) => `(${(n * cd) / d / lcd},${cd / lcd})`).join("");
};
// ============================================================

const gcd = (x: number, y: number): number => {
    while (y != 0) {
        const z = x % y;
        x = y;
        y = z;
    }

    return x;
};

const lcm = (x: number, y: number): number => (x * y) / gcd(x, y);

const convertFrac3 = (lst: [number, number][]): string => {
    const common = lst.map(([x, y]) => y).reduce(lcm, 1);

    const acc = lst.map(([x, y]) => x * (common / y));

    const least = acc.reduce(gcd, common);

    return acc.map((x) => `(${x / least},${common / least})`).join("");
};
// ============================================================
const findGcd = (a: number, b: number): number => (b ? findGcd(b, a % b) : a);

const findLcm = (a: number, b: number): number => (a * b) / findGcd(a, b);

const findLcmOfList = (arr: number[]): number =>
    arr.reduce((lcm, num) => findLcm(lcm, num), 1);

const simplify = (a: number, b: number): [number, number] => {
    const gcd = findGcd(a, b);
    return gcd === 1 ? [a, b] : [a / gcd, b / gcd];
};

export const convertFrac4 = (lst: [number, number][]): string => {
    let denoms: number[] = [];
    const list = lst.map(([n0, n1]) => {
        const simpleArr = simplify(n0, n1);
        denoms.push(simpleArr[1]);
        return simpleArr;
    });

    const lcm = findLcmOfList(denoms);

    return list.reduce(
        (result, [n0, n1]) => `${result}(${(n0 * lcm) / n1},${lcm})`,
        ""
    );
};
// ============================================================
interface IFactorized {
    [key: number]: number;
}

export const convertFrac5 = (lst: [number, number][]): string => {
    if (lst.length == 0) return "";
    const getPrimes = function (maxNum: number) {
        const candidates: boolean[] = Array.from(
            { length: maxNum },
            (i) => true
        );
        const maxi = Math.floor(Math.sqrt(maxNum));
        for (let i = 2; i <= maxi; i++) {
            if (candidates[i]) {
                const sqi = i * i;
                for (let k = 0; ; k++) {
                    const j = sqi + i * k;
                    if (j > maxNum) break;
                    candidates[j] = false;
                }
            }
        }
        const primes: number[] = [];
        for (let i = 2; i < candidates.length; i++) {
            if (candidates[i]) {
                primes.push(i);
            }
        }
        return primes;
    };
    const max_denom = lst
        .map((i) => i[1])
        .reduce((carry, item) => {
            if (carry < item) return item;
            return carry;
        });
    const primes = getPrimes(max_denom + 1);
    const factorize = function (num: number) {
        const res: IFactorized = {};
        primes.forEach((prime) => {
            let cnt = 0;
            while (num > 1) {
                if (num % prime === 0) {
                    num = Math.floor(num / prime);
                    cnt++;
                } else {
                    break;
                }
            }
            if (cnt > 0) res[prime] = cnt;
        });
        return res;
    };
    const simplified_lst = lst.map((item) => {
        const fnum = factorize(item[0]);
        const fdenom = factorize(item[1]);
        const cfactors: IFactorized = {};
        Object.keys(fnum).forEach((prime) => {
            if (fdenom[parseInt(prime)]) {
                cfactors[parseInt(prime)] =
                    fnum[parseInt(prime)] <= fdenom[parseInt(prime)]
                        ? fnum[parseInt(prime)]
                        : fdenom[parseInt(prime)];
            }
        });
        const div = Object.keys(cfactors).reduce((carry, prime) => {
            return carry * Math.pow(parseInt(prime), cfactors[parseInt(prime)]);
        }, 1);
        return [Math.floor(item[0] / div), Math.floor(item[1]) / div];
    });
    const fdenoms: IFactorized[] = simplified_lst.map((item) => {
        return factorize(item[1]);
    });
    const lcm_factors: IFactorized = {};
    for (const factors of fdenoms) {
        for (const prime in factors) {
            if (lcm_factors[parseInt(prime)]) {
                if (factors[parseInt(prime)] > lcm_factors[parseInt(prime)])
                    lcm_factors[parseInt(prime)] = factors[parseInt(prime)];
            } else {
                lcm_factors[parseInt(prime)] = factors[parseInt(prime)];
            }
        }
    }
    const lcd = Object.keys(lcm_factors).reduce((carry, prime) => {
        return carry * Math.pow(parseInt(prime), lcm_factors[parseInt(prime)]);
    }, 1);
    return simplified_lst
        .map((item) => {
            const num = Math.floor((item[0] * lcd) / item[1]);
            return `(${num},${lcd})`;
        })
        .join("");
};
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: MY SMALLEST CODE INTERPRETER (aka Brainf**k)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Inspired from real-world Brainf**k, we want to create an interpreter of that language which will support the following instructions:
 
> increment the data pointer (to point to the next cell to the right).
< decrement the data pointer (to point to the next cell to the left).
+ increment (increase by one, truncate overflow: 255 + 1 = 0) the byte at the data pointer.
- decrement (decrease by one, treat as unsigned byte: 0 - 1 = 255 ) the byte at the data pointer.
. output the byte at the data pointer.
, accept one byte of input, storing its value in the byte at the data pointer.
[ if the byte at the data pointer is zero, then instead of moving the instruction pointer forward to the next command, jump it forward to the command after the matching ] command.
] if the byte at the data pointer is nonzero, then instead of moving the instruction pointer forward to the next command, jump it back to the command after the matching [ command.
The function will take in input...
 
the program code, a string with the sequence of machine instructions,
the program input, a string, possibly empty, that will be interpreted as an array of bytes using each character's ASCII code and will be consumed by the , instruction
... and will return ...
 
the output of the interpreted code (always as a string), produced by the . instruction.
Implementation-specific details for this Kata:
 
Your memory tape should be large enough - the original implementation had 30,000 cells but a few thousand should suffice for this Kata
Each cell should hold an unsigned byte with wrapping behavior (i.e. 255 + 1 = 0, 0 - 1 = 255), initialized to 0
The memory pointer should initially point to a cell in the tape with a sufficient number (e.g. a few thousand or more) of cells to its right. For convenience, you may want to have it point to the leftmost cell initially
You may assume that the , command will never be invoked when the input stream is exhausted
Error-handling, e.g. unmatched square brackets and/or memory pointer going past the leftmost cell is not required in this Kata. If you see test cases that require you to perform error-handling then please open an Issue in the Discourse for this Kata (don't forget to state which programming language you are attempting this Kata in).
*/

function brainLuck(code: string, input: string) {
    // return output;
}

// 'Codewars'
// console.log(brainLuck(',+[-.,+]','Codewars'+String.fromCharCode(255)));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️  SOLUTION NOT WORKING IN IDE ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: CHAIN ADDING FUNCTION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ VALUEOF
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
We want to create a function that will add numbers together when called in succession.
 
add(1)(2); // == 3
We also want to be able to continue to add numbers to our chain.
 
add(1)(2)(3); // == 6
add(1)(2)(3)(4); //  == 10
add(1)(2)(3)(4)(5); // == 15
and so on.
 
A single call should be equal to the number passed in.
 
add(1); // == 1
We should be able to store the returned values and reuse them.
 
var addTwo = add(2);
addTwo; // == 2
addTwo + 5; // == 7
addTwo(3); // == 5
addTwo(3)(5); // == 10
We can assume any number being passed in will be valid whole number.
*/

// ❗️❗️❗️  SOLUTION NOT WORKING IN IDE ❗️❗️❗️
// [Function: sum] { valueOf: [Function (anonymous)] }

function add(n: number): any {
    const sum = function (y: number) {
        return add(n + y);
    };
    // ❗️❗️❗️
    sum.valueOf = function () {
        return n;
    };

    return sum;
}
// 15
// add(1)(2)(3)(4)(5);
// console.log(add(1)(2)(3)(4)(5));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
function add2(x: number): any {
    const fn = (y: number) => add(x + y);
    fn.valueOf = () => x;
    return fn;
}

function add3(x: number): any {
    // receives the next number in the sequence
    const addNum = (next: any) => {
        // returns the outer function, with cumulative number so far as the argument
        return add(x + next);
    };

    // sets value of method of inner function to return value of x for final number
    addNum.valueOf = () => {
        return x;
    };

    // returns addNum function which will be called with next number as argument
    return addNum;
}

/**
 * Calculates the sum of numbers.
 *
 * @param x number
 * @returns number
 * The sum of numbers using closures.
 */
function add4(x: number): any {
    let currentSum: number = x;

    function f(y: number): any {
        if (typeof y === "number") {
            currentSum += y;
            return f;
        }
    }

    // "f" is a function object and should include "toString" method.
    f.toString = function (): any {
        return currentSum;
    };

    return f;
}

function add5(n: number): any {
    return Object.assign((i: any) => add(i + n), { valueOf: () => n });
}

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: IS MY FRIEND CHEATING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A friend of mine takes the sequence of all numbers from 1 to n (where n > 0).
Within that sequence, he chooses two numbers, a and b.
He says that the product of a and b should be equal to the sum of all numbers in the sequence, excluding a and b.
Given a number n, could you tell me the numbers he excluded from the sequence?
The function takes the parameter: n (n is always strictly greater than 0) and returns an array or a string (depending on the language) of the form:
 
[(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or or [{a, b}, ...]
with all (a, b) which are the possible removed numbers in the sequence 1 to n.
 
[(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or ... will be sorted in increasing order of the "a".
 
It happens that there are several possible (a, b). The function returns an empty array (or an empty string) if no possible numbers are found which will prove that my friend has not told the truth! (Go: in this case return nil).
 
Examples:
removNb(26) should return [(15, 21), (21, 15)]
or
removNb(26) should return { {15, 21}, {21, 15} }
or
removeNb(26) should return [[15, 21], [21, 15]]
or
removNb(26) should return [ {15, 21}, {21, 15} ]
or
removNb(26) should return "15 21, 21 15"
or
 
in C:
removNb(26) should return  {{15, 21}{21, 15}} tested by way of strings.
Function removNb should return a pointer to an allocated array of Pair pointers, each one also allocated. 
Note
See examples of returns for each language in "RUN SAMPLE TESTS"
*/

class G965 {
    public static removeNb(n: number) {
        // your code
    }
}

// [[15,21],[21,15]]
// console.log(removeNb(26));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ NOT WORKING IN CODEWARS, FLATMAP GIVES ERROR ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: BEST TRAVEL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: FLATMAP()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: ❗️❗️❗️ https://stackoverflow.com/questions/9960908/permutations-in-javascript
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
John and Mary want to travel between a few towns A, B, C ... Mary has on a sheet of paper a list of distances between these towns. ls = [50, 55, 57, 58, 60]. John is tired of driving and he says to Mary that he doesn't want to drive more than t = 174 miles and he will visit only 3 towns.
 
Which distances, hence which towns, they will choose so that the sum of the distances is the biggest possible to please Mary and John?
 
Example:
With list ls and 3 towns to visit they can make a choice between: [50,55,57],[50,55,58],[50,55,60],[50,57,58],[50,57,60],[50,58,60],[55,57,58],[55,57,60],[55,58,60],[57,58,60].
 
The sums of distances are then: 162, 163, 165, 165, 167, 168, 170, 172, 173, 175.
 
The biggest possible sum taking a limit of 174 into account is then 173 and the distances of the 3 corresponding towns is [55, 58, 60].
 
The function chooseBestSum (or choose_best_sum or ... depending on the language) will take as parameters t (maximum sum of distances, integer >= 0), k (number of towns to visit, k >= 1) and ls (list of distances, all distances are positive or zero integers and this list has at least one element). The function returns the "best" sum ie the biggest possible sum of k distances less than or equal to the given limit t, if that sum exists, or otherwise nil, null, None, Nothing, depending on the language. In that case with C, C++, D, Dart, Fortran, F#, Go, Julia, Kotlin, Nim, OCaml, Pascal, Perl, PowerShell, Reason, Rust, Scala, Shell, Swift return -1.
 
Examples:
ts = [50, 55, 56, 57, 58] choose_best_sum(163, 3, ts) -> 163
 
xs = [50] choose_best_sum(163, 3, xs) -> nil (or null or ... or -1 (C++, C, D, Rust, Swift, Go, ...)
 
ys = [91, 74, 73, 85, 73, 81, 87] choose_best_sum(230, 3, ys) -> 228
 
Notes:
try not to modify the input list of distances ls
in some languages this "list" is in fact a string (see the Sample Tests).
*/

const chooseBestSum = (
    maxDist: number,
    numTowns: number,
    list: number[]
): number | null => {
    // if ()

    const generatePermutations = (
        list: number[],
        size = list.length
    ): number[][] => {
        if (size > list.length) return [];
        else if (size == 1) return list.map((d) => [d]);
        return list.flatMap((d) =>
            generatePermutations(
                list.filter((a) => a !== d),
                size - 1
            ).map((item) => [d, ...item])
        );
    };

    const allPermutations: number[][] = generatePermutations(list, numTowns);
    console.log(allPermutations);
    const allDistances: number[] = allPermutations.map((arr) => {
        return arr.reduce((acc, curr) => acc + curr);
    });
    console.log(allDistances);
    const distsInRange: number[] = allDistances.filter(
        (dist) => dist <= maxDist
    );
    console.log(distsInRange);
    const solution: number = Math.max(...distsInRange, 0);
    console.log(solution);
    return solution ? solution : null;
};

//   163
// console.log(chooseBestSum(163, 3, [50, 55, 56, 57, 58]));
// 50
// console.log(chooseBestSum(163, 3, [50]));
// console.log();
// console.log();

/*
❗️❗️❗️ THIS WILL GIVE ALL THE PERMUTATIONS, DUPLICATES WILL OCCUR ❗️❗️❗️
❗️❗️❗️ SOURCE: https://stackoverflow.com/questions/9960908/permutations-in-javascript
 
Here's a very concise and recursive solution that allows you to input the size of the output permutations similar to the statistical operator nPr. "5 permutation 3". This allows you to get all possible permutations with a specific size.
 
function generatePermutations(list, size=list.length) {
    if (size > list.length) return [];
    else if (size == 1) return list.map(d=>[d]); 
    return list.flatMap(d => generatePermutations(list.filter(a => a !== d), size - 1).map(item => [d, ...item]));
}
generatePermutations([1,2,3])
 
[[1, 2, 3],[1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
generatePermutations([1,2,3],2)
 
[[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]
 
OUTPUT EXAMPLE:
 
[
  [ 50, 55, 56 ], [ 50, 55, 57 ], [ 50, 55, 58 ],
  [ 50, 56, 55 ], [ 50, 56, 57 ], [ 50, 56, 58 ],
  [ 50, 57, 55 ], [ 50, 57, 56 ], [ 50, 57, 58 ],
  [ 50, 58, 55 ], [ 50, 58, 56 ], [ 50, 58, 57 ],
  [ 55, 50, 56 ], [ 55, 50, 57 ], [ 55, 50, 58 ],
  [ 55, 56, 50 ], [ 55, 56, 57 ], [ 55, 56, 58 ],
  [ 55, 57, 50 ], [ 55, 57, 56 ], [ 55, 57, 58 ],
  [ 55, 58, 50 ], [ 55, 58, 56 ], [ 55, 58, 57 ],
  [ 56, 50, 55 ], [ 56, 50, 57 ], [ 56, 50, 58 ],
  [ 56, 55, 50 ], [ 56, 55, 57 ], [ 56, 55, 58 ],
  [ 56, 57, 50 ], [ 56, 57, 55 ], [ 56, 57, 58 ],
  [ 56, 58, 50 ], [ 56, 58, 55 ], [ 56, 58, 57 ],
  [ 57, 50, 55 ], [ 57, 50, 56 ], [ 57, 50, 58 ],
  [ 57, 55, 50 ], [ 57, 55, 56 ], [ 57, 55, 58 ],
  [ 57, 56, 50 ], [ 57, 56, 55 ], [ 57, 56, 58 ],
  [ 57, 58, 50 ], [ 57, 58, 55 ], [ 57, 58, 56 ],
  [ 58, 50, 55 ], [ 58, 50, 56 ], [ 58, 50, 57 ],
  [ 58, 55, 50 ], [ 58, 55, 56 ], [ 58, 55, 57 ],
  [ 58, 56, 50 ], [ 58, 56, 55 ], [ 58, 56, 57 ],
  [ 58, 57, 50 ], [ 58, 57, 55 ], [ 58, 57, 56 ]
]
[
  161, 162, 163, 161, 163, 164, 162, 163, 165,
  163, 164, 165, 161, 162, 163, 161, 168, 169,
  162, 168, 170, 163, 169, 170, 161, 163, 164,
  161, 168, 169, 163, 168, 171, 164, 169, 171,
  162, 163, 165, 162, 168, 170, 163, 168, 171,
  165, 170, 171, 163, 164, 165, 163, 169, 170,
  164, 169, 171, 165, 170, 171
]
[
  161, 162, 163, 161, 163,
  162, 163, 163, 161, 162,
  163, 161, 162, 163, 161,
  163, 161, 163, 162, 163,
  162, 163, 163, 163
]
163
*/

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ TRY TO REFACTOR OTHER PRIME CHALLENGES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  GAP IN PRIMES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: PRIME NUMNERS, ISPRIME(),
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The prime numbers are not regularly spaced. For example from 2 to 3 the gap is 1. From 3 to 5 the gap is 2. From 7 to 11 it is 4. Between 2 and 50 we have the following pairs of 2-gaps primes: 3-5, 5-7, 11-13, 17-19, 29-31, 41-43
 
A prime gap of length n is a run of n-1 consecutive composite numbers between two successive primes (see: http://mathworld.wolfram.com/PrimeGaps.html).
 
We will write a function gap with parameters:
 
g (integer >= 2) which indicates the gap we are looking for
 
m (integer > 2) which gives the start of the search (m inclusive)
 
n (integer >= m) which gives the end of the search (n inclusive)
 
n won't go beyond 1100000.
 
In the example above gap(2, 3, 50) will return [3, 5] or (3, 5) or {3, 5} which is the first pair between 3 and 50 with a 2-gap.
 
So this function should return the first pair of two prime numbers spaced with a gap of g between the limits m, n if these numbers exist otherwise `nil or null or None or Nothing (or ... depending on the language).
 
In such a case (no pair of prime numbers with a gap of `g`)
In C: return [0, 0]
In C++, Lua, COBOL: return `{0, 0}`. 
In F#: return `[||]`. 
In Kotlin, Dart and Prolog: return `[]`.
In Pascal: return Type TGap (0, 0).
Examples:
- gap(2, 5, 7) --> [5, 7] or (5, 7) or {5, 7}
 
gap(2, 5, 5) --> nil. In C++ {0, 0}. In F# [||]. In Kotlin, Dart and Prolog return []`
 
gap(4, 130, 200) --> [163, 167] or (163, 167) or {163, 167}
 
([193, 197] is also such a 4-gap primes between 130 and 200 but it's not the first pair)
 
gap(6,100,110) --> nil or {0, 0} or ... : between 100 and 110 we have 101, 103, 107, 109 but 101-107is not a 6-gap because there is 103in between and 103-109is not a 6-gap because there is 107in between.
 
You can see more examples of return in Sample Tests.
 
Note for Go
For Go: nil slice is expected when there are no gap between m and n. Example: gap(11,30000,100000) --> nil
 
Ref
https://en.wikipedia.org/wiki/Prime_gap
*/

class G964b {
    public static gap = (gap: number, min: number, max: number): number[] => {
        let solution: number[] = [];
        let primesArr: number[] = [];
        // THIS WILL BE ALL THE POSSIBLE MATCHES WHICH IS NOT NECESSARY AS WE HAVE TO RETURN THE FIRST MATCH
        let allMatchesArr: [number, number][] = [];

        // GET ALL PRIMES WITHIN RANGE (MIN - MAX)

        // ISPRIME() FROM PREVIOUS CODEWARS EXAMPLE
        // const isPrime = (num: number) => {
        //     if (num === 1 || num === 2) return true;
        //     for (let i = 2; i < num; i++) {
        //         // console.table({num: num, divider: i});
        //         if (num % i === 0) return false;
        //     }
        //     return true;
        // };
        const isPrime = (num: number) => {
            for (let i = 2; i <= Math.sqrt(num); i++) {
                if (num % i === 0) {
                    return false;
                }
            }
            return true;
        };

        //   FIND PRIMES RANGING FROM 2 TO HALF OF NUM
        for (let i = min; i <= max; i++) {
            let prime = 0;
            if (isPrime(i)) {
                prime = i;
                // console.log("prime found: ", prime);

                primesArr.push(prime);
            }
        }
        // [ 101, 103, 107, 109 ]
        console.log(primesArr);
        // LOOP OVER PRIMES ARRAY (AND GET GAPS)
        // [ 2, 4, 2, NaN ] ❗️❗️❗️ LAST EL WILL BE NAN BECAUSE primesArr[idx + 1] IS UNDEFINE FOR THE LAST ELEMENT ❗️❗️❗️
        const gapsArr: number[] = primesArr.map((el, idx) => {
            if (primesArr[idx + 1] - el === gap) {
                console.log("match found");
                allMatchesArr.push([el, primesArr[idx + 1]]);
            }
            return primesArr[idx + 1] - el;
        });
        // .slice(0, -1);   // ❗️❗️❗️ [ 2, 4, 2 ]  RETURN NEW ARRAY WITHOUT LAST ELEMENT (NAN)

        console.table({
            primesArr: primesArr,
            "gaps arr: ": gapsArr,
            allMatchesArr: allMatchesArr,
        });

        if (allMatchesArr.length === 0) {
            console.log("empty array");
            return [0, 0];
        }
        //  FIND AND RETURN FIRST GAP MATCH
        solution = allMatchesArr[0];
        return solution;
    };
}

/*
G964b.gap(2, 100, 110) LOGS:
 
┌───────────────┬──────────────┬──────────────┬─────┬─────┐
│    (index)    │      0       │      1       │  2  │  3  │
├───────────────┼──────────────┼──────────────┼─────┼─────┤
│   primesArr   │     101      │     103      │ 107 │ 109 │
│  gaps arr:    │      2       │      4       │  2  │ NaN │
│ allMatchesArr │ [ 101, 103 ] │ [ 107, 109 ] │     │     │
└───────────────┴──────────────┴──────────────┴─────┴─────┘
[ 101, 103 ]
 
*/

// [ 101, 103 ]
// console.log(G964b.gap(2, 100, 110));
// console.log(G964b.gap(6, 100, 110));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
class G964b1 {
    public static gap = (g: number, m: number, n: number) => {
        let lower = 0;
        for (let i = m; i < n; i++) {
            if (G964b1.isPrime(i)) {
                if (lower === 0 || i - lower !== g) {
                    lower = i;
                } else {
                    return [lower, i];
                }
            }
        }
        return null;
    };

    private static isPrime(n: number) {
        for (let i = 2; i < n; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
}

// class G964b2 {

//     public static gap = (g:number, m:number, n:number):number[] => {
//       let store:number;
//       for (let i = m; i <= n; i++) {
//         if (G964b2.isPrime(i)) {
//           if (i - store === g) {return [store, i]}
//           else {store = i};
//         };
//       }
//       return null;
//     }

//     public static isPrime = (n:number):boolean => {
//       for (let x = Math.floor(Math.sqrt(n)); x > 1; x--) {
//         if (n % x === 0) {return false};
//       }
//       return true;
//     };
//   }

class G964b3 {
    public static gap = (g: number, m: number, n: number) => {
        const primes = [];

        for (let i = m; i < n; i++) {
            let prime = true;
            for (let j = 2; j < i / 2; j++) {
                if (i % j === 0) {
                    prime = false;
                    break;
                }
            }
            if (prime) {
                primes.push(i);
                const length = primes.length;
                if (length > 1) {
                    if (primes[length - 1] - primes[length - 2] === g) {
                        return [primes[length - 2], primes[length - 1]];
                    }
                }
            }
        }
        return null;
    };
}

// ❗️❗️❗️ INCLUDE ISPRIME() IN CODEWARS EXAMPLES ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// ❗️❗️❗️ Execution Timed Out (12000 ms) ❗️❗️❗️ REFACTOR ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PRIMES IN NUMBERS - PRIME FACTOR DECOMPOSITION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: PRIME NUMBERS, ISPRIME(),
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a positive number n > 1 find the prime factor decomposition of n. The result will be a string with the following form :
 
 "(p1**n1)(p2**n2)...(pk**nk)"
with the p(i) in increasing order and n(i) empty if n(i) is 1.
 
Example: n = 86240 should return "(2**5)(5)(7**2)(11)"
 
A prime number is a whole number greater than 1 whose only factors are 1 and itself. A factor is a whole number that can be divided evenly into another number. The first few prime numbers are 2, 3, 5, 7, 11, 13, 17, 19, 23 and 29. Numbers that have more than two factors are called composite numbers.
 
❗️❗️❗️
Prime Factor Decomposition
Quick revise
Prime factor decomposition of a number means writing it as a product of prime factors.
 
To factorise a number, divide it by the first possible prime number.
Take the resulting quotient below the number.
If it is possible, continue dividing this quotient successively by the same prime number.
When you cannot do the division by this prime number, divide it by the next possible prime number.
And so forth until the final quotient is 1.
Finally write this number as a product of powers of prime factors.
Example
 
Find the prime factor decomposition of 36.
 
We look at 36 and try to find numbers which we can divide it by. We can see that it divides by 2.
 
36 = 18 × 2
 
2 is a prime number, but 18 isn't. So we need to split 18 up into prime numbers. We can also divide 18 by 2.
 
18 = 9 × 2
 
and so 36 = 18 × 2 = 9 × 2 × 2
 
But we haven't finished, because 9 is not a prime number. We know that 9 divides by 3.
 
9 = 3 x 3.
 
Hence 36 = 9 × 2 × 2 = 3 × 3 × 2 × 2.
 
This is the answer, because both 2 and 3 are prime numbers.
❗️❗️❗️
*/

// const isPrime = (num: number) => {
//     if (num === 1 || num === 2) return true;
//     for (let i = 2; i < num; i++) {
//         // console.table({num: num, divider: i});
//         if (num % i === 0) return false;
//     }
//     return true;
// };

// MAY HAVE TO USE OBJECT TO COUNT OCCURENCES
const countPrimes = (primes: number[]): string => {
    interface StrKeyVal {
        [key: number]: number;
    }

    const counter: StrKeyVal = {};
    primes.forEach((number) => (counter[number] = (counter[number] || 0) + 1));

    console.log(counter);

    return "hello";
};

// countPrimes([2, 2, 2, 2, 2, 5, 7, 7, 11]);

// console.log(isPrime(5));
// =========================================

const primeFactors = (num: number): string => {
    let factors = [];
    let numRemainder = num;
    let solution: string = "";

    // const isPrime = (num: number) => {
    //     if (num === 1 || num === 2) return true;
    //     for (let i = 2; i < num; i++) {
    //         // console.table({num: num, divider: i});
    //         if (num % i === 0) return false;
    //     }
    //     return true;
    // };

    const isPrime = (num: number) => {
        for (let i = 2; i <= Math.sqrt(num); i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    };

    //   FIND PRIMES RANGING FROM 2 TO HALF OF NUM
    for (let i = 2; i < (num - 1) / 2; i++) {
        let prime = 0;
        if (isPrime(i)) {
            prime = i;
            // console.log("prime found: ", prime);
            while (numRemainder % prime === 0) {
                numRemainder = numRemainder / prime;
                factors.push(prime);
            }
        }
        if (numRemainder === 1) break;
    }
    console.log(factors);
    if (factors.length === 0) return `(${num})`;

    // COUNT OCCURENCES OF ARRAY ELEMENTS WITH LOOP
    let counter: number = 0;
    for (let i = 0; i < factors.length; i++) {
        counter++;
        console.log("counter: ", counter);
        if (factors[i] !== factors[i + 1] && factors[i] !== undefined) {
            console.log("new factor: ", factors[i], i);
            // FORMAT FACTORS AND CONCAT TO SOLUTION HERE
            solution +=
                counter < 2 ? `(${factors[i]})` : `(${factors[i]}**${counter})`;
            // RESET COUNTER
            counter = 0;
        }
    }

    return solution;
};

// (2**2)(3**2)
// console.log(primeFactors(36));
// (2**5)(5)(7**2)(11)
// console.log(primeFactors(86240));
// 7919
// console.log(primeFactors(7919));

// class G964a8 {
//     public static primeFactors = (num: number): string => {
//         // GET PRIME NUMBERS

//         // DIVIDE

//         // return "hello";
//     };
// }

// "(2**5)(5)(7**2)(11)"
// console.log(G964a8.primeFactors(86240));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PERIMETER OF SQUARES IN A RECTANGLE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The drawing shows 6 squares the sides of which have a length of 1, 1, 2, 3, 5, 8. It's easy to see that the sum of the perimeters of these squares is : 4 * (1 + 1 + 2 + 3 + 5 + 8) = 4 * 20 = 80
 
Could you give the sum of the perimeters of all the squares in a rectangle when there are n + 1 squares disposed in the same manner as in the drawing:
 
alternative text
 
Hint:
See Fibonacci sequence
 
Ref:
http://oeis.org/A000045
 
The function perimeter has for parameter n where n + 1 is the number of squares (they are numbered from 0 to n) and returns the total perimeter of all the squares.
 
perimeter(5)  should return 80
perimeter(7)  should return 216
*/

class G964a {
    public static perimeter = (num: number): number => {
        const fibonacciFirstN = (num: number): number[] => {
            const fibSequence: number[] = [1, 1];
            for (let i = 0; i < num - 1; i++) {
                let next = fibSequence[i] + fibSequence[i + 1];
                fibSequence.push(next);
            }
            return fibSequence;
        };

        return 4 * fibonacciFirstN(num).reduce((a, b) => a + b);
    };
}

// 80
// console.log(G964a.perimeter(5));
// 216
// console.log(G964a.perimeter(7));
//
// console.log(G964a.perimeter(3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G964a2 {
    public static perimeter = (n: number) => {
        let numbers = [1, 1];

        for (let i = 2; i <= n; i++) {
            numbers.push(numbers[i - 1] + numbers[i - 2]);
        }

        return 4 * numbers.reduce((curr, acc) => acc + curr, 0);
    };
}

class G964a3 {
    public static perimeter = (n: number) => {
        return (
            Array.from(Array(n + 2).keys())
                .map((e, i, arr) => {
                    if (i > 0) {
                        arr[i + 1] = arr[i] + arr[i - 1];
                        return e;
                    } else {
                        return 1;
                    }
                })
                .slice(1)
                .reduce((a, b) => a + b) * 4
        );
    };
}

class G964a4 {
    // private static memo = (num: number): number => {
    //   let dp = [];
    //   dp[1] = 1;
    //   dp[2] = 1;
    //   for (let i = 3; i <= num; i++) {
    //     dp[i] = dp[i-1] + dp[i-2];
    //   }
    //   return dp.reduce((prev, curr) => prev + curr);
    // }
    // public static perimeter = (n) => {
    //     return 4 * G964.memo(n+1);
    // }
}

class G964a5 {
    public static perimeter = (n: number) => {
        const fibCalc: number[] = [];
        function fibonacci(n: number): number {
            if (fibCalc[n] !== undefined) {
                return fibCalc[n];
            }

            let calc;
            if (n < 2) {
                calc = n;
            } else {
                calc = fibonacci(n - 2) + fibonacci(n - 1);
            }

            fibCalc.push(calc);
            return calc;
        }

        let length = 0;
        for (let i = 0; i <= n + 1; i++) {
            length += 4 * fibonacci(i);
        }
        return length;
    };
}

class G964a6 {
    public static perimeter = (n: number) => {
        // your code
        var sum = 0;
        var first = 0;
        var last = 0;
        for (var i = 1; i <= n + 1; i++) {
            var el = first + last;
            el = el == 0 ? 1 : el;
            first = last;
            last = el;
            sum += el * 4;
        }
        return sum;
    };
}

class G964a7 {
    public static perimeter = (n: number) => {
        let a = 0,
            b = 4,
            sum = 4;
        for (let i = 1; i <= n; i++) {
            const c = a + b;
            (a = b), (b = c), (sum += c);
        }
        return sum;
    };
}

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:  ORDER WEIGHT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
My friend John and I are members of the "Fat to Fit Club (FFC)". John is worried because each month a list with the weights of members is published and each month he is the last on the list which means he is the heaviest.
 
I am the one who establishes the list so I told him: "Don't worry any more, I will modify the order of the list". It was decided to attribute a "weight" to numbers. The weight of a number will be from now on the sum of its digits.
 
For example 99 will have "weight" 18, 100 will have "weight" 1 so in the list 100 will come before 99.
 
Given a string with the weights of FFC members in normal order can you give this string ordered by "weights" of these numbers?
 
Example:
"56 65 74 100 99 68 86 180 90" ordered by numbers weights becomes: 
 
"100 180 90 56 65 74 68 86 99"
When two numbers have the same "weight", let us class them as if they were strings (alphabetical ordering) and not numbers:
 
180 is before 90 since, having the same "weight" (9), it comes before as a string.
 
All numbers in the list are positive numbers and the list can be empty.
 
Notes
it may happen that the input string have leading, trailing whitespaces and more than a unique whitespace between two consecutive numbers
*/

// const orderWeight = (strng: string): string => {
//   }

// console.log(orderWeight("103 123 4444 99 2000"));
// console.log(orderWeight("2000 10003 1234000 44444444 9999 11 11 22 123"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ REFACTOR THIS ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PRODUCT OF CONSECUTIVE FIBONACCI NUMBERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The Fibonacci numbers are the numbers in the following integer sequence (Fn):
 
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ...
 
such as
 
F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
 
Given a number, say prod (for product), we search two Fibonacci numbers F(n) and F(n+1) verifying
 
F(n) * F(n+1) = prod.
 
Your function productFib takes an integer (prod) and returns an array:
 
[F(n), F(n+1), true] or {F(n), F(n+1), 1} or (F(n), F(n+1), True)
depending on the language if F(n) * F(n+1) = prod.
 
If you don't find two consecutive F(n) verifying F(n) * F(n+1) = prodyou will return
 
[F(n), F(n+1), false] or {F(n), F(n+1), 0} or (F(n), F(n+1), False)
F(n) being the smallest one such as F(n) * F(n+1) > prod.
 
Some Examples of Return:
(depend on the language)
 
productFib(714) # should return (21, 34, true), 
                # since F(8) = 21, F(9) = 34 and 714 = 21 * 34
 
productFib(800) # should return (34, 55, false), 
                # since F(8) = 21, F(9) = 34, F(10) = 55 and 21 * 34 < 800 < 34 * 55
-----
productFib(714) # should return [21, 34, true], 
productFib(800) # should return [34, 55, false], 
-----
productFib(714) # should return {21, 34, 1}, 
productFib(800) # should return {34, 55, 0},        
-----
productFib(714) # should return {21, 34, true}, 
productFib(800) # should return {34, 55, false}, 
*/

// 1️⃣ ✅     WHILE LOOP
class G964 {
    public static productFib = (num: number): (number | boolean)[] => {
        let solution: (number | boolean)[] = [];
        const sequence: number[] = [0, 1];
        const products: number[] = [];

        let current: number = 0;

        // ❗️❗️❗️ REFACTOR LOOP ❗️❗️❗️
        while (current <= num) {
            let next = sequence[current] + sequence[current + 1];
            sequence.push(next);
            let product = sequence[current + 1] * sequence[current + 2];
            products.push(product);
            if (product === num) {
                solution = [sequence[current + 1], sequence[current + 2], true];
                break;
            } else if (product > num) {
                solution = [
                    sequence[current + 1],
                    sequence[current + 2],
                    false,
                ];
                break;
            }
            current++;
        }

        return solution;
    };
}

//  INITIALIZE solution / FIBONACCI sequence AND products ARRAYS

//  INITIALIZE current AT 0

//  LOOP OVER INTEGERS UP TO num
//      CALC next ITEM BY ADDING current TO current + 1
//      PUSH next TO sequence
//      CALC CURRENT PRODUCT BY MULTIPLYING current AND current + 1
//      PUSH product INTO products
//      IF product === num
//          solution = [FACTORS OF product , true]
//          BREAK LOOP
//      ELSE IF product > num
//          solution = [FACTORS OF product, false]
//          BREAK LOOP
//      INCREMENT current BY ONE

//      RETURN SOLUTION

// 2️⃣ ✅     FOR LOOP WITH fibMax VARIABLE TO LIMIT MAX LENGHT OF SEQUENCE
export class G9642 {
    public static productFib = (num: number): (number | boolean)[] => {
        let solution: (number | boolean)[] = [];

        const sequence: number[] = [0, 1];
        const products: number[] = [];
        const fibMax = 15;

        for (let i = 0; i <= fibMax; i++) {
            let next = sequence[i] + sequence[i + 1];
            sequence.push(next);
            let product = sequence[i + 1] * sequence[i + 2];
            products.push(product);
            if (product === num) {
                console.log(`found: ${sequence[i + 1]} and ${sequence[i + 2]}`);
                solution = [sequence[i + 1], sequence[i + 2], true];
                break;
            } else if (product > num) {
                console.log("stop the loop: " + product);
                solution = [sequence[i + 1], sequence[i + 2], false];
                break;
            }
        }

        return solution;
    };
}

// console.log(G964.productFib(105));
// console.log(G964.productFib(800));
// console.log(G964.productFib(714));
// console.log(G964.productFib(4895));
// console.log(G964.productFib(5895));

//============= OTHER CODEWARS SOLUTIONS: =============

/*
export class G964 {
    public static productFib = (prod:number) => {
      let p1:number = 1, p2:number = 1;
      while (p1 * p2 < prod) [p1, p2] = [p2, p1+p2];
      return [p1 , p2, (p1 * p2 == prod)]; 
    }
}
 
 
 
export class G964 {
 
    public static productFib = (prod, f0 = 0, f1 = 1) => (f0 * f1 < prod) ? G964.productFib(prod, f1, f0+f1) : [f0,f1,(f0 * f1) === prod]
}
*/

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  DIRECTIONS REDUCTION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Once upon a time, on a way through the old wild mountainous west,…
… a man was given directions to go from one point to another. The directions were "NORTH", "SOUTH", "WEST", "EAST". Clearly "NORTH" and "SOUTH" are opposite, "WEST" and "EAST" too.
 
Going to one direction and coming back the opposite direction right away is a needless effort. Since this is the wild west, with dreadfull weather and not much water, it's important to save yourself some energy, otherwise you might die of thirst!
 
How I crossed a mountainous desert the smart way.
The directions given to the man are, for example, the following (depending on the language):
 
["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"].
or
{ "NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST" };
or
[North, South, South, East, West, North, West]
You can immediatly see that going "NORTH" and immediately "SOUTH" is not reasonable, better stay to the same place! So the task is to give to the man a simplified version of the plan. A better plan in this case is simply:
 
["WEST"]
or
{ "WEST" }
or
[West]
Other examples:
In ["NORTH", "SOUTH", "EAST", "WEST"], the direction "NORTH" + "SOUTH" is going north and coming back right away.
 
The path becomes ["EAST", "WEST"], now "EAST" and "WEST" annihilate each other, therefore, the final result is [] (nil in Clojure).
 
In ["NORTH", "EAST", "WEST", "SOUTH", "WEST", "WEST"], "NORTH" and "SOUTH" are not directly opposite but they become directly opposite after the reduction of "EAST" and "WEST" so the whole path is reducible to ["WEST", "WEST"].
 
Task
Write a function dirReduc which will take an array of strings and returns an array of strings with the needless directions removed (W<->E or S<->N side by side).
 
The Haskell version takes a list of directions with data Direction = North | East | West | South.
The Clojure version returns nil when the path is reduced to nothing.
The Rust version takes a slice of enum Direction {North, East, West, South}.
See more examples in "Sample Tests:"
Notes
Not all paths can be made simpler. The path ["NORTH", "WEST", "SOUTH", "EAST"] is not reducible. "NORTH" and "WEST", "WEST" and "SOUTH", "SOUTH" and "EAST" are not directly opposite of each other and can't become such. Hence the result path is itself : ["NORTH", "WEST", "SOUTH", "EAST"].
*/

// const dirReduc = (arr: string[]): string[] => {

//     while ((arr.includes("NORTH") && arr.includes("SOUTH"))) {
//         arr.splice(arr.indexOf("NORTH"), 1);
//         arr.splice(arr.indexOf("SOUTH"), 1);
//     }

//     while ((arr.includes("EAST") && arr.includes("WEST"))) {
//         arr.splice(arr.indexOf("EAST"), 1);
//         arr.splice(arr.indexOf("WEST"), 1);
//     }

//     console.log(arr);

//     return arr;

// }

const dirReduc = (arr: string[]): string[] => {
    for (let i = 0; i < arr.length; i++) {
        if (
            (arr[i] === "NORTH" && arr[i + 1] === "SOUTH") ||
            (arr[i] === "SOUTH" && arr[i + 1] === "NORTH") ||
            (arr[i] === "EAST" && arr[i + 1] === "WEST") ||
            (arr[i] === "WEST" && arr[i + 1] === "EAST")
        ) {
            arr.splice(i, 2);
            i -= 2;
        }
    }

    // console.log(arr);

    return arr;
};

//  IF PAIR OF OPPOSITES IS FOUND
//      DELETE PAIR
//      RESET LOOP

// console.log(dirReduc(["NORTH", "SOUTH", "NORTH", "SOUTH"]));
// [WEST]
// console.log(dirReduc(["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"]));
// []
// console.log(dirReduc(["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH"]));

// console.log(dirReduc(["NORTH", "SOUTH", "EAST", "WEST"]));

//============= OTHER CODEWARS SOLUTIONS: =============

function dirReduc2(arr: string[]): string[] {
    var pat = /(NORTHSOUTH|SOUTHNORTH|EASTWEST|WESTEAST)/;
    var way = arr.join("");
    while (pat.test(way)) way = way.replace(pat, "");
    return way.match(/(NORTH|SOUTH|EAST|WEST)/g) || [];
}

const dirReduc3 = (arr: string[]): string[] => {
    const opposites = [
        ["NORTH", "SOUTH"],
        ["EAST", "WEST"],
    ];

    return arr.reduce((acc: string[], curr: string) => {
        const opposite = opposites
            .find((el) => el.includes(curr))!
            .filter((el) => el !== curr)[0];

        const idx = acc.length - 1;

        return acc.length && acc[idx] === opposite
            ? acc.slice(0, idx)
            : acc.concat(curr);
    }, []);
};

function dirReduc4(arr: string[]): string[] {
    let str = arr.join(":");

    while (
        str.match(/NORTH:*SOUTH/) ||
        str.match(/SOUTH:*NORTH/) ||
        str.match(/EAST:*WEST/) ||
        str.match(/WEST:*EAST/)
    ) {
        str = str
            .replace(/NORTH:*SOUTH/g, "")
            .replace(/SOUTH:*NORTH/g, "")
            .replace(/EAST:*WEST/g, "")
            .replace(/WEST:*EAST/g, "");
    }

    return str.split(":").filter(Boolean);
}

function dirReduc5(arr: string[]): string[] {
    arr = arr.map((dir) => dir.toUpperCase());

    console.log(arr);
    for (let i = 0; i < arr.length; i++) {
        if (
            (arr[i] === "NORTH" && arr[i + 1] === "SOUTH") ||
            (arr[i] === "SOUTH" && arr[i + 1] === "NORTH") ||
            (arr[i] === "WEST" && arr[i + 1] === "EAST") ||
            (arr[i] === "EAST" && arr[i + 1] === "WEST")
        ) {
            arr.splice(i, 2);
            return dirReduc(arr);
        }
    }

    return arr;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  HUMAN READABLE TIME
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  PADSTART(),PADEND()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function, which takes a non-negative integer (seconds) as input and returns the time in a human-readable format (HH:MM:SS)
 
HH = hours, padded to 2 digits, range: 00 - 99
MM = minutes, padded to 2 digits, range: 00 - 59
SS = seconds, padded to 2 digits, range: 00 - 59
The maximum time never exceeds 359999 (99:59:59)
 
You can find some examples in the test fixtures.
*/

const humanReadable = (secInput: number): string => {
    const HOUR: number = 3600,
        MINUTE: number = 60;
    let secondsLeft: number = secInput;
    let hours: number = 0,
        minutes: number = 0,
        seconds: number = 0;

    const padToTwo = (num: number): string => {
        return num < 10 ? `0${String(num)}` : `${String(num)}`;
    };

    hours = Math.floor(secondsLeft / HOUR);
    secondsLeft = secondsLeft % HOUR;

    minutes = Math.floor(secondsLeft / MINUTE);
    secondsLeft = secondsLeft % MINUTE;

    seconds = secondsLeft;

    // console.table({ hours: hours, minutes: minutes, seconds: seconds });

    return `${padToTwo(hours)}:${padToTwo(minutes)}:${padToTwo(seconds)}`;
};

//  INITIALIZE ALL VARIABLES
//  padToTwo() WILL CONCAT A "0" IF NUMBER IS ONE DIGIT

//  CALC hours
//  UPDATE secondsLeft

//  CALC minutes
//  UPDATE secondsLeft

//  seconds NOW EQUALS TO secondsLeft

//  RETURN FORMATTED STRING

// console.log(humanReadable(86399));
// console.log(humanReadable(3661));
// console.log(humanReadable(3600));
// console.log(humanReadable(3599));
// console.log(humanReadable(66));
// console.log(humanReadable(59));
// console.log(humanReadable(0));

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ padStart() ❗️❗️❗️
const format = (n: number) => String(Math.floor(n)).padStart(2, "00");

export function humanReadable2(seconds: number): string {
    const h = seconds / 3600;
    const m = (seconds % 3600) / 60;
    const s = (seconds % 3600) % 60;

    return [h, m, s].map(format).join(":");
}

function humanReadable3(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds / 60) % 60;
    const pad = (n: number) => `${n}`.padStart(2, "0");
    return `${pad(hours)}:${pad(minutes)}:${pad(seconds % 60)}`;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SIMPLE PIG LATIN
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REGEX, REPLACE() WITH FUNCTION, IGNORE PUNCTUATION AND MULTIPLE SPACES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Move the first letter of each word to the end of it, then add "ay" to the end of the word. Leave punctuation marks untouched.
 
Examples
pigIt('Pig latin is cool'); // igPay atinlay siay oolcay
pigIt('Hello world !');     // elloHay orldway !
*/

const pigIt = (str: string): string => {
    // 1️⃣
    return str.replace(
        /[a-z]+/gi,
        (word) => `${word.slice(1)}${word.charAt(0)}ay`
    );

    // 2️⃣
    // const validWord = /[a-z]+/gi

    // return str.replace(validWord, (word) => {
    //     return `${word.slice(1)}${word.charAt(0)}ay`
    // });
};

// 'hisTay siay ymay tringsay'
// console.log(pigIt('This is my string'));
// console.log(pigIt('pdNWGEbnnAYBq  qKDVJ prMerdBgTDjFZYaHXd iX ! rxBwJkSVppxW hg . cQFYCExtQFgytIxTj HWEqmZ qFiJOYxcqIObSWjSlJL lg  !  mGJtNrQ iINNKiOohUuMAk dwwOYRmL'));

// pdNWGEbnnAYBq  qKDVJ prMerdBgTDjFZYaHXd iX ! rxBwJkSVppxW hg . cQFYCExtQFgytIxTj HWEqmZ qFiJOYxcqIObSWjSlJL lg  !  mGJtNrQ iINNKiOohUuMAk dwwOYRmL

// EXPECTED THIS:
// dNWGEbnnAYBqpay ay KDVJqay rMerdBgTDjFZYaHXdpay Xiay ! xBwJkSVppxWray ghay . QFYCExtQFgytIxTjcay WEqmZHay FiJOYxcqIObSWjSlJLqay glay ay ! ay GJtNrQmay INNKiOohUuMAkiay wwOYRmLday

// TO EQUAL:
// dNWGEbnnAYBqpay  KDVJqay rMerdBgTDjFZYaHXdpay Xiay ! xBwJkSVppxWray ghay . QFYCExtQFgytIxTjcay WEqmZHay FiJOYxcqIObSWjSlJLqay glay  !  GJtNrQmay INNKiOohUuMAkiay wwOYRmLday

// THIS IS UNSOLVED, FIRST ATTEMPT:
const pigIt2 = (str: string): string => {
    const punctuation = /[?!\.]/g;

    if (punctuation.test(str.charAt(str.length - 1))) {
        console.log("punctuation: " + str.charAt(str.length - 1));
    }

    return str
        .split(" ")
        .map((word) => {
            return `${word.slice(1)}${word.charAt(0)}ay`;
        })
        .join(" ");
};

//============= OTHER CODEWARS SOLUTIONS: =============

const pigIt3 = (a: string) => a.replace(/(\w)(\w+)*/g, "$2$1ay");

const pigIt4 = (a: string): string => {
    return a.replace(/[a-z]+/gi, (x) => x.slice(1) + x[0] + "ay");
};
