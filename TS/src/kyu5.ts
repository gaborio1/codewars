// ❗️❗️❗️ ✅  ❓❓❓
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: Vector class
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Create a Vector object that supports addition, subtraction, dot products, and norms. So, for example:

a = new Vector([1, 2, 3])
b = new Vector([3, 4, 5])
c = new Vector([5, 6, 7, 8])

a.add(b)      # should return a new Vector([4, 6, 8])
a.subtract(b) # should return a new Vector([-2, -2, -2])
a.dot(b)      # should return 1*3 + 2*4 + 3*5 = 26
a.norm()      # should return sqrt(1^2 + 2^2 + 3^2) = sqrt(14)
a.add(c)      # throws an error
If you try to add, subtract, or dot two vectors with different lengths, you must throw an error!

Also provide:

a toString method, so that using the vectors from above, a.toString() === '(1,2,3)' (in Python, this is a __str__ method, so that str(a) == '(1,2,3)')
an equals method, to check that two vectors that have the same components are equal
Note: the test cases will utilize the user-provided equals method.


*/
class Vector {

    constructor(components: number[]) {
        // Start here...
    }
};

/*
describe("Tests", () => {
it("Simple Equality Test", () => {
  let a = new Vector([1,2]);
  let b = new Vector([3,4]);
  assert.isFalse(a.equals(b));
});
 
it("Simple Add Test", function() {
  let a = new Vector([1, 2, 3]);
  let b = new Vector([3, 4, 5]);
  assert.isTrue(a.add(b).equals(new Vector([4,6, 8])));
})
 
it("Simple Norm Test", function () {
  assert.approximately(new Vector([1,2,3]).norm(), Math.sqrt(14),  0.1);
});
 
it("Simple Subtract Test", function() {
  let a = new Vector([1, 2, 3]);
  let b = new Vector([3, 4, 5]);
  assert.isTrue(a.subtract(b).equals(new Vector([-2,-2,-2])));
});
 
it("Simple Dot Test", function() {
  let a = new Vector([1, 2, 3]);
  let b = new Vector([3, 4, 5]);
  assert.strictEqual(a.dot(b), 26);
})
 
it("Simple ToString Test", function() {
  let a = new Vector([1, 2, 3]);
  assert.strictEqual(a.toString(), "(1,2,3)");
})
});
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: Esolang Interpreters #2 - Custom Smallfuck Interpreter
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Esolang Interpreters #2 - Custom Smallfuck Interpreter
About this Kata Series
"Esolang Interpreters" is a Kata Series that originally began as three separate, independent esolang interpreter Kata authored by @donaldsebleung which all shared a similar format and were all somewhat inter-related. Under the influence of a fellow Codewarrior, these three high-level inter-related Kata gradually evolved into what is known today as the "Esolang Interpreters" series.

This series is a high-level Kata Series designed to challenge the minds of bright and daring programmers by implementing interpreters for various esoteric programming languages/Esolangs, mainly Brainfuck derivatives but not limited to them, given a certain specification for a certain Esolang. Perhaps the only exception to this rule is the very first Kata in this Series which is intended as an introduction/taster to the world of esoteric programming languages and writing interpreters for them.

The Language
Smallfuck is an esoteric programming language/Esolang invented in 2002 which is a sized-down variant of the famous Brainfuck Esolang. Key differences include:

Smallfuck operates only on bits as opposed to bytes
It has a limited data storage which varies from implementation to implementation depending on the size of the tape
It does not define input or output - the "input" is encoded in the initial state of the data storage (tape) and the "output" should be decoded in the final state of the data storage (tape)
Here are a list of commands in Smallfuck:

> - Move pointer to the right (by 1 cell)
< - Move pointer to the left (by 1 cell)
* - Flip the bit at the current cell
[ - Jump past matching ] if value at current cell is 0
] - Jump back to matching [ (if value at current cell is nonzero)
As opposed to Brainfuck where a program terminates only when all of the commands in the program have been considered (left to right), Smallfuck terminates when any of the two conditions mentioned below become true:

All commands have been considered from left to right
The pointer goes out-of-bounds (i.e. if it moves to the left of the first cell or to the right of the last cell of the tape)
Smallfuck is considered to be Turing-complete if and only if it had a tape of infinite length; however, since the length of the tape is always defined as finite (as the interpreter cannot return a tape of infinite length), its computational class is of bounded-storage machines with bounded input.

More information on this Esolang can be found here.

The Task
Implement a custom Smallfuck interpreter interpreter() (interpreter in Haskell and F#, Interpreter in C#, custom_small_fuck:interpreter/2 in Erlang) which accepts the following arguments:

code - Required. The Smallfuck program to be executed, passed in as a string. May contain non-command characters. Your interpreter should simply ignore any non-command characters.
tape - Required. The initial state of the data storage (tape), passed in as a string. For example, if the string "00101100" is passed in then it should translate to something of this form within your interpreter: [0, 0, 1, 0, 1, 1, 0, 0]. You may assume that all input strings for tape will be non-empty and will only contain "0"s and "1"s.
Your interpreter should return the final state of the data storage (tape) as a string in the same format that it was passed in. For example, if the tape in your interpreter ends up being [1, 1, 1, 1, 1] then return the string "11111".

NOTE: The pointer of the interpreter always starts from the first (leftmost) cell of the tape, same as in Brainfuck.

Good luck :D
*/
function interpreter(code: string, tape: string): string {
    return "hello";
}

/*
// Flips the leftmost cell of the tape
    assert.equal(interpreter("*", "00101100"), "10101100");
    // Flips the second and third cell of the tape
    assert.equal(interpreter(">*>*", "00101100"), "01001100");
    // Flips all the bits in the tape
    assert.equal(interpreter("*>*>*>*>*>*>*>*", "00101100"), "11010011");
    // Flips all the bits that are initialized to 0
    assert.equal(interpreter("*>*>>*>>>*>*", "00101100"), "11111111");
    // Goes somewhere to the right of the tape and then flips all bits that are initialized to 1, progressing leftwards through the tape
    assert.equal(interpreter(">>>>>*<*<<*", "00101100"), "00000000");
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: FACTORIAL DECOMPOSITION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The aim of the kata is to decompose n! (factorial n) into its prime factors.

Examples:

n = 12; decomp(12) -> "2^10 * 3^5 * 5^2 * 7 * 11"
since 12! is divisible by 2 ten times, by 3 five times, by 5 two times and by 7 and 11 only once.

n = 22; decomp(22) -> "2^19 * 3^9 * 5^4 * 7^3 * 11^2 * 13 * 17 * 19"

n = 25; decomp(25) -> 2^22 * 3^10 * 5^6 * 7^3 * 11^2 * 13 * 17 * 19 * 23
Prime numbers should be in increasing order. When the exponent of a prime is 1 don't put the exponent.

Notes

the function is decomp(n) and should return the decomposition of n! into its prime factors in increasing order of the primes, as a string.
factorial can be a very big number (4000! has 12674 digits, n can go from 300 to 4000).
In Fortran - as in any other language - the returned string is not permitted to contain any redundant trailing whitespace: you can use dynamically allocated character strings.

*/
function decomp(n: number): string {
    return "your code";
}

/*
 assert.equal(decomp(17), "2^15 * 3^6 * 5^3 * 7^2 * 11 * 13 * 17")
        assert.equal(decomp(5), "2^3 * 3 * 5")
        assert.equal(decomp(22), "2^19 * 3^9 * 5^4 * 7^3 * 11^2 * 13 * 17 * 19")
        assert.equal(decomp(14), "2^11 * 3^5 * 5^2 * 7^2 * 11 * 13")
        assert.equal(decomp(25), "2^22 * 3^10 * 5^6 * 7^3 * 11^2 * 13 * 17 * 19 * 23")
        */

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: BEERAMID
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Let's pretend your company just hired your friend from college and paid you a referral bonus. Awesome! To celebrate, you're taking your team out to the terrible dive bar next door and using the referral bonus to buy, and build, the largest three-dimensional beer can pyramid you can. And then probably drink those beers, because let's pretend it's Friday too.

A beer can pyramid will square the number of cans in each level - 1 can in the top level, 4 in the second, 9 in the next, 16, 25...

Complete the beeramid function to return the number of complete levels of a beer can pyramid you can make, given the parameters of:

your referral bonus, and

the price of a beer can

For example:

beeramid(1500, 2); // should === 12
beeramid(5000, 3); // should === 16

*/
function beeramid(bonus: number, price: number): number {
    return 0;
}

/*
assert.strictEqual(beeramid(9, 2), 1);
    assert.strictEqual(beeramid(10, 2), 2);
    assert.strictEqual(beeramid(11, 2), 2);
    assert.strictEqual(beeramid(21, 1.5), 3);
    assert.strictEqual(beeramid(454, 5), 5);
    assert.strictEqual(beeramid(455, 5), 6);
    assert.strictEqual(beeramid(4, 4), 1);
    assert.strictEqual(beeramid(3, 4), 0);
    assert.strictEqual(beeramid(0, 4), 0);
    assert.strictEqual(beeramid(-1, 4), 0);
*/
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: SNAKES AND LADDERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
ntroduction
Snakes and Ladders is an ancient Indian board game regarded today as a worldwide classic. It is played between two or more players on a gameboard having numbered, gridded squares. A number of "ladders" and "snakes" are pictured on the board, each connecting two specific board squares. (Source Wikipedia)

Task
Your task is to make a simple class called SnakesLadders. The test cases will call the method play(die1, die2) independantly of the state of the game or the player turn. The variables die1 and die2 are the die thrown in a turn and are both integers between 1 and 6. The player will move the sum of die1 and die2.
The Board

Rules
1.  There are two players and both start off the board on square 0.

2.  Player 1 starts and alternates with player 2.

3.  You follow the numbers up the board in order 1=>100

4.  If the value of both die are the same then that player will have another go.

5.  Climb up ladders. The ladders on the game board allow you to move upwards and get ahead faster. If you land exactly on a square that shows an image of the bottom of a ladder, then you may move the player all the way up to the square at the top of the ladder. (even if you roll a double).

6.  Slide down snakes. Snakes move you back on the board because you have to slide down them. If you land exactly at the top of a snake, slide move the player all the way to the square at the bottom of the snake or chute. (even if you roll a double).

7.  Land exactly on the last square to win. The first person to reach the highest square on the board wins. But there's a twist! If you roll too high, your player "bounces" off the last square and moves back. You can only win by rolling the exact number needed to land on the last square. For example, if you are on square 98 and roll a five, move your game piece to 100 (two moves), then "bounce" back to 99, 98, 97 (three, four then five moves.)

8.  If the Player rolled a double and lands on the finish square “100” without any remaining moves then the Player wins the game and does not have to roll again.
Returns
Return Player n Wins!. Where n is winning player that has landed on square 100 without any remainding moves left.

Return Game over! if a player has won and another player tries to play.

Otherwise return Player n is on square x. Where n is the current player and x is the sqaure they are currently on.
Good luck and enjoy!
*/
class SnakesLadders {
    constructor() {
        // Good luck
    }

    play(die1: number, die2: number): string {
        return "HELLO";
    }
}

/*
assert.equal(game.play(1, 1), "Player 1 is on square 38", "Should return: 'Player 1 is on square 38'");
    assert.equal(game.play(1, 5), "Player 1 is on square 44", "Should return: 'Player 1 is on square 44'");
    assert.equal(game.play(6, 2), "Player 2 is on square 31", "Should return: 'Player 2 is on square 31'");
    assert.equal(game.play(1, 1), "Player 1 is on square 25", "Should return: 'Player 1 is on square 25'");
    */

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: MOLECULE TO ATOMS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
For a given chemical formula represented by a string, count the number of atoms of each element contained in the molecule and return an object (associative array in PHP, Dictionary<string, int> in C#, Map<String,Integer> in Java).

For example:

var water = 'H2O';
parseMolecule(water); // return {H: 2, O: 1}

var magnesiumHydroxide = 'Mg(OH)2';
parseMolecule(magnesiumHydroxide); // return {Mg: 1, O: 2, H: 2}

var fremySalt = 'K4[ON(SO3)2]2';
parseMolecule(fremySalt); // return {K: 4, O: 14, N: 2, S: 4}
As you can see, some formulas have brackets in them. The index outside the brackets tells you that you have to multiply count of each atom inside the bracket on this index. For example, in Fe(NO3)2 you have one iron atom, two nitrogen atoms and six oxygen atoms.

Note that brackets may be round, square or curly and can also be nested. Index after the braces is optional.


*/

const parseMolecule = (formula: string) => {
    // MATCH STANDALONE ELELMENT ( ONE UPPERCASE FOLLOWED BY OPTIONAL LOWERCASE)
    const elementMatch = /[A-Z]{1}[a-z]?/g;

    console.log(formula.match(elementMatch));
};

// {H: 2, O: 1}
console.log(parseMolecule("H2O"));
// {Mg: 1, O: 2, H: 2}
// console.log(parseMolecule("Mg(OH)2"));
// {K: 4, O: 14, N: 2, S: 4}
// console.log(parseMolecule("K4[ON(SO3)2]2"));
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

//  ❗️❗️❗️ REFACTOR, SLOW ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// ❗️❗️❗️ Timed Out Passed: 9 Failed: 1+ ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: JOSEPHUS SURVIVOR
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
In this kata you have to correctly return who is the "survivor", ie: the last element of a Josephus permutation.

Basically you have to assume that n people are put into a circle and that they are eliminated in steps of k elements, like this:

josephus_survivor(7,3) => means 7 people in a circle;
one every 3 is eliminated until one remains
[1,2,3,4,5,6,7] - initial sequence
[1,2,4,5,6,7] => 3 is counted out
[1,2,4,5,7] => 6 is counted out
[1,4,5,7] => 2 is counted out
[1,4,5] => 7 is counted out
[1,4] => 5 is counted out
[4] => 1 counted out, 4 is the last element - the survivor!
The above link about the "base" kata description will give you a more thorough insight about the origin of this kind of permutation, but basically that's all that there is to know to solve this kata.

Notes and tips: using the solution to the other kata to check your function may be helpful, but as much larger numbers will be used, using an array/list to compute the number of the survivor may be too slow; you may assume that both n and k will always be >=1.
*/

const josephusSurvivor = (num: number, gap: number): number => {
    // if (num === 1) return num;

    let items: number[] = [];
    for (let i = 1; i <= num; i += 1) {
        items.push(i);
    }
    console.log(items);

    // let targetIdx: number = gap > seqArr.length
    //     ? gap % seqArr.length - 1
    //     : gap - 1;

    // console.log("targetIdx:", targetIdx);

    // INITIALIZE SEQ ARR WITH COPY OF ITEMS
    let solutionArr: number[] = [],
        seqArr: number[] = [...items];
    // CONUNT VALID STEPS (IGNORE DEAD)
    let validSteps: number = 0;

    // LOOP THROUGH SEQ ARR
    for (let i = 0; i < seqArr.length; i += 1) {
        // INCREMENT VALID STEPS IF ELEMENT IS ALIVE
        if (!solutionArr.includes(seqArr[i])) validSteps += 1;
        // IF VALD STEPS === GAP (EVERY NTH), PUSH CURRENT AND RESET VALIDSTEPS
        if (validSteps === gap) {
            solutionArr.push(seqArr[i]);
            validSteps = 0;
        }
        // STOP LOOP IF EVERY ELEMENT HAS BEEN SELECTED
        if (solutionArr.length === items.length) break;
        // IF LOOP REACHES LENGTH OF ITEMS, CONCAT ANOTHER COPY TO EXTEND SEQUENCE
        if (i === seqArr.length - 1) seqArr = seqArr.concat(items);
    }

    return solutionArr[solutionArr.length - 1];

    // return 1;
};

//  4
// console.log(josephusSurvivor(7, 3));
// 10
// ❗️❗️❗️
// console.log(josephusSurvivor(11, 19));
// console.log(josephusSurvivor(7, 8));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ REFACTOR: DELETE CURRENT ITEM TO ELEMINATE SEQ ARR ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: FOSEPHUS PERMUTATION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
This problem takes its name by arguably the most important event in the life of the ancient historian Josephus: according to his tale, he and his 40 soldiers were trapped in a cave by the Romans during a siege.

Refusing to surrender to the enemy, they instead opted for mass suicide, with a twist: they formed a circle and proceeded to kill one man every three, until one last man was left (and that it was supposed to kill himself to end the act).

Well, Josephus and another man were the last two and, as we now know every detail of the story, you may have correctly guessed that they didn't exactly follow through the original idea.

You are now to create a function that returns a Josephus permutation, taking as parameters the initial array/list of items to be permuted as if they were in a circle and counted out every k places until none remained.

Tips and notes: it helps to start counting from 1 up to n, instead of the usual range 0..n-1; k will always be >=1.

For example, with n=7 and k=3 josephus(7,3) should act this way.

[1,2,3,4,5,6,7] - initial sequence
[1,2,4,5,6,7] => 3 is counted out and goes into the result [3]
[1,2,4,5,7] => 6 is counted out and goes into the result [3,6]
[1,4,5,7] => 2 is counted out and goes into the result [3,6,2]
[1,4,5] => 7 is counted out and goes into the result [3,6,2,7]
[1,4] => 5 is counted out and goes into the result [3,6,2,7,5]
[4] => 1 is counted out and goes into the result [3,6,2,7,5,1]
[] => 4 is counted out and goes into the result [3,6,2,7,5,1,4]
So our final result is:

josephus([1,2,3,4,5,6,7],3)==[3,6,2,7,5,1,4]
*/

// 2️⃣ SECOND SOLUTION, DYNAMIC SEQ ARR LENGTH !!!
const josephus2 = (items: any[], gap: number): any[] => {
    if (items.length === 1) return items;
    // INITIALIZE SEQ ARR WITH COPY OF ITEMS
    let solutionArr: any[] = [],
        seqArr: any[] = [...items];
    // CONUNT VALID STEPS (IGNORE DEAD)
    let validSteps: number = 0;

    // LOOP THROUGH SEQ ARR
    for (let i = 0; i < seqArr.length; i += 1) {
        // INCREMENT VALID STEPS IF ELEMENT IS ALIVE
        if (!solutionArr.includes(seqArr[i])) validSteps += 1;
        // IF VALD STEPS === GAP (EVERY NTH), PUSH CURRENT AND RESET VALIDSTEPS
        if (validSteps === gap) {
            solutionArr.push(seqArr[i]);
            validSteps = 0;
        }
        // STOP LOOP IF EVERY ELEMENT HAS BEEN SELECTED
        if (solutionArr.length === items.length) break;
        // IF LOOP REACHES LENGTH OF ITEMS, CONCAT ANOTHER COPY TO EXTEND SEQUENCE
        if (i === seqArr.length - 1) seqArr = seqArr.concat(items);
    }

    return solutionArr;
};

//   [3, 6, 2, 7, 5, 1, 4]
// console.log(josephus2([1, 2, 3, 4, 5, 6, 7], 3));
// console.log(josephus2([1, 2, 3, 4, 5, 6, 7], 10));
// console.log(josephus2([4, 5, 7, 1], 3));
// [1,2,3,4,5,6,7,8,9,10]
// console.log(josephus2([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1));
// [2, 4, 6, 8, 10, 3, 7, 1, 9, 5]
// console.log(josephus2([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2));
// ['e', 's', 'W', 'o', 'C', 'd', 'r', 'a']
// console.log(josephus2(["C", "o", "d", "e", "W", "a", "r", "s"], 4));
// []
// console.log(josephus2([], 3));
// [ 5, 1, 3, 4, 2 ]
// console.log(josephus2([1, 2, 3, 4, 5], 5));

// 1️⃣  FIRST SOLUTION, UNUSED CODE, HARD CODED SEQ ARR LENGTH !!!
const josephus3 = (items: any[], gap: number): any[] => {
    if (items.length === 1) return items;
    // NUMBER OF VALID STEPS TO NEXT ITEM
    // const validGap: number = gap <= items.length
    //     ? gap
    //     : gap % items.length;
    // console.log(validGap);

    let solutionArr: any[] = [],
        sequenceArr: any[] = [];

    for (let i = 0; i < items.length * 40; i += 1) {
        sequenceArr = sequenceArr.concat(items);
    }

    let validSteps: number = 0;

    for (let i = 0; i < sequenceArr.length; i += 1) {
        // console.log("CYCLE COUNT: ", i)
        // for (let i = 0; i < 49; i += 1) {
        if (!solutionArr.includes(sequenceArr[i])) {
            validSteps += 1;
        }
        if (validSteps === gap) {
            solutionArr.push(sequenceArr[i]);
            validSteps = 0;
        }
        if (solutionArr.length === items.length) break;
    }
    return solutionArr;
};

//   [3, 6, 2, 7, 5, 1, 4]
// console.log(josephus3([1, 2, 3, 4, 5, 6, 7], 3));
// console.log(josephus3([1, 2, 3, 4, 5, 6, 7], 10));
// console.log(josephus3([4, 5, 7, 1], 3));
// [1,2,3,4,5,6,7,8,9,10]
// console.log(josephus3([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1));
// [2, 4, 6, 8, 10, 3, 7, 1, 9, 5]
// console.log(josephus3([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2));
// ['e', 's', 'W', 'o', 'C', 'd', 'r', 'a']
// console.log(josephus3(["C", "o", "d", "e", "W", "a", "r", "s"], 4));
// []
// console.log(josephus3([], 3));
// [ 5, 1, 3, 4, 2 ]
// console.log(josephus3([1, 2, 3, 4, 5], 5));

//============= OTHER CODEWARS SOLUTIONS: =============

const josephus4 = (items: any[], k: number): any[] => {
    let lst: any[] = [];
    let i: number = (k - 1) % items.length;
    while (items.length) {
        lst.push(items[i]);
        items.splice(i, 1);
        i = (i + k - 1) % items.length;
    }
    return lst;
};

const josephus5 = (items: any[], k: number): any[] => {
    const alive = [...items];
    const dead = [];
    let i = (k - 1) % alive.length;

    while (alive.length) {
        const killed = alive.splice(i, 1);
        dead.push(...killed);
        i = (i + k - 1) % alive.length;
    }

    return dead;
};

function josephus6(items: any[], k: number): any[] {
    const result = [];

    while (items.length > 0) {
        for (let skip = 1; skip < k; skip++) {
            items.push(items.shift());
        }
        result.push(items.shift());
    }

    return result;
}

const josephus7 = (items: any[], k: number): any[] => {
    let result: any[] = [];
    let currentIndex: number = 1;

    while (items.length > 0) {
        currentIndex = currentIndex + k - 1;
        while (currentIndex > items.length) {
            currentIndex = currentIndex - items.length;
        }

        result.push(items[currentIndex - 1]);
        items.splice(currentIndex - 1, 1);
    }
    return result;
};

const josephus8 = (items: any[], k: number): any[] => {
    let res = [];
    let i = (k - 1) % items.length;
    while (items.length) {
        res.push(items[i]);
        items.splice(i, 1);
        i = (i + k - 1) % items.length;
    }
    return res;
};
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES (REPLACE) ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: COMMON DENOMINATORS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: EVERY(), SET(),  ❗️❗️❗️ REPLACE(PERFORM MATH OPERATIONS ON NUMERIC STRINGS)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Common denominators
 
You will have a list of rationals in the form
 
{ {numer_1, denom_1} , ... {numer_n, denom_n} } 
or
[ [numer_1, denom_1] , ... [numer_n, denom_n] ] 
or
[ (numer_1, denom_1) , ... (numer_n, denom_n) ] 
where all numbers are positive ints. You have to produce a result in the form:
 
(N_1, D) ... (N_n, D) 
or
[ [N_1, D] ... [N_n, D] ] 
or
[ (N_1', D) , ... (N_n, D) ] 
or
{{N_1, D} ... {N_n, D}} 
or
"(N_1, D) ... (N_n, D)"
depending on the language (See Example tests) in which D is as small as possible and
 
N_1/D == numer_1/denom_1 ... N_n/D == numer_n,/denom_n.
Example:
convertFracs [(1, 2), (1, 3), (1, 4)] `shouldBe` [(6, 12), (4, 12), (3, 12)]
Note:
Due to the fact that the first translations were written long ago - more than 6 years - these first translations have only irreducible fractions.
 
Newer translations have some reducible fractions. To be on the safe side it is better to do a bit more work by simplifying fractions even if they don't have to be.
*/
const convertFrac = (list: [number, number][]): string => {
    let solution: string = "";
    let denomsArr: number[] = [];
    // FIND COMMON DENOMINATOR
    list.forEach((frac) => {
        denomsArr.push(frac[1]);
    });
    // console.log("denomsArr: ", denomsArr);
    // denomsArr:  [ 2, 5, 4, 9, 10 ]

    let commDenom: number = 0;
    let i = Math.max(...denomsArr);
    while (true) {
        if (denomsArr.every((denom) => i % denom === 0)) {
            commDenom = i;
            break;
        }
        i++;
    }
    // console.log("common denom: ", commDenom);
    // common denom:  180

    // SET FOR ALL UNIQUE COMPONENTS (FURTHER REDUCTION OF FRACTIONS)
    const uniqueComps = new Set<number>();

    list.forEach((frac) => {
        // (90,180) AND SO ON...
        solution += `(${frac[0] * (commDenom / frac[1])},${commDenom})`;
        uniqueComps.add(frac[0] * (commDenom / frac[1]));
    });
    // console.log(uniqueComps);
    // Set(5) { 90, 144, 135, 120, 126 }

    // SIMPLIFY FRACTIONS IF POSSIBLE (FIND COMMON DIVIDER FOR ALL COMPONENTS)
    let simplifiedSolution: string = "";
    // ADD COMMON DENOMINATOR TO SET
    uniqueComps.add(commDenom);
    // MAKE ARRAY FROM SET FOR ARRAY METHOD EVERY
    const allCompsArr: number[] = Array.from(uniqueComps);
    // console.log("allCompsArr: ", allCompsArr);
    // allCompsArr:  [ 90, 144, 135, 120, 126, 180 ]
    for (let i = 2; i <= commDenom / 2; i++) {
        if (allCompsArr.every((comp) => comp % i === 0)) {
            // ❗️❗️❗️ REPLACE EVERY NUMBER IN STRING WITH ITSELF DIVIDED BY i (COMMON DIVIDER)
            simplifiedSolution = solution.replace(/\d+/g, (num: string) =>
                (Number(num) / i).toString()
            );
        }
    }

    // console.log("simplifiedSolution: ", simplifiedSolution);
    // simplifiedSolution:  (30,60)(48,60)(45,60)(40,60)(42,60)

    // IF SIMPLIFIED SOLUTION EXIST, RETURN IT, OTHERWISE RETURN SOLUTION
    return simplifiedSolution ? simplifiedSolution : solution;
};

// "(6,12)(4,12)(3,12)"
// console.log(convertFrac([[1, 2], [1, 3], [1, 4]]));
// ============================================================
// ❗️❗️❗️ SOLUTION:
// '(90,180)(144,180)(135,180)(120,180)(126,180)'
//  ❗️❗️❗️ SIMPLIFIED SOLUTION:
// '(30,60) (48,60)  (45,60)  (40,60)  (42,60)'
// console.log(convertFrac([[1, 2], [4, 5], [3, 4], [6, 9], [7, 10]]));
// ============================================================

// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
const convertFrac2 = (lst: [number, number][]): string => {
    const gcd = (a: number, b: number): number => (b ? gcd(b, a % b) : a);
    const lcm = (a: number, b: number): number => (a * b) / gcd(a, b);
    const cd = lst.reduce((a, [_, d]) => lcm(d, a), 1);
    const lcd = lst.reduce((d, [a, c]) => gcd(d, (a * cd) / c), cd);
    return lst.map(([n, d]) => `(${(n * cd) / d / lcd},${cd / lcd})`).join("");
};
// ============================================================

const gcd = (x: number, y: number): number => {
    while (y != 0) {
        const z = x % y;
        x = y;
        y = z;
    }

    return x;
};

const lcm = (x: number, y: number): number => (x * y) / gcd(x, y);

const convertFrac3 = (lst: [number, number][]): string => {
    const common = lst.map(([x, y]) => y).reduce(lcm, 1);

    const acc = lst.map(([x, y]) => x * (common / y));

    const least = acc.reduce(gcd, common);

    return acc.map((x) => `(${x / least},${common / least})`).join("");
};
// ============================================================
const findGcd = (a: number, b: number): number => (b ? findGcd(b, a % b) : a);

const findLcm = (a: number, b: number): number => (a * b) / findGcd(a, b);

const findLcmOfList = (arr: number[]): number =>
    arr.reduce((lcm, num) => findLcm(lcm, num), 1);

const simplify = (a: number, b: number): [number, number] => {
    const gcd = findGcd(a, b);
    return gcd === 1 ? [a, b] : [a / gcd, b / gcd];
};

export const convertFrac4 = (lst: [number, number][]): string => {
    let denoms: number[] = [];
    const list = lst.map(([n0, n1]) => {
        const simpleArr = simplify(n0, n1);
        denoms.push(simpleArr[1]);
        return simpleArr;
    });

    const lcm = findLcmOfList(denoms);

    return list.reduce(
        (result, [n0, n1]) => `${result}(${(n0 * lcm) / n1},${lcm})`,
        ""
    );
};
// ============================================================
interface IFactorized {
    [key: number]: number;
}

export const convertFrac5 = (lst: [number, number][]): string => {
    if (lst.length == 0) return "";
    const getPrimes = function (maxNum: number) {
        const candidates: boolean[] = Array.from(
            { length: maxNum },
            (i) => true
        );
        const maxi = Math.floor(Math.sqrt(maxNum));
        for (let i = 2; i <= maxi; i++) {
            if (candidates[i]) {
                const sqi = i * i;
                for (let k = 0; ; k++) {
                    const j = sqi + i * k;
                    if (j > maxNum) break;
                    candidates[j] = false;
                }
            }
        }
        const primes: number[] = [];
        for (let i = 2; i < candidates.length; i++) {
            if (candidates[i]) {
                primes.push(i);
            }
        }
        return primes;
    };
    const max_denom = lst
        .map((i) => i[1])
        .reduce((carry, item) => {
            if (carry < item) return item;
            return carry;
        });
    const primes = getPrimes(max_denom + 1);
    const factorize = function (num: number) {
        const res: IFactorized = {};
        primes.forEach((prime) => {
            let cnt = 0;
            while (num > 1) {
                if (num % prime === 0) {
                    num = Math.floor(num / prime);
                    cnt++;
                } else {
                    break;
                }
            }
            if (cnt > 0) res[prime] = cnt;
        });
        return res;
    };
    const simplified_lst = lst.map((item) => {
        const fnum = factorize(item[0]);
        const fdenom = factorize(item[1]);
        const cfactors: IFactorized = {};
        Object.keys(fnum).forEach((prime) => {
            if (fdenom[parseInt(prime)]) {
                cfactors[parseInt(prime)] =
                    fnum[parseInt(prime)] <= fdenom[parseInt(prime)]
                        ? fnum[parseInt(prime)]
                        : fdenom[parseInt(prime)];
            }
        });
        const div = Object.keys(cfactors).reduce((carry, prime) => {
            return carry * Math.pow(parseInt(prime), cfactors[parseInt(prime)]);
        }, 1);
        return [Math.floor(item[0] / div), Math.floor(item[1]) / div];
    });
    const fdenoms: IFactorized[] = simplified_lst.map((item) => {
        return factorize(item[1]);
    });
    const lcm_factors: IFactorized = {};
    for (const factors of fdenoms) {
        for (const prime in factors) {
            if (lcm_factors[parseInt(prime)]) {
                if (factors[parseInt(prime)] > lcm_factors[parseInt(prime)])
                    lcm_factors[parseInt(prime)] = factors[parseInt(prime)];
            } else {
                lcm_factors[parseInt(prime)] = factors[parseInt(prime)];
            }
        }
    }
    const lcd = Object.keys(lcm_factors).reduce((carry, prime) => {
        return carry * Math.pow(parseInt(prime), lcm_factors[parseInt(prime)]);
    }, 1);
    return simplified_lst
        .map((item) => {
            const num = Math.floor((item[0] * lcd) / item[1]);
            return `(${num},${lcd})`;
        })
        .join("");
};
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: MY SMALLEST CODE INTERPRETER (aka Brainf**k)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Inspired from real-world Brainf**k, we want to create an interpreter of that language which will support the following instructions:
 
> increment the data pointer (to point to the next cell to the right).
< decrement the data pointer (to point to the next cell to the left).
+ increment (increase by one, truncate overflow: 255 + 1 = 0) the byte at the data pointer.
- decrement (decrease by one, treat as unsigned byte: 0 - 1 = 255 ) the byte at the data pointer.
. output the byte at the data pointer.
, accept one byte of input, storing its value in the byte at the data pointer.
[ if the byte at the data pointer is zero, then instead of moving the instruction pointer forward to the next command, jump it forward to the command after the matching ] command.
] if the byte at the data pointer is nonzero, then instead of moving the instruction pointer forward to the next command, jump it back to the command after the matching [ command.
The function will take in input...
 
the program code, a string with the sequence of machine instructions,
the program input, a string, possibly empty, that will be interpreted as an array of bytes using each character's ASCII code and will be consumed by the , instruction
... and will return ...
 
the output of the interpreted code (always as a string), produced by the . instruction.
Implementation-specific details for this Kata:
 
Your memory tape should be large enough - the original implementation had 30,000 cells but a few thousand should suffice for this Kata
Each cell should hold an unsigned byte with wrapping behavior (i.e. 255 + 1 = 0, 0 - 1 = 255), initialized to 0
The memory pointer should initially point to a cell in the tape with a sufficient number (e.g. a few thousand or more) of cells to its right. For convenience, you may want to have it point to the leftmost cell initially
You may assume that the , command will never be invoked when the input stream is exhausted
Error-handling, e.g. unmatched square brackets and/or memory pointer going past the leftmost cell is not required in this Kata. If you see test cases that require you to perform error-handling then please open an Issue in the Discourse for this Kata (don't forget to state which programming language you are attempting this Kata in).
*/

function brainLuck(code: string, input: string) {
    // return output;
}

// 'Codewars'
// console.log(brainLuck(',+[-.,+]','Codewars'+String.fromCharCode(255)));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️  SOLUTION NOT WORKING IN IDE ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: CHAIN ADDING FUNCTION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ VALUEOF
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
We want to create a function that will add numbers together when called in succession.
 
add(1)(2); // == 3
We also want to be able to continue to add numbers to our chain.
 
add(1)(2)(3); // == 6
add(1)(2)(3)(4); //  == 10
add(1)(2)(3)(4)(5); // == 15
and so on.
 
A single call should be equal to the number passed in.
 
add(1); // == 1
We should be able to store the returned values and reuse them.
 
var addTwo = add(2);
addTwo; // == 2
addTwo + 5; // == 7
addTwo(3); // == 5
addTwo(3)(5); // == 10
We can assume any number being passed in will be valid whole number.
*/

// ❗️❗️❗️  SOLUTION NOT WORKING IN IDE ❗️❗️❗️
// [Function: sum] { valueOf: [Function (anonymous)] }

function add(n: number): any {
    const sum = function (y: number) {
        return add(n + y);
    };
    // ❗️❗️❗️
    sum.valueOf = function () {
        return n;
    };

    return sum;
}
// 15
// add(1)(2)(3)(4)(5);
// console.log(add(1)(2)(3)(4)(5));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
function add2(x: number): any {
    const fn = (y: number) => add(x + y);
    fn.valueOf = () => x;
    return fn;
}

function add3(x: number): any {
    // receives the next number in the sequence
    const addNum = (next: any) => {
        // returns the outer function, with cumulative number so far as the argument
        return add(x + next);
    };

    // sets value of method of inner function to return value of x for final number
    addNum.valueOf = () => {
        return x;
    };

    // returns addNum function which will be called with next number as argument
    return addNum;
}

/**
 * Calculates the sum of numbers.
 *
 * @param x number
 * @returns number
 * The sum of numbers using closures.
 */
function add4(x: number): any {
    let currentSum: number = x;

    function f(y: number): any {
        if (typeof y === "number") {
            currentSum += y;
            return f;
        }
    }

    // "f" is a function object and should include "toString" method.
    f.toString = function (): any {
        return currentSum;
    };

    return f;
}

function add5(n: number): any {
    return Object.assign((i: any) => add(i + n), { valueOf: () => n });
}

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: IS MY FRIEND CHEATING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A friend of mine takes the sequence of all numbers from 1 to n (where n > 0).
Within that sequence, he chooses two numbers, a and b.
He says that the product of a and b should be equal to the sum of all numbers in the sequence, excluding a and b.
Given a number n, could you tell me the numbers he excluded from the sequence?
The function takes the parameter: n (n is always strictly greater than 0) and returns an array or a string (depending on the language) of the form:
 
[(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or or [{a, b}, ...]
with all (a, b) which are the possible removed numbers in the sequence 1 to n.
 
[(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or ... will be sorted in increasing order of the "a".
 
It happens that there are several possible (a, b). The function returns an empty array (or an empty string) if no possible numbers are found which will prove that my friend has not told the truth! (Go: in this case return nil).
 
Examples:
removNb(26) should return [(15, 21), (21, 15)]
or
removNb(26) should return { {15, 21}, {21, 15} }
or
removeNb(26) should return [[15, 21], [21, 15]]
or
removNb(26) should return [ {15, 21}, {21, 15} ]
or
removNb(26) should return "15 21, 21 15"
or
 
in C:
removNb(26) should return  {{15, 21}{21, 15}} tested by way of strings.
Function removNb should return a pointer to an allocated array of Pair pointers, each one also allocated. 
Note
See examples of returns for each language in "RUN SAMPLE TESTS"
*/

class G965 {
    public static removeNb(n: number) {
        // your code
    }
}

// [[15,21],[21,15]]
// console.log(removeNb(26));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ NOT WORKING IN CODEWARS, FLATMAP GIVES ERROR ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: BEST TRAVEL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: FLATMAP()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: ❗️❗️❗️ https://stackoverflow.com/questions/9960908/permutations-in-javascript
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
John and Mary want to travel between a few towns A, B, C ... Mary has on a sheet of paper a list of distances between these towns. ls = [50, 55, 57, 58, 60]. John is tired of driving and he says to Mary that he doesn't want to drive more than t = 174 miles and he will visit only 3 towns.
 
Which distances, hence which towns, they will choose so that the sum of the distances is the biggest possible to please Mary and John?
 
Example:
With list ls and 3 towns to visit they can make a choice between: [50,55,57],[50,55,58],[50,55,60],[50,57,58],[50,57,60],[50,58,60],[55,57,58],[55,57,60],[55,58,60],[57,58,60].
 
The sums of distances are then: 162, 163, 165, 165, 167, 168, 170, 172, 173, 175.
 
The biggest possible sum taking a limit of 174 into account is then 173 and the distances of the 3 corresponding towns is [55, 58, 60].
 
The function chooseBestSum (or choose_best_sum or ... depending on the language) will take as parameters t (maximum sum of distances, integer >= 0), k (number of towns to visit, k >= 1) and ls (list of distances, all distances are positive or zero integers and this list has at least one element). The function returns the "best" sum ie the biggest possible sum of k distances less than or equal to the given limit t, if that sum exists, or otherwise nil, null, None, Nothing, depending on the language. In that case with C, C++, D, Dart, Fortran, F#, Go, Julia, Kotlin, Nim, OCaml, Pascal, Perl, PowerShell, Reason, Rust, Scala, Shell, Swift return -1.
 
Examples:
ts = [50, 55, 56, 57, 58] choose_best_sum(163, 3, ts) -> 163
 
xs = [50] choose_best_sum(163, 3, xs) -> nil (or null or ... or -1 (C++, C, D, Rust, Swift, Go, ...)
 
ys = [91, 74, 73, 85, 73, 81, 87] choose_best_sum(230, 3, ys) -> 228
 
Notes:
try not to modify the input list of distances ls
in some languages this "list" is in fact a string (see the Sample Tests).
*/

const chooseBestSum = (
    maxDist: number,
    numTowns: number,
    list: number[]
): number | null => {
    // if ()

    const generatePermutations = (
        list: number[],
        size = list.length
    ): number[][] => {
        if (size > list.length) return [];
        else if (size == 1) return list.map((d) => [d]);
        return list.flatMap((d) =>
            generatePermutations(
                list.filter((a) => a !== d),
                size - 1
            ).map((item) => [d, ...item])
        );
    };

    const allPermutations: number[][] = generatePermutations(list, numTowns);
    console.log(allPermutations);
    const allDistances: number[] = allPermutations.map((arr) => {
        return arr.reduce((acc, curr) => acc + curr);
    });
    console.log(allDistances);
    const distsInRange: number[] = allDistances.filter(
        (dist) => dist <= maxDist
    );
    console.log(distsInRange);
    const solution: number = Math.max(...distsInRange, 0);
    console.log(solution);
    return solution ? solution : null;
};

//   163
// console.log(chooseBestSum(163, 3, [50, 55, 56, 57, 58]));
// 50
// console.log(chooseBestSum(163, 3, [50]));
// console.log();
// console.log();

/*
❗️❗️❗️ THIS WILL GIVE ALL THE PERMUTATIONS, DUPLICATES WILL OCCUR ❗️❗️❗️
❗️❗️❗️ SOURCE: https://stackoverflow.com/questions/9960908/permutations-in-javascript
 
Here's a very concise and recursive solution that allows you to input the size of the output permutations similar to the statistical operator nPr. "5 permutation 3". This allows you to get all possible permutations with a specific size.
 
function generatePermutations(list, size=list.length) {
    if (size > list.length) return [];
    else if (size == 1) return list.map(d=>[d]); 
    return list.flatMap(d => generatePermutations(list.filter(a => a !== d), size - 1).map(item => [d, ...item]));
}
generatePermutations([1,2,3])
 
[[1, 2, 3],[1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
generatePermutations([1,2,3],2)
 
[[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]
 
OUTPUT EXAMPLE:
 
[
  [ 50, 55, 56 ], [ 50, 55, 57 ], [ 50, 55, 58 ],
  [ 50, 56, 55 ], [ 50, 56, 57 ], [ 50, 56, 58 ],
  [ 50, 57, 55 ], [ 50, 57, 56 ], [ 50, 57, 58 ],
  [ 50, 58, 55 ], [ 50, 58, 56 ], [ 50, 58, 57 ],
  [ 55, 50, 56 ], [ 55, 50, 57 ], [ 55, 50, 58 ],
  [ 55, 56, 50 ], [ 55, 56, 57 ], [ 55, 56, 58 ],
  [ 55, 57, 50 ], [ 55, 57, 56 ], [ 55, 57, 58 ],
  [ 55, 58, 50 ], [ 55, 58, 56 ], [ 55, 58, 57 ],
  [ 56, 50, 55 ], [ 56, 50, 57 ], [ 56, 50, 58 ],
  [ 56, 55, 50 ], [ 56, 55, 57 ], [ 56, 55, 58 ],
  [ 56, 57, 50 ], [ 56, 57, 55 ], [ 56, 57, 58 ],
  [ 56, 58, 50 ], [ 56, 58, 55 ], [ 56, 58, 57 ],
  [ 57, 50, 55 ], [ 57, 50, 56 ], [ 57, 50, 58 ],
  [ 57, 55, 50 ], [ 57, 55, 56 ], [ 57, 55, 58 ],
  [ 57, 56, 50 ], [ 57, 56, 55 ], [ 57, 56, 58 ],
  [ 57, 58, 50 ], [ 57, 58, 55 ], [ 57, 58, 56 ],
  [ 58, 50, 55 ], [ 58, 50, 56 ], [ 58, 50, 57 ],
  [ 58, 55, 50 ], [ 58, 55, 56 ], [ 58, 55, 57 ],
  [ 58, 56, 50 ], [ 58, 56, 55 ], [ 58, 56, 57 ],
  [ 58, 57, 50 ], [ 58, 57, 55 ], [ 58, 57, 56 ]
]
[
  161, 162, 163, 161, 163, 164, 162, 163, 165,
  163, 164, 165, 161, 162, 163, 161, 168, 169,
  162, 168, 170, 163, 169, 170, 161, 163, 164,
  161, 168, 169, 163, 168, 171, 164, 169, 171,
  162, 163, 165, 162, 168, 170, 163, 168, 171,
  165, 170, 171, 163, 164, 165, 163, 169, 170,
  164, 169, 171, 165, 170, 171
]
[
  161, 162, 163, 161, 163,
  162, 163, 163, 161, 162,
  163, 161, 162, 163, 161,
  163, 161, 163, 162, 163,
  162, 163, 163, 163
]
163
*/

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ TRY TO REFACTOR OTHER PRIME CHALLENGES ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  GAP IN PRIMES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: PRIME NUMNERS, ISPRIME(),
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The prime numbers are not regularly spaced. For example from 2 to 3 the gap is 1. From 3 to 5 the gap is 2. From 7 to 11 it is 4. Between 2 and 50 we have the following pairs of 2-gaps primes: 3-5, 5-7, 11-13, 17-19, 29-31, 41-43
 
A prime gap of length n is a run of n-1 consecutive composite numbers between two successive primes (see: http://mathworld.wolfram.com/PrimeGaps.html).
 
We will write a function gap with parameters:
 
g (integer >= 2) which indicates the gap we are looking for
 
m (integer > 2) which gives the start of the search (m inclusive)
 
n (integer >= m) which gives the end of the search (n inclusive)
 
n won't go beyond 1100000.
 
In the example above gap(2, 3, 50) will return [3, 5] or (3, 5) or {3, 5} which is the first pair between 3 and 50 with a 2-gap.
 
So this function should return the first pair of two prime numbers spaced with a gap of g between the limits m, n if these numbers exist otherwise `nil or null or None or Nothing (or ... depending on the language).
 
In such a case (no pair of prime numbers with a gap of `g`)
In C: return [0, 0]
In C++, Lua, COBOL: return `{0, 0}`. 
In F#: return `[||]`. 
In Kotlin, Dart and Prolog: return `[]`.
In Pascal: return Type TGap (0, 0).
Examples:
- gap(2, 5, 7) --> [5, 7] or (5, 7) or {5, 7}
 
gap(2, 5, 5) --> nil. In C++ {0, 0}. In F# [||]. In Kotlin, Dart and Prolog return []`
 
gap(4, 130, 200) --> [163, 167] or (163, 167) or {163, 167}
 
([193, 197] is also such a 4-gap primes between 130 and 200 but it's not the first pair)
 
gap(6,100,110) --> nil or {0, 0} or ... : between 100 and 110 we have 101, 103, 107, 109 but 101-107is not a 6-gap because there is 103in between and 103-109is not a 6-gap because there is 107in between.
 
You can see more examples of return in Sample Tests.
 
Note for Go
For Go: nil slice is expected when there are no gap between m and n. Example: gap(11,30000,100000) --> nil
 
Ref
https://en.wikipedia.org/wiki/Prime_gap
*/

class G964b {
    public static gap = (gap: number, min: number, max: number): number[] => {
        let solution: number[] = [];
        let primesArr: number[] = [];
        // THIS WILL BE ALL THE POSSIBLE MATCHES WHICH IS NOT NECESSARY AS WE HAVE TO RETURN THE FIRST MATCH
        let allMatchesArr: [number, number][] = [];

        // GET ALL PRIMES WITHIN RANGE (MIN - MAX)

        // ISPRIME() FROM PREVIOUS CODEWARS EXAMPLE
        // const isPrime = (num: number) => {
        //     if (num === 1 || num === 2) return true;
        //     for (let i = 2; i < num; i++) {
        //         // console.table({num: num, divider: i});
        //         if (num % i === 0) return false;
        //     }
        //     return true;
        // };
        const isPrime = (num: number) => {
            for (let i = 2; i <= Math.sqrt(num); i++) {
                if (num % i === 0) {
                    return false;
                }
            }
            return true;
        };

        //   FIND PRIMES RANGING FROM 2 TO HALF OF NUM
        for (let i = min; i <= max; i++) {
            let prime = 0;
            if (isPrime(i)) {
                prime = i;
                // console.log("prime found: ", prime);

                primesArr.push(prime);
            }
        }
        // [ 101, 103, 107, 109 ]
        console.log(primesArr);
        // LOOP OVER PRIMES ARRAY (AND GET GAPS)
        // [ 2, 4, 2, NaN ] ❗️❗️❗️ LAST EL WILL BE NAN BECAUSE primesArr[idx + 1] IS UNDEFINE FOR THE LAST ELEMENT ❗️❗️❗️
        const gapsArr: number[] = primesArr.map((el, idx) => {
            if (primesArr[idx + 1] - el === gap) {
                console.log("match found");
                allMatchesArr.push([el, primesArr[idx + 1]]);
            }
            return primesArr[idx + 1] - el;
        });
        // .slice(0, -1);   // ❗️❗️❗️ [ 2, 4, 2 ]  RETURN NEW ARRAY WITHOUT LAST ELEMENT (NAN)

        console.table({
            primesArr: primesArr,
            "gaps arr: ": gapsArr,
            allMatchesArr: allMatchesArr,
        });

        if (allMatchesArr.length === 0) {
            console.log("empty array");
            return [0, 0];
        }
        //  FIND AND RETURN FIRST GAP MATCH
        solution = allMatchesArr[0];
        return solution;
    };
}

/*
G964b.gap(2, 100, 110) LOGS:
 
┌───────────────┬──────────────┬──────────────┬─────┬─────┐
│    (index)    │      0       │      1       │  2  │  3  │
├───────────────┼──────────────┼──────────────┼─────┼─────┤
│   primesArr   │     101      │     103      │ 107 │ 109 │
│  gaps arr:    │      2       │      4       │  2  │ NaN │
│ allMatchesArr │ [ 101, 103 ] │ [ 107, 109 ] │     │     │
└───────────────┴──────────────┴──────────────┴─────┴─────┘
[ 101, 103 ]
 
*/

// [ 101, 103 ]
// console.log(G964b.gap(2, 100, 110));
// console.log(G964b.gap(6, 100, 110));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
class G964b1 {
    public static gap = (g: number, m: number, n: number) => {
        let lower = 0;
        for (let i = m; i < n; i++) {
            if (G964b1.isPrime(i)) {
                if (lower === 0 || i - lower !== g) {
                    lower = i;
                } else {
                    return [lower, i];
                }
            }
        }
        return null;
    };

    private static isPrime(n: number) {
        for (let i = 2; i < n; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
}

// class G964b2 {

//     public static gap = (g:number, m:number, n:number):number[] => {
//       let store:number;
//       for (let i = m; i <= n; i++) {
//         if (G964b2.isPrime(i)) {
//           if (i - store === g) {return [store, i]}
//           else {store = i};
//         };
//       }
//       return null;
//     }

//     public static isPrime = (n:number):boolean => {
//       for (let x = Math.floor(Math.sqrt(n)); x > 1; x--) {
//         if (n % x === 0) {return false};
//       }
//       return true;
//     };
//   }

class G964b3 {
    public static gap = (g: number, m: number, n: number) => {
        const primes = [];

        for (let i = m; i < n; i++) {
            let prime = true;
            for (let j = 2; j < i / 2; j++) {
                if (i % j === 0) {
                    prime = false;
                    break;
                }
            }
            if (prime) {
                primes.push(i);
                const length = primes.length;
                if (length > 1) {
                    if (primes[length - 1] - primes[length - 2] === g) {
                        return [primes[length - 2], primes[length - 1]];
                    }
                }
            }
        }
        return null;
    };
}

// ❗️❗️❗️ INCLUDE ISPRIME() IN CODEWARS EXAMPLES ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// ❗️❗️❗️ Execution Timed Out (12000 ms) ❗️❗️❗️ REFACTOR ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PRIMES IN NUMBERS - PRIME FACTOR DECOMPOSITION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: PRIME NUMBERS, ISPRIME(),
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a positive number n > 1 find the prime factor decomposition of n. The result will be a string with the following form :
 
 "(p1**n1)(p2**n2)...(pk**nk)"
with the p(i) in increasing order and n(i) empty if n(i) is 1.
 
Example: n = 86240 should return "(2**5)(5)(7**2)(11)"
 
A prime number is a whole number greater than 1 whose only factors are 1 and itself. A factor is a whole number that can be divided evenly into another number. The first few prime numbers are 2, 3, 5, 7, 11, 13, 17, 19, 23 and 29. Numbers that have more than two factors are called composite numbers.
 
❗️❗️❗️
Prime Factor Decomposition
Quick revise
Prime factor decomposition of a number means writing it as a product of prime factors.
 
To factorise a number, divide it by the first possible prime number.
Take the resulting quotient below the number.
If it is possible, continue dividing this quotient successively by the same prime number.
When you cannot do the division by this prime number, divide it by the next possible prime number.
And so forth until the final quotient is 1.
Finally write this number as a product of powers of prime factors.
Example
 
Find the prime factor decomposition of 36.
 
We look at 36 and try to find numbers which we can divide it by. We can see that it divides by 2.
 
36 = 18 × 2
 
2 is a prime number, but 18 isn't. So we need to split 18 up into prime numbers. We can also divide 18 by 2.
 
18 = 9 × 2
 
and so 36 = 18 × 2 = 9 × 2 × 2
 
But we haven't finished, because 9 is not a prime number. We know that 9 divides by 3.
 
9 = 3 x 3.
 
Hence 36 = 9 × 2 × 2 = 3 × 3 × 2 × 2.
 
This is the answer, because both 2 and 3 are prime numbers.
❗️❗️❗️
*/

// const isPrime = (num: number) => {
//     if (num === 1 || num === 2) return true;
//     for (let i = 2; i < num; i++) {
//         // console.table({num: num, divider: i});
//         if (num % i === 0) return false;
//     }
//     return true;
// };

// MAY HAVE TO USE OBJECT TO COUNT OCCURENCES
const countPrimes = (primes: number[]): string => {
    interface StrKeyVal {
        [key: number]: number;
    }

    const counter: StrKeyVal = {};
    primes.forEach((number) => (counter[number] = (counter[number] || 0) + 1));

    console.log(counter);

    return "hello";
};

// countPrimes([2, 2, 2, 2, 2, 5, 7, 7, 11]);

// console.log(isPrime(5));
// =========================================

const primeFactors = (num: number): string => {
    let factors = [];
    let numRemainder = num;
    let solution: string = "";

    // const isPrime = (num: number) => {
    //     if (num === 1 || num === 2) return true;
    //     for (let i = 2; i < num; i++) {
    //         // console.table({num: num, divider: i});
    //         if (num % i === 0) return false;
    //     }
    //     return true;
    // };

    const isPrime = (num: number) => {
        for (let i = 2; i <= Math.sqrt(num); i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true;
    };

    //   FIND PRIMES RANGING FROM 2 TO HALF OF NUM
    for (let i = 2; i < (num - 1) / 2; i++) {
        let prime = 0;
        if (isPrime(i)) {
            prime = i;
            // console.log("prime found: ", prime);
            while (numRemainder % prime === 0) {
                numRemainder = numRemainder / prime;
                factors.push(prime);
            }
        }
        if (numRemainder === 1) break;
    }
    console.log(factors);
    if (factors.length === 0) return `(${num})`;

    // COUNT OCCURENCES OF ARRAY ELEMENTS WITH LOOP
    let counter: number = 0;
    for (let i = 0; i < factors.length; i++) {
        counter++;
        console.log("counter: ", counter);
        if (factors[i] !== factors[i + 1] && factors[i] !== undefined) {
            console.log("new factor: ", factors[i], i);
            // FORMAT FACTORS AND CONCAT TO SOLUTION HERE
            solution +=
                counter < 2 ? `(${factors[i]})` : `(${factors[i]}**${counter})`;
            // RESET COUNTER
            counter = 0;
        }
    }

    return solution;
};

// (2**2)(3**2)
// console.log(primeFactors(36));
// (2**5)(5)(7**2)(11)
// console.log(primeFactors(86240));
// 7919
// console.log(primeFactors(7919));

// class G964a8 {
//     public static primeFactors = (num: number): string => {
//         // GET PRIME NUMBERS

//         // DIVIDE

//         // return "hello";
//     };
// }

// "(2**5)(5)(7**2)(11)"
// console.log(G964a8.primeFactors(86240));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PERIMETER OF SQUARES IN A RECTANGLE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The drawing shows 6 squares the sides of which have a length of 1, 1, 2, 3, 5, 8. It's easy to see that the sum of the perimeters of these squares is : 4 * (1 + 1 + 2 + 3 + 5 + 8) = 4 * 20 = 80
 
Could you give the sum of the perimeters of all the squares in a rectangle when there are n + 1 squares disposed in the same manner as in the drawing:
 
alternative text
 
Hint:
See Fibonacci sequence
 
Ref:
http://oeis.org/A000045
 
The function perimeter has for parameter n where n + 1 is the number of squares (they are numbered from 0 to n) and returns the total perimeter of all the squares.
 
perimeter(5)  should return 80
perimeter(7)  should return 216
*/

class G964a {
    public static perimeter = (num: number): number => {
        const fibonacciFirstN = (num: number): number[] => {
            const fibSequence: number[] = [1, 1];
            for (let i = 0; i < num - 1; i++) {
                let next = fibSequence[i] + fibSequence[i + 1];
                fibSequence.push(next);
            }
            return fibSequence;
        };

        return 4 * fibonacciFirstN(num).reduce((a, b) => a + b);
    };
}

// 80
// console.log(G964a.perimeter(5));
// 216
// console.log(G964a.perimeter(7));
//
// console.log(G964a.perimeter(3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G964a2 {
    public static perimeter = (n: number) => {
        let numbers = [1, 1];

        for (let i = 2; i <= n; i++) {
            numbers.push(numbers[i - 1] + numbers[i - 2]);
        }

        return 4 * numbers.reduce((curr, acc) => acc + curr, 0);
    };
}

class G964a3 {
    public static perimeter = (n: number) => {
        return (
            Array.from(Array(n + 2).keys())
                .map((e, i, arr) => {
                    if (i > 0) {
                        arr[i + 1] = arr[i] + arr[i - 1];
                        return e;
                    } else {
                        return 1;
                    }
                })
                .slice(1)
                .reduce((a, b) => a + b) * 4
        );
    };
}

class G964a4 {
    // private static memo = (num: number): number => {
    //   let dp = [];
    //   dp[1] = 1;
    //   dp[2] = 1;
    //   for (let i = 3; i <= num; i++) {
    //     dp[i] = dp[i-1] + dp[i-2];
    //   }
    //   return dp.reduce((prev, curr) => prev + curr);
    // }
    // public static perimeter = (n) => {
    //     return 4 * G964.memo(n+1);
    // }
}

class G964a5 {
    public static perimeter = (n: number) => {
        const fibCalc: number[] = [];
        function fibonacci(n: number): number {
            if (fibCalc[n] !== undefined) {
                return fibCalc[n];
            }

            let calc;
            if (n < 2) {
                calc = n;
            } else {
                calc = fibonacci(n - 2) + fibonacci(n - 1);
            }

            fibCalc.push(calc);
            return calc;
        }

        let length = 0;
        for (let i = 0; i <= n + 1; i++) {
            length += 4 * fibonacci(i);
        }
        return length;
    };
}

class G964a6 {
    public static perimeter = (n: number) => {
        // your code
        var sum = 0;
        var first = 0;
        var last = 0;
        for (var i = 1; i <= n + 1; i++) {
            var el = first + last;
            el = el == 0 ? 1 : el;
            first = last;
            last = el;
            sum += el * 4;
        }
        return sum;
    };
}

class G964a7 {
    public static perimeter = (n: number) => {
        let a = 0,
            b = 4,
            sum = 4;
        for (let i = 1; i <= n; i++) {
            const c = a + b;
            (a = b), (b = c), (sum += c);
        }
        return sum;
    };
}

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:  ORDER WEIGHT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
My friend John and I are members of the "Fat to Fit Club (FFC)". John is worried because each month a list with the weights of members is published and each month he is the last on the list which means he is the heaviest.
 
I am the one who establishes the list so I told him: "Don't worry any more, I will modify the order of the list". It was decided to attribute a "weight" to numbers. The weight of a number will be from now on the sum of its digits.
 
For example 99 will have "weight" 18, 100 will have "weight" 1 so in the list 100 will come before 99.
 
Given a string with the weights of FFC members in normal order can you give this string ordered by "weights" of these numbers?
 
Example:
"56 65 74 100 99 68 86 180 90" ordered by numbers weights becomes: 
 
"100 180 90 56 65 74 68 86 99"
When two numbers have the same "weight", let us class them as if they were strings (alphabetical ordering) and not numbers:
 
180 is before 90 since, having the same "weight" (9), it comes before as a string.
 
All numbers in the list are positive numbers and the list can be empty.
 
Notes
it may happen that the input string have leading, trailing whitespaces and more than a unique whitespace between two consecutive numbers
*/

// const orderWeight = (strng: string): string => {
//   }

// console.log(orderWeight("103 123 4444 99 2000"));
// console.log(orderWeight("2000 10003 1234000 44444444 9999 11 11 22 123"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ REFACTOR THIS ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PRODUCT OF CONSECUTIVE FIBONACCI NUMBERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The Fibonacci numbers are the numbers in the following integer sequence (Fn):
 
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ...
 
such as
 
F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
 
Given a number, say prod (for product), we search two Fibonacci numbers F(n) and F(n+1) verifying
 
F(n) * F(n+1) = prod.
 
Your function productFib takes an integer (prod) and returns an array:
 
[F(n), F(n+1), true] or {F(n), F(n+1), 1} or (F(n), F(n+1), True)
depending on the language if F(n) * F(n+1) = prod.
 
If you don't find two consecutive F(n) verifying F(n) * F(n+1) = prodyou will return
 
[F(n), F(n+1), false] or {F(n), F(n+1), 0} or (F(n), F(n+1), False)
F(n) being the smallest one such as F(n) * F(n+1) > prod.
 
Some Examples of Return:
(depend on the language)
 
productFib(714) # should return (21, 34, true), 
                # since F(8) = 21, F(9) = 34 and 714 = 21 * 34
 
productFib(800) # should return (34, 55, false), 
                # since F(8) = 21, F(9) = 34, F(10) = 55 and 21 * 34 < 800 < 34 * 55
-----
productFib(714) # should return [21, 34, true], 
productFib(800) # should return [34, 55, false], 
-----
productFib(714) # should return {21, 34, 1}, 
productFib(800) # should return {34, 55, 0},        
-----
productFib(714) # should return {21, 34, true}, 
productFib(800) # should return {34, 55, false}, 
*/

// 1️⃣ ✅     WHILE LOOP
class G964 {
    public static productFib = (num: number): (number | boolean)[] => {
        let solution: (number | boolean)[] = [];
        const sequence: number[] = [0, 1];
        const products: number[] = [];

        let current: number = 0;

        // ❗️❗️❗️ REFACTOR LOOP ❗️❗️❗️
        while (current <= num) {
            let next = sequence[current] + sequence[current + 1];
            sequence.push(next);
            let product = sequence[current + 1] * sequence[current + 2];
            products.push(product);
            if (product === num) {
                solution = [sequence[current + 1], sequence[current + 2], true];
                break;
            } else if (product > num) {
                solution = [
                    sequence[current + 1],
                    sequence[current + 2],
                    false,
                ];
                break;
            }
            current++;
        }

        return solution;
    };
}

//  INITIALIZE solution / FIBONACCI sequence AND products ARRAYS

//  INITIALIZE current AT 0

//  LOOP OVER INTEGERS UP TO num
//      CALC next ITEM BY ADDING current TO current + 1
//      PUSH next TO sequence
//      CALC CURRENT PRODUCT BY MULTIPLYING current AND current + 1
//      PUSH product INTO products
//      IF product === num
//          solution = [FACTORS OF product , true]
//          BREAK LOOP
//      ELSE IF product > num
//          solution = [FACTORS OF product, false]
//          BREAK LOOP
//      INCREMENT current BY ONE

//      RETURN SOLUTION

// 2️⃣ ✅     FOR LOOP WITH fibMax VARIABLE TO LIMIT MAX LENGHT OF SEQUENCE
export class G9642 {
    public static productFib = (num: number): (number | boolean)[] => {
        let solution: (number | boolean)[] = [];

        const sequence: number[] = [0, 1];
        const products: number[] = [];
        const fibMax = 15;

        for (let i = 0; i <= fibMax; i++) {
            let next = sequence[i] + sequence[i + 1];
            sequence.push(next);
            let product = sequence[i + 1] * sequence[i + 2];
            products.push(product);
            if (product === num) {
                console.log(`found: ${sequence[i + 1]} and ${sequence[i + 2]}`);
                solution = [sequence[i + 1], sequence[i + 2], true];
                break;
            } else if (product > num) {
                console.log("stop the loop: " + product);
                solution = [sequence[i + 1], sequence[i + 2], false];
                break;
            }
        }

        return solution;
    };
}

// console.log(G964.productFib(105));
// console.log(G964.productFib(800));
// console.log(G964.productFib(714));
// console.log(G964.productFib(4895));
// console.log(G964.productFib(5895));

//============= OTHER CODEWARS SOLUTIONS: =============

/*
export class G964 {
    public static productFib = (prod:number) => {
      let p1:number = 1, p2:number = 1;
      while (p1 * p2 < prod) [p1, p2] = [p2, p1+p2];
      return [p1 , p2, (p1 * p2 == prod)]; 
    }
}
 
 
 
export class G964 {
 
    public static productFib = (prod, f0 = 0, f1 = 1) => (f0 * f1 < prod) ? G964.productFib(prod, f1, f0+f1) : [f0,f1,(f0 * f1) === prod]
}
*/

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  DIRECTIONS REDUCTION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Once upon a time, on a way through the old wild mountainous west,…
… a man was given directions to go from one point to another. The directions were "NORTH", "SOUTH", "WEST", "EAST". Clearly "NORTH" and "SOUTH" are opposite, "WEST" and "EAST" too.
 
Going to one direction and coming back the opposite direction right away is a needless effort. Since this is the wild west, with dreadfull weather and not much water, it's important to save yourself some energy, otherwise you might die of thirst!
 
How I crossed a mountainous desert the smart way.
The directions given to the man are, for example, the following (depending on the language):
 
["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"].
or
{ "NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST" };
or
[North, South, South, East, West, North, West]
You can immediatly see that going "NORTH" and immediately "SOUTH" is not reasonable, better stay to the same place! So the task is to give to the man a simplified version of the plan. A better plan in this case is simply:
 
["WEST"]
or
{ "WEST" }
or
[West]
Other examples:
In ["NORTH", "SOUTH", "EAST", "WEST"], the direction "NORTH" + "SOUTH" is going north and coming back right away.
 
The path becomes ["EAST", "WEST"], now "EAST" and "WEST" annihilate each other, therefore, the final result is [] (nil in Clojure).
 
In ["NORTH", "EAST", "WEST", "SOUTH", "WEST", "WEST"], "NORTH" and "SOUTH" are not directly opposite but they become directly opposite after the reduction of "EAST" and "WEST" so the whole path is reducible to ["WEST", "WEST"].
 
Task
Write a function dirReduc which will take an array of strings and returns an array of strings with the needless directions removed (W<->E or S<->N side by side).
 
The Haskell version takes a list of directions with data Direction = North | East | West | South.
The Clojure version returns nil when the path is reduced to nothing.
The Rust version takes a slice of enum Direction {North, East, West, South}.
See more examples in "Sample Tests:"
Notes
Not all paths can be made simpler. The path ["NORTH", "WEST", "SOUTH", "EAST"] is not reducible. "NORTH" and "WEST", "WEST" and "SOUTH", "SOUTH" and "EAST" are not directly opposite of each other and can't become such. Hence the result path is itself : ["NORTH", "WEST", "SOUTH", "EAST"].
*/

// const dirReduc = (arr: string[]): string[] => {

//     while ((arr.includes("NORTH") && arr.includes("SOUTH"))) {
//         arr.splice(arr.indexOf("NORTH"), 1);
//         arr.splice(arr.indexOf("SOUTH"), 1);
//     }

//     while ((arr.includes("EAST") && arr.includes("WEST"))) {
//         arr.splice(arr.indexOf("EAST"), 1);
//         arr.splice(arr.indexOf("WEST"), 1);
//     }

//     console.log(arr);

//     return arr;

// }

const dirReduc = (arr: string[]): string[] => {
    for (let i = 0; i < arr.length; i++) {
        if (
            (arr[i] === "NORTH" && arr[i + 1] === "SOUTH") ||
            (arr[i] === "SOUTH" && arr[i + 1] === "NORTH") ||
            (arr[i] === "EAST" && arr[i + 1] === "WEST") ||
            (arr[i] === "WEST" && arr[i + 1] === "EAST")
        ) {
            arr.splice(i, 2);
            i -= 2;
        }
    }

    // console.log(arr);

    return arr;
};

//  IF PAIR OF OPPOSITES IS FOUND
//      DELETE PAIR
//      RESET LOOP

// console.log(dirReduc(["NORTH", "SOUTH", "NORTH", "SOUTH"]));
// [WEST]
// console.log(dirReduc(["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"]));
// []
// console.log(dirReduc(["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH"]));

// console.log(dirReduc(["NORTH", "SOUTH", "EAST", "WEST"]));

//============= OTHER CODEWARS SOLUTIONS: =============

function dirReduc2(arr: string[]): string[] {
    var pat = /(NORTHSOUTH|SOUTHNORTH|EASTWEST|WESTEAST)/;
    var way = arr.join("");
    while (pat.test(way)) way = way.replace(pat, "");
    return way.match(/(NORTH|SOUTH|EAST|WEST)/g) || [];
}

const dirReduc3 = (arr: string[]): string[] => {
    const opposites = [
        ["NORTH", "SOUTH"],
        ["EAST", "WEST"],
    ];

    return arr.reduce((acc: string[], curr: string) => {
        const opposite = opposites
            .find((el) => el.includes(curr))!
            .filter((el) => el !== curr)[0];

        const idx = acc.length - 1;

        return acc.length && acc[idx] === opposite
            ? acc.slice(0, idx)
            : acc.concat(curr);
    }, []);
};

function dirReduc4(arr: string[]): string[] {
    let str = arr.join(":");

    while (
        str.match(/NORTH:*SOUTH/) ||
        str.match(/SOUTH:*NORTH/) ||
        str.match(/EAST:*WEST/) ||
        str.match(/WEST:*EAST/)
    ) {
        str = str
            .replace(/NORTH:*SOUTH/g, "")
            .replace(/SOUTH:*NORTH/g, "")
            .replace(/EAST:*WEST/g, "")
            .replace(/WEST:*EAST/g, "");
    }

    return str.split(":").filter(Boolean);
}

function dirReduc5(arr: string[]): string[] {
    arr = arr.map((dir) => dir.toUpperCase());

    console.log(arr);
    for (let i = 0; i < arr.length; i++) {
        if (
            (arr[i] === "NORTH" && arr[i + 1] === "SOUTH") ||
            (arr[i] === "SOUTH" && arr[i + 1] === "NORTH") ||
            (arr[i] === "WEST" && arr[i + 1] === "EAST") ||
            (arr[i] === "EAST" && arr[i + 1] === "WEST")
        ) {
            arr.splice(i, 2);
            return dirReduc(arr);
        }
    }

    return arr;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  HUMAN READABLE TIME
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  PADSTART(),PADEND()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function, which takes a non-negative integer (seconds) as input and returns the time in a human-readable format (HH:MM:SS)
 
HH = hours, padded to 2 digits, range: 00 - 99
MM = minutes, padded to 2 digits, range: 00 - 59
SS = seconds, padded to 2 digits, range: 00 - 59
The maximum time never exceeds 359999 (99:59:59)
 
You can find some examples in the test fixtures.
*/

const humanReadable = (secInput: number): string => {
    const HOUR: number = 3600,
        MINUTE: number = 60;
    let secondsLeft: number = secInput;
    let hours: number = 0,
        minutes: number = 0,
        seconds: number = 0;

    const padToTwo = (num: number): string => {
        return num < 10 ? `0${String(num)}` : `${String(num)}`;
    };

    hours = Math.floor(secondsLeft / HOUR);
    secondsLeft = secondsLeft % HOUR;

    minutes = Math.floor(secondsLeft / MINUTE);
    secondsLeft = secondsLeft % MINUTE;

    seconds = secondsLeft;

    // console.table({ hours: hours, minutes: minutes, seconds: seconds });

    return `${padToTwo(hours)}:${padToTwo(minutes)}:${padToTwo(seconds)}`;
};

//  INITIALIZE ALL VARIABLES
//  padToTwo() WILL CONCAT A "0" IF NUMBER IS ONE DIGIT

//  CALC hours
//  UPDATE secondsLeft

//  CALC minutes
//  UPDATE secondsLeft

//  seconds NOW EQUALS TO secondsLeft

//  RETURN FORMATTED STRING

// console.log(humanReadable(86399));
// console.log(humanReadable(3661));
// console.log(humanReadable(3600));
// console.log(humanReadable(3599));
// console.log(humanReadable(66));
// console.log(humanReadable(59));
// console.log(humanReadable(0));

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ padStart() ❗️❗️❗️
const format = (n: number) => String(Math.floor(n)).padStart(2, "00");

export function humanReadable2(seconds: number): string {
    const h = seconds / 3600;
    const m = (seconds % 3600) / 60;
    const s = (seconds % 3600) % 60;

    return [h, m, s].map(format).join(":");
}

function humanReadable3(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds / 60) % 60;
    const pad = (n: number) => `${n}`.padStart(2, "0");
    return `${pad(hours)}:${pad(minutes)}:${pad(seconds % 60)}`;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SIMPLE PIG LATIN
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REGEX, REPLACE() WITH FUNCTION, IGNORE PUNCTUATION AND MULTIPLE SPACES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Move the first letter of each word to the end of it, then add "ay" to the end of the word. Leave punctuation marks untouched.
 
Examples
pigIt('Pig latin is cool'); // igPay atinlay siay oolcay
pigIt('Hello world !');     // elloHay orldway !
*/

const pigIt = (str: string): string => {
    // 1️⃣
    return str.replace(
        /[a-z]+/gi,
        (word) => `${word.slice(1)}${word.charAt(0)}ay`
    );

    // 2️⃣
    // const validWord = /[a-z]+/gi

    // return str.replace(validWord, (word) => {
    //     return `${word.slice(1)}${word.charAt(0)}ay`
    // });
};

// 'hisTay siay ymay tringsay'
// console.log(pigIt('This is my string'));
// console.log(pigIt('pdNWGEbnnAYBq  qKDVJ prMerdBgTDjFZYaHXd iX ! rxBwJkSVppxW hg . cQFYCExtQFgytIxTj HWEqmZ qFiJOYxcqIObSWjSlJL lg  !  mGJtNrQ iINNKiOohUuMAk dwwOYRmL'));

// pdNWGEbnnAYBq  qKDVJ prMerdBgTDjFZYaHXd iX ! rxBwJkSVppxW hg . cQFYCExtQFgytIxTj HWEqmZ qFiJOYxcqIObSWjSlJL lg  !  mGJtNrQ iINNKiOohUuMAk dwwOYRmL

// EXPECTED THIS:
// dNWGEbnnAYBqpay ay KDVJqay rMerdBgTDjFZYaHXdpay Xiay ! xBwJkSVppxWray ghay . QFYCExtQFgytIxTjcay WEqmZHay FiJOYxcqIObSWjSlJLqay glay ay ! ay GJtNrQmay INNKiOohUuMAkiay wwOYRmLday

// TO EQUAL:
// dNWGEbnnAYBqpay  KDVJqay rMerdBgTDjFZYaHXdpay Xiay ! xBwJkSVppxWray ghay . QFYCExtQFgytIxTjcay WEqmZHay FiJOYxcqIObSWjSlJLqay glay  !  GJtNrQmay INNKiOohUuMAkiay wwOYRmLday

// THIS IS UNSOLVED, FIRST ATTEMPT:
const pigIt2 = (str: string): string => {
    const punctuation = /[?!\.]/g;

    if (punctuation.test(str.charAt(str.length - 1))) {
        console.log("punctuation: " + str.charAt(str.length - 1));
    }

    return str
        .split(" ")
        .map((word) => {
            return `${word.slice(1)}${word.charAt(0)}ay`;
        })
        .join(" ");
};

//============= OTHER CODEWARS SOLUTIONS: =============

const pigIt3 = (a: string) => a.replace(/(\w)(\w+)*/g, "$2$1ay");

const pigIt4 = (a: string): string => {
    return a.replace(/[a-z]+/gi, (x) => x.slice(1) + x[0] + "ay");
};
