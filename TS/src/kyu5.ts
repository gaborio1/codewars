// ❗️❗️❗️ ✅  ❓❓❓
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/

// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ REFACTOR: DELETE CURRENT ITEM TO ELEMINATE SEQ ARR ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: FOSEPHUS PERMUTATION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
This problem takes its name by arguably the most important event in the life of the ancient historian Josephus: according to his tale, he and his 40 soldiers were trapped in a cave by the Romans during a siege.

Refusing to surrender to the enemy, they instead opted for mass suicide, with a twist: they formed a circle and proceeded to kill one man every three, until one last man was left (and that it was supposed to kill himself to end the act).

Well, Josephus and another man were the last two and, as we now know every detail of the story, you may have correctly guessed that they didn't exactly follow through the original idea.

You are now to create a function that returns a Josephus permutation, taking as parameters the initial array/list of items to be permuted as if they were in a circle and counted out every k places until none remained.

Tips and notes: it helps to start counting from 1 up to n, instead of the usual range 0..n-1; k will always be >=1.

For example, with n=7 and k=3 josephus(7,3) should act this way.

[1,2,3,4,5,6,7] - initial sequence
[1,2,4,5,6,7] => 3 is counted out and goes into the result [3]
[1,2,4,5,7] => 6 is counted out and goes into the result [3,6]
[1,4,5,7] => 2 is counted out and goes into the result [3,6,2]
[1,4,5] => 7 is counted out and goes into the result [3,6,2,7]
[1,4] => 5 is counted out and goes into the result [3,6,2,7,5]
[4] => 1 is counted out and goes into the result [3,6,2,7,5,1]
[] => 4 is counted out and goes into the result [3,6,2,7,5,1,4]
So our final result is:

josephus([1,2,3,4,5,6,7],3)==[3,6,2,7,5,1,4]
*/

// 2️⃣ SECOND SOLUTION, DYNAMIC SEQ ARR LENGTH !!!
const josephus2 = (items: any[], gap: number): any[] => {

    if (items.length === 1) return items;
    // INITIALIZE SEQ ARR WITH COPY OF ITEMS
    let solutionArr: any[] = [], seqArr: any[] = [...items];
    // CONUNT VALID STEPS (IGNORE DEAD)
    let validSteps: number = 0;

    // LOOP THROUGH SEQ ARR
    for (let i = 0; i < seqArr.length; i += 1) {
        // INCREMENT VALID STEPS IF ELEMENT IS ALIVE
        if (!solutionArr.includes(seqArr[i])) validSteps += 1;
        // IF VALD STEPS === GAP (EVERY NTH), PUSH CURRENT AND RESET VALIDSTEPS
        if (validSteps === gap) {
            solutionArr.push(seqArr[i]);
            validSteps = 0;
        }
        // STOP LOOP IF EVERY ELEMENT HAS BEEN SELECTED
        if (solutionArr.length === items.length) break;
        // IF LOOP REACHES LENGTH OF ITEMS, CONCAT ANOTHER COPY TO EXTEND SEQUENCE
        if (i === seqArr.length - 1) seqArr = seqArr.concat(items);

    }

    return solutionArr;

}

//   [3, 6, 2, 7, 5, 1, 4]
console.log(josephus2([1, 2, 3, 4, 5, 6, 7], 3));
// console.log(josephus2([1, 2, 3, 4, 5, 6, 7], 10));
// console.log(josephus2([4, 5, 7, 1], 3));
// [1,2,3,4,5,6,7,8,9,10]
// console.log(josephus2([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1));
// [2, 4, 6, 8, 10, 3, 7, 1, 9, 5]
// console.log(josephus2([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2));
// ['e', 's', 'W', 'o', 'C', 'd', 'r', 'a']
// console.log(josephus2(["C", "o", "d", "e", "W", "a", "r", "s"], 4));
// []
// console.log(josephus2([], 3));
// [ 5, 1, 3, 4, 2 ]
// console.log(josephus2([1, 2, 3, 4, 5], 5));

// 1️⃣  FIRST SOLUTION, UNUSED CODE, HARD CODED SEQ ARR LENGTH !!!
const josephus3 = (items: any[], gap: number): any[] => {

    if (items.length === 1) return items;
    // NUMBER OF VALID STEPS TO NEXT ITEM
    // const validGap: number = gap <= items.length
    //     ? gap
    //     : gap % items.length;
    // console.log(validGap);

    let solutionArr: any[] = [], sequenceArr: any[] = [];

    for (let i = 0; i < items.length * 40; i += 1) {
        sequenceArr = sequenceArr.concat(items);
    }

    let validSteps: number = 0;

    for (let i = 0; i < sequenceArr.length; i += 1) {
        // console.log("CYCLE COUNT: ", i)
        // for (let i = 0; i < 49; i += 1) {
        if (!solutionArr.includes(sequenceArr[i])) {
            validSteps += 1;
        }
        if (validSteps === gap) {
            solutionArr.push(sequenceArr[i]);
            validSteps = 0;
        }
        if (solutionArr.length === items.length) break;
    }
    return solutionArr;

}



//   [3, 6, 2, 7, 5, 1, 4]
// console.log(josephus3([1, 2, 3, 4, 5, 6, 7], 3));
// console.log(josephus3([1, 2, 3, 4, 5, 6, 7], 10));
// console.log(josephus3([4, 5, 7, 1], 3));
// [1,2,3,4,5,6,7,8,9,10]
// console.log(josephus3([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1));
// [2, 4, 6, 8, 10, 3, 7, 1, 9, 5]
// console.log(josephus3([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2));
// ['e', 's', 'W', 'o', 'C', 'd', 'r', 'a']
// console.log(josephus3(["C", "o", "d", "e", "W", "a", "r", "s"], 4));
// []
// console.log(josephus3([], 3));
// [ 5, 1, 3, 4, 2 ]
// console.log(josephus3([1, 2, 3, 4, 5], 5));

//============= OTHER CODEWARS SOLUTIONS: =============

const josephus4 = (items: any[], k: number): any[] => {
    let lst: any[] = []
    let i: number = (k - 1) % items.length
    while (items.length) {
        lst.push(items[i])
        items.splice(i, 1)
        i = (i + k - 1) % items.length
    }
    return lst
}


const josephus5 = (items: any[], k: number): any[] => {
    const alive = [...items]
    const dead = []
    let i = (k - 1) % alive.length

    while (alive.length) {
        const killed = alive.splice(i, 1)
        dead.push(...killed)
        i = (i + k - 1) % alive.length
    }

    return dead
}


function josephus6(items: any[], k: number): any[] {
    const result = [];

    while (items.length > 0) {
        for (let skip = 1; skip < k; skip++) {
            items.push(items.shift());
        }
        result.push(items.shift());
    }

    return result;
}


const josephus7 = (items: any[], k: number): any[] => {
    let result: any[] = [];
    let currentIndex: number = 1;

    while (items.length > 0) {
        currentIndex = currentIndex + k - 1;
        while (currentIndex > items.length) {
            currentIndex = currentIndex - items.length;
        }

        result.push(items[currentIndex - 1]);
        items.splice(currentIndex - 1, 1);
    }
    return result;
}

const josephus8 = (items: any[], k: number): any[] => {
    let res = [];
    let i = (k - 1) % items.length;
    while (items.length) {
        res.push(items[i]);
        items.splice(i, 1);
        i = (i + k - 1) % items.length;
    }
    return res;
}
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ INCLUDE THIS IN EXAMPLES (REPLACE) ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE: COMMON DENOMINATORS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: EVERY(), SET(),  ❗️❗️❗️ REPLACE(PERFORM MATH OPERATIONS ON NUMERIC STRINGS)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Common denominators
 
You will have a list of rationals in the form
 
{ {numer_1, denom_1} , ... {numer_n, denom_n} } 
or
[ [numer_1, denom_1] , ... [numer_n, denom_n] ] 
or
[ (numer_1, denom_1) , ... (numer_n, denom_n) ] 
where all numbers are positive ints. You have to produce a result in the form:
 
(N_1, D) ... (N_n, D) 
or
[ [N_1, D] ... [N_n, D] ] 
or
[ (N_1', D) , ... (N_n, D) ] 
or
{{N_1, D} ... {N_n, D}} 
or
"(N_1, D) ... (N_n, D)"
depending on the language (See Example tests) in which D is as small as possible and
 
N_1/D == numer_1/denom_1 ... N_n/D == numer_n,/denom_n.
Example:
convertFracs [(1, 2), (1, 3), (1, 4)] `shouldBe` [(6, 12), (4, 12), (3, 12)]
Note:
Due to the fact that the first translations were written long ago - more than 6 years - these first translations have only irreducible fractions.
 
Newer translations have some reducible fractions. To be on the safe side it is better to do a bit more work by simplifying fractions even if they don't have to be.
*/
const convertFrac = (list: [number, number][]): string => {

    let solution: string = "";
    let denomsArr: number[] = [];
    // FIND COMMON DENOMINATOR
    list.forEach((frac) => {
        denomsArr.push(frac[1]);
    });
    // console.log("denomsArr: ", denomsArr); 
    // denomsArr:  [ 2, 5, 4, 9, 10 ]

    let commDenom: number = 0;
    let i = Math.max(...denomsArr);
    while (true) {
        if (denomsArr.every((denom) => i % denom === 0)) {
            commDenom = i;
            break;
        }
        i++;
    }
    // console.log("common denom: ", commDenom);
    // common denom:  180

    // SET FOR ALL UNIQUE COMPONENTS (FURTHER REDUCTION OF FRACTIONS)
    const uniqueComps = new Set<number>();

    list.forEach((frac) => {
        // (90,180) AND SO ON...
        solution += `(${frac[0] * (commDenom / frac[1])},${commDenom})`;
        uniqueComps.add(frac[0] * (commDenom / frac[1]));
    })
    // console.log(uniqueComps);
    // Set(5) { 90, 144, 135, 120, 126 }

    // SIMPLIFY FRACTIONS IF POSSIBLE (FIND COMMON DIVIDER FOR ALL COMPONENTS)
    let simplifiedSolution: string = "";
    // ADD COMMON DENOMINATOR TO SET
    uniqueComps.add(commDenom);
    // MAKE ARRAY FROM SET FOR ARRAY METHOD EVERY
    const allCompsArr: number[] = Array.from(uniqueComps);
    // console.log("allCompsArr: ", allCompsArr);
    // allCompsArr:  [ 90, 144, 135, 120, 126, 180 ]
    for (let i = 2; i <= commDenom / 2; i++) {
        if (allCompsArr.every((comp) => comp % i === 0)) {
            // ❗️❗️❗️ REPLACE EVERY NUMBER IN STRING WITH ITSELF DIVIDED BY i (COMMON DIVIDER)
            simplifiedSolution = solution
                .replace(/\d+/g, (num: string) => (Number(num) / i).toString());
        }
    }

    // console.log("simplifiedSolution: ", simplifiedSolution);
    // simplifiedSolution:  (30,60)(48,60)(45,60)(40,60)(42,60)

    // IF SIMPLIFIED SOLUTION EXIST, RETURN IT, OTHERWISE RETURN SOLUTION
    return simplifiedSolution
        ? simplifiedSolution
        : solution;
}

// "(6,12)(4,12)(3,12)"
// console.log(convertFrac([[1, 2], [1, 3], [1, 4]]));
// ============================================================
// ❗️❗️❗️ SOLUTION:
// '(90,180)(144,180)(135,180)(120,180)(126,180)'
//  ❗️❗️❗️ SIMPLIFIED SOLUTION:
// '(30,60) (48,60)  (45,60)  (40,60)  (42,60)'
// console.log(convertFrac([[1, 2], [4, 5], [3, 4], [6, 9], [7, 10]]));
// ============================================================

// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
const convertFrac2 = (lst: [number, number][]): string => {
    const gcd = (a: number, b: number): number => (b ? gcd(b, a % b) : a);
    const lcm = (a: number, b: number): number => (a * b) / gcd(a, b);
    const cd = lst.reduce((a, [_, d]) => lcm(d, a), 1);
    const lcd = lst.reduce((d, [a, c]) => gcd(d, (a * cd) / c), cd);
    return lst.map(([n, d]) => `(${(n * cd) / d / lcd},${cd / lcd})`).join('');
}
// ============================================================


const gcd = (x: number, y: number): number => {
    while (y != 0) {
        const z = x % y;
        x = y;
        y = z;
    }

    return x;
}

const lcm = (x: number, y: number): number =>
    x * y / gcd(x, y);


const convertFrac3 = (lst: [number, number][]): string => {
    const common = lst
        .map(([x, y]) => y)
        .reduce(lcm, 1);

    const acc = lst
        .map(([x, y]) => x * (common / y))

    const least = acc
        .reduce(gcd, common);

    return acc
        .map(x => `(${x / least},${common / least})`)
        .join('');
}
// ============================================================
const findGcd = (a: number, b: number): number => b ? findGcd(b, a % b) : a;

const findLcm = (a: number, b: number): number => a * b / findGcd(a, b)

const findLcmOfList = (arr: number[]): number => arr.reduce((lcm, num) => findLcm(lcm, num), 1)

const simplify = (a: number, b: number): [number, number] => {
    const gcd = findGcd(a, b)
    return gcd === 1 ? [a, b] : [a / gcd, b / gcd]
}

export const convertFrac4 = (lst: [number, number][]): string => {
    let denoms: number[] = [];
    const list = lst.map(([n0, n1]) => {
        const simpleArr = simplify(n0, n1)
        denoms.push(simpleArr[1])
        return simpleArr
    })

    const lcm = findLcmOfList(denoms)

    return list.reduce((result, [n0, n1]) => `${result}(${n0 * lcm / n1},${lcm})`, '')

}
// ============================================================
interface IFactorized {
    [key: number]: number;
}

export const convertFrac5 = (lst: [number, number][]): string => {
    if (lst.length == 0)
        return "";
    const getPrimes = function (maxNum: number) {
        const candidates: boolean[] = Array.from({ length: maxNum }, i => true);
        const maxi = Math.floor(Math.sqrt(maxNum));
        for (let i = 2; i <= maxi; i++) {
            if (candidates[i]) {
                const sqi = i * i;
                for (let k = 0; ; k++) {
                    const j = sqi + i * k;
                    if (j > maxNum) break;
                    candidates[j] = false;
                }
            }
        }
        const primes: number[] = [];
        for (let i = 2; i < candidates.length; i++) {
            if (candidates[i]) {
                primes.push(i);
            }
        }
        return primes;
    };
    const max_denom = lst.map(i => i[1]).reduce((carry, item) => {
        if (carry < item) return item;
        return carry;
    });
    const primes = getPrimes(max_denom + 1);
    const factorize = function (num: number) {
        const res: IFactorized = {};
        primes.forEach(prime => {
            let cnt = 0;
            while (num > 1) {
                if ((num % prime) === 0) {
                    num = Math.floor(num / prime);
                    cnt++;
                } else {
                    break;
                }
            }
            if (cnt > 0)
                res[prime] = cnt;
        });
        return res;
    };
    const simplified_lst = lst.map(item => {
        const fnum = factorize(item[0]);
        const fdenom = factorize(item[1]);
        const cfactors: IFactorized = {};
        Object.keys(fnum).forEach(prime => {
            if (fdenom[parseInt(prime)]) {
                cfactors[parseInt(prime)] = (fnum[parseInt(prime)] <= fdenom[parseInt(prime)]) ? fnum[parseInt(prime)] : fdenom[parseInt(prime)];
            }
        });
        const div = Object.keys(cfactors).reduce((carry, prime) => {
            return carry * Math.pow(parseInt(prime), cfactors[parseInt(prime)])
        }, 1);
        return [Math.floor(item[0] / div), Math.floor(item[1]) / div];
    });
    const fdenoms: IFactorized[] = simplified_lst.map(item => {
        return factorize(item[1]);
    });
    const lcm_factors: IFactorized = {};
    for (const factors of fdenoms) {
        for (const prime in factors) {
            if (lcm_factors[parseInt(prime)]) {
                if (factors[parseInt(prime)] > lcm_factors[parseInt(prime)])
                    lcm_factors[parseInt(prime)] = factors[parseInt(prime)];
            } else {
                lcm_factors[parseInt(prime)] = factors[parseInt(prime)];
            }
        }
    }
    const lcd = Object.keys(lcm_factors).reduce((carry, prime) => {
        return carry * Math.pow(parseInt(prime), lcm_factors[parseInt(prime)]);
    }, 1);
    return simplified_lst.map(item => {
        const num = Math.floor(item[0] * lcd / item[1]);
        return `(${num},${lcd})`;
    }).join('');
}
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: MY SMALLEST CODE INTERPRETER (aka Brainf**k)
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Inspired from real-world Brainf**k, we want to create an interpreter of that language which will support the following instructions:
 
> increment the data pointer (to point to the next cell to the right).
< decrement the data pointer (to point to the next cell to the left).
+ increment (increase by one, truncate overflow: 255 + 1 = 0) the byte at the data pointer.
- decrement (decrease by one, treat as unsigned byte: 0 - 1 = 255 ) the byte at the data pointer.
. output the byte at the data pointer.
, accept one byte of input, storing its value in the byte at the data pointer.
[ if the byte at the data pointer is zero, then instead of moving the instruction pointer forward to the next command, jump it forward to the command after the matching ] command.
] if the byte at the data pointer is nonzero, then instead of moving the instruction pointer forward to the next command, jump it back to the command after the matching [ command.
The function will take in input...
 
the program code, a string with the sequence of machine instructions,
the program input, a string, possibly empty, that will be interpreted as an array of bytes using each character's ASCII code and will be consumed by the , instruction
... and will return ...
 
the output of the interpreted code (always as a string), produced by the . instruction.
Implementation-specific details for this Kata:
 
Your memory tape should be large enough - the original implementation had 30,000 cells but a few thousand should suffice for this Kata
Each cell should hold an unsigned byte with wrapping behavior (i.e. 255 + 1 = 0, 0 - 1 = 255), initialized to 0
The memory pointer should initially point to a cell in the tape with a sufficient number (e.g. a few thousand or more) of cells to its right. For convenience, you may want to have it point to the leftmost cell initially
You may assume that the , command will never be invoked when the input stream is exhausted
Error-handling, e.g. unmatched square brackets and/or memory pointer going past the leftmost cell is not required in this Kata. If you see test cases that require you to perform error-handling then please open an Issue in the Discourse for this Kata (don't forget to state which programming language you are attempting this Kata in).
*/

function brainLuck(code: string, input: string) {
    // return output;
}

// 'Codewars'
// console.log(brainLuck(',+[-.,+]','Codewars'+String.fromCharCode(255)));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️  SOLUTION NOT WORKING IN IDE ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: CHAIN ADDING FUNCTION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: ❗️❗️❗️ VALUEOF
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
We want to create a function that will add numbers together when called in succession.
 
add(1)(2); // == 3
We also want to be able to continue to add numbers to our chain.
 
add(1)(2)(3); // == 6
add(1)(2)(3)(4); //  == 10
add(1)(2)(3)(4)(5); // == 15
and so on.
 
A single call should be equal to the number passed in.
 
add(1); // == 1
We should be able to store the returned values and reuse them.
 
var addTwo = add(2);
addTwo; // == 2
addTwo + 5; // == 7
addTwo(3); // == 5
addTwo(3)(5); // == 10
We can assume any number being passed in will be valid whole number.
*/

// ❗️❗️❗️  SOLUTION NOT WORKING IN IDE ❗️❗️❗️
// [Function: sum] { valueOf: [Function (anonymous)] }

function add(n: number): any {
    const sum = function (y: number) {
        return add(n + y);
    };
    // ❗️❗️❗️
    sum.valueOf = function () {
        return n;
    };

    return sum;
}
// 15
// add(1)(2)(3)(4)(5);
// console.log(add(1)(2)(3)(4)(5));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
function add2(x: number): any {
    const fn = (y: number) => add(x + y);
    fn.valueOf = () => x;
    return fn;
}


function add3(x: number): any {
    // receives the next number in the sequence
    const addNum = (next: any) => {
        // returns the outer function, with cumulative number so far as the argument
        return add(x + next)
    }

    // sets value of method of inner function to return value of x for final number
    addNum.valueOf = () => {
        return x
    }

    // returns addNum function which will be called with next number as argument
    return addNum
}


/**
 * Calculates the sum of numbers.
 *
 * @param x number
 * @returns number
 * The sum of numbers using closures.
 */
function add4(x: number): any {
    let currentSum: number = x;

    function f(y: number): any {
        if (typeof (y) === "number") {
            currentSum += y;
            return f;
        }
    }

    // "f" is a function object and should include "toString" method.
    f.toString = function (): any {
        return currentSum;
    };

    return f;
}

function add5(n: number): any { return Object.assign((i: any) => add(i + n), { valueOf: () => n }) }


// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: IS MY FRIEND CHEATING
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
A friend of mine takes the sequence of all numbers from 1 to n (where n > 0).
Within that sequence, he chooses two numbers, a and b.
He says that the product of a and b should be equal to the sum of all numbers in the sequence, excluding a and b.
Given a number n, could you tell me the numbers he excluded from the sequence?
The function takes the parameter: n (n is always strictly greater than 0) and returns an array or a string (depending on the language) of the form:
 
[(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or or [{a, b}, ...]
with all (a, b) which are the possible removed numbers in the sequence 1 to n.
 
[(a, b), ...] or [[a, b], ...] or {{a, b}, ...} or ... will be sorted in increasing order of the "a".
 
It happens that there are several possible (a, b). The function returns an empty array (or an empty string) if no possible numbers are found which will prove that my friend has not told the truth! (Go: in this case return nil).
 
Examples:
removNb(26) should return [(15, 21), (21, 15)]
or
removNb(26) should return { {15, 21}, {21, 15} }
or
removeNb(26) should return [[15, 21], [21, 15]]
or
removNb(26) should return [ {15, 21}, {21, 15} ]
or
removNb(26) should return "15 21, 21 15"
or
 
in C:
removNb(26) should return  {{15, 21}{21, 15}} tested by way of strings.
Function removNb should return a pointer to an allocated array of Pair pointers, each one also allocated. 
Note
See examples of returns for each language in "RUN SAMPLE TESTS"
*/

class G965 {
    public static removeNb(n: number) {
        // your code
    }
}

// [[15,21],[21,15]]
// console.log(removeNb(26));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// ❗️❗️❗️ NOT WORKING IN CODEWARS, FLATMAP GIVES ERROR ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE: BEST TRAVEL
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: FLATMAP()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: ❗️❗️❗️ https://stackoverflow.com/questions/9960908/permutations-in-javascript
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
John and Mary want to travel between a few towns A, B, C ... Mary has on a sheet of paper a list of distances between these towns. ls = [50, 55, 57, 58, 60]. John is tired of driving and he says to Mary that he doesn't want to drive more than t = 174 miles and he will visit only 3 towns.
 
Which distances, hence which towns, they will choose so that the sum of the distances is the biggest possible to please Mary and John?
 
Example:
With list ls and 3 towns to visit they can make a choice between: [50,55,57],[50,55,58],[50,55,60],[50,57,58],[50,57,60],[50,58,60],[55,57,58],[55,57,60],[55,58,60],[57,58,60].
 
The sums of distances are then: 162, 163, 165, 165, 167, 168, 170, 172, 173, 175.
 
The biggest possible sum taking a limit of 174 into account is then 173 and the distances of the 3 corresponding towns is [55, 58, 60].
 
The function chooseBestSum (or choose_best_sum or ... depending on the language) will take as parameters t (maximum sum of distances, integer >= 0), k (number of towns to visit, k >= 1) and ls (list of distances, all distances are positive or zero integers and this list has at least one element). The function returns the "best" sum ie the biggest possible sum of k distances less than or equal to the given limit t, if that sum exists, or otherwise nil, null, None, Nothing, depending on the language. In that case with C, C++, D, Dart, Fortran, F#, Go, Julia, Kotlin, Nim, OCaml, Pascal, Perl, PowerShell, Reason, Rust, Scala, Shell, Swift return -1.
 
Examples:
ts = [50, 55, 56, 57, 58] choose_best_sum(163, 3, ts) -> 163
 
xs = [50] choose_best_sum(163, 3, xs) -> nil (or null or ... or -1 (C++, C, D, Rust, Swift, Go, ...)
 
ys = [91, 74, 73, 85, 73, 81, 87] choose_best_sum(230, 3, ys) -> 228
 
Notes:
try not to modify the input list of distances ls
in some languages this "list" is in fact a string (see the Sample Tests).
*/

const chooseBestSum = (maxDist: number, numTowns: number, list: number[]): number | null => {

    // if ()

    const generatePermutations = (list: number[], size = list.length): number[][] => {
        if (size > list.length) return [];
        else if (size == 1) return list.map(d => [d]);
        return list.flatMap(d => generatePermutations(list.filter(a => a !== d), size - 1).map(item => [d, ...item]));
    }


    const allPermutations: number[][] = generatePermutations(list, numTowns);
    console.log(allPermutations);
    const allDistances: number[] = allPermutations.map((arr) => {
        return arr.reduce((acc, curr) => acc + curr);
    });
    console.log(allDistances);
    const distsInRange: number[] = allDistances.filter((dist) => dist <= maxDist);
    console.log(distsInRange);
    const solution: number = Math.max(...distsInRange, 0);
    console.log(solution);
    return solution
        ? solution
        : null;
}

//   163
// console.log(chooseBestSum(163, 3, [50, 55, 56, 57, 58]));
// 50
// console.log(chooseBestSum(163, 3, [50]));
// console.log();
// console.log();

/*
❗️❗️❗️ THIS WILL GIVE ALL THE PERMUTATIONS, DUPLICATES WILL OCCUR ❗️❗️❗️
❗️❗️❗️ SOURCE: https://stackoverflow.com/questions/9960908/permutations-in-javascript
 
Here's a very concise and recursive solution that allows you to input the size of the output permutations similar to the statistical operator nPr. "5 permutation 3". This allows you to get all possible permutations with a specific size.
 
function generatePermutations(list, size=list.length) {
    if (size > list.length) return [];
    else if (size == 1) return list.map(d=>[d]); 
    return list.flatMap(d => generatePermutations(list.filter(a => a !== d), size - 1).map(item => [d, ...item]));
}
generatePermutations([1,2,3])
 
[[1, 2, 3],[1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
generatePermutations([1,2,3],2)
 
[[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]
 
OUTPUT EXAMPLE:
 
[
  [ 50, 55, 56 ], [ 50, 55, 57 ], [ 50, 55, 58 ],
  [ 50, 56, 55 ], [ 50, 56, 57 ], [ 50, 56, 58 ],
  [ 50, 57, 55 ], [ 50, 57, 56 ], [ 50, 57, 58 ],
  [ 50, 58, 55 ], [ 50, 58, 56 ], [ 50, 58, 57 ],
  [ 55, 50, 56 ], [ 55, 50, 57 ], [ 55, 50, 58 ],
  [ 55, 56, 50 ], [ 55, 56, 57 ], [ 55, 56, 58 ],
  [ 55, 57, 50 ], [ 55, 57, 56 ], [ 55, 57, 58 ],
  [ 55, 58, 50 ], [ 55, 58, 56 ], [ 55, 58, 57 ],
  [ 56, 50, 55 ], [ 56, 50, 57 ], [ 56, 50, 58 ],
  [ 56, 55, 50 ], [ 56, 55, 57 ], [ 56, 55, 58 ],
  [ 56, 57, 50 ], [ 56, 57, 55 ], [ 56, 57, 58 ],
  [ 56, 58, 50 ], [ 56, 58, 55 ], [ 56, 58, 57 ],
  [ 57, 50, 55 ], [ 57, 50, 56 ], [ 57, 50, 58 ],
  [ 57, 55, 50 ], [ 57, 55, 56 ], [ 57, 55, 58 ],
  [ 57, 56, 50 ], [ 57, 56, 55 ], [ 57, 56, 58 ],
  [ 57, 58, 50 ], [ 57, 58, 55 ], [ 57, 58, 56 ],
  [ 58, 50, 55 ], [ 58, 50, 56 ], [ 58, 50, 57 ],
  [ 58, 55, 50 ], [ 58, 55, 56 ], [ 58, 55, 57 ],
  [ 58, 56, 50 ], [ 58, 56, 55 ], [ 58, 56, 57 ],
  [ 58, 57, 50 ], [ 58, 57, 55 ], [ 58, 57, 56 ]
]
[
  161, 162, 163, 161, 163, 164, 162, 163, 165,
  163, 164, 165, 161, 162, 163, 161, 168, 169,
  162, 168, 170, 163, 169, 170, 161, 163, 164,
  161, 168, 169, 163, 168, 171, 164, 169, 171,
  162, 163, 165, 162, 168, 170, 163, 168, 171,
  165, 170, 171, 163, 164, 165, 163, 169, 170,
  164, 169, 171, 165, 170, 171
]
[
  161, 162, 163, 161, 163,
  162, 163, 163, 161, 162,
  163, 161, 162, 163, 161,
  163, 161, 163, 162, 163,
  162, 163, 163, 163
]
163
*/

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// ❗️❗️❗️ Execution Timed Out (12000 ms) ❗️❗️❗️ REFACTOR ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  GAP IN PRIMES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: PRIME NUMNERS, ISPRIME(),
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The prime numbers are not regularly spaced. For example from 2 to 3 the gap is 1. From 3 to 5 the gap is 2. From 7 to 11 it is 4. Between 2 and 50 we have the following pairs of 2-gaps primes: 3-5, 5-7, 11-13, 17-19, 29-31, 41-43
 
A prime gap of length n is a run of n-1 consecutive composite numbers between two successive primes (see: http://mathworld.wolfram.com/PrimeGaps.html).
 
We will write a function gap with parameters:
 
g (integer >= 2) which indicates the gap we are looking for
 
m (integer > 2) which gives the start of the search (m inclusive)
 
n (integer >= m) which gives the end of the search (n inclusive)
 
n won't go beyond 1100000.
 
In the example above gap(2, 3, 50) will return [3, 5] or (3, 5) or {3, 5} which is the first pair between 3 and 50 with a 2-gap.
 
So this function should return the first pair of two prime numbers spaced with a gap of g between the limits m, n if these numbers exist otherwise `nil or null or None or Nothing (or ... depending on the language).
 
In such a case (no pair of prime numbers with a gap of `g`)
In C: return [0, 0]
In C++, Lua, COBOL: return `{0, 0}`. 
In F#: return `[||]`. 
In Kotlin, Dart and Prolog: return `[]`.
In Pascal: return Type TGap (0, 0).
Examples:
- gap(2, 5, 7) --> [5, 7] or (5, 7) or {5, 7}
 
gap(2, 5, 5) --> nil. In C++ {0, 0}. In F# [||]. In Kotlin, Dart and Prolog return []`
 
gap(4, 130, 200) --> [163, 167] or (163, 167) or {163, 167}
 
([193, 197] is also such a 4-gap primes between 130 and 200 but it's not the first pair)
 
gap(6,100,110) --> nil or {0, 0} or ... : between 100 and 110 we have 101, 103, 107, 109 but 101-107is not a 6-gap because there is 103in between and 103-109is not a 6-gap because there is 107in between.
 
You can see more examples of return in Sample Tests.
 
Note for Go
For Go: nil slice is expected when there are no gap between m and n. Example: gap(11,30000,100000) --> nil
 
Ref
https://en.wikipedia.org/wiki/Prime_gap
*/

class G964b {
    public static gap = (gap: number, min: number, max: number): number[] => {
        let solution: number[] = [];
        let primesArr: number[] = [];
        // THIS WILL BE ALL THE POSSIBLE MATCHES WHICH IS NOT NECESSARY AS WE HAVE TO RETURN THE FIRST MATCH
        let allMatchesArr: [number, number][] = [];

        // GET ALL PRIMES WITHIN RANGE (MIN - MAX)

        // ISPRIME() FROM PREVIOUS CODEWARS EXAMPLE
        const isPrime = (num: number) => {
            if (num === 1 || num === 2) return true;
            for (let i = 2; i < num; i++) {
                // console.table({num: num, divider: i});
                if (num % i === 0) return false;
            }
            return true;
        };

        //   FIND PRIMES RANGING FROM 2 TO HALF OF NUM
        for (let i = min; i <= max; i++) {
            let prime = 0;
            if (isPrime(i)) {
                prime = i;
                // console.log("prime found: ", prime);

                primesArr.push(prime);
            }
        }
        // [ 101, 103, 107, 109 ]
        console.log(primesArr);
        // LOOP OVER PRIMES ARRAY (AND GET GAPS)
        // [ 2, 4, 2, NaN ] ❗️❗️❗️ LAST EL WILL BE NAN BECAUSE primesArr[idx + 1] IS UNDEFINE FOR THE LAST ELEMENT ❗️❗️❗️
        const gapsArr: number[] = primesArr.map((el, idx) => {
            if (primesArr[idx + 1] - el === gap) {
                console.log("match found");
                allMatchesArr.push([el, primesArr[idx + 1]]);
            }
            return primesArr[idx + 1] - el;
        });
        // .slice(0, -1);   // ❗️❗️❗️ [ 2, 4, 2 ]  RETURN NEW ARRAY WITHOUT LAST ELEMENT (NAN)

        console.table({
            primesArr: primesArr,
            "gaps arr: ": gapsArr,
            allMatchesArr: allMatchesArr,
        });

        if (allMatchesArr.length === 0) {
            console.log("empty array");
            return [0, 0];
        }
        //  FIND AND RETURN FIRST GAP MATCH
        solution = allMatchesArr[0];
        return solution;
    };
}

/*
G964b.gap(2, 100, 110) LOGS:
 
┌───────────────┬──────────────┬──────────────┬─────┬─────┐
│    (index)    │      0       │      1       │  2  │  3  │
├───────────────┼──────────────┼──────────────┼─────┼─────┤
│   primesArr   │     101      │     103      │ 107 │ 109 │
│  gaps arr:    │      2       │      4       │  2  │ NaN │
│ allMatchesArr │ [ 101, 103 ] │ [ 107, 109 ] │     │     │
└───────────────┴──────────────┴──────────────┴─────┴─────┘
[ 101, 103 ]
 
*/

// [ 101, 103 ]
// console.log(G964b.gap(2, 100, 110));
// console.log(G964b.gap(6, 100, 110));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ INCLUDE ISPRIME() IN CODEWARS EXAMPLES ❗️❗️❗️
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// ❗️❗️❗️ Execution Timed Out (12000 ms) ❗️❗️❗️ REFACTOR ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PRIMES IN NUMBERS - PRIME FACTOR DECOMPOSITION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS: PRIME NUMBERS, ISPRIME(),
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a positive number n > 1 find the prime factor decomposition of n. The result will be a string with the following form :
 
 "(p1**n1)(p2**n2)...(pk**nk)"
with the p(i) in increasing order and n(i) empty if n(i) is 1.
 
Example: n = 86240 should return "(2**5)(5)(7**2)(11)"
 
A prime number is a whole number greater than 1 whose only factors are 1 and itself. A factor is a whole number that can be divided evenly into another number. The first few prime numbers are 2, 3, 5, 7, 11, 13, 17, 19, 23 and 29. Numbers that have more than two factors are called composite numbers.
 
❗️❗️❗️
Prime Factor Decomposition
Quick revise
Prime factor decomposition of a number means writing it as a product of prime factors.
 
To factorise a number, divide it by the first possible prime number.
Take the resulting quotient below the number.
If it is possible, continue dividing this quotient successively by the same prime number.
When you cannot do the division by this prime number, divide it by the next possible prime number.
And so forth until the final quotient is 1.
Finally write this number as a product of powers of prime factors.
Example
 
Find the prime factor decomposition of 36.
 
We look at 36 and try to find numbers which we can divide it by. We can see that it divides by 2.
 
36 = 18 × 2
 
2 is a prime number, but 18 isn't. So we need to split 18 up into prime numbers. We can also divide 18 by 2.
 
18 = 9 × 2
 
and so 36 = 18 × 2 = 9 × 2 × 2
 
But we haven't finished, because 9 is not a prime number. We know that 9 divides by 3.
 
9 = 3 x 3.
 
Hence 36 = 9 × 2 × 2 = 3 × 3 × 2 × 2.
 
This is the answer, because both 2 and 3 are prime numbers.
❗️❗️❗️
*/

// const isPrime = (num: number) => {
//     if (num === 1 || num === 2) return true;
//     for (let i = 2; i < num; i++) {
//         // console.table({num: num, divider: i});
//         if (num % i === 0) return false;
//     }
//     return true;
// };

// MAY HAVE TO USE OBJECT TO COUNT OCCURENCES
const countPrimes = (primes: number[]): string => {
    interface StrKeyVal {
        [key: number]: number;
    }

    const counter: StrKeyVal = {};
    primes.forEach((number) => (counter[number] = (counter[number] || 0) + 1));

    console.log(counter);

    return "hello";
};

// countPrimes([2, 2, 2, 2, 2, 5, 7, 7, 11]);

// console.log(isPrime(5));
// =========================================

const primeFactors = (num: number): string => {
    let factors = [];
    let numRemainder = num;
    let solution: string = "";

    const isPrime = (num: number) => {
        if (num === 1 || num === 2) return true;
        for (let i = 2; i < num; i++) {
            // console.table({num: num, divider: i});
            if (num % i === 0) return false;
        }
        return true;
    };

    //   FIND PRIMES RANGING FROM 2 TO HALF OF NUM
    for (let i = 2; i < (num - 1) / 2; i++) {
        let prime = 0;
        if (isPrime(i)) {
            prime = i;
            // console.log("prime found: ", prime);
            while (numRemainder % prime === 0) {
                numRemainder = numRemainder / prime;
                factors.push(prime);
            }
        }
        if (numRemainder === 1) break;
    }
    console.log(factors);
    if (factors.length === 0) return `(${num})`;

    // COUNT OCCURENCES OF ARRAY ELEMENTS WITH LOOP
    let counter: number = 0;
    for (let i = 0; i < factors.length; i++) {
        counter++;
        console.log("counter: ", counter);
        if (factors[i] !== factors[i + 1] && factors[i] !== undefined) {
            console.log("new factor: ", factors[i], i);
            // FORMAT FACTORS AND CONCAT TO SOLUTION HERE
            solution +=
                counter < 2 ? `(${factors[i]})` : `(${factors[i]}**${counter})`;
            // RESET COUNTER
            counter = 0;
        }
    }

    return solution;
};

// (2**2)(3**2)
// console.log(primeFactors(36));
// (2**5)(5)(7**2)(11)
// console.log(primeFactors(86240));
// 7919
// console.log(primeFactors(7919));

// class G964a8 {
//     public static primeFactors = (num: number): string => {
//         // GET PRIME NUMBERS

//         // DIVIDE

//         // return "hello";
//     };
// }

// "(2**5)(5)(7**2)(11)"
// console.log(G964a8.primeFactors(86240));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PERIMETER OF SQUARES IN A RECTANGLE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The drawing shows 6 squares the sides of which have a length of 1, 1, 2, 3, 5, 8. It's easy to see that the sum of the perimeters of these squares is : 4 * (1 + 1 + 2 + 3 + 5 + 8) = 4 * 20 = 80
 
Could you give the sum of the perimeters of all the squares in a rectangle when there are n + 1 squares disposed in the same manner as in the drawing:
 
alternative text
 
Hint:
See Fibonacci sequence
 
Ref:
http://oeis.org/A000045
 
The function perimeter has for parameter n where n + 1 is the number of squares (they are numbered from 0 to n) and returns the total perimeter of all the squares.
 
perimeter(5)  should return 80
perimeter(7)  should return 216
*/

class G964a {
    public static perimeter = (num: number): number => {
        const fibonacciFirstN = (num: number): number[] => {
            const fibSequence: number[] = [1, 1];
            for (let i = 0; i < num - 1; i++) {
                let next = fibSequence[i] + fibSequence[i + 1];
                fibSequence.push(next);
            }
            return fibSequence;
        };

        return 4 * fibonacciFirstN(num).reduce((a, b) => a + b);
    };
}

// 80
// console.log(G964a.perimeter(5));
// 216
// console.log(G964a.perimeter(7));
//
// console.log(G964a.perimeter(3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

class G964a2 {
    public static perimeter = (n: number) => {
        let numbers = [1, 1];

        for (let i = 2; i <= n; i++) {
            numbers.push(numbers[i - 1] + numbers[i - 2]);
        }

        return 4 * numbers.reduce((curr, acc) => acc + curr, 0);
    };
}

class G964a3 {
    public static perimeter = (n: number) => {
        return (
            Array.from(Array(n + 2).keys())
                .map((e, i, arr) => {
                    if (i > 0) {
                        arr[i + 1] = arr[i] + arr[i - 1];
                        return e;
                    } else {
                        return 1;
                    }
                })
                .slice(1)
                .reduce((a, b) => a + b) * 4
        );
    };
}

class G964a4 {
    // private static memo = (num: number): number => {
    //   let dp = [];
    //   dp[1] = 1;
    //   dp[2] = 1;
    //   for (let i = 3; i <= num; i++) {
    //     dp[i] = dp[i-1] + dp[i-2];
    //   }
    //   return dp.reduce((prev, curr) => prev + curr);
    // }
    // public static perimeter = (n) => {
    //     return 4 * G964.memo(n+1);
    // }
}

class G964a5 {
    public static perimeter = (n: number) => {
        const fibCalc: number[] = [];
        function fibonacci(n: number): number {
            if (fibCalc[n] !== undefined) {
                return fibCalc[n];
            }

            let calc;
            if (n < 2) {
                calc = n;
            } else {
                calc = fibonacci(n - 2) + fibonacci(n - 1);
            }

            fibCalc.push(calc);
            return calc;
        }

        let length = 0;
        for (let i = 0; i <= n + 1; i++) {
            length += 4 * fibonacci(i);
        }
        return length;
    };
}

class G964a6 {
    public static perimeter = (n: number) => {
        // your code
        var sum = 0;
        var first = 0;
        var last = 0;
        for (var i = 1; i <= n + 1; i++) {
            var el = first + last;
            el = el == 0 ? 1 : el;
            first = last;
            last = el;
            sum += el * 4;
        }
        return sum;
    };
}

class G964a7 {
    public static perimeter = (n: number) => {
        let a = 0,
            b = 4,
            sum = 4;
        for (let i = 1; i <= n; i++) {
            const c = a + b;
            (a = b), (b = c), (sum += c);
        }
        return sum;
    };
}

// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:  ORDER WEIGHT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
My friend John and I are members of the "Fat to Fit Club (FFC)". John is worried because each month a list with the weights of members is published and each month he is the last on the list which means he is the heaviest.
 
I am the one who establishes the list so I told him: "Don't worry any more, I will modify the order of the list". It was decided to attribute a "weight" to numbers. The weight of a number will be from now on the sum of its digits.
 
For example 99 will have "weight" 18, 100 will have "weight" 1 so in the list 100 will come before 99.
 
Given a string with the weights of FFC members in normal order can you give this string ordered by "weights" of these numbers?
 
Example:
"56 65 74 100 99 68 86 180 90" ordered by numbers weights becomes: 
 
"100 180 90 56 65 74 68 86 99"
When two numbers have the same "weight", let us class them as if they were strings (alphabetical ordering) and not numbers:
 
180 is before 90 since, having the same "weight" (9), it comes before as a string.
 
All numbers in the list are positive numbers and the list can be empty.
 
Notes
it may happen that the input string have leading, trailing whitespaces and more than a unique whitespace between two consecutive numbers
*/

// const orderWeight = (strng: string): string => {
//   }

// console.log(orderWeight("103 123 4444 99 2000"));
// console.log(orderWeight("2000 10003 1234000 44444444 9999 11 11 22 123"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ REFACTOR THIS ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PRODUCT OF CONSECUTIVE FIBONACCI NUMBERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The Fibonacci numbers are the numbers in the following integer sequence (Fn):
 
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ...
 
such as
 
F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.
 
Given a number, say prod (for product), we search two Fibonacci numbers F(n) and F(n+1) verifying
 
F(n) * F(n+1) = prod.
 
Your function productFib takes an integer (prod) and returns an array:
 
[F(n), F(n+1), true] or {F(n), F(n+1), 1} or (F(n), F(n+1), True)
depending on the language if F(n) * F(n+1) = prod.
 
If you don't find two consecutive F(n) verifying F(n) * F(n+1) = prodyou will return
 
[F(n), F(n+1), false] or {F(n), F(n+1), 0} or (F(n), F(n+1), False)
F(n) being the smallest one such as F(n) * F(n+1) > prod.
 
Some Examples of Return:
(depend on the language)
 
productFib(714) # should return (21, 34, true), 
                # since F(8) = 21, F(9) = 34 and 714 = 21 * 34
 
productFib(800) # should return (34, 55, false), 
                # since F(8) = 21, F(9) = 34, F(10) = 55 and 21 * 34 < 800 < 34 * 55
-----
productFib(714) # should return [21, 34, true], 
productFib(800) # should return [34, 55, false], 
-----
productFib(714) # should return {21, 34, 1}, 
productFib(800) # should return {34, 55, 0},        
-----
productFib(714) # should return {21, 34, true}, 
productFib(800) # should return {34, 55, false}, 
*/

// 1️⃣ ✅     WHILE LOOP
class G964 {
    public static productFib = (num: number): (number | boolean)[] => {
        let solution: (number | boolean)[] = [];
        const sequence: number[] = [0, 1];
        const products: number[] = [];

        let current: number = 0;

        // ❗️❗️❗️ REFACTOR LOOP ❗️❗️❗️
        while (current <= num) {
            let next = sequence[current] + sequence[current + 1];
            sequence.push(next);
            let product = sequence[current + 1] * sequence[current + 2];
            products.push(product);
            if (product === num) {
                solution = [sequence[current + 1], sequence[current + 2], true];
                break;
            } else if (product > num) {
                solution = [
                    sequence[current + 1],
                    sequence[current + 2],
                    false,
                ];
                break;
            }
            current++;
        }

        return solution;
    };
}

//  INITIALIZE solution / FIBONACCI sequence AND products ARRAYS

//  INITIALIZE current AT 0

//  LOOP OVER INTEGERS UP TO num
//      CALC next ITEM BY ADDING current TO current + 1
//      PUSH next TO sequence
//      CALC CURRENT PRODUCT BY MULTIPLYING current AND current + 1
//      PUSH product INTO products
//      IF product === num
//          solution = [FACTORS OF product , true]
//          BREAK LOOP
//      ELSE IF product > num
//          solution = [FACTORS OF product, false]
//          BREAK LOOP
//      INCREMENT current BY ONE

//      RETURN SOLUTION

// 2️⃣ ✅     FOR LOOP WITH fibMax VARIABLE TO LIMIT MAX LENGHT OF SEQUENCE
export class G9642 {
    public static productFib = (num: number): (number | boolean)[] => {
        let solution: (number | boolean)[] = [];

        const sequence: number[] = [0, 1];
        const products: number[] = [];
        const fibMax = 15;

        for (let i = 0; i <= fibMax; i++) {
            let next = sequence[i] + sequence[i + 1];
            sequence.push(next);
            let product = sequence[i + 1] * sequence[i + 2];
            products.push(product);
            if (product === num) {
                console.log(`found: ${sequence[i + 1]} and ${sequence[i + 2]}`);
                solution = [sequence[i + 1], sequence[i + 2], true];
                break;
            } else if (product > num) {
                console.log("stop the loop: " + product);
                solution = [sequence[i + 1], sequence[i + 2], false];
                break;
            }
        }

        return solution;
    };
}

// console.log(G964.productFib(105));
// console.log(G964.productFib(800));
// console.log(G964.productFib(714));
// console.log(G964.productFib(4895));
// console.log(G964.productFib(5895));

//============= OTHER CODEWARS SOLUTIONS: =============

/*
export class G964 {
    public static productFib = (prod:number) => {
      let p1:number = 1, p2:number = 1;
      while (p1 * p2 < prod) [p1, p2] = [p2, p1+p2];
      return [p1 , p2, (p1 * p2 == prod)]; 
    }
}
 
 
 
export class G964 {
 
    public static productFib = (prod, f0 = 0, f1 = 1) => (f0 * f1 < prod) ? G964.productFib(prod, f1, f0+f1) : [f0,f1,(f0 * f1) === prod]
}
*/

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  DIRECTIONS REDUCTION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Once upon a time, on a way through the old wild mountainous west,…
… a man was given directions to go from one point to another. The directions were "NORTH", "SOUTH", "WEST", "EAST". Clearly "NORTH" and "SOUTH" are opposite, "WEST" and "EAST" too.
 
Going to one direction and coming back the opposite direction right away is a needless effort. Since this is the wild west, with dreadfull weather and not much water, it's important to save yourself some energy, otherwise you might die of thirst!
 
How I crossed a mountainous desert the smart way.
The directions given to the man are, for example, the following (depending on the language):
 
["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"].
or
{ "NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST" };
or
[North, South, South, East, West, North, West]
You can immediatly see that going "NORTH" and immediately "SOUTH" is not reasonable, better stay to the same place! So the task is to give to the man a simplified version of the plan. A better plan in this case is simply:
 
["WEST"]
or
{ "WEST" }
or
[West]
Other examples:
In ["NORTH", "SOUTH", "EAST", "WEST"], the direction "NORTH" + "SOUTH" is going north and coming back right away.
 
The path becomes ["EAST", "WEST"], now "EAST" and "WEST" annihilate each other, therefore, the final result is [] (nil in Clojure).
 
In ["NORTH", "EAST", "WEST", "SOUTH", "WEST", "WEST"], "NORTH" and "SOUTH" are not directly opposite but they become directly opposite after the reduction of "EAST" and "WEST" so the whole path is reducible to ["WEST", "WEST"].
 
Task
Write a function dirReduc which will take an array of strings and returns an array of strings with the needless directions removed (W<->E or S<->N side by side).
 
The Haskell version takes a list of directions with data Direction = North | East | West | South.
The Clojure version returns nil when the path is reduced to nothing.
The Rust version takes a slice of enum Direction {North, East, West, South}.
See more examples in "Sample Tests:"
Notes
Not all paths can be made simpler. The path ["NORTH", "WEST", "SOUTH", "EAST"] is not reducible. "NORTH" and "WEST", "WEST" and "SOUTH", "SOUTH" and "EAST" are not directly opposite of each other and can't become such. Hence the result path is itself : ["NORTH", "WEST", "SOUTH", "EAST"].
*/

// const dirReduc = (arr: string[]): string[] => {

//     while ((arr.includes("NORTH") && arr.includes("SOUTH"))) {
//         arr.splice(arr.indexOf("NORTH"), 1);
//         arr.splice(arr.indexOf("SOUTH"), 1);
//     }

//     while ((arr.includes("EAST") && arr.includes("WEST"))) {
//         arr.splice(arr.indexOf("EAST"), 1);
//         arr.splice(arr.indexOf("WEST"), 1);
//     }

//     console.log(arr);

//     return arr;

// }

const dirReduc = (arr: string[]): string[] => {
    for (let i = 0; i < arr.length; i++) {
        if (
            (arr[i] === "NORTH" && arr[i + 1] === "SOUTH") ||
            (arr[i] === "SOUTH" && arr[i + 1] === "NORTH") ||
            (arr[i] === "EAST" && arr[i + 1] === "WEST") ||
            (arr[i] === "WEST" && arr[i + 1] === "EAST")
        ) {
            arr.splice(i, 2);
            i -= 2;
        }
    }

    // console.log(arr);

    return arr;
};

//  IF PAIR OF OPPOSITES IS FOUND
//      DELETE PAIR
//      RESET LOOP

// console.log(dirReduc(["NORTH", "SOUTH", "NORTH", "SOUTH"]));
// [WEST]
// console.log(dirReduc(["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"]));
// []
// console.log(dirReduc(["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH"]));

// console.log(dirReduc(["NORTH", "SOUTH", "EAST", "WEST"]));

//============= OTHER CODEWARS SOLUTIONS: =============

function dirReduc2(arr: string[]): string[] {
    var pat = /(NORTHSOUTH|SOUTHNORTH|EASTWEST|WESTEAST)/;
    var way = arr.join("");
    while (pat.test(way)) way = way.replace(pat, "");
    return way.match(/(NORTH|SOUTH|EAST|WEST)/g) || [];
}

const dirReduc3 = (arr: string[]): string[] => {
    const opposites = [
        ["NORTH", "SOUTH"],
        ["EAST", "WEST"],
    ];

    return arr.reduce((acc: string[], curr: string) => {
        const opposite = opposites
            .find((el) => el.includes(curr))!
            .filter((el) => el !== curr)[0];

        const idx = acc.length - 1;

        return acc.length && acc[idx] === opposite
            ? acc.slice(0, idx)
            : acc.concat(curr);
    }, []);
};

function dirReduc4(arr: string[]): string[] {
    let str = arr.join(":");

    while (
        str.match(/NORTH:*SOUTH/) ||
        str.match(/SOUTH:*NORTH/) ||
        str.match(/EAST:*WEST/) ||
        str.match(/WEST:*EAST/)
    ) {
        str = str
            .replace(/NORTH:*SOUTH/g, "")
            .replace(/SOUTH:*NORTH/g, "")
            .replace(/EAST:*WEST/g, "")
            .replace(/WEST:*EAST/g, "");
    }

    return str.split(":").filter(Boolean);
}

function dirReduc5(arr: string[]): string[] {
    arr = arr.map((dir) => dir.toUpperCase());

    console.log(arr);
    for (let i = 0; i < arr.length; i++) {
        if (
            (arr[i] === "NORTH" && arr[i + 1] === "SOUTH") ||
            (arr[i] === "SOUTH" && arr[i + 1] === "NORTH") ||
            (arr[i] === "WEST" && arr[i + 1] === "EAST") ||
            (arr[i] === "EAST" && arr[i + 1] === "WEST")
        ) {
            arr.splice(i, 2);
            return dirReduc(arr);
        }
    }

    return arr;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  HUMAN READABLE TIME
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  PADSTART(),PADEND()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function, which takes a non-negative integer (seconds) as input and returns the time in a human-readable format (HH:MM:SS)
 
HH = hours, padded to 2 digits, range: 00 - 99
MM = minutes, padded to 2 digits, range: 00 - 59
SS = seconds, padded to 2 digits, range: 00 - 59
The maximum time never exceeds 359999 (99:59:59)
 
You can find some examples in the test fixtures.
*/

const humanReadable = (secInput: number): string => {
    const HOUR: number = 3600,
        MINUTE: number = 60;
    let secondsLeft: number = secInput;
    let hours: number = 0,
        minutes: number = 0,
        seconds: number = 0;

    const padToTwo = (num: number): string => {
        return num < 10 ? `0${String(num)}` : `${String(num)}`;
    };

    hours = Math.floor(secondsLeft / HOUR);
    secondsLeft = secondsLeft % HOUR;

    minutes = Math.floor(secondsLeft / MINUTE);
    secondsLeft = secondsLeft % MINUTE;

    seconds = secondsLeft;

    // console.table({ hours: hours, minutes: minutes, seconds: seconds });

    return `${padToTwo(hours)}:${padToTwo(minutes)}:${padToTwo(seconds)}`;
};

//  INITIALIZE ALL VARIABLES
//  padToTwo() WILL CONCAT A "0" IF NUMBER IS ONE DIGIT

//  CALC hours
//  UPDATE secondsLeft

//  CALC minutes
//  UPDATE secondsLeft

//  seconds NOW EQUALS TO secondsLeft

//  RETURN FORMATTED STRING

// console.log(humanReadable(86399));
// console.log(humanReadable(3661));
// console.log(humanReadable(3600));
// console.log(humanReadable(3599));
// console.log(humanReadable(66));
// console.log(humanReadable(59));
// console.log(humanReadable(0));

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ padStart() ❗️❗️❗️
const format = (n: number) => String(Math.floor(n)).padStart(2, "00");

export function humanReadable2(seconds: number): string {
    const h = seconds / 3600;
    const m = (seconds % 3600) / 60;
    const s = (seconds % 3600) % 60;

    return [h, m, s].map(format).join(":");
}

function humanReadable3(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds / 60) % 60;
    const pad = (n: number) => `${n}`.padStart(2, "0");
    return `${pad(hours)}:${pad(minutes)}:${pad(seconds % 60)}`;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SIMPLE PIG LATIN
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REGEX, REPLACE() WITH FUNCTION, IGNORE PUNCTUATION AND MULTIPLE SPACES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE:
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Move the first letter of each word to the end of it, then add "ay" to the end of the word. Leave punctuation marks untouched.
 
Examples
pigIt('Pig latin is cool'); // igPay atinlay siay oolcay
pigIt('Hello world !');     // elloHay orldway !
*/

const pigIt = (str: string): string => {
    // 1️⃣
    return str.replace(
        /[a-z]+/gi,
        (word) => `${word.slice(1)}${word.charAt(0)}ay`
    );

    // 2️⃣
    // const validWord = /[a-z]+/gi

    // return str.replace(validWord, (word) => {
    //     return `${word.slice(1)}${word.charAt(0)}ay`
    // });
};

// 'hisTay siay ymay tringsay'
// console.log(pigIt('This is my string'));
// console.log(pigIt('pdNWGEbnnAYBq  qKDVJ prMerdBgTDjFZYaHXd iX ! rxBwJkSVppxW hg . cQFYCExtQFgytIxTj HWEqmZ qFiJOYxcqIObSWjSlJL lg  !  mGJtNrQ iINNKiOohUuMAk dwwOYRmL'));

// pdNWGEbnnAYBq  qKDVJ prMerdBgTDjFZYaHXd iX ! rxBwJkSVppxW hg . cQFYCExtQFgytIxTj HWEqmZ qFiJOYxcqIObSWjSlJL lg  !  mGJtNrQ iINNKiOohUuMAk dwwOYRmL

// EXPECTED THIS:
// dNWGEbnnAYBqpay ay KDVJqay rMerdBgTDjFZYaHXdpay Xiay ! xBwJkSVppxWray ghay . QFYCExtQFgytIxTjcay WEqmZHay FiJOYxcqIObSWjSlJLqay glay ay ! ay GJtNrQmay INNKiOohUuMAkiay wwOYRmLday

// TO EQUAL:
// dNWGEbnnAYBqpay  KDVJqay rMerdBgTDjFZYaHXdpay Xiay ! xBwJkSVppxWray ghay . QFYCExtQFgytIxTjcay WEqmZHay FiJOYxcqIObSWjSlJLqay glay  !  GJtNrQmay INNKiOohUuMAkiay wwOYRmLday

// THIS IS UNSOLVED, FIRST ATTEMPT:
const pigIt2 = (str: string): string => {
    const punctuation = /[?!\.]/g;

    if (punctuation.test(str.charAt(str.length - 1))) {
        console.log("punctuation: " + str.charAt(str.length - 1));
    }

    return str
        .split(" ")
        .map((word) => {
            return `${word.slice(1)}${word.charAt(0)}ay`;
        })
        .join(" ");
};

//============= OTHER CODEWARS SOLUTIONS: =============

const pigIt3 = (a: string) => a.replace(/(\w)(\w+)*/g, "$2$1ay");

const pigIt4 = (a: string): string => {
    return a.replace(/[a-z]+/gi, (x) => x.slice(1) + x[0] + "ay");
};
