// ❗️❗️❗️ ✅  ❓❓❓
// 🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨🟨
// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*

*/



// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:  PRIME FACTOR DECOMPOSITION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Given a positive number n > 1 find the prime factor decomposition of n. The result will be a string with the following form :

 "(p1**n1)(p2**n2)...(pk**nk)"
with the p(i) in increasing order and n(i) empty if n(i) is 1.

Example: n = 86240 should return "(2**5)(5)(7**2)(11)"

A prime number is a whole number greater than 1 whose only factors are 1 and itself. A factor is a whole number that can be divided evenly into another number. The first few prime numbers are 2, 3, 5, 7, 11, 13, 17, 19, 23 and 29. Numbers that have more than two factors are called composite numbers.

Prime Factor Decomposition
Quick revise
Prime factor decomposition of a number means writing it as a product of prime factors.

To factorise a number, divide it by the first possible prime number.
Take the resulting quotient below the number.
If it is possible, continue dividing this quotient successively by the same prime number.
When you cannot do the division by this prime number, divide it by the next possible prime number.
And so forth until the final quotient is 1.
Finally write this number as a product of powers of prime factors.
Example

Find the prime factor decomposition of 36.

We look at 36 and try to find numbers which we can divide it by. We can see that it divides by 2.

36 = 18 × 2

2 is a prime number, but 18 isn't. So we need to split 18 up into prime numbers. We can also divide 18 by 2.

18 = 9 × 2

and so 36 = 18 × 2 = 9 × 2 × 2

But we haven't finished, because 9 is not a prime number. We know that 9 divides by 3.

9 = 3 x 3.

Hence 36 = 9 × 2 × 2 = 3 × 3 × 2 × 2.

This is the answer, because both 2 and 3 are prime numbers.
*/

class G964a8 {

    public static primeFactors = (num: number): string => {

        // GET PRIME NUMBERS

        // DIVIDE 

        return "hello";
    }
}
// console.log();
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============



// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PERIMETER OF SQUARES IN A RECTANGLE
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The drawing shows 6 squares the sides of which have a length of 1, 1, 2, 3, 5, 8. It's easy to see that the sum of the perimeters of these squares is : 4 * (1 + 1 + 2 + 3 + 5 + 8) = 4 * 20 = 80

Could you give the sum of the perimeters of all the squares in a rectangle when there are n + 1 squares disposed in the same manner as in the drawing:

alternative text

Hint:
See Fibonacci sequence

Ref:
http://oeis.org/A000045

The function perimeter has for parameter n where n + 1 is the number of squares (they are numbered from 0 to n) and returns the total perimeter of all the squares.

perimeter(5)  should return 80
perimeter(7)  should return 216
*/

class G964a {

    public static perimeter = (num: number): number => {

        const fibonacciFirstN = (num: number): number[] => {
            const fibSequence: number[] = [1, 1];
            for (let i = 0; i < num - 1; i++) {
                let next = fibSequence[i] + fibSequence[i + 1];
                fibSequence.push(next);
            }
            return fibSequence;
        }

        return 4 * fibonacciFirstN(num).reduce((a, b) => a + b);

    }
}

// 80
// console.log(G964a.perimeter(5));
// 216
// console.log(G964a.perimeter(7));
// 
// console.log(G964a.perimeter(3));
// console.log();
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============


class G964a2 {

    public static perimeter = (n: number) => {
        let numbers = [1, 1];

        for (let i = 2; i <= n; i++) {
            numbers.push(numbers[i - 1] + numbers[i - 2]);
        }

        return 4 * numbers.reduce((curr, acc) => acc + curr, 0);
    }
}



class G964a3 {

    public static perimeter = (n: number) => {
        return Array.from(Array(n + 2).keys()).map((e, i, arr) => { if (i > 0) { arr[i + 1] = arr[i] + arr[i - 1]; return e } else { return 1 } }).slice(1).reduce((a, b) => a + b) * 4
    }
}



class G964a4 {

    // private static memo = (num: number): number => {
    //   let dp = [];
    //   dp[1] = 1;
    //   dp[2] = 1;
    //   for (let i = 3; i <= num; i++) {
    //     dp[i] = dp[i-1] + dp[i-2];
    //   }

    //   return dp.reduce((prev, curr) => prev + curr);
    // }

    // public static perimeter = (n) => {
    //     return 4 * G964.memo(n+1); 
    // }

}



class G964a5 {
    public static perimeter = (n: number) => {
        const fibCalc: number[] = []
        function fibonacci(n: number): number {
            if (fibCalc[n] !== undefined) {
                return fibCalc[n];
            }

            let calc;
            if (n < 2) {
                calc = n;
            } else {
                calc = fibonacci(n - 2) + fibonacci(n - 1)
            }

            fibCalc.push(calc);
            return calc;
        }

        let length = 0;
        for (let i = 0; i <= n + 1; i++) {
            length += (4 * fibonacci(i));
        }
        return length;
    }
}



class G964a6 {

    public static perimeter = (n: number) => {
        // your code
        var sum = 0;
        var first = 0;
        var last = 0;
        for (var i = 1; i <= n + 1; i++) {
            var el = first + last;
            el = el == 0 ? 1 : el;
            first = last;
            last = el;
            sum += el * 4;
        }
        return sum;
    }
}



class G964a7 {

    public static perimeter = (n: number) => {
        let a = 0, b = 4, sum = 4;
        for (let i = 1; i <= n; i++) {
            const c = a + b;
            a = b, b = c, sum += c;
        }
        return sum;
    }
}



// 🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥🟥
// TITLE:  ORDER WEIGHT
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
My friend John and I are members of the "Fat to Fit Club (FFC)". John is worried because each month a list with the weights of members is published and each month he is the last on the list which means he is the heaviest.

I am the one who establishes the list so I told him: "Don't worry any more, I will modify the order of the list". It was decided to attribute a "weight" to numbers. The weight of a number will be from now on the sum of its digits.

For example 99 will have "weight" 18, 100 will have "weight" 1 so in the list 100 will come before 99.

Given a string with the weights of FFC members in normal order can you give this string ordered by "weights" of these numbers?

Example:
"56 65 74 100 99 68 86 180 90" ordered by numbers weights becomes: 

"100 180 90 56 65 74 68 86 99"
When two numbers have the same "weight", let us class them as if they were strings (alphabetical ordering) and not numbers:

180 is before 90 since, having the same "weight" (9), it comes before as a string.

All numbers in the list are positive numbers and the list can be empty.

Notes
it may happen that the input string have leading, trailing whitespaces and more than a unique whitespace between two consecutive numbers
*/

// const orderWeight = (strng: string): string => {
//   }


// console.log(orderWeight("103 123 4444 99 2000"));
// console.log(orderWeight("2000 10003 1234000 44444444 9999 11 11 22 123"));
// console.log();
// console.log();

//============= OTHER CODEWARS SOLUTIONS: =============








//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ REFACTOR THIS ❗️❗️❗️
// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  PRODUCT OF CONSECUTIVE FIBONACCI NUMBERS
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
The Fibonacci numbers are the numbers in the following integer sequence (Fn):

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ...

such as

F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1.

Given a number, say prod (for product), we search two Fibonacci numbers F(n) and F(n+1) verifying

F(n) * F(n+1) = prod.

Your function productFib takes an integer (prod) and returns an array:

[F(n), F(n+1), true] or {F(n), F(n+1), 1} or (F(n), F(n+1), True)
depending on the language if F(n) * F(n+1) = prod.

If you don't find two consecutive F(n) verifying F(n) * F(n+1) = prodyou will return

[F(n), F(n+1), false] or {F(n), F(n+1), 0} or (F(n), F(n+1), False)
F(n) being the smallest one such as F(n) * F(n+1) > prod.

Some Examples of Return:
(depend on the language)

productFib(714) # should return (21, 34, true), 
                # since F(8) = 21, F(9) = 34 and 714 = 21 * 34

productFib(800) # should return (34, 55, false), 
                # since F(8) = 21, F(9) = 34, F(10) = 55 and 21 * 34 < 800 < 34 * 55
-----
productFib(714) # should return [21, 34, true], 
productFib(800) # should return [34, 55, false], 
-----
productFib(714) # should return {21, 34, 1}, 
productFib(800) # should return {34, 55, 0},        
-----
productFib(714) # should return {21, 34, true}, 
productFib(800) # should return {34, 55, false}, 
*/

// 1️⃣ ✅     WHILE LOOP
class G964 {

    public static productFib = (num: number): (number | boolean)[] => {

        let solution: (number | boolean)[] = [];
        const sequence: number[] = [0, 1];
        const products: number[] = [];

        let current: number = 0;

        // ❗️❗️❗️ REFACTOR LOOP ❗️❗️❗️
        while (current <= num) {
            let next = sequence[current] + sequence[current + 1];
            sequence.push(next);
            let product = sequence[current + 1] * sequence[current + 2];
            products.push(product);
            if (product === num) {
                solution = [sequence[current + 1], sequence[current + 2], true];
                break;
            } else if (product > num) {
                solution = [sequence[current + 1], sequence[current + 2], false];
                break;
            }
            current++;
        }

        return solution;

    }

}

//  INITIALIZE solution / FIBONACCI sequence AND products ARRAYS

//  INITIALIZE current AT 0

//  LOOP OVER INTEGERS UP TO num
//      CALC next ITEM BY ADDING current TO current + 1
//      PUSH next TO sequence
//      CALC CURRENT PRODUCT BY MULTIPLYING current AND current + 1
//      PUSH product INTO products
//      IF product === num
//          solution = [FACTORS OF product , true]
//          BREAK LOOP
//      ELSE IF product > num
//          solution = [FACTORS OF product, false]
//          BREAK LOOP
//      INCREMENT current BY ONE

//      RETURN SOLUTION

// 2️⃣ ✅     FOR LOOP WITH fibMax VARIABLE TO LIMIT MAX LENGHT OF SEQUENCE
export class G9642 {

    public static productFib = (num: number): (number | boolean)[] => {

        let solution: (number | boolean)[] = [];

        const sequence: number[] = [0, 1];
        const products: number[] = [];
        const fibMax = 15;

        for (let i = 0; i <= fibMax; i++) {
            let next = sequence[i] + sequence[i + 1];
            sequence.push(next);
            let product = sequence[i + 1] * sequence[i + 2];
            products.push(product);
            if (product === num) {
                console.log(`found: ${sequence[i + 1]} and ${sequence[i + 2]}`);
                solution = [sequence[i + 1], sequence[i + 2], true];
                break;
            } else if (product > num) {
                console.log("stop the loop: " + product);
                solution = [sequence[i + 1], sequence[i + 2], false];
                break;
            }
        }

        return solution;

    }

}


// console.log(G964.productFib(105));
// console.log(G964.productFib(800));
// console.log(G964.productFib(714));
// console.log(G964.productFib(4895));
// console.log(G964.productFib(5895));

//============= OTHER CODEWARS SOLUTIONS: =============

/*
export class G964 {
    public static productFib = (prod:number) => {
      let p1:number = 1, p2:number = 1;
      while (p1 * p2 < prod) [p1, p2] = [p2, p1+p2];
      return [p1 , p2, (p1 * p2 == prod)]; 
    }
}



export class G964 {

    public static productFib = (prod, f0 = 0, f1 = 1) => (f0 * f1 < prod) ? G964.productFib(prod, f1, f0+f1) : [f0,f1,(f0 * f1) === prod]
}
*/

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  DIRECTIONS REDUCTION
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Once upon a time, on a way through the old wild mountainous west,…
… a man was given directions to go from one point to another. The directions were "NORTH", "SOUTH", "WEST", "EAST". Clearly "NORTH" and "SOUTH" are opposite, "WEST" and "EAST" too.

Going to one direction and coming back the opposite direction right away is a needless effort. Since this is the wild west, with dreadfull weather and not much water, it's important to save yourself some energy, otherwise you might die of thirst!

How I crossed a mountainous desert the smart way.
The directions given to the man are, for example, the following (depending on the language):

["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"].
or
{ "NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST" };
or
[North, South, South, East, West, North, West]
You can immediatly see that going "NORTH" and immediately "SOUTH" is not reasonable, better stay to the same place! So the task is to give to the man a simplified version of the plan. A better plan in this case is simply:

["WEST"]
or
{ "WEST" }
or
[West]
Other examples:
In ["NORTH", "SOUTH", "EAST", "WEST"], the direction "NORTH" + "SOUTH" is going north and coming back right away.

The path becomes ["EAST", "WEST"], now "EAST" and "WEST" annihilate each other, therefore, the final result is [] (nil in Clojure).

In ["NORTH", "EAST", "WEST", "SOUTH", "WEST", "WEST"], "NORTH" and "SOUTH" are not directly opposite but they become directly opposite after the reduction of "EAST" and "WEST" so the whole path is reducible to ["WEST", "WEST"].

Task
Write a function dirReduc which will take an array of strings and returns an array of strings with the needless directions removed (W<->E or S<->N side by side).

The Haskell version takes a list of directions with data Direction = North | East | West | South.
The Clojure version returns nil when the path is reduced to nothing.
The Rust version takes a slice of enum Direction {North, East, West, South}.
See more examples in "Sample Tests:"
Notes
Not all paths can be made simpler. The path ["NORTH", "WEST", "SOUTH", "EAST"] is not reducible. "NORTH" and "WEST", "WEST" and "SOUTH", "SOUTH" and "EAST" are not directly opposite of each other and can't become such. Hence the result path is itself : ["NORTH", "WEST", "SOUTH", "EAST"].
*/



// const dirReduc = (arr: string[]): string[] => {


//     while ((arr.includes("NORTH") && arr.includes("SOUTH"))) {
//         arr.splice(arr.indexOf("NORTH"), 1);
//         arr.splice(arr.indexOf("SOUTH"), 1);
//     }

//     while ((arr.includes("EAST") && arr.includes("WEST"))) {
//         arr.splice(arr.indexOf("EAST"), 1);
//         arr.splice(arr.indexOf("WEST"), 1);
//     }

//     console.log(arr);

//     return arr;

// }


const dirReduc = (arr: string[]): string[] => {

    for (let i = 0; i < arr.length; i++) {

        if ((arr[i] === "NORTH" && arr[i + 1] === "SOUTH")
            || (arr[i] === "SOUTH" && arr[i + 1] === "NORTH")
            || (arr[i] === "EAST" && arr[i + 1] === "WEST")
            || (arr[i] === "WEST" && arr[i + 1] === "EAST")
        ) {
            arr.splice(i, 2);
            i -= 2;
        }

    }

    // console.log(arr);

    return arr;

}

//  IF PAIR OF OPPOSITES IS FOUND
//      DELETE PAIR
//      RESET LOOP

// console.log(dirReduc(["NORTH", "SOUTH", "NORTH", "SOUTH"]));
// [WEST]
// console.log(dirReduc(["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH", "WEST"]));
// []
// console.log(dirReduc(["NORTH", "SOUTH", "SOUTH", "EAST", "WEST", "NORTH"]));

// console.log(dirReduc(["NORTH", "SOUTH", "EAST", "WEST"]));

//============= OTHER CODEWARS SOLUTIONS: =============

function dirReduc2(arr: string[]): string[] {
    var pat = /(NORTHSOUTH|SOUTHNORTH|EASTWEST|WESTEAST)/;
    var way = arr.join('');
    while (pat.test(way)) way = way.replace(pat, '');
    return way.match(/(NORTH|SOUTH|EAST|WEST)/g) || [];
}



const dirReduc3 = (arr: string[]): string[] => {
    const opposites = [
        ['NORTH', 'SOUTH'],
        ['EAST', 'WEST'],
    ];

    return arr.reduce((acc: string[], curr: string) => {
        const opposite = opposites
            .find((el) => el.includes(curr))!
            .filter((el) => el !== curr)[0];

        const idx = acc.length - 1;

        return acc.length && acc[idx] === opposite
            ? acc.slice(0, idx)
            : acc.concat(curr);
    }, []);
};



function dirReduc4(arr: string[]): string[] {
    let str = arr.join(':');

    while (str.match(/NORTH:*SOUTH/) || str.match(/SOUTH:*NORTH/) || str.match(/EAST:*WEST/) || str.match(/WEST:*EAST/)) {
        str = str.replace(/NORTH:*SOUTH/g, '').replace(/SOUTH:*NORTH/g, '').replace(/EAST:*WEST/g, '').replace(/WEST:*EAST/g, '');
    }

    return str.split(':').filter(Boolean);
}



function dirReduc5(arr: string[]): string[] {
    arr = arr.map(dir => dir.toUpperCase());

    console.log(arr)
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === "NORTH" && arr[i + 1] === "SOUTH" ||
            arr[i] === "SOUTH" && arr[i + 1] === "NORTH" ||
            arr[i] === "WEST" && arr[i + 1] === "EAST" ||
            arr[i] === "EAST" && arr[i + 1] === "WEST") {
            arr.splice(i, 2);
            return dirReduc(arr);
        }
    }

    return arr;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  HUMAN READABLE TIME
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  PADSTART(),PADEND()
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Write a function, which takes a non-negative integer (seconds) as input and returns the time in a human-readable format (HH:MM:SS)

HH = hours, padded to 2 digits, range: 00 - 99
MM = minutes, padded to 2 digits, range: 00 - 59
SS = seconds, padded to 2 digits, range: 00 - 59
The maximum time never exceeds 359999 (99:59:59)

You can find some examples in the test fixtures.
*/

const humanReadable = (secInput: number): string => {

    const HOUR: number = 3600, MINUTE: number = 60;
    let secondsLeft: number = secInput;
    let hours: number = 0, minutes: number = 0, seconds: number = 0;

    const padToTwo = (num: number): string => {
        return num < 10 ? `0${String(num)}` : `${String(num)}`
    }

    hours = Math.floor(secondsLeft / HOUR);
    secondsLeft = secondsLeft % HOUR;

    minutes = Math.floor(secondsLeft / MINUTE);
    secondsLeft = secondsLeft % MINUTE;

    seconds = secondsLeft;

    // console.table({ hours: hours, minutes: minutes, seconds: seconds });

    return `${padToTwo(hours)}:${padToTwo(minutes)}:${padToTwo(seconds)}`;

}

//  INITIALIZE ALL VARIABLES
//  padToTwo() WILL CONCAT A "0" IF NUMBER IS ONE DIGIT 

//  CALC hours
//  UPDATE secondsLeft

//  CALC minutes
//  UPDATE secondsLeft

//  seconds NOW EQUALS TO secondsLeft

//  RETURN FORMATTED STRING




// console.log(humanReadable(86399));
// console.log(humanReadable(3661));
// console.log(humanReadable(3600));
// console.log(humanReadable(3599));
// console.log(humanReadable(66));
// console.log(humanReadable(59));
// console.log(humanReadable(0));

//============= OTHER CODEWARS SOLUTIONS: =============

// ❗️❗️❗️ padStart() ❗️❗️❗️
const format = (n: number) => String(Math.floor(n)).padStart(2, "00");

export function humanReadable2(seconds: number): string {
    const h = seconds / 3600;
    const m = seconds % 3600 / 60;
    const s = seconds % 3600 % 60;

    return [h, m, s].map(format).join(":");
}



function humanReadable3(seconds: number): string {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds / 60) % 60;
    const pad = (n: number) => `${n}`.padStart(2, '0');
    return `${pad(hours)}:${pad(minutes)}:${pad(seconds % 60)}`;
}

// 🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩🟩
// TITLE:  SIMPLE PIG LATIN
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// KEYWORDS:  REGEX, REPLACE() WITH FUNCTION, IGNORE PUNCTUATION AND MULTIPLE SPACES
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰
// SOURCE: 
// 🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰🀰

/*
Move the first letter of each word to the end of it, then add "ay" to the end of the word. Leave punctuation marks untouched.

Examples
pigIt('Pig latin is cool'); // igPay atinlay siay oolcay
pigIt('Hello world !');     // elloHay orldway !
*/

const pigIt = (str: string): string => {

    // 1️⃣
    return str.replace(/[a-z]+/gi, (word) => `${word.slice(1)}${word.charAt(0)}ay`);

    // 2️⃣
    // const validWord = /[a-z]+/gi

    // return str.replace(validWord, (word) => {
    //     return `${word.slice(1)}${word.charAt(0)}ay`
    // });

}

// 'hisTay siay ymay tringsay'
// console.log(pigIt('This is my string'));
// console.log(pigIt('pdNWGEbnnAYBq  qKDVJ prMerdBgTDjFZYaHXd iX ! rxBwJkSVppxW hg . cQFYCExtQFgytIxTj HWEqmZ qFiJOYxcqIObSWjSlJL lg  !  mGJtNrQ iINNKiOohUuMAk dwwOYRmL'));

// pdNWGEbnnAYBq  qKDVJ prMerdBgTDjFZYaHXd iX ! rxBwJkSVppxW hg . cQFYCExtQFgytIxTj HWEqmZ qFiJOYxcqIObSWjSlJL lg  !  mGJtNrQ iINNKiOohUuMAk dwwOYRmL

// EXPECTED THIS:
// dNWGEbnnAYBqpay ay KDVJqay rMerdBgTDjFZYaHXdpay Xiay ! xBwJkSVppxWray ghay . QFYCExtQFgytIxTjcay WEqmZHay FiJOYxcqIObSWjSlJLqay glay ay ! ay GJtNrQmay INNKiOohUuMAkiay wwOYRmLday

// TO EQUAL:
// dNWGEbnnAYBqpay  KDVJqay rMerdBgTDjFZYaHXdpay Xiay ! xBwJkSVppxWray ghay . QFYCExtQFgytIxTjcay WEqmZHay FiJOYxcqIObSWjSlJLqay glay  !  GJtNrQmay INNKiOohUuMAkiay wwOYRmLday


// THIS IS UNSOLVED, FIRST ATTEMPT:
const pigIt2 = (str: string): string => {

    const punctuation = /[?!\.]/g;

    if (punctuation.test(str.charAt(str.length - 1))) {
        console.log("punctuation: " + str.charAt(str.length - 1));
    }

    return str
        .split(" ")
        .map((word) => {
            return `${word.slice(1)}${word.charAt(0)}ay`
        })
        .join(" ");
}

//============= OTHER CODEWARS SOLUTIONS: =============

const pigIt3 = (a: string) => a.replace(/(\w)(\w+)*/g, "$2$1ay")


const pigIt4 = (a: string): string => {
    return a.replace(/[a-z]+/ig, x => x.slice(1) + x[0] + "ay")
}
