// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============


// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============






// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============


// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============






// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============


// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============






// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============


// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============






// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============


// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============






// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============


// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============






// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============


// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============






// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============


// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°


//============= OTHER CODEWARS SOLUTIONS: =============



// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  CONVERT STRING TO CAMEL CASE / UPPER CAMEL (PASCAL)
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// Complete the method/function so that it converts dash/underscore delimited words into camel casing. The first word within the output should be capitalized only if the original word was capitalized (known as Upper Camel Case, also often referred to as Pascal case).

// Examples
// "the-stealth-warrior" gets converted to "theStealthWarrior"
// "The_Stealth_Warrior" gets converted to "TheStealthWarrior"

const isCapitalized = (word) => {                           // IS word CAPITALIZED?
	return word.charAt(0) === word.charAt(0).toUpperCase();
};

const capitalizeStr = (str) => {                        //  CAPITALIZE
	return str.charAt(0).toUpperCase() + str.slice(1);
};

const toCamelCase = (str) => {
	const strArr = str.split(/[_-]/g);                  // SPLIT ON _ AND -
	if (isCapitalized(strArr[0])) {                     // IF FIRST WORD IS CAPITALIZED:
		return strArr.map(capitalizeStr).join("");          // CAPITALIZE ALL
	} else {                                            // OTHERWISE:
		for (let i = 1; i < strArr.length; i++) {           // CAPITALIZE ALL BUT FIRST
			strArr[i] = capitalizeStr(strArr[i]);
		}
		return strArr.join("");
	}
};

// toCamelCase("the_stealth_warrior");
// toCamelCase("The-Stealth-Warrior");
// toCamelCase("A-B-C");

//============= OTHER CODEWARS SOLUTIONS: =============


// function toCamelCase(str){
//       var regExp=/[-_]\w/ig;
//       return str.replace(regExp,function(match){
//             return match.charAt(1).toUpperCase();
//        });
// }

// function toCamelCase(str){
//   return str.replace(/[-_](.)/g, (_, c) => c.toUpperCase());
// }

// function toCamelCase(str){
//   return str.split(/-|_/g).map((w, i) => (i > 0 ? w.charAt(0).toUpperCase() : w.charAt(0)) + w.slice(1)).join('');
// }



// ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨ðŸŸ¨
// TITLE:  TAKE A TEN MINUTE WALK (UNSOLVED)
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// You live in the city of Cartesia where all roads are laid out in a perfect grid. You arrived ten minutes too early to an appointment, so you decided to take the opportunity to go for a short walk. The city provides its citizens with a Walk Generating App on their phones -- everytime you press the button it sends you an array of one-letter strings representing directions to walk (eg. ['n', 's', 'w', 'e']). You always walk only a single block for each letter (direction) and you know it takes you one minute to traverse one city block, so create a function that will return true if the walk the app gives you will take you exactly ten minutes (you don't want to be early or late!) and will, of course, return you to your starting point. Return false otherwise.

// Note: you will always receive a valid array containing a random assortment of direction letters ('n', 's', 'e', or 'w' only). It will never give you an empty array (that's not a walk, that's standing still!).

const isValidWalk = (walk) => {
	const counter = {};
	for (dir of walk) {
		if (!counter[dir]) {
			counter[dir] = 0;
		}
		counter[dir] += 1;
	}
	// for (let i = 0; i < walk.length; i++) {
	//     if (!counter[walk[i]]) {
	//         counter[walk[i]] = 0;
	//     }
	//    counter[walk[i]] += 1;
	//  }
	// console.log(counter);
	return counter["e"] === counter["w"] && counter["n"] === counter["s"];
};

// isValidWalk(["n", "s", "n", "s", "n", "s", "n", "s", "n", "s"]);
// isValidWalk(['w','e','w','e','w','e','w','e','w','e','w','e']);
// isValidWalk(["n", "s", "w", "e", "n", "s"]);

!isValidWalk(['w', 'e', 'w', 'e', 'w', 'e', 'w', 'e', 'w', 'e', 'w', 'e'])



// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  DECODE THE MORSE CODE
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// In this kata you have to write a simple Morse code decoder. While the Morse code is now mostly superseded by voice and digital data communication channels, it still has its use in some applications around the world.
// The Morse code encodes every character as a sequence of "dots" and "dashes". For example, the letter A is coded as Â·âˆ’, letter Q is coded as âˆ’âˆ’Â·âˆ’, and digit 1 is coded as Â·âˆ’âˆ’âˆ’âˆ’. The Morse code is case-insensitive, traditionally capital letters are used. When the message is written in Morse code, a single space is used to separate the character codes and 3 spaces are used to separate words. For example, the message HEY JUDE in Morse code is Â·Â·Â·Â· Â· âˆ’Â·âˆ’âˆ’   Â·âˆ’âˆ’âˆ’ Â·Â·âˆ’ âˆ’Â·Â· Â·.

// NOTE: Extra spaces before or after the code have no meaning and should be ignored.

// In addition to letters, digits and some punctuation, there are some special service codes, the most notorious of those is the international distress signal SOS (that was first issued by Titanic), that is coded as Â·Â·Â·âˆ’âˆ’âˆ’Â·Â·Â·. These special codes are treated as single special characters, and usually are transmitted as separate words.

// Your task is to implement a function that would take the morse code as input and return a decoded human-readable string.

// For example:

// decodeMorse('.... . -.--   .--- ..- -.. .')
// //should return "HEY JUDE"
// NOTE: For coding purposes you have to use ASCII characters . and -, not Unicode characters.

// The Morse code table is preloaded for you as a dictionary, feel free to use it:

// Coffeescript/C++/Go/JavaScript/Julia/PHP/Python/Ruby/TypeScript: MORSE_CODE['.--']
// C#: MorseCode.Get(".--") (returns string)
// F#: MorseCode.get ".--" (returns string)
// Elixir: @morse_codes variable (from use MorseCode.Constants). Ignore the unused variable warning for morse_codes because it's no longer used and kept only for old solutions.
// Elm: MorseCodes.get : Dict String String
// Haskell: morseCodes ! ".--" (Codes are in a Map String String)
// Java: MorseCode.get(".--")
// Kotlin: MorseCode[".--"] ?: "" or MorseCode.getOrDefault(".--", "")
// Racket: morse-code (a hash table)
// Rust: MORSE_CODE
// Scala: morseCodes(".--")
// Swift: MorseCode[".--"] ?? "" or MorseCode[".--", default: ""]
// C: provides parallel arrays, i.e. morse[2] == "-.-" for ascii[2] == "C"
// NASM: a table of pointers to the morsecodes, and a corresponding list of ascii symbols
// All the test strings would contain valid Morse code, so you may skip checking for errors and exceptions. In C#, tests will fail if the solution code throws an exception, please keep that in mind. This is mostly because otherwise the engine would simply ignore the tests, resulting in a "valid" solution.

decodeMorse = function (mCode) {
	// if (mCode === "...---...") {
	// 	return "SOS";
	// }
	const wordsArr = mCode.trim().split("   ");
	let solutionArr = [];
	for (word of wordsArr) {
		let solutionWord = "";
		// console.log(word);
		let lettersArr = word.split(" ");
		// console.log(lettersArr);
		for (let i = 0; i < lettersArr.length; i++) {
			let current = lettersArr[i];
			console.log(current);
			if (current === ".-") solutionWord += "A";
			if (current === "-...") solutionWord += "B";
			if (current === "-.-.") solutionWord += "C";
			if (current === "-..") solutionWord += "D";
			if (current === ".") solutionWord += "E";
			if (current === "..-.") solutionWord += "F";
			if (current === "--.") solutionWord += "G";
			if (current === "....") solutionWord += "H";
			if (current === "..") solutionWord += "I";
			if (current === ".---") solutionWord += "J";
			if (current === "-.-") solutionWord += "K";
			if (current === ".-..") solutionWord += "L";
			if (current === "--") solutionWord += "M";
			if (current === "-.") solutionWord += "N";
			if (current === "---") solutionWord += "O";
			if (current === ".--.") solutionWord += "P";
			if (current === "--.-") solutionWord += "Q";
			if (current === ".-.") solutionWord += "R";
			if (current === "...") solutionWord += "S";
			if (current === "-") solutionWord += "T";
			if (current === "..-") solutionWord += "U";
			if (current === "...-") solutionWord += "V";
			if (current === ".--") solutionWord += "W";
			if (current === "-..-") solutionWord += "X";
			if (current === "-.--") solutionWord += "Y";
			if (current === "--..") solutionWord += "Z";

			if (current === "-.-.--") solutionWord += "!";
			if (current === ".-.-.-") solutionWord += ".";

		}
		// console.log(lettersArr);
		// console.log(solutionWord);
		solutionArr.push(solutionWord);
	}
	// console.log(solutionArr);
	// console.log(solutionArr.join(" "));
	return solutionArr.join(" ");
};

// decodeMorse(".... . -.--   .--- ..- -.. .");
decodeMorse("   .   . ");

// NOTE: for (word in wordsArr) WILL RETURN INDICES OF ELEMENTS !!!

//============= OTHER CODEWARS SOLUTIONS: =============

// decodeMorse = function(morseCode){
//   function decodeMorseLetter(letter) {
//     return MORSE_CODE[letter];
//   }
//   function decodeMorseWord(word) {
//     return word.split(' ').map(decodeMorseLetter).join('');
//   }
//   return morseCode.trim().split('   ').map(decodeMorseWord).join(' ');
// }

// decodeMorse = function(morseCode){
//   return morseCode
//     .trim()
//     .split(/  | /)
//     .map( (code) => MORSE_CODE[code] || ' ')
//     .join('');
// }

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// Write a function that accepts an array of 10 integers (between 0 and 9), that returns a string of those numbers in the form of a phone number.

// Example
// createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]) // => returns "(123) 456-7890"
// The returned format must be correct in order to complete this challenge.
// Don't forget the space after the closing parentheses!

const createPhoneNumber = (nums) => {
	nums.splice(0, 0, "(");
	nums.splice(4, 0, ") ");
	nums.splice(8, 0, "-");
	return nums.join("");
};

createPhoneNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]);

// ========== OTHER CODEWARS SOLUTIONS ==========

// function createPhoneNumber(numbers){
//   var n = numbers;
//   return '('+n[0]+n[1]+n[2]+') '+n[3]+n[4]+n[5]+'-'+n[6]+n[7]+n[8]+n[9];
// }

// function createPhoneNumber(numbers){
//   return `(${numbers[0]}${numbers[1]}${numbers[2]}) ${numbers[3]}${numbers[4]}${numbers[5]}-${numbers[6]}${numbers[7]}${numbers[8]}${numbers[9]}`
// }

// function createPhoneNumber(numbers){
//   return numbers.join('').replace(/(...)(...)(.*)/, '($1) $2-$3');
// }

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// 24/3/20

var uniqueInOrder = function (iterable) {
	var resultArr = [];                                                   // EMPTY ARR FOR RESULT
	if (typeof iterable === "string") {                                   // if INPUT IS STR
		var inputArr = iterable.split("");                                  // CONVERT IT TO ARR
	} else {                                                              // if INPUT STR IS ARR
		inputArr = iterable;                                                // LEAVE AS IT IS
	}
	if (inputArr.length < 2) {                                            // if INPUT HAS ONLY ONE CHAR
		return inputArr;                                                    // RETURN IT
	}
	for (var i = 1; i < inputArr.length; i++) {                           // LOOP OVER ARRAY
		resultArr[0] = inputArr[0];                                         // START RESULT ARRAY WITH FIRST ELEMENT OF INPUT ARRAY
		if (inputArr[i] !== inputArr[i - 1]) {                              // if CURRENT ELEMENT IS DIFFERENT FROM PREVIOUS ELEMENT
			resultArr.push(inputArr[i]);                                      // PUSH IT TO RESULT ARRAY
		}
	}
	return resultArr;                                                     // RETURN RESULT
}

//===================================== ANOTHER SOLUTION =================================================

// function uniqueInOrder(it) {
//   var result = []
//   var last

//   for (var i = 0; i < it.length; i++) {
//     if (it[i] !== last) {
//       result.push(last = it[i])
//     }
//   }

//   return result
// }

//===================================== ANOTHER SOLUTION =================================================

// var uniqueInOrder=function(iterable){
//   return Array.from(iterable)
//     .filter((el, i, arr) => i == 0 || el != arr[i-1])
// }

//===================================== ANOTHER SOLUTION =================================================


// Implement the function unique_in_order which takes as argument a sequence and returns a list of items without any elements with the same value next to each other and preserving the original order of elements. Remember iterable can be a string or an array and has to work with one character too !!!

// uniqueInOrder('A')
// uniqueInOrder('AAAABBBCCDAABBB')// == ['A', 'B', 'C', 'D', 'A', 'B']
// uniqueInOrder('ABBCcAD')        // == ['A', 'B', 'C', 'c', 'A', 'D']
// uniqueInOrder([1,2,2,3,3])       //== [1,2,3]

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// Remove all values from list a, which are present in list b.
//  23/3/20

function arrayDiff(a, b) {
	var arrA = a;                                 // SAVE INPUT TO VARS
	var arrB = b;
	var resultArr = [];                           // EMPTY ARR FOR RESULT
	for (var i = 0; i < arrA.length; i++) {       // ITERATE OVER ARRAY A
		if (!arrB.includes(arrA[i])) {              // IF CURRENT ELEMENT IS NOT LISTED IN ARRAY B
			// console.log("match");
			resultArr.push(arrA[i]);                  // PUSH IT INTO RESULT ARR
		}
	}
	// console.log(resultArr);
	return resultArr;
}

//========================== ANOTHER SOLUTION ====================================

// var array_diff = (a, b) => a.filter(item => b.indexOf(item) < 0)

//========================== ANOTHER SOLUTION ====================================

// function array_diff(a, b) {
//   return a.filter((v) => b.indexOf(v));
// }

//========================== ANOTHER SOLUTION ====================================

// function array_diff(a, b) {
//   return a.filter(function(x) { return b.indexOf(x) == -1; });
// }

//========================== ANOTHER SOLUTION ====================================

// function array_diff(a, b) {
//   return a.filter(e => !b.includes(e));
// }


// arrayDiff([1,2,1,1],[1])

// Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.

// It should remove all values from list a, which are present in list b.

// arrayDiff([1,2],[1])// == [2]
// If a value is present in b, all of its occurrences must be removed from the other:

// arrayDiff([1,2,2,2,3],[2])// == [1,3]

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// Remove all values from list a, which are present in list b.
//  23/3/20

function arrayDiff(a, b) {
	var arrA = a;                                 // SAVE INPUT TO VARS
	var arrB = b;
	var resultArr = [];                           // EMPTY ARR FOR RESULT
	for (var i = 0; i < arrA.length; i++) {       // ITERATE OVER ARRAY A
		if (!arrB.includes(arrA[i])) {              // IF CURRENT ELEMENT IS NOT LISTED IN ARRAY B
			// console.log("match");
			resultArr.push(arrA[i]);                  // PUSH IT INTO RESULT ARR
		}
	}
	// console.log(resultArr);
	return resultArr;
}

//========================== ANOTHER SOLUTION ====================================

// var array_diff = (a, b) => a.filter(item => b.indexOf(item) < 0)

//========================== ANOTHER SOLUTION ====================================

// function array_diff(a, b) {
//   return a.filter((v) => b.indexOf(v));
// }

//========================== ANOTHER SOLUTION ====================================

// function array_diff(a, b) {
//   return a.filter(function(x) { return b.indexOf(x) == -1; });
// }

//========================== ANOTHER SOLUTION ====================================

// function array_diff(a, b) {
//   return a.filter(e => !b.includes(e));
// }


// arrayDiff([1,2,1,1],[1])

// Your goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.

// It should remove all values from list a, which are present in list b.

// arrayDiff([1,2],[1])// == [2]
// If a value is present in b, all of its occurrences must be removed from the other:

// arrayDiff([1,2,2,2,3],[2])// == [1,3]

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// find out which one of the given numbers differs from the others and return its position
// 22/3/20

function iqTest(numbers) {
	var numsArr = numbers.split(" ");                                     // SPLIT STR INTO ARRAY OF SUBSRINGS
	var odds = [];                                                        // EMPTY ARR FOR ODDS / EVENS
	var evens = [];
	for (var i = 0; i < numsArr.length; i++) {
		numsArr[i] = Number(numsArr[i]);                                    // CONVERT SUBSTRINGS TO NUMBER
		var currentNum = numsArr[i];                                        // DEFINE CURRENT NUMBER
		if (!Number.isInteger(currentNum / 2)) {                            // if ODD
			odds.push(currentNum);                                            // PUSH INTO ODDS
		} else {                                                            // if EVEN
			evens.push(currentNum);                                           // PUSH INTO EVENS
		}
	}
	if (odds.length === 1) {                                              // FIND NUM THAT DIFFERS FROM OTHERS IF ODD
		// console.log("The odd one out is " + odds[0] + " at index "+ numsArr.indexOf(odds[0]));
		return numsArr.indexOf(odds[0]) + 1;                                // FIND ITS POSITION (INDEX + 1) IN INPUT ARRAY
	} else {                                                              // FIND NUM THAT DIFFERS FROM OTHERS IF EVEN
		// console.log("The odd one out is " + evens[0] + " at index "+ numsArr.indexOf(evens[0]));
		return numsArr.indexOf(evens[0]) + 1;                               // FIND ITS POSITION (INDEX + 1) IN INPUT ARRAY
	}
}


//================================= ANOTHER SOLUTION =====================================

// function iqTest(numbers){
//   numbers = numbers.split(" ").map(function(el){return parseInt(el)});

//   var odd = numbers.filter(function(el){ return el % 2 === 1});
//   var even = numbers.filter(function(el){ return el % 2 === 0});

//   return odd.length < even.length ? (numbers.indexOf(odd[0]) + 1) : (numbers.indexOf(even[0]) + 1);
// }

//================================= ANOTHER SOLUTION =====================================

// Bob is preparing to pass IQ test. The most frequent task in this test is to find out which one of the given numbers differs from the others. Bob observed that one number usually differs from the others in evenness. Help Bob â€” to check his answers, he needs a program that among the given numbers finds one that is different in evenness, and return a position of this number.

// ! Keep in mind that your task is to help Bob solve a real IQ test, which means indexes of the elements start from 1 (not 0)

// ##Examples :

// iqTest("2 4 7 8 10") //  => 3  Third number is odd, while the rest of the numbers are even

// iqTest("1 2 1 1") // => 2  Second number is even, while the rest of the numbers are odd

//==========================================================================================
//   var arr = [2,4,6,7,8]
// undefined
// arr
// (5)Â [2, 4, 6, 7, 8]
// arr.indexOf(7)
// 3
//   var odds = [7]
// undefined
// odds[0]
// 7
// arr.indexOf(odds[0])
// 3

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// Replace Chars a-z With Alphabet Position
// 21/3/20

function alphabetPosition(text) {
	var text = text.toLowerCase();                                // CASE INSENSITIVE
	var abc = "abcdefghijklmnopqrstuvwxyz";                       // ALL CHARACTERS a-z AS A STRING SO THEIR INDEXES CAN BE ACCESSED
	var positionArr = [];                                         // EMPTY ARR FOR POSITON VALUES       
	var positionStr = "";                                         // EMPTY STR FOR RESULT
	var currentLetter;
	for (var i = 0; i < text.length; i++) {                       // LOOP THROUGH INPUT STR
		currentLetter = text.charAt(i);                             // SAVE text.charAt(i) TO A VARIABLE
		if (abc.includes(currentLetter)) {                          // if CURRENT LETTER IS FOUND IN abc (a-z)    (text.charAt(i) = CURRENT LETTER)
			positionArr.push(abc.indexOf(currentLetter) + 1);         // PUSH ITS abc INDEX + 1 TO POSITIONARR
		}                                                           // !!!  POSITION = (INDEX + 1) !!!
	}
	positionStr = positionArr.join(" ");                          // CONCATENATE ARR ELEMENTS TO FORM A STRING FOR RESULT
	return positionStr;                                           // RETURN RESULT
}

//======================================= ANOTHER SOLUTION ==========================================

// function alphabetPosition(text) {
//   return text
//     .toUpperCase()
//     .match(/[a-z]/gi)
//     .map( (c) => c.charCodeAt() - 64)
//     .join(' ');
// }

//======================================= ANOTHER SOLUTION ==========================================

// In this kata you are required to, given a string, replace every letter with its position in the alphabet.
// If anything in the text isn't a letter, ignore it and don't return it.
// "a" = 1, "b" = 2, etc.

// Examples
// alphabetPosition("abcdefghijk")
// alphabetPosition("The sunset sets at twelve o' clock.")
// Should return "20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11" (as a string)





//   var lettersStr = "abcdefghijklmnopqrstuvwxyz";

// lettersStr.indexOf("a")
// 0

// var text = "hello"

//   lettersStr.includes(text.charAt(0));
// true

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// Bit Counting
// 20/3/20

var countBits = function (num) {
	var placeValueArr = [1];                             // DECLARE PLACEVALUEARR FOR PLACE VALUES
	var bitArr = [];                                     // EMPTY ARRAY FOR BINARY DIGITS
	var placeValue = 1;                                  // SET PLACEVALUE TO 1 AS THE FIRST BASE 2 PLACE VALUE
	while (placeValue <= num) {                          // THIS LOOP WILL GENERATE A REVERSED SEQUENCE OF PLACE VALUES (LESS OR EQUAL TO INPUT NUM)
		placeValue = placeValue * 2;
		placeValueArr.unshift(placeValue);                     // RESULT:[1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1]
	}
	for (var i = 0; i < placeValueArr.length; i++) {     // THIS LOOP CONVERTS INPUT NUM TO BINARY
		if (num - placeValueArr[i] >= 0) {                    // if PLACE VALUE CAN BE SUBTRACTED FROM NUM WITH ZERO OR POSITIVE REMAINDER 
			num = num - placeValueArr[i];                          // SUBTRACT IT AND
			bitArr.push(1);                                        // PUSH 1 
		} else {                                              // if IT WOULD LEAVE A NEGATIVE REMAINDER, MOVE ON TO NEXT VALUE WITHOUT SUBTRACTING
			bitArr.push(0);                                         // PUSH 0 
		}                                                         // RESULT:[1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0]
	}
	if (bitArr[0] === 0) {                               // REMOVE FIRST DIGIT IF IT IS 0
		bitArr.splice(0, 1);
	}
	return bitArr.reduce((a, b) => a + b, 0);            // 5      RETURN SUM OF BITARR ELEMENTS
};


// countBits(4);

//================================================= OTHER SOLUTION =========================================================

// countBits = n => n.toString(2).split('0').join('').length;

//================================================= OTHER SOLUTION =========================================================
// var countBits = function(n)
// {
//   a = n.toString(2).match(/1/g);
//   return a == null ? 0 : a.length;
// };
//================================================= OTHER SOLUTION =========================================================
// var countBits = function(n) {
//   var count = 0;
//   while(n > 0){
//     if(n%2 === 1) {
//       count++;
//     }
//     n = Math.floor(n/2);
//   }
//   return count;
// };
// countBits(4);


//=================================================================

// Write a function that takes an integer as input, and returns the number of bits that are equal to one in the binary representation of that number. You can guarantee that input is non-negative.

// Example: The binary representation of 1234 is 10011010010, so the function should return 5 in this case

//=================================================================

// function calcPlaceValues(num) {
//   var placeValueArr = [1];
//   var x = 1;
//   while (x < num / 2) {
//     x = x * 2;
//     // console.log(x);
//     placeValueArr.unshift(x);
//   }
//   // console.log(placeValueArr);
//   return placeValueArr;
// }

// calcPlaceValues(100);

// function getBinaryArr(num, placeValueArr) {
//   var bitArr = [];
//   for (var i = 0; i < placeValueArr.length; i++) {
//     console.log(placeValueArr[i]);
//     if (num - placeValueArr[i] >= 0) {
//       num = num - placeValueArr[i];
//       bitArr.push(1);
//     } else {
//       bitArr.push(0);
//     }
//   }
//   console.log(bitArr);
//   console.log(bitArr.reduce((a, b) => a + b, 0));
//   return bitArr.reduce((a, b) => a + b, 0);
// }

// getBinaryArr(100, [64, 32, 16, 8, 4, 2, 1]);

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// Return the words of the initial song that Polycarpus used to make a dubsteb remix.Remove all WUB's, separate the words with a space and trim.
// 19/3/20

function songDecoder(song) {
	var noWub = song.replace(/WUB/g, " "); // REMOVE ALL WUBS
	return noWub.replace(/\s+/g, " ").trim(); // REMOVE EXTRA SPACES
}

//================================ OTHER SOLUTION ==============================

// function songDecoder(song) {
//   return song.replace(/(WUB)+/g, " ").trim();
// }

//================================ OTHER SOLUTION ==============================

// const songDecoder = song => song.replace(/(WUB)+/g, " ").trim();

//================================ OTHER SOLUTION ==============================

// const songDecoder = song =>
//   song
//     .split("WUB")
//     .filter(a => a !== "")
//     .join(" ");

// songDecoder("WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB");
// =>  WE ARE THE CHAMPIONS MY FRIEND

// songDecoder("WUBWEWUBAREWUBWUBTHEWUBCHAMPIONSWUBMYWUBFRIENDWUB");
// =>  WE ARE THE CHAMPIONS MY FRIEND

// Polycarpus works as a DJ in the best Berland nightclub, and he often uses dubstep music in his performance. Recently, he has decided to take a couple of old songs and make dubstep remixes from them.

// Let's assume that a song consists of some number of words (that don't contain WUB). To make the dubstep remix of this song, Polycarpus inserts a certain number of words "WUB" before the first word of the song (the number may be zero), after the last word (the number may be zero), and between words (at least one between any pair of neighbouring words), and then the boy glues together all the words, including "WUB", in one string and plays the song at the club.

// For example, a song with words "I AM X" can transform into a dubstep remix as "WUBWUBIWUBAMWUBWUBX" and cannot transform into "WUBWUBIAMWUBX".

// Recently, Jonny has heard Polycarpus's new dubstep track, but since he isn't into modern music, he decided to find out what was the initial song that Polycarpus remixed. Help Jonny restore the original song.

// Input
// The input consists of a single non-empty string, consisting only of uppercase English letters, the string's length doesn't exceed 200 characters

// Output
// Return the words of the initial song that Polycarpus used to make a dubsteb remix. Separate the words with a space.


// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// Vasya - Clerk 
// HAVE CHANGE FOR 50 OR 100 WITHOUT LETTING PEOPLE WITH EXACT AMOUNT PURCHASE FIRST WITH NO FLOAT IN CASH BOX?
// 19/3/20

function tickets(peopleInLine) {
	var noteSequence = peopleInLine;                      // SEQUENCE OF NOTES      
	var note25s = 0;                                      // KEEP TRACK OF 25s
	var note50s = 0;                                      // AND 50s
	for (var i = 0; i < noteSequence.length; i++) {

		if (noteSequence[i] === 25) {                     // $25
			note25s += 1;                                     // TAKE $25

		} else if (noteSequence[i] === 50) {              // $50
			if (note25s < 1) {                                // NO 25s,
				return "NO";                                    // NO SALE!
			} else {                                          // HAVE 25s
				note50s += 1;                                   // TAKE $50
				note25s -= 1;                                   // GIVE $25 CHANGE
			}

		} else if (noteSequence[i] === 100) {             // $100
			if (note25s === 0) {                              // NO 25s
				return "NO";                                    // NO SALE!
			} else if (note25s === 1) {                       // 1*25
				if (note50s < 1) {                              // NO 50s
					return "NO";                                  // NO SALE!
				} else {                                        // HAVE $50
					note25s -= 1;                                 // GIVE $75 CHANGE, 25+50
					note50s -= 1;
				}
			} else if (note25s === 2) {                       // 2*25                   
				if (note50s < 1) {                              // NO 50s
					return "NO";                                  // NO SALE!
				} else {                                        // HAVE $50
					note25s -= 1;                                 // GIVE $75 CHANGE, 25+50
					note50s -= 1;
				}
			} else if (note25s > 2) {                         // 3*25
				if (note50s < 1) {                              // NO 50s
					note25s -= 3;                                 // GIVE $75 CHANGE, 25+25+25
				} else {                                        // HAVE $50
					note25s -= 1;                                 // GIVE $75 CHANGE, 25+50
					note50s -= 1;
				}
			}
		}
	}
	return "YES";                                         // OTHERWISE "YES"
}

//================================== ANOTHER SOLUTION ======================================

// function tickets(peopleInLine) {
//   var bills = [0, 0, 0]
//   for (var i = 0; i < peopleInLine.length; i++) {
//     switch (peopleInLine[i]) {
//       case 25:
//         bills[0]++
//         break

//       case 50:
//         bills[0]--
//         bills[1]++
//         break

//       case 100:
//         bills[1] ? bills[1]-- : bills[0] -= 2
//         bills[0]--
//         break
//     }

//     if (bills[0] < 0) {
//       return 'NO'
//     }
//   }

//   return 'YES'
// }

//================================== ANOTHER SOLUTION ======================================

// function tickets(peopleInLine){
//   let [c25,c50,c100] = [0,0,0];
//   for(let v of peopleInLine) {
//     if(v===25) c25++;
//     if(v===50) {c50++; c25--;}
//     if(v===100) {c25--; c50>0?c50--:c25-=2;}
//     if(c25<0||c50<0) return 'NO'
//   }
//   return 'YES'
// }

//================================== ANOTHER SOLUTION ======================================
// function tickets(peopleInLine){
//    var m25 = 0, m50 = 0;

//     for (var i = 0; i < peopleInLine.length; i++) {
//         switch(peopleInLine[i]){
//             case 25:
//                 m25++;
//                 break;
//             case 50:
//                 m25 > 0 ? m25-- : m25 = -1;
//                 m50++;
//                 break;
//             case 100:
//                 m25 > 0 && m50 > 0 ? m50-- : (m25 > 2 ? m25 -= 2 : m25 = -1);
//                 m25--;
//                 break;
//         }
//     }
//     return m25 < 0 ? "NO" : "YES";
// }

//================================== ANOTHER SOLUTION ======================================
// function tickets(peopleInLine){
//   var [n25, n50, n100] = [0, 0, 0];
//   for (var i = 0; i < peopleInLine.length; i++) {
//     switch(peopleInLine[i]) {
//       case 25: n25++; break;
//       case 50: n50++; n25--; break;
//       case 100: n100++; n25--; 
//         if (n50) n50--; else n25 -= 2; break;
//     }
//     if ([n25, n50, n100].some(v => v < 0)) return 'NO';
//   }
//   return 'YES';
// }


// tickets([25, 25, 25, 100, 25, 50, 100]);
// tickets([25,25,25,100,25,25,50,100,25,25,50,100,25,25,50,100,25,50,25,100,25,50,50,25]);
// tickets([25, 25, 50]); // => YES
// tickets([25, 100]); // => NO. Vasya will not have enough money to give change to 100 dollars
// tickets([25, 25, 50, 50, 100]); // => NO. Vasya will not have the right bills to give 75 dollars of change (you can't make two bills of 25 from one of 50)

// The new "Avengers" movie has just been released! There are a lot of people at the cinema box office standing in a huge line. Each of them has a single 100, 50 or 25 dollar bill. An "Avengers" ticket costs 25 dollars.

// Vasya is currently working as a clerk. He wants to sell a ticket to every single person in this line.

// Can Vasya sell a ticket to every person and give change if he initially has no money and sells the tickets strictly in the order people queue?

// Return YES, if Vasya can sell a ticket to every person and give change with the bills he has at hand at that moment. Otherwise return NO.

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// Your order, please 
// 18/3/20

// FIRST TRY NOT ENTIRELY HAPPY WITH LOGIC NEED TO REFACTOR !

function order(words) {
	var wordsArr = words.split(" ");                                 // SPLIT INPUT STR INTO ARRAY OF STR'S
	var sortedByDigitArr = [];                                       // CREATE EMPTY ARR FOR SOLUTION
	for (var i = 0; i < wordsArr.length; i++) {
		var digitFoundInWord = Number(wordsArr[i].match(/\d/g));       // FIND DIGIT IN EACH WORD, CONVERT TO NUMBER AND SAVE IT TO A VAR
		sortedByDigitArr[digitFoundInWord - 1] = wordsArr[i];          // THE (FOUND DIGIT - 1) THEN BECOMES THE INDEX FOR THE WORD CONTAINIG IT
	}                                                                // -1 MAKES SURE THAT THERE'S NO undefined sortedByDigitArr[0]
	return sortedByDigitArr.join(" ");                               // CREATE AND RETURN NEW STR AS RESULT BY CONCATENATING ARR ELEMENTS WITH SINGLE SPACE
}

//===================================== ANOTHER SOLUTION ==================================

//   function order(words){

//     return words.split(' ').sort(function(a, b){
//         return a.match(/\d/) - b.match(/\d/);
//      }).join(' ');
//   }    

//   function order(words){
//     return words.split(' ').sort(function(a, b){    
//       return a.match(/\d+/g) - b.match(/\d+/g);    
//     }).join(' ');
//   }


//   function order(words){
//      return words.split(' ').sort((a,b)=> +a.match(/\d+/)- +b.match(/\d+/)).join(' ');
//   }


//   order("is2 Thi1s T4est 3a");

// Your task is to sort a given string. Each word in the string will contain a single number. This number is the position the word should have in the result.

// Note: Numbers can be from 1 to 9. So 1 will be the first word (not 0).

// If the input string is empty, return an empty string. The words in the input String will only contain valid consecutive numbers.

// Examples
// "is2 Thi1s T4est 3a"  -->  "Thi1s is2 3a T4est"
// "4of Fo1r pe6ople g3ood th5e the2"  -->  "Fo1r the2 g3ood 4of th5e pe6ople"
// ""  -->  ""

//===========================================================================
// thenum = "foo3bar5".match(/\d+/)[0] // "3"

// var numb = txt.match(/\d/g);   // ALL NUMBERS IN STR

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// likes(names)
// 17/3/20

function likes(names) {
	var namesArr = names;
	var others = namesArr.length - 2;                             // THIS DETERMINES THE NUMBER OF "OTHER PEOPLE" if MORE THAN 4 NAMES WITH FIRST 2 DISPLAYED
	if (namesArr.length === 0) {
		return "No one likes this";
	} else if (namesArr.length === 1) {
		return namesArr[0] + " likes this";
	} else if (namesArr.length === 2) {
		return namesArr[0] + " and " + namesArr[1] + " like this";
	} else if (namesArr.length === 3) {
		return namesArr[0] + ", " + namesArr[1] + " and " + namesArr[2] + " like this";
	} else {
		return namesArr[0] + ", " + namesArr[1] + " and " + others + " other people like this";
	}
}

// ============================ OTHER SOLUTION =====================================

//   function likes(names) {
//     names = names || [];
//     switch(names.length){
//       case 0: return 'no one likes this'; break;
//       case 1: return names[0] + ' likes this'; break;
//       case 2: return names[0] + ' and ' + names[1] + ' like this'; break;
//       case 3: return names[0] + ', ' + names[1] + ' and ' + names[2] + ' like this'; break;
//       default: return names[0] + ', ' + names[1] + ' and ' + (names.length - 2) + ' others like this';
//     }
//   }


//   function likes(names) {
//     return {
//       0: 'no one likes this',
//       1: `${names[0]} likes this`, 
//       2: `${names[0]} and ${names[1]} like this`, 
//       3: `${names[0]}, ${names[1]} and ${names[2]} like this`, 
//       4: `${names[0]}, ${names[1]} and ${names.length - 2} others like this`, 
//     }[Math.min(4, names.length)]
//   }


//   function likes(names) {
//     if(names.length === 0) return "no one likes this";
//     if(names.length === 1) return names[0] + " likes this";
//     if(names.length === 2) return names[0] + " and " + names[1] + " like this";
//     if(names.length === 3) return names[0] + ", " + names[1] + " and " + names[2] + " like this";
//     return names[0] + ", " + names[1] + " and " + (names.length - 2) + " others like this";
//   }

// likes([]);
// likes(["Peter"]);
// likes(["Peter", "Frank"]);
// likes(["Peter", "Frank", "Alex"]);;
// likes(["Alex", "Jacob", "Mark", "Max"]);

// Implement a function likes :: [String] -> String, which must take in input array, containing the names of people who like an item. It must return the display text as shown in the examples:

// likes [] // must be "no one likes this"
// likes ["Peter"] // must be "Peter likes this"
// likes ["Jacob", "Alex"] // must be "Jacob and Alex like this"
// likes ["Max", "John", "Mark"] // must be "Max, John and Mark like this"
// likes ["Alex", "Jacob", "Mark", "Max"] // must be "Alex, Jacob and 2 others like this"
// For 4 or more names, the number in and 2 others simply increases.


// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// Summing the last 3 (instead of 2) numbers of the sequence to generate the next
// 16/3/20

function tribonacci(signature, n) {
	var resultArr = signature;                                                    // START RESULT WITH 3 ELEMENTS GIVEN AS SIGNATURE
	if (n === 0) {                                                                // if n === 0, RETURN EMPTY ARRAY
		return [];
	} else if (n === 1 || n === 2) {                                              // if n < 3 AND n > 0, RETURN FIRST n ELEMENTS
		return resultArr.slice(0, n);
	} else {                                                                      // OTHERWISE,
		for (var i = 3; i < n; i++) {                                             // LOOP THROUGH ARRAY STARTING AT array[3],
			resultArr.push(resultArr[i - 1] + resultArr[i - 2] + resultArr[i - 3]);       // VALUE OF NEXT INDEX IS THE SUM OF PREVIOUS 3 NUMBERS
		}
		return resultArr;                                                           // RETURN RESULT
	}
}

//  ===============  ANOTHER SOLUTION  ==================== 


function tribonacci(signature, n) {
	for (var i = 0; i < n - 3; i++) { // iterate n times
		signature.push(signature[i] + signature[i + 1] + signature[i + 2]); // add last 3 array items and push to trib
	}
	return signature.slice(0, n); //return trib - length of n
}

//  ===============  ANOTHER SOLUTION  ==================== 

//   function tribonacci(s,n){
//     var arr = [];
//     for(var i=0; i<n; i++) {
//       arr.push((i<3) ? s[i] : arr[i-1]+arr[i-2]+arr[i-3]);
//     }
//     return arr;
//   }


// function tribonacci(signature,n) {
//   var trib = signature;
//   for (i = 3; i < n; i++) {
//     trib.push((trib[i-1] + trib[i-2] + trib[i-3]));
//   }
//   return trib.slice(0, n);
// }

// tribonacci([1,1,1], 1);

// Well met with Fibonacci bigger brother, AKA Tribonacci.

// As the name may already reveal, it works basically like a Fibonacci, but summing the last 3 (instead of 2) numbers of the sequence to generate the next. And, worse part of it, regrettably I won't get to hear non-native Italian speakers trying to pronounce it :(

// So, if we are to start our Tribonacci sequence with [1, 1, 1] as a starting input (AKA signature), we have this sequence:

// [1, 1 ,1, 3, 5, 9, 17, 31, ...]
// But what if we started with [0, 0, 1] as a signature? As starting with [0, 1] instead of [1, 1] basically shifts the common Fibonacci sequence by once place, you may be tempted to think that we would get the same sequence shifted by 2 places, but that is not the case and we would get:

// [0, 0, 1, 1, 2, 4, 7, 13, 24, ...]
// Well, you may have guessed it by now, but to be clear: you need to create a fibonacci function that given a signature array/list, returns the first n elements - signature included of the so seeded sequence.

// Signature will always contain 3 numbers; n will always be a non-negative number; if n == 0, then return an empty array (except in C return NULL) and be ready for anything else which is not clearly specified ;)

// If you enjoyed this kata more advanced and generalized version of it can be found in the Xbonacci kata

// [Personal thanks to Professor Jim Fowler on Coursera for his awesome classes that I really recommend to any math enthusiast and for showing me this mathematical curiosity too with his usual contagious passion :)]


// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// Equal Sides Of An Array
// 15/3/20

function findEvenIndex(arr) {
	var inputArr = arr;
	var sum = inputArr.reduce((a, b) => a + b, 0);                      // CALCULATE SUM OF ARR
	var currentSum = 0;                                                 // SET CURRENTSUM TO 0
	var falseCounter = 0;                                               // SET COUNTER TO 0, COUNT HOW MANY TIMES CONDITON EVALUATES TO FALSE 
	for (var i = 0; i < inputArr.length; i++) {
		currentSum += inputArr[i];                                        // INCREMENT CURRENTSUM BY INPUTARR[I] (CURRENT VALUE)
		if (currentSum - inputArr[i] === (sum - inputArr[i]) / 2) {       // IF CURRENTSUM-CURRENTVALUE === (SUM-CURRENTVALUE)/2 EVALUATES TO TRUE
			return i;                                                       // RETURN CURRENT INDEX AS RESULT
		} else {                                                          // OTHERWISE
			falseCounter += 1;                                              // INCREMENT FALSECOUNTER BY 1
		}
	}
	if (falseCounter = inputArr.length) {                               // IF ABOVE CONDITON IS NOT MET BE ANY ELEMENTS
		return -1;                                                        // RETURN -1
	}                                                                   // !!! WITHOUT THIS LOGIC FUNCTION RETURNS undefined IF NO INDEX FOUND !!!
}

//  ===============  ANOTHER SOLUTION  ==================== 

// function findEvenIndex(arr) {
//     for(var i=1; i<arr.length-1; i++) {
//       if(arr.slice(0, i).reduce((a, b) =>  a+b) === arr.slice(i+1).reduce((a, b) =>  a+b)) {
//         return i;
//       }
//     }
//     return -1;
// }

//  ===============  ANOTHER SOLUTION  ==================== 

//   function findEvenIndex(arr) {
//       var i,
//           left,
//           right = 0,
//           len = arr.length;

//       if (len === 0) {
//           return -1;
//       }

//       left = arr[0];

//       for (i = 1; i < len; i++) {
//           right += arr[i];
//       }

//       for (i = 1; i < len; i++) {
//           right -= arr[i];
//           if (left === right) {
//               return i;
//           }
//           left += arr[i];
//       }

//       return -1;
//   }

// findEvenIndex([1, 2, 3, 4, 3, 2, 1]);
// findEvenIndex([1, 100, 50, -51, 1, 1]);
// findEvenIndex([1,1,2]);

// You are going to be given an array of integers. Your job is to take that array and find an index N where the sum of the integers to the left of N is equal to the sum of the integers to the right of N. If there is no index that would make this happen, return -1.

// For example:

// Let's say you are given the array {1,2,3,4,3,2,1}: Your function will return the index 3, because at the 3rd position of the array, the sum of left side of the index ({1,2,3}) and the sum of the right side of the index ({3,2,1}) both equal 6.

// Let's look at another one.
// You are given the array {1,100,50,-51,1,1}: Your function will return the index 1, because at the 1st position of the array, the sum of left side of the index ({1}) and the sum of the right side of the index ({50,-51,1,1}) both equal 1.

// Last one:
// You are given the array {20,10,-80,10,10,15,35}
// At index 0 the left side is {}
// The right side is {10,-80,10,10,15,35}
// They both are equal to 0 when added. (Empty arrays are equal to 0 in this problem)
// Index 0 is the place where the left side and right side are equal.

// Output:
// The lowest index N where the side to the left of N is equal to the side to the right of N. If you do not find an index that fits these rules, then you will return -1.

// Note:
// If you are given an array with multiple answers, return the lowest correct index.

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

//  convert a string to a new string where each character in the new string is "(" if that character appears only once in the original string, or ")" if that character appears more than once in the original string. Ignore capitalization when determining if a character is a duplicate.

// 14/3/20

// BASED ON isIsogram()

function duplicateEncode(str) {
	var str = str.toLowerCase();                                                     // CASE INSENSITIVE
	var encodedStr = "";                                                             // CREATE EMPTY STRING FOR RESULT
	for (var i = 0; i < str.length; i++) {                                           // ITERATE OVER INPUT STR 
		if (str.indexOf(str.charAt(i)) === str.lastIndexOf(str.charAt(i))) {            // indexOf() - FIRST OCCURRENCE OF CHAR, VS lastIndexOf() - LAST OCCURANCE OF CHAR!!!
			encodedStr += "(";                                                           // IF FIRST OCCURRENCE === LAST -> ADD "(" TO RESULT
		} else {                                                                              // if(str.indexOf(str.charAt(i)) !== str.lastIndexOf(str.charAt(i))) {
			encodedStr += ")";                                                           // // IF FIRST OCCURRENCE !== LAST ->ADD ")" TO RESULT
		}
	}
	return encodedStr;                                                                // RETURN RESULT                         
}

//  ===============  ANOTHER SOLUTION  ==================== 


//   const duplicateEncode = word => {
//     word = word.toLowerCase();
//     return word.replace(/./g, w => word.indexOf(w) == word.lastIndexOf(w)? '(': ')');
//   }


//   const duplicateEncode = word => {
//     word = word.toUpperCase();
//     result = '';
//     for (let i = 0; i < word.length; i++) {
//       result += (word.indexOf(word[i]) === word.lastIndexOf(word[i])) ? '(' : ')';
//     }
//     return result;
//   }


//   function duplicateEncode(word){

//       var unique='';
//       word = word.toLowerCase();
//       for(var i=0; i<word.length; i++){
//           if(word.lastIndexOf(word[i]) == word.indexOf(word[i])){
//               unique += '(';
//           }
//           else{
//               unique += ')';
//           }
//       }
//       return unique;

//   }


// duplicateEncode("recede");

// "din"      =>  "((("
// "recede"   =>  "()()()"
// "Success"  =>  ")())())"
// "(( @"     =>  "))((" 

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// Write a function that takes in a string of one or more words, and returns the same string, but with all five or more letter words reversed (Just like the name of this Kata). Strings passed in will consist of only letters and spaces. Spaces will be included only when more than one word is present.
// 13/3/20

function spinWords(str) {
	var strArr = str.split(" ");                                       // SPLIT STR INTO ARRAY OF STR'S
	var revArr = [];                                                   // DECLARE EMPTY ARR FOR SOLUTION       !!! NO NEED FOR THIS !!! SEE SOLUTION 2 !!!
	for (var i = 0; i < strArr.length; i++) {                           // LOOP THROUGH ARR
		if (strArr[i].length < 5) {                                       // IF WORD SHORTER THAN 5 CHARS
			revArr.push(strArr[i]);                                       // PUSH IT INTO SOLUTION AS IT IS
		} else if (strArr[i].length >= 5) {                               // IF WORD LONGER THAN 5
			revArr.push(strArr[i].split("").reverse().join(""));            // REVERSE CHAR ORDER AND THEN PUSH INTO SOLUTION ARR
		}
	}
	return revArr.join(" ");                                           // RETURN SOLUTION
}


//  ===============  ANOTHER SOLUTION  ==================== 

// DON'T NEED ANOTHER ARRAY !!!

//   function spinWords(str) {
//     let strArr = str.split(' ');
//     for (let i = 0; i < strArr.length; i++) {
//       if (strArr[i].length >= 5)
//         strArr[i] = strArr[i].split('').reverse().join('');
//     }
//     return strArr.join(' ');
//   }


//   function spinWords(words){
//     return words.split(' ').map(function (word) {
//       return (word.length > 4) ? word.split('').reverse().join('') : word;
//     }).join(' ');
//   }

// spinWords( "Hey fellow warriors" );

// Examples: spinWords( "Hey fellow warriors" ) => returns "Hey wollef sroirraw" spinWords( "This is a test") => returns "This is a test" spinWords( "This is another test" )=> returns "This is rehtona test"

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// Write a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string. The input string can be assumed to contain only alphabets (both uppercase and lowercase) and numeric digits.
// 13/3/20

function duplicateCount(text) {
	var lettersArr = text.toLowerCase().split("");                                         // LOWERCASE STR AND SPLIT INTO ARRAY
	var duplicateCount = 0;                                                                // DECLARE COUNT VAR WITH THE INITIAL VALUE OF 0   
	var countObj = {};                                                                     // COUNT ALL OCCOURANCES IN ARRAY USING AN OBJECT
	lettersArr.forEach(letter => (countObj[letter] = (countObj[letter] || 0) + 1));       // count[2]; //3 <= 2 appears 3/times
	for (const property in countObj) {                                                  // ITERATE OVER ALL ENUMERABLE PROPERTIES OF AN OBJ THAT ARE KEYED BY STRINGS
		// console.log(`${property}: ${countObj[property]}`);                            // (PRINT KEY VALUE PAIRS)
		if (`${countObj[property]}` > 1) {                                                //  IF PROP VALUE IS MORE THAN ONE     console.log("Duplicate found");
			duplicateCount += 1;                                                           // INCREMENT COUNT BY ONE
		}
	}                                                                                   // console.log(countObj); console.log(duplicateCount);
	return duplicateCount;                                                               // RETURN RESULT
}


// duplicateCount("aA11");

// Example
// "abcde" -> 0 # no characters repeats more than once
// "aabbcde" -> 2 # 'a' and 'b'
// "aabBcde" -> 2 # 'a' occurs twice and 'b' twice (`b` and `B`)
// "indivisibility" -> 1 # 'i' occurs six times
// "Indivisibilities" -> 2 # 'i' occurs seven times and 's' occurs twice
// "aA11" -> 2 # 'a' and '1'
// "ABBA" -> 2 # 'A' and 'B' each occur twice

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// You are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer N. Write a method that takes the array as an argument and returns this "outlier" N.

// 12/3/20

// Examples
// [2, 4, 0, 100, 4, 11, 2602, 36]
// Should return: 11 (the only odd number)

// [160, 3, 1719, 19, 11, 13, -21]
// Should return: 160 (the only even number)

function findOutlier(integers) {
	var inputArr = integers;
	var oddsArr = [];                                      // CREATE EMPTY ARRAYS FOR ODDS AND EVENS
	var evensArr = [];
	for (var i = 0; i < inputArr.length; i++) {            // PUSH ODDS AND EVENS IN THEIR RESPECTIVE ARRAYS
		if (Number.isInteger(inputArr[i] / 2)) {                   // a%2==0
			evensArr.push(inputArr[i]);
		} else {                                                  // a%2!==0
			oddsArr.push(inputArr[i]);
		}
	}
	if (oddsArr.length < 2) {                               // WHICHEVER HAS ONLY ONE ELEMENT
		return oddsArr[0];
	} else if (evensArr.length < 2) {
		return evensArr[0];                                  // RETURN ITS ONLY (ZERO INDEX) ELEMENT
	}
}

//  ===============  ANOTHER SOLUTION  ==================== 


//   function findOutlier(int){
//     var even = int.filter(a=>a%2==0);
//     var odd = int.filter(a=>a%2!==0);
//     return even.length==1? even[0] : odd[0];
//   }



//   findOutlier([2, 4, 0, 100, 4, 11, 2602, 36]);

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// A digital root is the recursive sum of all the digits in a number. Given n, take the sum of the digits of n. If that value has more than one digit, continue reducing in this way until a single-digit number is produced. This is only applicable to the natural numbers.
// 12/3/20

// SAME LOGIC AS 6kyu - persistence(num) - Persistent bugger(multiplicative persistence) BUT HAVE TO CONVERT ( number -> string -> array(of strings) -> array(of numbers)) AS WE NEED THE FINAL VALUE AS A NUMBER?

function digital_root(num) {
	function sum(n) {                              // SUM ALL ELEMENTS (DIGITS OF NUM) OF A GIVEN ARRAY 
		return n.reduce(function (a, b) {
			return a + b;
		});
	}
	// var count = 0;                             // START COUNT AT 0
	while (num > 9) {                              // WHILE NUM HAS MORE THAN ONE DIGIT     
		num = num.toString().split("");             // CONVERT NUM TO STRING AND SPLIT IT INTO AN ARRAY (number -> string -> array)
		for (var i = 0; i < num.length; i++) {       // !!! CONVERT ALL ELEMENTS BACK TO NUMBER !!!
			num[i] = parseInt(num[i], 10);
		}
		num = sum(num);                             // PASS ARRAY TO SUM()              
		// count++;                                 // INCREMENT COUNT BY 1
	}
	return num;
	// return count;
}

//  ===============  ANOTHER SOLUTION  ==================== 

//   function digital_root(n) {
//     if(n < 10) {
//       return n;
//     }
//     n = n.toString().split("");
//     var result = 0;
//     for(var i = 0; i < n.length; i++) {
//       result += parseInt(n[i]);
//     }
//     return result < 10 ? result : digital_root(result);
//   }


//   function digital_root(n) {
//     return (n - 1) % 9 + 1;
//   }

// Things, that helped me to understand this solution:

// -the remainder of dividing the number by 9 is equal to the remainder of dividing the sum of the number's digits by 9
// -the last recursive sum is a one-digit number
// -the remainder of dividing the one-digit number by 9 is equal to this one-digit number (8 % 9 = 8)

// In modulo 9 arithmetic any number multiplied by 10 is the same number. We can show that by proving that any number's remainder of dividing by 9 is the same as a remainder from dividing the same number multiplied by 10:

// n = 9k + l // any number can be represented as k multiplicity of 9 and l remainder
// 10n = 90k + 10l
// 10n = 90k + 9l + l
// 10n = 9(10k + l) + l // the remainder is also l
// With that, we can write any number like so:

// 1234 = 1 * 10^3 + 2 * 10^2 + 3 * 10 + 4
// which in modulo 9 arithmetic is equivalent to

// 1 + 2 + 3 + 4
// So, in mod 9 arithmetic any number is equal to sum of its digits, and also to sum of that sum's digits, and so on...

// ==========================================================
// digital_root(132189);

// => 1 + 3 + 2 + 1 + 8 + 9
// => 24 ...
// => 2 + 4
// => 6

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// Write a function, persistence, that takes in a positive parameter num and returns its multiplicative persistence, which is the number of times you must multiply the digits in num until you reach a single digit.
//  persistence(39) === 3 // because 3*9 = 27, 2*7 = 14, 1*4=4
// and 4 has only one digit
// 10/3/20

function persistence(num) {
	function multiply(n) {                               // MULTIPLY ALL ELEMENTS (DIGITS OF NUM) OF A GIVEN ARRAY 
		return n.reduce(function (a, b) {
			return a * b;
		});
	}
	var count = 0;                                      // START COUNT AT 0
	while (num > 9) {                                    // WHILE NUM HAS MORE THAN ONE DIGIT      THIS ALSO WORKS: while(num.toString.length > 1)
		num = num.toString().split("");                   // CONVERT NUM TO STRING AND SPLIT IT INTO AN ARRAY (number -> string -> array)
		num = multiply(num);                              // PASS ARRAY TO MULTIPLY()               COULD DO:  num = multiply(num.toString().split(""));
		count++;                                          // INCREMENT COUNT BY 1
	}
	return count;                                       // RETURN COUNT
}

//  ===============  ANOTHER SOLUTION  ==================== 

//   function persistence(num) {
//       var times = 0;
//       num = num.toString();
//       while (num.length > 1) {
//           times++;
//           num = num.split('').map(Number).reduce((a, b) => a * b).toString();
//       }
//       return times;
//   }

//  =============== THIS MULTIPLIES DIGITS ONCE ==================== 

// function persistence(num) {
//   var numStr = num.toString();
//   console.log(numStr);
//   var newNumStr = 1;
//   for(var i = 0; i < numStr.length; i++) {
//     newNumStr = newNumStr * numStr[i];
//   }
//   console.log(newNumStr);
//   if(newNumStr > 9) {
//     console.log("more than one digit");
//   }
// }

// persistence(39);

// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

//solution() - Find the sum of all the multiples of 3 or 5 below the number passed in.
// Note: If the number is a multiple of both 3 and 5, only count it once.
// 9/3/20

function solution(number) {
	var range = number;                                                     // SET RANGE 
	var rangeArr = [];                                                      // CREATE EMPTY RANGE ARRAY
	var multiplesArr = [];                                                  // CREATE EMPTY MULTIPLES ARRAY
	for (var i = 0; i < range; i++) {                                        // ITERATE OVER RANGE FROM 0 TO (RANGE - 1)
		rangeArr.push(i);                                                     // FILL RANGEARR WITH CURRENT VALUES
		if (rangeArr[i] % 3 === 0 || rangeArr[i] % 5 === 0) {                  // IF ELEMENT IS A MULTIPLE OF 3 OR 5
			multiplesArr.push(rangeArr[i]);                                     // PUSH IT INTO MULTIPLES ARRAY
		}
	}
	return multiplesArr.reduce(function (accumulator, currentValue) {       // RETURN SUM OF ALL MULTIPLES
		return accumulator + currentValue
	}, 0)
}

// solution(10);

// ===================================================================

// codewars

// function solution(number){
//   sum = 0
//   for (i = 3; i < number; i++) {
//     if (i % 3 == 0 || i % 5 == 0) {
//       sum += i;
//     }
//   }
//   return sum;
// }


// ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©ðŸŸ©
// TITLE:  
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°
// SOURCE: 
// ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°ðŸ€°

// FIND INTEGER THAT APPEARS AN ODD NUMBER OF TIMES
// 8/3/20

function findOdd(A) {
	var numArr = A.sort(function (a, b) {                                   // SORT ARRAY IN ASCENDING ORDER
		return a - b;
	});
	var count = {};                                                        // COUNT OCCOURANCES OF EACH ELEMENT IN ARRAY
	numArr.forEach(number => (count[number] = (count[number] || 0) + 1));  // count[2]; //3 <= 2 appears 3/times
	for (const property in count) {                                        // ITERATE OVER ALL ENUMERABLE PROPERTIES OF AN OBJ THAT ARE KEYED BY STRINGS
		if (!Number.isInteger(count[property] / 2)) {                        // IF VALUE OF PROPERTY IS NOT AN EVEN NUMBER
			console.log(`${property}: ${count[property]}`);                 // (PRINT KEY VALUE PAIRS)
			return Number(`${property}`);                                      // RETURN ITS KEY PROPERTY
		}
	}
}

  // findOdd([1, 2, 2, 2, 1, 4, 4]);

   // for (let [key, value] of Object.entries(count)) {
    //   console.log(key, value);
    // }


     // for (let key in count) {
     //    if (count.hasOwnProperty(key)) {
     //      console.log(key, count[key]);
     //    }
     //  }

// ============================================================================
// ============================================================================


